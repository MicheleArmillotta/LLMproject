[
  {
    "function_name": "xfs_icsb_modify_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1846-1977",
    "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock",
          "args": [
            "mp"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_balance_counter",
          "args": [
            "mp",
            "field",
            "delta"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_balance_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1835-1844",
          "snippet": "STATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock",
          "args": [
            "mp"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_unlock_cntr",
          "args": [
            "icsbp"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_cntr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1598-1603",
          "snippet": "STATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb_unlocked",
          "args": [
            "mp",
            "field",
            "delta",
            "rsvd"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1111-1273",
          "snippet": "STATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_counter_disabled",
          "args": [
            "mp",
            "field"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_counter_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1657-1664",
          "snippet": "STATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcounter < 0"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(mp->m_resblks - mp->m_resblks_avail) != 0"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcounter < 0"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcounter < 0"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "xfs_icsb_counter_disabled(mp, field)"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock_cntr",
          "args": [
            "icsbp"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_cntr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1589-1596",
          "snippet": "STATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "xfs_icsb_counter_disabled(mp, field)"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "mp->m_sb_cnts"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
  },
  {
    "function_name": "xfs_icsb_balance_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1835-1844",
    "snippet": "STATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_balance_counter_locked",
          "args": [
            "mp",
            "fields",
            "min_per_cpu"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_balance_counter_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1793-1833",
          "snippet": "STATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64\n\nSTATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}"
  },
  {
    "function_name": "xfs_icsb_balance_counter_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1793-1833",
    "snippet": "STATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_enable_counter",
          "args": [
            "mp",
            "field",
            "count",
            "resid"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_enable_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1709-1742",
          "snippet": "STATIC void\nxfs_icsb_enable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tuint64_t\tcount,\n\tuint64_t\tresid)\n{\n\txfs_icsb_cnts_t\t*cntp;\n\tint\t\ti;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\txfs_icsb_lock_all_counters(mp);\n\tfor_each_online_cpu(i) {\n\t\tcntp = per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tswitch (field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tcntp->icsb_icount = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tcntp->icsb_ifree = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tcntp->icsb_fdblocks = count + resid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t\tresid = 0;\n\t}\n\tclear_bit(field, &mp->m_icsb_counters);\n\txfs_icsb_unlock_all_counters(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_enable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tuint64_t\tcount,\n\tuint64_t\tresid)\n{\n\txfs_icsb_cnts_t\t*cntp;\n\tint\t\ti;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\txfs_icsb_lock_all_counters(mp);\n\tfor_each_online_cpu(i) {\n\t\tcntp = per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tswitch (field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tcntp->icsb_icount = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tcntp->icsb_ifree = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tcntp->icsb_fdblocks = count + resid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t\tresid = 0;\n\t}\n\tclear_bit(field, &mp->m_icsb_counters);\n\txfs_icsb_unlock_all_counters(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "min",
            "XFS_ICSB_FDBLK_CNTR_REENABLE(mp)"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ICSB_FDBLK_CNTR_REENABLE",
          "args": [
            "mp"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "count",
            "weight"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "count",
            "weight"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "count",
            "weight"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_disable_counter",
          "args": [
            "mp",
            "field"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_disable_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1666-1707",
          "snippet": "STATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64\n\nSTATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}"
  },
  {
    "function_name": "xfs_icsb_sync_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1764-1772",
    "snippet": "void\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_sync_counters_locked",
          "args": [
            "mp",
            "flags"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_sync_counters_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1744-1759",
          "snippet": "void\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}"
  },
  {
    "function_name": "xfs_icsb_sync_counters_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1744-1759",
    "snippet": "void\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_counter_disabled",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_counter_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1657-1664",
          "snippet": "STATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_count",
          "args": [
            "mp",
            "&cnt",
            "flags"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1632-1655",
          "snippet": "STATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters_locked(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\txfs_icsb_count(mp, &cnt, flags);\n\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))\n\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))\n\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\tif (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))\n\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n}"
  },
  {
    "function_name": "xfs_icsb_enable_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1709-1742",
    "snippet": "STATIC void\nxfs_icsb_enable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tuint64_t\tcount,\n\tuint64_t\tresid)\n{\n\txfs_icsb_cnts_t\t*cntp;\n\tint\t\ti;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\txfs_icsb_lock_all_counters(mp);\n\tfor_each_online_cpu(i) {\n\t\tcntp = per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tswitch (field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tcntp->icsb_icount = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tcntp->icsb_ifree = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tcntp->icsb_fdblocks = count + resid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t\tresid = 0;\n\t}\n\tclear_bit(field, &mp->m_icsb_counters);\n\txfs_icsb_unlock_all_counters(mp);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "field",
            "&mp->m_icsb_counters"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "i"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS)"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_enable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tuint64_t\tcount,\n\tuint64_t\tresid)\n{\n\txfs_icsb_cnts_t\t*cntp;\n\tint\t\ti;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\txfs_icsb_lock_all_counters(mp);\n\tfor_each_online_cpu(i) {\n\t\tcntp = per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tswitch (field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tcntp->icsb_icount = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tcntp->icsb_ifree = count + resid;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tcntp->icsb_fdblocks = count + resid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t\tresid = 0;\n\t}\n\tclear_bit(field, &mp->m_icsb_counters);\n\txfs_icsb_unlock_all_counters(mp);\n}"
  },
  {
    "function_name": "xfs_icsb_disable_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1666-1707",
    "snippet": "STATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_count",
          "args": [
            "mp",
            "&cnt",
            "XFS_ICSB_LAZY_COUNT"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1632-1655",
          "snippet": "STATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "field",
            "&mp->m_icsb_counters"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_counter_disabled",
          "args": [
            "mp",
            "field"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_counter_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1657-1664",
          "snippet": "STATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}"
  },
  {
    "function_name": "xfs_icsb_counter_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1657-1664",
    "snippet": "STATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "field",
            "&mp->m_icsb_counters"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS)"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_icsb_counter_disabled(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\treturn test_bit(field, &mp->m_icsb_counters);\n}"
  },
  {
    "function_name": "xfs_icsb_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1632-1655",
    "snippet": "STATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "i"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock_all_counters",
          "args": [
            "mp"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cnt",
            "0",
            "sizeof(xfs_icsb_cnts_t)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_count(\n\txfs_mount_t\t*mp,\n\txfs_icsb_cnts_t\t*cnt,\n\tint\t\tflags)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmemset(cnt, 0, sizeof(xfs_icsb_cnts_t));\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_lock_all_counters(mp);\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tcnt->icsb_icount += cntp->icsb_icount;\n\t\tcnt->icsb_ifree += cntp->icsb_ifree;\n\t\tcnt->icsb_fdblocks += cntp->icsb_fdblocks;\n\t}\n\n\tif (!(flags & XFS_ICSB_LAZY_COUNT))\n\t\txfs_icsb_unlock_all_counters(mp);\n}"
  },
  {
    "function_name": "xfs_icsb_unlock_all_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1619-1630",
    "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock_cntr",
          "args": [
            "cntp"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_cntr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1598-1603",
          "snippet": "STATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "i"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
  },
  {
    "function_name": "xfs_icsb_lock_all_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1606-1617",
    "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_lock_cntr",
          "args": [
            "cntp"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_cntr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1589-1596",
          "snippet": "STATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "i"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
  },
  {
    "function_name": "xfs_icsb_unlock_cntr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1598-1603",
    "snippet": "STATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "XFS_ICSB_FLAG_LOCK",
            "&icsbp->icsb_flags"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\tclear_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags);\n}"
  },
  {
    "function_name": "xfs_icsb_lock_cntr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1589-1596",
    "snippet": "STATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndelay",
          "args": [
            "1000"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "XFS_ICSB_FLAG_LOCK",
            "&icsbp->icsb_flags"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_cntr(\n\txfs_icsb_cnts_t\t*icsbp)\n{\n\twhile (test_and_set_bit(XFS_ICSB_FLAG_LOCK, &icsbp->icsb_flags)) {\n\t\tndelay(1000);\n\t}\n}"
  },
  {
    "function_name": "xfs_icsb_destroy_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1578-1587",
    "snippet": "void\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&mp->m_icsb_mutex"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "mp->m_sb_cnts"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_hotcpu_notifier",
          "args": [
            "&mp->m_icsb_notifier"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_destroy_counters(\n\txfs_mount_t\t*mp)\n{\n\tif (mp->m_sb_cnts) {\n\t\tunregister_hotcpu_notifier(&mp->m_icsb_notifier);\n\t\tfree_percpu(mp->m_sb_cnts);\n\t}\n\tmutex_destroy(&mp->m_icsb_mutex);\n}"
  },
  {
    "function_name": "xfs_icsb_reinit_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1562-1576",
    "snippet": "void\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock",
          "args": [
            "mp"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_balance_counter",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "0"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_balance_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1835-1844",
          "snippet": "STATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock",
          "args": [
            "mp"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}"
  },
  {
    "function_name": "xfs_icsb_init_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1529-1560",
    "snippet": "int\nxfs_icsb_init_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);\n\tif (mp->m_sb_cnts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t}\n\n\tmutex_init(&mp->m_icsb_mutex);\n\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tmp->m_icsb_notifier.notifier_call = xfs_icsb_cpu_notify;\n\tmp->m_icsb_notifier.priority = 0;\n\tregister_hotcpu_notifier(&mp->m_icsb_notifier);\n#endif /* CONFIG_HOTPLUG_CPU */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_hotcpu_notifier",
          "args": [
            "&mp->m_icsb_notifier"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&mp->m_icsb_mutex"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cntp",
            "0",
            "sizeof(xfs_icsb_cnts_t)"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "i"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "xfs_icsb_cnts_t"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_init_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tmp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);\n\tif (mp->m_sb_cnts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t}\n\n\tmutex_init(&mp->m_icsb_mutex);\n\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tmp->m_icsb_notifier.notifier_call = xfs_icsb_cpu_notify;\n\tmp->m_icsb_notifier.priority = 0;\n\tregister_hotcpu_notifier(&mp->m_icsb_notifier);\n#endif /* CONFIG_HOTPLUG_CPU */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_icsb_cpu_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1473-1526",
    "snippet": "STATIC int\nxfs_icsb_cpu_notify(\n\tstruct notifier_block *nfb,\n\tunsigned long action,\n\tvoid *hcpu)\n{\n\txfs_icsb_cnts_t *cntp;\n\txfs_mount_t\t*mp;\n\n\tmp = (xfs_mount_t *)container_of(nfb, xfs_mount_t, m_icsb_notifier);\n\tcntp = (xfs_icsb_cnts_t *)\n\t\t\tper_cpu_ptr(mp->m_sb_cnts, (unsigned long)hcpu);\n\tswitch (action) {\n\tcase CPU_UP_PREPARE:\n\tcase CPU_UP_PREPARE_FROZEN:\n\t\t/* Easy Case - initialize the area and locks, and\n\t\t * then rebalance when online does everything else for us. */\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t\tbreak;\n\tcase CPU_ONLINE:\n\tcase CPU_ONLINE_FROZEN:\n\t\txfs_icsb_lock(mp);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\t\txfs_icsb_unlock(mp);\n\t\tbreak;\n\tcase CPU_DEAD:\n\tcase CPU_DEAD_FROZEN:\n\t\t/* Disable all the counters, then fold the dead cpu's\n\t\t * count into the total on the global superblock and\n\t\t * re-enable the counters. */\n\t\txfs_icsb_lock(mp);\n\t\tspin_lock(&mp->m_sb_lock);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_ICOUNT);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_IFREE);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_FDBLOCKS);\n\n\t\tmp->m_sb.sb_icount += cntp->icsb_icount;\n\t\tmp->m_sb.sb_ifree += cntp->icsb_ifree;\n\t\tmp->m_sb.sb_fdblocks += cntp->icsb_fdblocks;\n\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_ICOUNT, 0);\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_IFREE, 0);\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_FDBLOCKS, 0);\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\txfs_icsb_unlock(mp);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_unlock",
          "args": [
            "mp"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_unlock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1619-1630",
          "snippet": "STATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_unlock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_unlock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_balance_counter_locked",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "0"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_balance_counter_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1793-1833",
          "snippet": "STATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ICSB_INO_CNTR_REENABLE\t(uint64_t)64\n\nSTATIC void\nxfs_icsb_balance_counter_locked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  field,\n\tint\t\tmin_per_cpu)\n{\n\tuint64_t\tcount, resid;\n\tint\t\tweight = num_online_cpus();\n\tuint64_t\tmin = (uint64_t)min_per_cpu;\n\n\t/* disable counter and sync counter */\n\txfs_icsb_disable_counter(mp, field);\n\n\t/* update counters  - first CPU gets residual*/\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tcount = mp->m_sb.sb_icount;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_IFREE:\n\t\tcount = mp->m_sb.sb_ifree;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tcount = mp->m_sb.sb_fdblocks;\n\t\tresid = do_div(count, weight);\n\t\tif (count < max(min, XFS_ICSB_FDBLK_CNTR_REENABLE(mp)))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tcount = resid = 0;\t/* quiet, gcc */\n\t\tbreak;\n\t}\n\n\txfs_icsb_enable_counter(mp, field, count, resid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cntp",
            "0",
            "sizeof(xfs_icsb_cnts_t)"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_disable_counter",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_disable_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1666-1707",
          "snippet": "STATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_disable_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield)\n{\n\txfs_icsb_cnts_t\tcnt;\n\n\tASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));\n\n\t/*\n\t * If we are already disabled, then there is nothing to do\n\t * here. We check before locking all the counters to avoid\n\t * the expensive lock operation when being called in the\n\t * slow path and the counter is already disabled. This is\n\t * safe because the only time we set or clear this state is under\n\t * the m_icsb_mutex.\n\t */\n\tif (xfs_icsb_counter_disabled(mp, field))\n\t\treturn;\n\n\txfs_icsb_lock_all_counters(mp);\n\tif (!test_and_set_bit(field, &mp->m_icsb_counters)) {\n\t\t/* drain back to superblock */\n\n\t\txfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);\n\t\tswitch(field) {\n\t\tcase XFS_SBS_ICOUNT:\n\t\t\tmp->m_sb.sb_icount = cnt.icsb_icount;\n\t\t\tbreak;\n\t\tcase XFS_SBS_IFREE:\n\t\t\tmp->m_sb.sb_ifree = cnt.icsb_ifree;\n\t\t\tbreak;\n\t\tcase XFS_SBS_FDBLOCKS:\n\t\t\tmp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\txfs_icsb_unlock_all_counters(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_lock",
          "args": [
            "mp"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_lock_all_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1606-1617",
          "snippet": "STATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_lock_all_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_cnts_t *cntp;\n\tint\t\ti;\n\n\tfor_each_online_cpu(i) {\n\t\tcntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);\n\t\txfs_icsb_lock_cntr(cntp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_balance_counter",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "0"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_balance_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1835-1844",
          "snippet": "STATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_icsb_balance_counter(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t  fields,\n\tint\t\tmin_per_cpu)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_balance_counter_locked(mp, fields, min_per_cpu);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cntp",
            "0",
            "sizeof(xfs_icsb_cnts_t)"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mp->m_sb_cnts",
            "(unsigned long)hcpu"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "nfb",
            "xfs_mount_t",
            "m_icsb_notifier"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_icsb_cpu_notify(\n\tstruct notifier_block *nfb,\n\tunsigned long action,\n\tvoid *hcpu)\n{\n\txfs_icsb_cnts_t *cntp;\n\txfs_mount_t\t*mp;\n\n\tmp = (xfs_mount_t *)container_of(nfb, xfs_mount_t, m_icsb_notifier);\n\tcntp = (xfs_icsb_cnts_t *)\n\t\t\tper_cpu_ptr(mp->m_sb_cnts, (unsigned long)hcpu);\n\tswitch (action) {\n\tcase CPU_UP_PREPARE:\n\tcase CPU_UP_PREPARE_FROZEN:\n\t\t/* Easy Case - initialize the area and locks, and\n\t\t * then rebalance when online does everything else for us. */\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\t\tbreak;\n\tcase CPU_ONLINE:\n\tcase CPU_ONLINE_FROZEN:\n\t\txfs_icsb_lock(mp);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\t\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\t\txfs_icsb_unlock(mp);\n\t\tbreak;\n\tcase CPU_DEAD:\n\tcase CPU_DEAD_FROZEN:\n\t\t/* Disable all the counters, then fold the dead cpu's\n\t\t * count into the total on the global superblock and\n\t\t * re-enable the counters. */\n\t\txfs_icsb_lock(mp);\n\t\tspin_lock(&mp->m_sb_lock);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_ICOUNT);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_IFREE);\n\t\txfs_icsb_disable_counter(mp, XFS_SBS_FDBLOCKS);\n\n\t\tmp->m_sb.sb_icount += cntp->icsb_icount;\n\t\tmp->m_sb.sb_ifree += cntp->icsb_ifree;\n\t\tmp->m_sb.sb_fdblocks += cntp->icsb_fdblocks;\n\n\t\tmemset(cntp, 0, sizeof(xfs_icsb_cnts_t));\n\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_ICOUNT, 0);\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_IFREE, 0);\n\t\txfs_icsb_balance_counter_locked(mp, XFS_SBS_FDBLOCKS, 0);\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\txfs_icsb_unlock(mp);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "xfs_dev_is_read_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1396-1409",
    "snippet": "int\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"write access unavailable, cannot proceed.\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s required on read-only device.\"",
            "message"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_readonly_buftarg",
          "args": [
            "mp->m_rtdev_targp"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_readonly_buftarg",
          "args": [
            "mp->m_logdev_targp"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_readonly_buftarg",
          "args": [
            "mp->m_ddev_targp"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_freesb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1381-1390",
    "snippet": "void\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_freesb(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\txfs_buf_lock(bp);\n\tmp->m_sb_bp = NULL;\n\txfs_buf_relse(bp);\n}"
  },
  {
    "function_name": "xfs_getsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1360-1376",
    "snippet": "struct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ISDONE(bp)"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISDONE",
          "args": [
            "bp"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_trylock",
          "args": [
            "bp"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "934-946",
          "snippet": "int\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}"
  },
  {
    "function_name": "xfs_mod_incore_sb_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1312-1349",
    "snippet": "int\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == 0"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb_unlocked",
          "args": [
            "mp",
            "msbp->msb_field",
            "-msbp->msb_delta",
            "rsvd"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1111-1273",
          "snippet": "STATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_mod_incore_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1281-1298",
    "snippet": "int\nxfs_mod_incore_sb(\n\tstruct xfs_mount\t*mp,\n\txfs_sb_field_t\t\tfield,\n\tint64_t\t\t\tdelta,\n\tint\t\t\trsvd)\n{\n\tint\t\t\tstatus;\n\n#ifdef HAVE_PERCPU_SB\n\tASSERT(field < XFS_SBS_ICOUNT || field > XFS_SBS_FDBLOCKS);\n#endif\n\tspin_lock(&mp->m_sb_lock);\n\tstatus = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\treturn status;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb_unlocked",
          "args": [
            "mp",
            "field",
            "delta",
            "rsvd"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1111-1273",
          "snippet": "STATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "field < XFS_SBS_ICOUNT || field > XFS_SBS_FDBLOCKS"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb(\n\tstruct xfs_mount\t*mp,\n\txfs_sb_field_t\t\tfield,\n\tint64_t\t\t\tdelta,\n\tint\t\t\trsvd)\n{\n\tint\t\t\tstatus;\n\n#ifdef HAVE_PERCPU_SB\n\tASSERT(field < XFS_SBS_ICOUNT || field > XFS_SBS_FDBLOCKS);\n#endif\n\tspin_lock(&mp->m_sb_lock);\n\tstatus = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\treturn status;\n}"
  },
  {
    "function_name": "xfs_mod_incore_sb_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1111-1273",
    "snippet": "STATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\"",
            "mp->m_fsname"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_SET_ASIDE",
          "args": [
            "mp"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mod_incore_sb_unlocked(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\tint\t\tscounter;\t/* short counter for 32 bit fields */\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tlong long\tres_used, rem;\n\n\t/*\n\t * With the in-core superblock spin lock held, switch\n\t * on the indicated field.  Apply the delta to the\n\t * proper field.  If the fields value would dip below\n\t * 0, then do not apply the delta and return EINVAL.\n\t */\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = (long long)mp->m_sb.sb_icount;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_icount = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = (long long)mp->m_sb.sb_ifree;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_ifree = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_FDBLOCKS:\n\t\tlcounter = (long long)\n\t\t\tmp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\n\n\t\tif (delta > 0) {\t\t/* Putting blocks back */\n\t\t\tif (res_used > delta) {\n\t\t\t\tmp->m_resblks_avail += delta;\n\t\t\t} else {\n\t\t\t\trem = delta - res_used;\n\t\t\t\tmp->m_resblks_avail = mp->m_resblks;\n\t\t\t\tlcounter += rem;\n\t\t\t}\n\t\t} else {\t\t\t\t/* Taking blocks away */\n\t\t\tlcounter += delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_sb.sb_fdblocks = lcounter +\n\t\t\t\t\t\t\tXFS_ALLOC_SET_ASIDE(mp);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We are out of blocks, use any available reserved\n\t\t\t * blocks if were allowed to.\n\t\t\t */\n\t\t\tif (!rsvd)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tlcounter = (long long)mp->m_resblks_avail + delta;\n\t\t\tif (lcounter >= 0) {\n\t\t\t\tmp->m_resblks_avail = lcounter;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"Filesystem \\\"%s\\\": reserve blocks depleted! \"\n\t\t\t\t\"Consider increasing reserve pool size.\",\n\t\t\t\tmp->m_fsname);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\treturn 0;\n\tcase XFS_SBS_FREXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_frextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmp->m_sb.sb_frextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_DBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_dblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_dblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_AGCOUNT:\n\t\tscounter = mp->m_sb.sb_agcount;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_agcount = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_IMAX_PCT:\n\t\tscounter = mp->m_sb.sb_imax_pct;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_imax_pct = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSIZE:\n\t\tscounter = mp->m_sb.sb_rextsize;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextsize = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBMBLOCKS:\n\t\tscounter = mp->m_sb.sb_rbmblocks;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rbmblocks = scounter;\n\t\treturn 0;\n\tcase XFS_SBS_RBLOCKS:\n\t\tlcounter = (long long)mp->m_sb.sb_rblocks;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rblocks = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTENTS:\n\t\tlcounter = (long long)mp->m_sb.sb_rextents;\n\t\tlcounter += delta;\n\t\tif (lcounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextents = lcounter;\n\t\treturn 0;\n\tcase XFS_SBS_REXTSLOG:\n\t\tscounter = mp->m_sb.sb_rextslog;\n\t\tscounter += delta;\n\t\tif (scounter < 0) {\n\t\t\tASSERT(0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmp->m_sb.sb_rextslog = scounter;\n\t\treturn 0;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "xfs_log_sbcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1083-1100",
    "snippet": "int\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "true"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_sync_counters",
          "args": [
            "mp",
            "0"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_sync_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1764-1772",
          "snippet": "void\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_sync_counters(\n\txfs_mount_t\t*mp,\n\tint\t\tflags)\n{\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, flags);\n\tspin_unlock(&mp->m_sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fs_writable",
          "args": [
            "mp",
            "SB_FREEZE_COMPLETE"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1061-1072",
          "snippet": "bool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}"
  },
  {
    "function_name": "xfs_fs_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "1061-1072",
    "snippet": "bool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level > SB_UNFROZEN"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_unmountfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "977-1053",
    "snippet": "void\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sysfs_del",
          "args": [
            "&mp->m_kobj"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "51-58",
          "snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_perag",
          "args": [
            "mp"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_perag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "146-161",
          "snippet": "STATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_errortag_clearall",
          "args": [
            "mp",
            "0"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_errortag_clearall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "92-120",
          "snippet": "int\nxfs_errortag_clearall(xfs_mount_t *mp, int loud)\n{\n\tint64_t fsid;\n\tint cleared = 0;\n\tint i;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++) {\n\t\tif ((fsid == 0LL || xfs_etest_fsid[i] == fsid) &&\n\t\t     xfs_etest[i] != 0) {\n\t\t\tcleared = 1;\n\t\t\txfs_warn(mp, \"Clearing XFS error tag #%d\",\n\t\t\t\txfs_etest[i]);\n\t\t\txfs_etest[i] = 0;\n\t\t\txfs_etest_fsid[i] = 0LL;\n\t\t\tkmem_free(xfs_etest_fsname[i]);\n\t\t\txfs_etest_fsname[i] = NULL;\n\t\t\txfs_error_test_active--;\n\t\t}\n\t}\n\n\tif (loud || cleared)\n\t\txfs_warn(mp, \"Cleared all XFS error tags for filesystem\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_errortag_clearall(xfs_mount_t *mp, int loud)\n{\n\tint64_t fsid;\n\tint cleared = 0;\n\tint i;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++) {\n\t\tif ((fsid == 0LL || xfs_etest_fsid[i] == fsid) &&\n\t\t     xfs_etest[i] != 0) {\n\t\t\tcleared = 1;\n\t\t\txfs_warn(mp, \"Clearing XFS error tag #%d\",\n\t\t\t\txfs_etest[i]);\n\t\t\txfs_etest[i] = 0;\n\t\t\txfs_etest_fsid[i] = 0LL;\n\t\t\tkmem_free(xfs_etest_fsname[i]);\n\t\t\txfs_etest_fsname[i] = NULL;\n\t\t\txfs_error_test_active--;\n\t\t}\n\t}\n\n\tif (loud || cleared)\n\t\txfs_warn(mp, \"Cleared all XFS error tags for filesystem\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_uuid_unmount",
          "args": [
            "mp"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_uuid_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "109-130",
          "snippet": "STATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(xfs_uuid_table_mutex);",
            "static int xfs_uuid_table_size;",
            "static uuid_t *xfs_uuid_table;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nSTATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_unmount",
          "args": [
            "mp"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "162-168",
          "snippet": "void\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_unmount",
          "args": [
            "mp"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "948-959",
          "snippet": "void\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_sbcount",
          "args": [
            "mp"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1083-1100",
          "snippet": "int\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reserve_blocks",
          "args": [
            "mp",
            "&resblks",
            "NULL"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "665-764",
          "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_unmount",
          "args": [
            "mp"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_unmount_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "225-257",
          "snippet": "void\nxfs_qm_unmount_quotas(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * Release the dquots that root inode, et al might be holding,\n\t * before we flush quotas and blow away the quotainfo structure.\n\t */\n\tASSERT(mp->m_rootip);\n\txfs_qm_dqdetach(mp->m_rootip);\n\tif (mp->m_rbmip)\n\t\txfs_qm_dqdetach(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\txfs_qm_dqdetach(mp->m_rsumip);\n\n\t/*\n\t * Release the quota inodes.\n\t */\n\tif (mp->m_quotainfo) {\n\t\tif (mp->m_quotainfo->qi_uquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_uquotaip);\n\t\t\tmp->m_quotainfo->qi_uquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_gquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_gquotaip);\n\t\t\tmp->m_quotainfo->qi_gquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_pquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_pquotaip);\n\t\t\tmp->m_quotainfo->qi_pquotaip = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_unmount_quotas(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * Release the dquots that root inode, et al might be holding,\n\t * before we flush quotas and blow away the quotainfo structure.\n\t */\n\tASSERT(mp->m_rootip);\n\txfs_qm_dqdetach(mp->m_rootip);\n\tif (mp->m_rbmip)\n\t\txfs_qm_dqdetach(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\txfs_qm_dqdetach(mp->m_rsumip);\n\n\t/*\n\t * Release the quota inodes.\n\t */\n\tif (mp->m_quotainfo) {\n\t\tif (mp->m_quotainfo->qi_uquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_uquotaip);\n\t\t\tmp->m_quotainfo->qi_uquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_gquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_gquotaip);\n\t\t\tmp->m_quotainfo->qi_gquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_pquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_pquotaip);\n\t\t\tmp->m_quotainfo->qi_pquotaip = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes",
          "args": [
            "mp",
            "SYNC_WAIT"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1156-1166",
          "snippet": "long\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nlong\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mp->m_reclaim_work"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_push_all_sync",
          "args": [
            "mp->m_ail"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push_all_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "594-613",
          "snippet": "void\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_rootip"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtunmount_inodes",
          "args": [
            "mp"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtunmount_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1249-1257",
          "snippet": "void\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mp->m_eofblocks_work"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_unmountfs(\n\tstruct xfs_mount\t*mp)\n{\n\t__uint64_t\t\tresblks;\n\tint\t\t\terror;\n\n\tcancel_delayed_work_sync(&mp->m_eofblocks_work);\n\n\txfs_qm_unmount_quotas(mp);\n\txfs_rtunmount_inodes(mp);\n\tIRELE(mp->m_rootip);\n\n\t/*\n\t * We can potentially deadlock here if we have an inode cluster\n\t * that has been freed has its buffer still pinned in memory because\n\t * the transaction is still sitting in a iclog. The stale inodes\n\t * on that buffer will have their flush locks held until the\n\t * transaction hits the disk and the callbacks run. the inode\n\t * flush takes the flush lock unconditionally and with nothing to\n\t * push out the iclog we will never get that unlocked. hence we\n\t * need to force the log first.\n\t */\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * Flush all pending changes from the AIL.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\n\t/*\n\t * And reclaim all inodes.  At this point there should be no dirty\n\t * inodes and none should be pinned or locked, but use synchronous\n\t * reclaim just to be sure. We can stop background inode reclaim\n\t * here as well if it is still running.\n\t */\n\tcancel_delayed_work_sync(&mp->m_reclaim_work);\n\txfs_reclaim_inodes(mp, SYNC_WAIT);\n\n\txfs_qm_unmount(mp);\n\n\t/*\n\t * Unreserve any blocks we have so that when we unmount we don't account\n\t * the reserved free space as used. This is really only necessary for\n\t * lazy superblock counting because it trusts the incore superblock\n\t * counters to be absolutely correct on clean unmount.\n\t *\n\t * We don't bother correcting this elsewhere for lazy superblock\n\t * counting because on mount of an unclean filesystem we reconstruct the\n\t * correct counter value and this is irrelevant.\n\t *\n\t * For non-lazy counter filesystems, this doesn't matter at all because\n\t * we only every apply deltas to the superblock and hence the incore\n\t * value does not matter....\n\t */\n\tresblks = 0;\n\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to free reserved block pool. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\terror = xfs_log_sbcount(mp);\n\tif (error)\n\t\txfs_warn(mp, \"Unable to update superblock counters. \"\n\t\t\t\t\"Freespace may not be correct on next mount.\");\n\n\txfs_log_unmount(mp);\n\txfs_da_unmount(mp);\n\txfs_uuid_unmount(mp);\n\n#if defined(DEBUG)\n\txfs_errortag_clearall(mp, 0);\n#endif\n\txfs_free_perag(mp);\n\n\txfs_sysfs_del(&mp->m_kobj);\n}"
  },
  {
    "function_name": "xfs_mountfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "629-971",
    "snippet": "int\nxfs_mountfs(\n\txfs_mount_t\t*mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\txfs_inode_t\t*rip;\n\t__uint64_t\tresblks;\n\tuint\t\tquotamount = 0;\n\tuint\t\tquotaflags = 0;\n\tint\t\terror = 0;\n\n\txfs_sb_mount_common(mp, sbp);\n\n\t/*\n\t * Check for a mismatched features2 values.  Older kernels read & wrote\n\t * into the wrong sb offset for sb_features2 on some platforms due to\n\t * xfs_sb_t not being 64bit size aligned when sb_features2 was added,\n\t * which made older superblock reading/writing routines swap it as a\n\t * 64-bit value.\n\t *\n\t * For backwards compatibility, we make both slots equal.\n\t *\n\t * If we detect a mismatched field, we OR the set bits into the existing\n\t * features2 field in case it has already been modified; we don't want\n\t * to lose any features.  We then update the bad location with the ORed\n\t * value so that older kernels will see any features2 flags. The\n\t * superblock writeback code ensures the new sb_features2 is copied to\n\t * sb_bad_features2 before it is logged or written to disk.\n\t */\n\tif (xfs_sb_has_mismatched_features2(sbp)) {\n\t\txfs_warn(mp, \"correcting sb_features alignment problem\");\n\t\tsbp->sb_features2 |= sbp->sb_bad_features2;\n\t\tmp->m_update_sb = true;\n\n\t\t/*\n\t\t * Re-check for ATTR2 in case it was found in bad_features2\n\t\t * slot.\n\t\t */\n\t\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t\t   !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t}\n\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t   (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_sb_version_removeattr2(&mp->m_sb);\n\t\tmp->m_update_sb = true;\n\n\t\t/* update sb_versionnum for the clearing of the morebits */\n\t\tif (!sbp->sb_features2)\n\t\t\tmp->m_update_sb = true;\n\t}\n\n\t/* always use v2 inodes by default now */\n\tif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\n\t\tmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\n\t\tmp->m_update_sb = true;\n\t}\n\n\t/*\n\t * Check if sb_agblocks is aligned at stripe boundary\n\t * If sb_agblocks is NOT aligned turn off m_dalign since\n\t * allocator alignment is within an ag, therefore ag has\n\t * to be aligned at stripe boundary.\n\t */\n\terror = xfs_update_alignment(mp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_alloc_compute_maxlevels(mp);\n\txfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\n\txfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\n\txfs_ialloc_compute_maxlevels(mp);\n\n\txfs_set_maxicount(mp);\n\n\terror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_uuid_mount(mp);\n\tif (error)\n\t\tgoto out_remove_sysfs;\n\n\t/*\n\t * Set the minimum read and write sizes\n\t */\n\txfs_set_rw_sizes(mp);\n\n\t/* set the low space thresholds for dynamic preallocation */\n\txfs_set_low_space_thresholds(mp);\n\n\t/*\n\t * Set the inode cluster size.\n\t * This may still be overridden by the file system\n\t * block size if it is larger than the chosen cluster size.\n\t *\n\t * For v5 filesystems, scale the cluster size with the inode size to\n\t * keep a constant ratio of inode per cluster buffer, but only if mkfs\n\t * has set the inode alignment value appropriately for larger cluster\n\t * sizes.\n\t */\n\tmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint\tnew_size = mp->m_inode_cluster_size;\n\n\t\tnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\n\t\tif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\n\t\t\tmp->m_inode_cluster_size = new_size;\n\t}\n\n\t/*\n\t * Set inode alignment fields\n\t */\n\txfs_set_inoalignment(mp);\n\n\t/*\n\t * Check that the data (and log if separate) is an ok size.\n\t */\n\terror = xfs_check_sizes(mp);\n\tif (error)\n\t\tgoto out_remove_uuid;\n\n\t/*\n\t * Initialize realtime fields in the mount structure\n\t */\n\terror = xfs_rtmount_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"RT mount failed\");\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t *  Copies the low order bits of the timestamp and the randomly\n\t *  set \"sequence\" number out of a UUID.\n\t */\n\tuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\n\n\tmp->m_dmevmask = 0;\t/* not persistent; set after each mount */\n\n\terror = xfs_da_mount(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed dir/attr init: %d\", error);\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t * Initialize the precomputed transaction reservations values.\n\t */\n\txfs_trans_init(mp);\n\n\t/*\n\t * Allocate and initialize the per-ag data.\n\t */\n\tspin_lock_init(&mp->m_perag_lock);\n\tINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed per-ag init: %d\", error);\n\t\tgoto out_free_dir;\n\t}\n\n\tif (!sbp->sb_logblocks) {\n\t\txfs_warn(mp, \"no log defined\");\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs\", XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_perag;\n\t}\n\n\t/*\n\t * log's mount-time initialization. Perform 1st part recovery if needed\n\t */\n\terror = xfs_log_mount(mp, mp->m_logdev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\n\t\t\t      XFS_FSB_TO_BB(mp, sbp->sb_logblocks));\n\tif (error) {\n\t\txfs_warn(mp, \"log mount failed\");\n\t\tgoto out_fail_wait;\n\t}\n\n\t/*\n\t * Now the log is mounted, we know if it was an unclean shutdown or\n\t * not. If it was, with the first phase of recovery has completed, we\n\t * have consistent AG blocks on disk. We have not recovered EFIs yet,\n\t * but they are recovered transactionally in the second recovery phase\n\t * later.\n\t *\n\t * Hence we can safely re-initialise incore superblock counters from\n\t * the per-ag data. These may not be correct if the filesystem was not\n\t * cleanly unmounted, so we need to wait for recovery to finish before\n\t * doing this.\n\t *\n\t * If the filesystem was cleanly unmounted, then we can trust the\n\t * values in the superblock to be correct and we don't need to do\n\t * anything here.\n\t *\n\t * If we are currently making the filesystem, the initialisation will\n\t * fail as the perag data is in an undefined state.\n\t */\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    !XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\n\t     !mp->m_sb.sb_inprogress) {\n\t\terror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\n\t\tif (error)\n\t\t\tgoto out_log_dealloc;\n\t}\n\n\t/*\n\t * Get and sanity-check the root inode.\n\t * Save the pointer to it in the mount structure.\n\t */\n\terror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\n\tif (error) {\n\t\txfs_warn(mp, \"failed to read root inode\");\n\t\tgoto out_log_dealloc;\n\t}\n\n\tASSERT(rip != NULL);\n\n\tif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\n\t\txfs_warn(mp, \"corrupted root inode %llu: not a directory\",\n\t\t\t(unsigned long long)rip->i_ino);\n\t\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs_int(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_rele_rip;\n\t}\n\tmp->m_rootip = rip;\t/* save it */\n\n\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Initialize realtime inode pointers in the mount structure\n\t */\n\terror = xfs_rtmount_inodes(mp);\n\tif (error) {\n\t\t/*\n\t\t * Free up the root inode.\n\t\t */\n\t\txfs_warn(mp, \"failed to read RT inodes\");\n\t\tgoto out_rele_rip;\n\t}\n\n\t/*\n\t * If this is a read-only mount defer the superblock updates until\n\t * the next remount into writeable mode.  Otherwise we would never\n\t * perform the update e.g. for the root filesystem.\n\t */\n\tif (mp->m_update_sb && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Initialise the XFS quota management subsystem for this mount\n\t */\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\terror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\n\t\tif (error)\n\t\t\tgoto out_rtunmount;\n\t} else {\n\t\tASSERT(!XFS_IS_QUOTA_ON(mp));\n\n\t\t/*\n\t\t * If a file system had quotas running earlier, but decided to\n\t\t * mount without -o uquota/pquota/gquota options, revoke the\n\t\t * quotachecked license.\n\t\t */\n\t\tif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\n\t\t\txfs_notice(mp, \"resetting quota flags\");\n\t\t\terror = xfs_mount_reset_sbqflags(mp);\n\t\t\tif (error)\n\t\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Finish recovering the file system.  This part needed to be\n\t * delayed until after the root and real-time bitmap inodes\n\t * were consistently read in.\n\t */\n\terror = xfs_log_mount_finish(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"log mount finish failed\");\n\t\tgoto out_rtunmount;\n\t}\n\n\t/*\n\t * Complete the quota initialisation, post-log-replay component.\n\t */\n\tif (quotamount) {\n\t\tASSERT(mp->m_qflags == 0);\n\t\tmp->m_qflags = quotaflags;\n\n\t\txfs_qm_mount_quotas(mp);\n\t}\n\n\t/*\n\t * Now we are mounted, reserve a small amount of unused space for\n\t * privileged transactions. This is needed so that transaction\n\t * space required for critical operations can dip into this pool\n\t * when at ENOSPC. This is needed for operations like create with\n\t * attr, unwritten extent conversion at ENOSPC, etc. Data allocations\n\t * are not allowed to use this reserved space.\n\t *\n\t * This may drive us straight to ENOSPC on mount, but that implies\n\t * we were already there on the last unmount. Warn if this occurs.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\tresblks = xfs_default_resblks(mp);\n\t\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\t\tif (error)\n\t\t\txfs_warn(mp,\n\t\"Unable to allocate reserve blocks. Continuing without reserve pool.\");\n\t}\n\n\treturn 0;\n\n out_rtunmount:\n\txfs_rtunmount_inodes(mp);\n out_rele_rip:\n\tIRELE(rip);\n out_log_dealloc:\n\txfs_log_unmount(mp);\n out_fail_wait:\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_wait_buftarg(mp->m_logdev_targp);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n out_free_perag:\n\txfs_free_perag(mp);\n out_free_dir:\n\txfs_da_unmount(mp);\n out_remove_uuid:\n\txfs_uuid_unmount(mp);\n out_remove_sysfs:\n\txfs_sysfs_del(&mp->m_kobj);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sysfs_del",
          "args": [
            "&mp->m_kobj"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "51-58",
          "snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_uuid_unmount",
          "args": [
            "mp"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_uuid_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "109-130",
          "snippet": "STATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(xfs_uuid_table_mutex);",
            "static int xfs_uuid_table_size;",
            "static uuid_t *xfs_uuid_table;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nSTATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_unmount",
          "args": [
            "mp"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "162-168",
          "snippet": "void\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tkmem_free(mp->m_dir_geo);\n\tkmem_free(mp->m_attr_geo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_perag",
          "args": [
            "mp"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_perag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "146-161",
          "snippet": "STATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_wait_buftarg",
          "args": [
            "mp->m_ddev_targp"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_wait_buftarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1518-1545",
          "snippet": "void\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_unmount",
          "args": [
            "mp"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "948-959",
          "snippet": "void\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "rip"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtunmount_inodes",
          "args": [
            "mp"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtunmount_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1249-1257",
          "snippet": "void\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Unable to allocate reserve blocks. Continuing without reserve pool.\""
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reserve_blocks",
          "args": [
            "mp",
            "&resblks",
            "NULL"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "665-764",
          "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_default_resblks",
          "args": [
            "mp"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_default_resblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "601-617",
          "snippet": "__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_mount_quotas",
          "args": [
            "mp"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_mount_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1388-1470",
          "snippet": "void\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_qflags == 0"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log mount finish failed\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_mount_finish",
          "args": [
            "mp"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_mount_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "745-760",
          "snippet": "int\nxfs_log_mount_finish(xfs_mount_t *mp)\n{\n\tint\terror = 0;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\terror = xlog_recover_finish(mp->m_log);\n\t\tif (!error)\n\t\t\txfs_log_work_queue(mp);\n\t} else {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_mount_finish(xfs_mount_t *mp)\n{\n\tint\terror = 0;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\terror = xlog_recover_finish(mp->m_log);\n\t\tif (!error)\n\t\t\txfs_log_work_queue(mp);\n\t} else {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mount_reset_sbqflags",
          "args": [
            "mp"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mount_reset_sbqflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "582-599",
          "snippet": "int\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"resetting quota flags\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!XFS_IS_QUOTA_ON(mp)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_newmount",
          "args": [
            "mp",
            "&quotamount",
            "&quotaflags"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_newmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
          "lines": "81-149",
          "snippet": "int\nxfs_qm_newmount(\n\txfs_mount_t\t*mp,\n\tuint\t\t*needquotamount,\n\tuint\t\t*quotaflags)\n{\n\tuint\t\tquotaondisk;\n\tuint\t\tuquotaondisk = 0, gquotaondisk = 0, pquotaondisk = 0;\n\n\tquotaondisk = xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t\t\t(mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT);\n\n\tif (quotaondisk) {\n\t\tuquotaondisk = mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT;\n\t\tpquotaondisk = mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT;\n\t\tgquotaondisk = mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT;\n\t}\n\n\t/*\n\t * If the device itself is read-only, we can't allow\n\t * the user to change the state of quota on the mount -\n\t * this would generate a transaction on the ro device,\n\t * which would lead to an I/O error and shutdown\n\t */\n\n\tif (((uquotaondisk && !XFS_IS_UQUOTA_ON(mp)) ||\n\t    (!uquotaondisk &&  XFS_IS_UQUOTA_ON(mp)) ||\n\t     (gquotaondisk && !XFS_IS_GQUOTA_ON(mp)) ||\n\t    (!gquotaondisk &&  XFS_IS_GQUOTA_ON(mp)) ||\n\t     (pquotaondisk && !XFS_IS_PQUOTA_ON(mp)) ||\n\t    (!pquotaondisk &&  XFS_IS_PQUOTA_ON(mp)))  &&\n\t    xfs_dev_is_read_only(mp, \"changing quota state\")) {\n\t\txfs_warn(mp, \"please mount with%s%s%s%s.\",\n\t\t\t(!quotaondisk ? \"out quota\" : \"\"),\n\t\t\t(uquotaondisk ? \" usrquota\" : \"\"),\n\t\t\t(gquotaondisk ? \" grpquota\" : \"\"),\n\t\t\t(pquotaondisk ? \" prjquota\" : \"\"));\n\t\treturn -EPERM;\n\t}\n\n\tif (XFS_IS_QUOTA_ON(mp) || quotaondisk) {\n\t\t/*\n\t\t * Call mount_quotas at this point only if we won't have to do\n\t\t * a quotacheck.\n\t\t */\n\t\tif (quotaondisk && !XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\t\t/*\n\t\t\t * If an error occurred, qm_mount_quotas code\n\t\t\t * has already disabled quotas. So, just finish\n\t\t\t * mounting, and get on with the boring life\n\t\t\t * without disk quotas.\n\t\t\t */\n\t\t\txfs_qm_mount_quotas(mp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Clear the quota flags, but remember them. This\n\t\t\t * is so that the quota code doesn't get invoked\n\t\t\t * before we're ready. This can happen when an\n\t\t\t * inode goes inactive and wants to free blocks,\n\t\t\t * or via xfs_log_mount_finish.\n\t\t\t */\n\t\t\t*needquotamount = true;\n\t\t\t*quotaflags = mp->m_qflags;\n\t\t\tmp->m_qflags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_newmount(\n\txfs_mount_t\t*mp,\n\tuint\t\t*needquotamount,\n\tuint\t\t*quotaflags)\n{\n\tuint\t\tquotaondisk;\n\tuint\t\tuquotaondisk = 0, gquotaondisk = 0, pquotaondisk = 0;\n\n\tquotaondisk = xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t\t\t(mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT);\n\n\tif (quotaondisk) {\n\t\tuquotaondisk = mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT;\n\t\tpquotaondisk = mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT;\n\t\tgquotaondisk = mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT;\n\t}\n\n\t/*\n\t * If the device itself is read-only, we can't allow\n\t * the user to change the state of quota on the mount -\n\t * this would generate a transaction on the ro device,\n\t * which would lead to an I/O error and shutdown\n\t */\n\n\tif (((uquotaondisk && !XFS_IS_UQUOTA_ON(mp)) ||\n\t    (!uquotaondisk &&  XFS_IS_UQUOTA_ON(mp)) ||\n\t     (gquotaondisk && !XFS_IS_GQUOTA_ON(mp)) ||\n\t    (!gquotaondisk &&  XFS_IS_GQUOTA_ON(mp)) ||\n\t     (pquotaondisk && !XFS_IS_PQUOTA_ON(mp)) ||\n\t    (!pquotaondisk &&  XFS_IS_PQUOTA_ON(mp)))  &&\n\t    xfs_dev_is_read_only(mp, \"changing quota state\")) {\n\t\txfs_warn(mp, \"please mount with%s%s%s%s.\",\n\t\t\t(!quotaondisk ? \"out quota\" : \"\"),\n\t\t\t(uquotaondisk ? \" usrquota\" : \"\"),\n\t\t\t(gquotaondisk ? \" grpquota\" : \"\"),\n\t\t\t(pquotaondisk ? \" prjquota\" : \"\"));\n\t\treturn -EPERM;\n\t}\n\n\tif (XFS_IS_QUOTA_ON(mp) || quotaondisk) {\n\t\t/*\n\t\t * Call mount_quotas at this point only if we won't have to do\n\t\t * a quotacheck.\n\t\t */\n\t\tif (quotaondisk && !XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\t\t/*\n\t\t\t * If an error occurred, qm_mount_quotas code\n\t\t\t * has already disabled quotas. So, just finish\n\t\t\t * mounting, and get on with the boring life\n\t\t\t * without disk quotas.\n\t\t\t */\n\t\t\txfs_qm_mount_quotas(mp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Clear the quota flags, but remember them. This\n\t\t\t * is so that the quota code doesn't get invoked\n\t\t\t * before we're ready. This can happen when an\n\t\t\t * inode goes inactive and wants to free blocks,\n\t\t\t * or via xfs_log_mount_finish.\n\t\t\t */\n\t\t\t*needquotamount = true;\n\t\t\t*quotaflags = mp->m_qflags;\n\t\t\tmp->m_qflags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"failed to write sb changes\""
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"failed to read RT inodes\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtmount_inodes",
          "args": [
            "mp"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmount_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1225-1247",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_rtmount_inodes(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\terror;\t\t/* error return value */\n\txfs_sb_t\t*sbp;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rbmino == NULLFSINO)\n\t\treturn 0;\n\terror = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\tASSERT(mp->m_rbmip != NULL);\n\tASSERT(sbp->sb_rsumino != NULLFSINO);\n\terror = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip);\n\tif (error) {\n\t\tIRELE(mp->m_rbmip);\n\t\treturn error;\n\t}\n\tASSERT(mp->m_rsumip != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtmount_inodes(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\terror;\t\t/* error return value */\n\txfs_sb_t\t*sbp;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rbmino == NULLFSINO)\n\t\treturn 0;\n\terror = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\tASSERT(mp->m_rbmip != NULL);\n\tASSERT(sbp->sb_rsumino != NULLFSINO);\n\terror = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip);\n\tif (error) {\n\t\tIRELE(mp->m_rbmip);\n\t\treturn error;\n\t}\n\tASSERT(mp->m_rsumip != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "rip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_mountfs_int(2)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"corrupted root inode %llu: not a directory\"",
            "(unsigned long long)rip->i_ino"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!S_ISDIR(rip->i_d.di_mode)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "rip->i_d.di_mode"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rip != NULL"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"failed to read root inode\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "sbp->sb_rootino",
            "0",
            "XFS_ILOCK_EXCL",
            "&rip"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_initialize_perag_data",
          "args": [
            "mp",
            "sbp->sb_agcount"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_initialize_perag_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "710-759",
          "snippet": "int\nxfs_initialize_perag_data(\n\tstruct xfs_mount *mp,\n\txfs_agnumber_t\tagcount)\n{\n\txfs_agnumber_t\tindex;\n\txfs_perag_t\t*pag;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tuint64_t\tifree = 0;\n\tuint64_t\tialloc = 0;\n\tuint64_t\tbfree = 0;\n\tuint64_t\tbfreelst = 0;\n\tuint64_t\tbtree = 0;\n\tint\t\terror;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\t/*\n\t\t * read the agf, then the agi. This gets us\n\t\t * all the information we need and populates the\n\t\t * per-ag structures for us.\n\t\t */\n\t\terror = xfs_alloc_pagf_init(mp, NULL, index, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_ialloc_pagi_init(mp, NULL, index);\n\t\tif (error)\n\t\t\treturn error;\n\t\tpag = xfs_perag_get(mp, index);\n\t\tifree += pag->pagi_freecount;\n\t\tialloc += pag->pagi_count;\n\t\tbfree += pag->pagf_freeblks;\n\t\tbfreelst += pag->pagf_flcount;\n\t\tbtree += pag->pagf_btreeblks;\n\t\txfs_perag_put(pag);\n\t}\n\t/*\n\t * Overwrite incore superblock counters with just-read data\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbp->sb_ifree = ifree;\n\tsbp->sb_icount = ialloc;\n\tsbp->sb_fdblocks = bfree + bfreelst + btree;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/* Fixup the per-cpu counters as well. */\n\txfs_icsb_reinit_counters(mp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_initialize_perag_data(\n\tstruct xfs_mount *mp,\n\txfs_agnumber_t\tagcount)\n{\n\txfs_agnumber_t\tindex;\n\txfs_perag_t\t*pag;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tuint64_t\tifree = 0;\n\tuint64_t\tialloc = 0;\n\tuint64_t\tbfree = 0;\n\tuint64_t\tbfreelst = 0;\n\tuint64_t\tbtree = 0;\n\tint\t\terror;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\t/*\n\t\t * read the agf, then the agi. This gets us\n\t\t * all the information we need and populates the\n\t\t * per-ag structures for us.\n\t\t */\n\t\terror = xfs_alloc_pagf_init(mp, NULL, index, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_ialloc_pagi_init(mp, NULL, index);\n\t\tif (error)\n\t\t\treturn error;\n\t\tpag = xfs_perag_get(mp, index);\n\t\tifree += pag->pagi_freecount;\n\t\tialloc += pag->pagi_count;\n\t\tbfree += pag->pagf_freeblks;\n\t\tbfreelst += pag->pagf_flcount;\n\t\tbtree += pag->pagf_btreeblks;\n\t\txfs_perag_put(pag);\n\t}\n\t/*\n\t * Overwrite incore superblock counters with just-read data\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbp->sb_ifree = ifree;\n\tsbp->sb_icount = ialloc;\n\tsbp->sb_fdblocks = bfree + bfreelst + btree;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/* Fixup the per-cpu counters as well. */\n\txfs_icsb_reinit_counters(mp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_LAST_UNMOUNT_WAS_CLEAN",
          "args": [
            "mp"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log mount failed\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_mount",
          "args": [
            "mp",
            "mp->m_logdev_targp",
            "XFS_FSB_TO_DADDR(mp, sbp->sb_logstart)",
            "XFS_FSB_TO_BB(mp, sbp->sb_logblocks)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "609-733",
          "snippet": "int\nxfs_log_mount(\n\txfs_mount_t\t*mp,\n\txfs_buftarg_t\t*log_target,\n\txfs_daddr_t\tblk_offset,\n\tint\t\tnum_bblks)\n{\n\tint\t\terror = 0;\n\tint\t\tmin_logfsbs;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\txfs_notice(mp, \"Mounting V%d Filesystem\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t} else {\n\t\txfs_notice(mp,\n\"Mounting V%d filesystem in no-recovery mode. Filesystem will be inconsistent.\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\tmp->m_log = xlog_alloc_log(mp, log_target, blk_offset, num_bblks);\n\tif (IS_ERR(mp->m_log)) {\n\t\terror = PTR_ERR(mp->m_log);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Validate the given log space and drop a critical message via syslog\n\t * if the log size is too small that would lead to some unexpected\n\t * situations in transaction log space reservation stage.\n\t *\n\t * Note: we can't just reject the mount if the validation fails.  This\n\t * would mean that people would have to downgrade their kernel just to\n\t * remedy the situation as there is no way to grow the log (short of\n\t * black magic surgery with xfs_db).\n\t *\n\t * We can, however, reject mounts for CRC format filesystems, as the\n\t * mkfs binary being used to make the filesystem should never create a\n\t * filesystem with a log that is too small.\n\t */\n\tmin_logfsbs = xfs_log_calc_minimum_size(mp);\n\n\tif (mp->m_sb.sb_logblocks < min_logfsbs) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too small, minimum size is %d blocks\",\n\t\t\t mp->m_sb.sb_logblocks, min_logfsbs);\n\t\terror = -EINVAL;\n\t} else if (mp->m_sb.sb_logblocks > XFS_MAX_LOG_BLOCKS) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too large, maximum size is %lld blocks\",\n\t\t\t mp->m_sb.sb_logblocks, XFS_MAX_LOG_BLOCKS);\n\t\terror = -EINVAL;\n\t} else if (XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks) > XFS_MAX_LOG_BYTES) {\n\t\txfs_warn(mp,\n\t\t\"log size %lld bytes too large, maximum size is %lld bytes\",\n\t\t\t XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks),\n\t\t\t XFS_MAX_LOG_BYTES);\n\t\terror = -EINVAL;\n\t}\n\tif (error) {\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_crit(mp, \"AAIEEE! Log failed size checks. Abort!\");\n\t\t\tASSERT(0);\n\t\t\tgoto out_free_log;\n\t\t}\n\t\txfs_crit(mp,\n\"Log size out of supported range. Continuing onwards, but if log hangs are\\n\"\n\"experienced then please report this message in the bug report.\");\n\t}\n\n\t/*\n\t * Initialize the AIL now we have a log.\n\t */\n\terror = xfs_trans_ail_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"AIL initialisation failed: error %d\", error);\n\t\tgoto out_free_log;\n\t}\n\tmp->m_log->l_ailp = mp->m_ail;\n\n\t/*\n\t * skip log recovery on a norecovery mount.  pretend it all\n\t * just worked.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\tint\treadonly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\terror = xlog_recover(mp->m_log);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"log mount/recovery failed: error %d\",\n\t\t\t\terror);\n\t\t\tgoto out_destroy_ail;\n\t\t}\n\t}\n\n\terror = xfs_sysfs_init(&mp->m_log->l_kobj, &xfs_log_ktype, &mp->m_kobj,\n\t\t\t       \"log\");\n\tif (error)\n\t\tgoto out_destroy_ail;\n\n\t/* Normal transactions can now occur */\n\tmp->m_log->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\n\t/*\n\t * Now the log has been fully initialised and we know were our\n\t * space grant counters are, we can initialise the permanent ticket\n\t * needed for delayed logging to work.\n\t */\n\txlog_cil_init_post_recovery(mp->m_log);\n\n\treturn 0;\n\nout_destroy_ail:\n\txfs_trans_ail_destroy(mp);\nout_free_log:\n\txlog_dealloc_log(mp->m_log);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\n\nint\nxfs_log_mount(\n\txfs_mount_t\t*mp,\n\txfs_buftarg_t\t*log_target,\n\txfs_daddr_t\tblk_offset,\n\tint\t\tnum_bblks)\n{\n\tint\t\terror = 0;\n\tint\t\tmin_logfsbs;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\txfs_notice(mp, \"Mounting V%d Filesystem\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t} else {\n\t\txfs_notice(mp,\n\"Mounting V%d filesystem in no-recovery mode. Filesystem will be inconsistent.\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\tmp->m_log = xlog_alloc_log(mp, log_target, blk_offset, num_bblks);\n\tif (IS_ERR(mp->m_log)) {\n\t\terror = PTR_ERR(mp->m_log);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Validate the given log space and drop a critical message via syslog\n\t * if the log size is too small that would lead to some unexpected\n\t * situations in transaction log space reservation stage.\n\t *\n\t * Note: we can't just reject the mount if the validation fails.  This\n\t * would mean that people would have to downgrade their kernel just to\n\t * remedy the situation as there is no way to grow the log (short of\n\t * black magic surgery with xfs_db).\n\t *\n\t * We can, however, reject mounts for CRC format filesystems, as the\n\t * mkfs binary being used to make the filesystem should never create a\n\t * filesystem with a log that is too small.\n\t */\n\tmin_logfsbs = xfs_log_calc_minimum_size(mp);\n\n\tif (mp->m_sb.sb_logblocks < min_logfsbs) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too small, minimum size is %d blocks\",\n\t\t\t mp->m_sb.sb_logblocks, min_logfsbs);\n\t\terror = -EINVAL;\n\t} else if (mp->m_sb.sb_logblocks > XFS_MAX_LOG_BLOCKS) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too large, maximum size is %lld blocks\",\n\t\t\t mp->m_sb.sb_logblocks, XFS_MAX_LOG_BLOCKS);\n\t\terror = -EINVAL;\n\t} else if (XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks) > XFS_MAX_LOG_BYTES) {\n\t\txfs_warn(mp,\n\t\t\"log size %lld bytes too large, maximum size is %lld bytes\",\n\t\t\t XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks),\n\t\t\t XFS_MAX_LOG_BYTES);\n\t\terror = -EINVAL;\n\t}\n\tif (error) {\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_crit(mp, \"AAIEEE! Log failed size checks. Abort!\");\n\t\t\tASSERT(0);\n\t\t\tgoto out_free_log;\n\t\t}\n\t\txfs_crit(mp,\n\"Log size out of supported range. Continuing onwards, but if log hangs are\\n\"\n\"experienced then please report this message in the bug report.\");\n\t}\n\n\t/*\n\t * Initialize the AIL now we have a log.\n\t */\n\terror = xfs_trans_ail_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"AIL initialisation failed: error %d\", error);\n\t\tgoto out_free_log;\n\t}\n\tmp->m_log->l_ailp = mp->m_ail;\n\n\t/*\n\t * skip log recovery on a norecovery mount.  pretend it all\n\t * just worked.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\tint\treadonly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\terror = xlog_recover(mp->m_log);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"log mount/recovery failed: error %d\",\n\t\t\t\terror);\n\t\t\tgoto out_destroy_ail;\n\t\t}\n\t}\n\n\terror = xfs_sysfs_init(&mp->m_log->l_kobj, &xfs_log_ktype, &mp->m_kobj,\n\t\t\t       \"log\");\n\tif (error)\n\t\tgoto out_destroy_ail;\n\n\t/* Normal transactions can now occur */\n\tmp->m_log->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\n\t/*\n\t * Now the log has been fully initialised and we know were our\n\t * space grant counters are, we can initialise the permanent ticket\n\t * needed for delayed logging to work.\n\t */\n\txlog_cil_init_post_recovery(mp->m_log);\n\n\treturn 0;\n\nout_destroy_ail:\n\txfs_trans_ail_destroy(mp);\nout_free_log:\n\txlog_dealloc_log(mp->m_log);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "sbp->sb_logblocks"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "sbp->sb_logstart"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_mountfs\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"no log defined\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Failed per-ag init: %d\"",
            "error"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_initialize_perag",
          "args": [
            "mp",
            "sbp->sb_agcount",
            "&mp->m_maxagi"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_initialize_perag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "181-263",
          "snippet": "int\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&mp->m_perag_tree",
            "GFP_ATOMIC"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mp->m_perag_lock"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_init",
          "args": [
            "mp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "42-47",
          "snippet": "void\nxfs_trans_init(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_trans_resv_calc(mp, M_RES(mp));\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_init(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_trans_resv_calc(mp, M_RES(mp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Failed dir/attr init: %d\"",
            "error"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_mount",
          "args": [
            "mp"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "100-160",
          "snippet": "int\nxfs_da_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_da_geometry\t*dageo;\n\tint\t\t\tnodehdr_size;\n\n\n\tASSERT(mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT);\n\tASSERT((1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\n\t       XFS_MAX_BLOCKSIZE);\n\n\tmp->m_dir_inode_ops = xfs_dir_get_ops(mp, NULL);\n\tmp->m_nondir_inode_ops = xfs_nondir_get_ops(mp, NULL);\n\n\tnodehdr_size = mp->m_dir_inode_ops->node_hdr_size;\n\tmp->m_dir_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t    KM_SLEEP | KM_MAYFAIL);\n\tmp->m_attr_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t     KM_SLEEP | KM_MAYFAIL);\n\tif (!mp->m_dir_geo || !mp->m_attr_geo) {\n\t\tkmem_free(mp->m_dir_geo);\n\t\tkmem_free(mp->m_attr_geo);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set up directory geometry */\n\tdageo = mp->m_dir_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;\n\n\t/*\n\t * Now we've set up the block conversion variables, we can calculate the\n\t * segment block constants using the geometry structure.\n\t */\n\tdageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);\n\tdageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);\n\tdageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\t/* set up attribute geometry - single fsb only */\n\tdageo = mp->m_attr_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1;\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\tif (xfs_sb_version_hasasciici(&mp->m_sb))\n\t\tmp->m_dirnameops = &xfs_ascii_ci_nameops;\n\telse\n\t\tmp->m_dirnameops = &xfs_default_nameops;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct xfs_nameops xfs_ascii_ci_nameops = {\n\t.hashname\t= xfs_ascii_ci_hashname,\n\t.compname\t= xfs_ascii_ci_compname,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_nameops xfs_ascii_ci_nameops = {\n\t.hashname\t= xfs_ascii_ci_hashname,\n\t.compname\t= xfs_ascii_ci_compname,\n};\n\nint\nxfs_da_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_da_geometry\t*dageo;\n\tint\t\t\tnodehdr_size;\n\n\n\tASSERT(mp->m_sb.sb_versionnum & XFS_SB_VERSION_DIRV2BIT);\n\tASSERT((1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\n\t       XFS_MAX_BLOCKSIZE);\n\n\tmp->m_dir_inode_ops = xfs_dir_get_ops(mp, NULL);\n\tmp->m_nondir_inode_ops = xfs_nondir_get_ops(mp, NULL);\n\n\tnodehdr_size = mp->m_dir_inode_ops->node_hdr_size;\n\tmp->m_dir_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t    KM_SLEEP | KM_MAYFAIL);\n\tmp->m_attr_geo = kmem_zalloc(sizeof(struct xfs_da_geometry),\n\t\t\t\t     KM_SLEEP | KM_MAYFAIL);\n\tif (!mp->m_dir_geo || !mp->m_attr_geo) {\n\t\tkmem_free(mp->m_dir_geo);\n\t\tkmem_free(mp->m_attr_geo);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set up directory geometry */\n\tdageo = mp->m_dir_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;\n\n\t/*\n\t * Now we've set up the block conversion variables, we can calculate the\n\t * segment block constants using the geometry structure.\n\t */\n\tdageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);\n\tdageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);\n\tdageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\t/* set up attribute geometry - single fsb only */\n\tdageo = mp->m_attr_geo;\n\tdageo->blklog = mp->m_sb.sb_blocklog;\n\tdageo->fsblog = mp->m_sb.sb_blocklog;\n\tdageo->blksize = 1 << dageo->blklog;\n\tdageo->fsbcount = 1;\n\tdageo->node_ents = (dageo->blksize - nodehdr_size) /\n\t\t\t\t(uint)sizeof(xfs_da_node_entry_t);\n\tdageo->magicpct = (dageo->blksize * 37) / 100;\n\n\tif (xfs_sb_version_hasasciici(&mp->m_sb))\n\t\tmp->m_dirnameops = &xfs_ascii_ci_nameops;\n\telse\n\t\tmp->m_dirnameops = &xfs_default_nameops;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_getnodeuniq",
          "args": [
            "&sbp->sb_uuid",
            "mp->m_fixedfsid"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_getnodeuniq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "35-43",
          "snippet": "void\nuuid_getnodeuniq(uuid_t *uuid, int fsid [2])\n{\n\txfs_uu_t *uup = (xfs_uu_t *)uuid;\n\n\tfsid[0] = (be16_to_cpu(uup->uu_clockseq) << 16) |\n\t\t   be16_to_cpu(uup->uu_timemid);\n\tfsid[1] = be32_to_cpu(uup->uu_timelow);\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nvoid\nuuid_getnodeuniq(uuid_t *uuid, int fsid [2])\n{\n\txfs_uu_t *uup = (xfs_uu_t *)uuid;\n\n\tfsid[0] = (be16_to_cpu(uup->uu_clockseq) << 16) |\n\t\t   be16_to_cpu(uup->uu_timemid);\n\tfsid[1] = be32_to_cpu(uup->uu_timelow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"RT mount failed\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtmount_init",
          "args": [
            "mp"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmount_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1177-1219",
          "snippet": "int\t\t\t\t/* error */\nxfs_rtmount_init(\n\tstruct xfs_mount\t*mp)\t/* file system mount structure */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer for last block of subvolume */\n\tstruct xfs_sb\t\t*sbp;\t/* filesystem superblock copy in mount */\n\txfs_daddr_t\t\td;\t/* address of last block of subvolume */\n\tint\t\t\terror;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rblocks == 0)\n\t\treturn 0;\n\tif (mp->m_rtdev_targp == NULL) {\n\t\txfs_warn(mp,\n\t\"Filesystem has a realtime volume, use rtdev=device option\");\n\t\treturn -ENODEV;\n\t}\n\tmp->m_rsumlevels = sbp->sb_rextslog + 1;\n\tmp->m_rsumsize =\n\t\t(uint)sizeof(xfs_suminfo_t) * mp->m_rsumlevels *\n\t\tsbp->sb_rbmblocks;\n\tmp->m_rsumsize = roundup(mp->m_rsumsize, sbp->sb_blocksize);\n\tmp->m_rbmip = mp->m_rsumip = NULL;\n\t/*\n\t * Check that the realtime section is an ok size.\n\t */\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_rblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_rblocks) {\n\t\txfs_warn(mp, \"realtime mount -- %llu != %llu\",\n\t\t\t(unsigned long long) XFS_BB_TO_FSB(mp, d),\n\t\t\t(unsigned long long) mp->m_sb.sb_rblocks);\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"realtime device size check failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_rtmount_init(\n\tstruct xfs_mount\t*mp)\t/* file system mount structure */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer for last block of subvolume */\n\tstruct xfs_sb\t\t*sbp;\t/* filesystem superblock copy in mount */\n\txfs_daddr_t\t\td;\t/* address of last block of subvolume */\n\tint\t\t\terror;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rblocks == 0)\n\t\treturn 0;\n\tif (mp->m_rtdev_targp == NULL) {\n\t\txfs_warn(mp,\n\t\"Filesystem has a realtime volume, use rtdev=device option\");\n\t\treturn -ENODEV;\n\t}\n\tmp->m_rsumlevels = sbp->sb_rextslog + 1;\n\tmp->m_rsumsize =\n\t\t(uint)sizeof(xfs_suminfo_t) * mp->m_rsumlevels *\n\t\tsbp->sb_rbmblocks;\n\tmp->m_rsumsize = roundup(mp->m_rsumsize, sbp->sb_blocksize);\n\tmp->m_rbmip = mp->m_rsumip = NULL;\n\t/*\n\t * Check that the realtime section is an ok size.\n\t */\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_rblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_rblocks) {\n\t\txfs_warn(mp, \"realtime mount -- %llu != %llu\",\n\t\t\t(unsigned long long) XFS_BB_TO_FSB(mp, d),\n\t\t\t(unsigned long long) mp->m_sb.sb_rblocks);\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"realtime device size check failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_check_sizes",
          "args": [
            "mp"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "538-577",
          "snippet": "STATIC int\nxfs_check_sizes(\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf\t*bp;\n\txfs_daddr_t\td;\n\tint\t\terror;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\n\t\txfs_warn(mp, \"filesystem size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\t\td - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"last sector read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\n\tif (mp->m_logdev_targp == mp->m_ddev_targp)\n\t\treturn 0;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\n\t\txfs_warn(mp, \"log size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_logdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"log device read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_sizes(\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf\t*bp;\n\txfs_daddr_t\td;\n\tint\t\terror;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\n\t\txfs_warn(mp, \"filesystem size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\t\td - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"last sector read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\n\tif (mp->m_logdev_targp == mp->m_ddev_targp)\n\t\treturn 0;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\n\t\txfs_warn(mp, \"log size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_logdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"log device read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_inoalignment",
          "args": [
            "mp"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_inoalignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "515-533",
          "snippet": "STATIC void\nxfs_set_inoalignment(xfs_mount_t *mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t    XFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\tmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\n\telse\n\t\tmp->m_inoalign_mask = 0;\n\t/*\n\t * If we are using stripe alignment, check whether\n\t * the stripe unit is a multiple of the inode alignment\n\t */\n\tif (mp->m_dalign && mp->m_inoalign_mask &&\n\t    !(mp->m_dalign & mp->m_inoalign_mask))\n\t\tmp->m_sinoalign = mp->m_dalign;\n\telse\n\t\tmp->m_sinoalign = 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_inoalignment(xfs_mount_t *mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t    XFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\tmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\n\telse\n\t\tmp->m_inoalign_mask = 0;\n\t/*\n\t * If we are using stripe alignment, check whether\n\t * the stripe unit is a multiple of the inode alignment\n\t */\n\tif (mp->m_dalign && mp->m_inoalign_mask &&\n\t    !(mp->m_dalign & mp->m_inoalign_mask))\n\t\tmp->m_sinoalign = mp->m_dalign;\n\telse\n\t\tmp->m_sinoalign = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "new_size"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_low_space_thresholds",
          "args": [
            "mp"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_low_space_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "497-509",
          "snippet": "void\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_rw_sizes",
          "args": [
            "mp"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_rw_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "461-492",
          "snippet": "STATIC void\nxfs_set_rw_sizes(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\tint\t\treadio_log, writeio_log;\n\n\tif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\n\t\tif (mp->m_flags & XFS_MOUNT_WSYNC) {\n\t\t\treadio_log = XFS_WSYNC_READIO_LOG;\n\t\t\twriteio_log = XFS_WSYNC_WRITEIO_LOG;\n\t\t} else {\n\t\t\treadio_log = XFS_READIO_LOG_LARGE;\n\t\t\twriteio_log = XFS_WRITEIO_LOG_LARGE;\n\t\t}\n\t} else {\n\t\treadio_log = mp->m_readio_log;\n\t\twriteio_log = mp->m_writeio_log;\n\t}\n\n\tif (sbp->sb_blocklog > readio_log) {\n\t\tmp->m_readio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_readio_log = readio_log;\n\t}\n\tmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\n\tif (sbp->sb_blocklog > writeio_log) {\n\t\tmp->m_writeio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_writeio_log = writeio_log;\n\t}\n\tmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_rw_sizes(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\tint\t\treadio_log, writeio_log;\n\n\tif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\n\t\tif (mp->m_flags & XFS_MOUNT_WSYNC) {\n\t\t\treadio_log = XFS_WSYNC_READIO_LOG;\n\t\t\twriteio_log = XFS_WSYNC_WRITEIO_LOG;\n\t\t} else {\n\t\t\treadio_log = XFS_READIO_LOG_LARGE;\n\t\t\twriteio_log = XFS_WRITEIO_LOG_LARGE;\n\t\t}\n\t} else {\n\t\treadio_log = mp->m_readio_log;\n\t\twriteio_log = mp->m_writeio_log;\n\t}\n\n\tif (sbp->sb_blocklog > readio_log) {\n\t\tmp->m_readio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_readio_log = readio_log;\n\t}\n\tmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\n\tif (sbp->sb_blocklog > writeio_log) {\n\t\tmp->m_writeio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_writeio_log = writeio_log;\n\t}\n\tmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_uuid_mount",
          "args": [
            "mp"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_uuid_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "66-107",
          "snippet": "STATIC int\nxfs_uuid_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\thole, i;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn 0;\n\n\tif (uuid_is_nil(uuid)) {\n\t\txfs_warn(mp, \"Filesystem has nil UUID - can't mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i])) {\n\t\t\thole = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tgoto out_duplicate;\n\t}\n\n\tif (hole < 0) {\n\t\txfs_uuid_table = kmem_realloc(xfs_uuid_table,\n\t\t\t(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\n\t\t\txfs_uuid_table_size  * sizeof(*xfs_uuid_table),\n\t\t\tKM_SLEEP);\n\t\thole = xfs_uuid_table_size++;\n\t}\n\txfs_uuid_table[hole] = *uuid;\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\n\treturn 0;\n\n out_duplicate:\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\txfs_warn(mp, \"Filesystem has duplicate UUID %pU - can't mount\", uuid);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(xfs_uuid_table_mutex);",
            "static int xfs_uuid_table_size;",
            "static uuid_t *xfs_uuid_table;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nSTATIC int\nxfs_uuid_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\thole, i;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn 0;\n\n\tif (uuid_is_nil(uuid)) {\n\t\txfs_warn(mp, \"Filesystem has nil UUID - can't mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i])) {\n\t\t\thole = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tgoto out_duplicate;\n\t}\n\n\tif (hole < 0) {\n\t\txfs_uuid_table = kmem_realloc(xfs_uuid_table,\n\t\t\t(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\n\t\t\txfs_uuid_table_size  * sizeof(*xfs_uuid_table),\n\t\t\tKM_SLEEP);\n\t\thole = xfs_uuid_table_size++;\n\t}\n\txfs_uuid_table[hole] = *uuid;\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\n\treturn 0;\n\n out_duplicate:\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\txfs_warn(mp, \"Filesystem has duplicate UUID %pU - can't mount\", uuid);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_init",
          "args": [
            "&mp->m_kobj",
            "&xfs_mp_ktype",
            "NULL",
            "mp->m_fsname"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "39-49",
          "snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_maxicount",
          "args": [
            "mp"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_maxicount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "434-453",
          "snippet": "STATIC void\nxfs_set_maxicount(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\t__uint64_t\ticount;\n\n\tif (sbp->sb_imax_pct) {\n\t\t/*\n\t\t * Make sure the maximum inode count is a multiple\n\t\t * of the units we allocate inodes in.\n\t\t */\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tdo_div(icount, mp->m_ialloc_blks);\n\t\tmp->m_maxicount = (icount * mp->m_ialloc_blks)  <<\n\t\t\t\t   sbp->sb_inopblog;\n\t} else {\n\t\tmp->m_maxicount = 0;\n\t}\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_maxicount(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\t__uint64_t\ticount;\n\n\tif (sbp->sb_imax_pct) {\n\t\t/*\n\t\t * Make sure the maximum inode count is a multiple\n\t\t * of the units we allocate inodes in.\n\t\t */\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tdo_div(icount, mp->m_ialloc_blks);\n\t\tmp->m_maxicount = (icount * mp->m_ialloc_blks)  <<\n\t\t\t\t   sbp->sb_inopblog;\n\t} else {\n\t\tmp->m_maxicount = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_compute_maxlevels",
          "args": [
            "mp"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_compute_maxlevels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1939-1957",
          "snippet": "void\nxfs_ialloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (1LL << XFS_INO_AGINO_BITS(mp)) >>\n\t\tXFS_INODES_PER_CHUNK_LOG;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_in_maxlevels = level;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (1LL << XFS_INO_AGINO_BITS(mp)) >>\n\t\tXFS_INODES_PER_CHUNK_LOG;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_in_maxlevels = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_compute_maxlevels",
          "args": [
            "mp",
            "XFS_ATTR_FORK"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_compute_maxlevels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "60-105",
          "snippet": "void\nxfs_bmap_compute_maxlevels(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\tint\t\tlevel;\t\t/* btree level */\n\tuint\t\tmaxblocks;\t/* max blocks at this level */\n\tuint\t\tmaxleafents;\t/* max leaf entries possible */\n\tint\t\tmaxrootrecs;\t/* max records in root block */\n\tint\t\tminleafrecs;\t/* min records in leaf block */\n\tint\t\tminnoderecs;\t/* min records in node block */\n\tint\t\tsz;\t\t/* root block size */\n\n\t/*\n\t * The maximum number of extents in a file, hence the maximum\n\t * number of leaf entries, is controlled by the type of di_nextents\n\t * (a signed 32-bit number, xfs_extnum_t), or by di_anextents\n\t * (a signed 16-bit number, xfs_aextnum_t).\n\t *\n\t * Note that we can no longer assume that if we are in ATTR1 that\n\t * the fork offset of all the inodes will be\n\t * (xfs_default_attroffset(ip) >> 3) because we could have mounted\n\t * with ATTR2 and then mounted back with ATTR1, keeping the\n\t * di_forkoff's fixed but probably at various positions. Therefore,\n\t * for both ATTR1 and ATTR2 we have to assume the worst case scenario\n\t * of a minimum size available.\n\t */\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tmaxleafents = MAXEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t} else {\n\t\tmaxleafents = MAXAEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t}\n\tmaxrootrecs = xfs_bmdr_maxrecs(sz, 0);\n\tminleafrecs = mp->m_bmap_dmnr[0];\n\tminnoderecs = mp->m_bmap_dmnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++) {\n\t\tif (maxblocks <= maxrootrecs)\n\t\t\tmaxblocks = 1;\n\t\telse\n\t\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\t}\n\tmp->m_bm_maxlevels[whichfork] = level;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_compute_maxlevels(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\tint\t\tlevel;\t\t/* btree level */\n\tuint\t\tmaxblocks;\t/* max blocks at this level */\n\tuint\t\tmaxleafents;\t/* max leaf entries possible */\n\tint\t\tmaxrootrecs;\t/* max records in root block */\n\tint\t\tminleafrecs;\t/* min records in leaf block */\n\tint\t\tminnoderecs;\t/* min records in node block */\n\tint\t\tsz;\t\t/* root block size */\n\n\t/*\n\t * The maximum number of extents in a file, hence the maximum\n\t * number of leaf entries, is controlled by the type of di_nextents\n\t * (a signed 32-bit number, xfs_extnum_t), or by di_anextents\n\t * (a signed 16-bit number, xfs_aextnum_t).\n\t *\n\t * Note that we can no longer assume that if we are in ATTR1 that\n\t * the fork offset of all the inodes will be\n\t * (xfs_default_attroffset(ip) >> 3) because we could have mounted\n\t * with ATTR2 and then mounted back with ATTR1, keeping the\n\t * di_forkoff's fixed but probably at various positions. Therefore,\n\t * for both ATTR1 and ATTR2 we have to assume the worst case scenario\n\t * of a minimum size available.\n\t */\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tmaxleafents = MAXEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t} else {\n\t\tmaxleafents = MAXAEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t}\n\tmaxrootrecs = xfs_bmdr_maxrecs(sz, 0);\n\tminleafrecs = mp->m_bmap_dmnr[0];\n\tminnoderecs = mp->m_bmap_dmnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++) {\n\t\tif (maxblocks <= maxrootrecs)\n\t\t\tmaxblocks = 1;\n\t\telse\n\t\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\t}\n\tmp->m_bm_maxlevels[whichfork] = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_maxlevels",
          "args": [
            "mp"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_maxlevels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1797-1814",
          "snippet": "void\nxfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (mp->m_sb.sb_agblocks + 1) / 2;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_ag_maxlevels = level;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (mp->m_sb.sb_agblocks + 1) / 2;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_ag_maxlevels = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_update_alignment",
          "args": [
            "mp"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "368-429",
          "snippet": "STATIC int\nxfs_update_alignment(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\n\tif (mp->m_dalign) {\n\t\t/*\n\t\t * If stripe unit and stripe width are not multiples\n\t\t * of the fs blocksize turn off alignment.\n\t\t */\n\t\tif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\n\t\t    (BBTOB(mp->m_swidth) & mp->m_blockmask)) {\n\t\t\txfs_warn(mp,\n\t\t\"alignment check failed: sunit/swidth vs. blocksize(%d)\",\n\t\t\t\tsbp->sb_blocksize);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Convert the stripe unit and width to FSBs.\n\t\t\t */\n\t\t\tmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\n\t\t\tif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit/swidth vs. agsize(%d)\",\n\t\t\t\t\t sbp->sb_agblocks);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (mp->m_dalign) {\n\t\t\t\tmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\n\t\t\t} else {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit(%d) less than bsize(%d)\",\n\t\t\t\t\t mp->m_dalign, sbp->sb_blocksize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Update superblock with new values\n\t\t * and log changes\n\t\t */\n\t\tif (xfs_sb_version_hasdalign(sbp)) {\n\t\t\tif (sbp->sb_unit != mp->m_dalign) {\n\t\t\t\tsbp->sb_unit = mp->m_dalign;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t\tif (sbp->sb_width != mp->m_swidth) {\n\t\t\t\tsbp->sb_width = mp->m_swidth;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_warn(mp,\n\t\"cannot change alignment: superblock does not support data alignment\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\n\t\t    xfs_sb_version_hasdalign(&mp->m_sb)) {\n\t\t\tmp->m_dalign = sbp->sb_unit;\n\t\t\tmp->m_swidth = sbp->sb_width;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_update_alignment(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\n\tif (mp->m_dalign) {\n\t\t/*\n\t\t * If stripe unit and stripe width are not multiples\n\t\t * of the fs blocksize turn off alignment.\n\t\t */\n\t\tif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\n\t\t    (BBTOB(mp->m_swidth) & mp->m_blockmask)) {\n\t\t\txfs_warn(mp,\n\t\t\"alignment check failed: sunit/swidth vs. blocksize(%d)\",\n\t\t\t\tsbp->sb_blocksize);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Convert the stripe unit and width to FSBs.\n\t\t\t */\n\t\t\tmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\n\t\t\tif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit/swidth vs. agsize(%d)\",\n\t\t\t\t\t sbp->sb_agblocks);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (mp->m_dalign) {\n\t\t\t\tmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\n\t\t\t} else {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit(%d) less than bsize(%d)\",\n\t\t\t\t\t mp->m_dalign, sbp->sb_blocksize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Update superblock with new values\n\t\t * and log changes\n\t\t */\n\t\tif (xfs_sb_version_hasdalign(sbp)) {\n\t\t\tif (sbp->sb_unit != mp->m_dalign) {\n\t\t\t\tsbp->sb_unit = mp->m_dalign;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t\tif (sbp->sb_width != mp->m_swidth) {\n\t\t\t\tsbp->sb_width = mp->m_swidth;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_warn(mp,\n\t\"cannot change alignment: superblock does not support data alignment\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\n\t\t    xfs_sb_version_hasdalign(&mp->m_sb)) {\n\t\t\tmp->m_dalign = sbp->sb_unit;\n\t\t\tmp->m_swidth = sbp->sb_width;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_removeattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_removeattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "461-466",
          "snippet": "static inline void xfs_sb_version_removeattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_features2 &= ~XFS_SB_VERSION2_ATTR2BIT;\n\tif (!sbp->sb_features2)\n\t\tsbp->sb_versionnum &= ~XFS_SB_VERSION_MOREBITSBIT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000\n\nstatic inline void xfs_sb_version_removeattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_features2 &= ~XFS_SB_VERSION2_ATTR2BIT;\n\tif (!sbp->sb_features2)\n\t\tsbp->sb_versionnum &= ~XFS_SB_VERSION_MOREBITSBIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "448-453",
          "snippet": "static inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"correcting sb_features alignment problem\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_has_mismatched_features2",
          "args": [
            "sbp"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_has_mismatched_features2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "374-377",
          "snippet": "static inline bool xfs_sb_has_mismatched_features2(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_bad_features2 != sbp->sb_features2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_sb_has_mismatched_features2(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_bad_features2 != sbp->sb_features2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_mount_common",
          "args": [
            "mp",
            "sbp"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_mount_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "664-700",
          "snippet": "void\nxfs_sb_mount_common(\n\tstruct xfs_mount *mp,\n\tstruct xfs_sb\t*sbp)\n{\n\tmp->m_agfrotor = mp->m_agirotor = 0;\n\tspin_lock_init(&mp->m_agirotor_lock);\n\tmp->m_maxagi = mp->m_sb.sb_agcount;\n\tmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\n\tmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\n\tmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\n\tmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\n\tmp->m_agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\n\tmp->m_blockmask = sbp->sb_blocksize - 1;\n\tmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\n\tmp->m_blockwmask = mp->m_blockwsize - 1;\n\n\tmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\n\tmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\n\n\tmp->m_inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_inobt_mnr[0] = mp->m_inobt_mxr[0] / 2;\n\tmp->m_inobt_mnr[1] = mp->m_inobt_mxr[1] / 2;\n\n\tmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\n\tmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\n\n\tmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\n\tmp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,\n\t\t\t\t\tsbp->sb_inopblock);\n\tmp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_mount_common(\n\tstruct xfs_mount *mp,\n\tstruct xfs_sb\t*sbp)\n{\n\tmp->m_agfrotor = mp->m_agirotor = 0;\n\tspin_lock_init(&mp->m_agirotor_lock);\n\tmp->m_maxagi = mp->m_sb.sb_agcount;\n\tmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\n\tmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\n\tmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\n\tmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\n\tmp->m_agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\n\tmp->m_blockmask = sbp->sb_blocksize - 1;\n\tmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\n\tmp->m_blockwmask = mp->m_blockwsize - 1;\n\n\tmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\n\tmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\n\n\tmp->m_inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_inobt_mnr[0] = mp->m_inobt_mxr[0] / 2;\n\tmp->m_inobt_mnr[1] = mp->m_inobt_mxr[1] / 2;\n\n\tmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\n\tmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\n\n\tmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\n\tmp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,\n\t\t\t\t\tsbp->sb_inopblock);\n\tmp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mountfs(\n\txfs_mount_t\t*mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\txfs_inode_t\t*rip;\n\t__uint64_t\tresblks;\n\tuint\t\tquotamount = 0;\n\tuint\t\tquotaflags = 0;\n\tint\t\terror = 0;\n\n\txfs_sb_mount_common(mp, sbp);\n\n\t/*\n\t * Check for a mismatched features2 values.  Older kernels read & wrote\n\t * into the wrong sb offset for sb_features2 on some platforms due to\n\t * xfs_sb_t not being 64bit size aligned when sb_features2 was added,\n\t * which made older superblock reading/writing routines swap it as a\n\t * 64-bit value.\n\t *\n\t * For backwards compatibility, we make both slots equal.\n\t *\n\t * If we detect a mismatched field, we OR the set bits into the existing\n\t * features2 field in case it has already been modified; we don't want\n\t * to lose any features.  We then update the bad location with the ORed\n\t * value so that older kernels will see any features2 flags. The\n\t * superblock writeback code ensures the new sb_features2 is copied to\n\t * sb_bad_features2 before it is logged or written to disk.\n\t */\n\tif (xfs_sb_has_mismatched_features2(sbp)) {\n\t\txfs_warn(mp, \"correcting sb_features alignment problem\");\n\t\tsbp->sb_features2 |= sbp->sb_bad_features2;\n\t\tmp->m_update_sb = true;\n\n\t\t/*\n\t\t * Re-check for ATTR2 in case it was found in bad_features2\n\t\t * slot.\n\t\t */\n\t\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t\t   !(mp->m_flags & XFS_MOUNT_NOATTR2))\n\t\t\tmp->m_flags |= XFS_MOUNT_ATTR2;\n\t}\n\n\tif (xfs_sb_version_hasattr2(&mp->m_sb) &&\n\t   (mp->m_flags & XFS_MOUNT_NOATTR2)) {\n\t\txfs_sb_version_removeattr2(&mp->m_sb);\n\t\tmp->m_update_sb = true;\n\n\t\t/* update sb_versionnum for the clearing of the morebits */\n\t\tif (!sbp->sb_features2)\n\t\t\tmp->m_update_sb = true;\n\t}\n\n\t/* always use v2 inodes by default now */\n\tif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\n\t\tmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\n\t\tmp->m_update_sb = true;\n\t}\n\n\t/*\n\t * Check if sb_agblocks is aligned at stripe boundary\n\t * If sb_agblocks is NOT aligned turn off m_dalign since\n\t * allocator alignment is within an ag, therefore ag has\n\t * to be aligned at stripe boundary.\n\t */\n\terror = xfs_update_alignment(mp);\n\tif (error)\n\t\tgoto out;\n\n\txfs_alloc_compute_maxlevels(mp);\n\txfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\n\txfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\n\txfs_ialloc_compute_maxlevels(mp);\n\n\txfs_set_maxicount(mp);\n\n\terror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_uuid_mount(mp);\n\tif (error)\n\t\tgoto out_remove_sysfs;\n\n\t/*\n\t * Set the minimum read and write sizes\n\t */\n\txfs_set_rw_sizes(mp);\n\n\t/* set the low space thresholds for dynamic preallocation */\n\txfs_set_low_space_thresholds(mp);\n\n\t/*\n\t * Set the inode cluster size.\n\t * This may still be overridden by the file system\n\t * block size if it is larger than the chosen cluster size.\n\t *\n\t * For v5 filesystems, scale the cluster size with the inode size to\n\t * keep a constant ratio of inode per cluster buffer, but only if mkfs\n\t * has set the inode alignment value appropriately for larger cluster\n\t * sizes.\n\t */\n\tmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint\tnew_size = mp->m_inode_cluster_size;\n\n\t\tnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\n\t\tif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\n\t\t\tmp->m_inode_cluster_size = new_size;\n\t}\n\n\t/*\n\t * Set inode alignment fields\n\t */\n\txfs_set_inoalignment(mp);\n\n\t/*\n\t * Check that the data (and log if separate) is an ok size.\n\t */\n\terror = xfs_check_sizes(mp);\n\tif (error)\n\t\tgoto out_remove_uuid;\n\n\t/*\n\t * Initialize realtime fields in the mount structure\n\t */\n\terror = xfs_rtmount_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"RT mount failed\");\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t *  Copies the low order bits of the timestamp and the randomly\n\t *  set \"sequence\" number out of a UUID.\n\t */\n\tuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\n\n\tmp->m_dmevmask = 0;\t/* not persistent; set after each mount */\n\n\terror = xfs_da_mount(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed dir/attr init: %d\", error);\n\t\tgoto out_remove_uuid;\n\t}\n\n\t/*\n\t * Initialize the precomputed transaction reservations values.\n\t */\n\txfs_trans_init(mp);\n\n\t/*\n\t * Allocate and initialize the per-ag data.\n\t */\n\tspin_lock_init(&mp->m_perag_lock);\n\tINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\n\terror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\n\tif (error) {\n\t\txfs_warn(mp, \"Failed per-ag init: %d\", error);\n\t\tgoto out_free_dir;\n\t}\n\n\tif (!sbp->sb_logblocks) {\n\t\txfs_warn(mp, \"no log defined\");\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs\", XFS_ERRLEVEL_LOW, mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_free_perag;\n\t}\n\n\t/*\n\t * log's mount-time initialization. Perform 1st part recovery if needed\n\t */\n\terror = xfs_log_mount(mp, mp->m_logdev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\n\t\t\t      XFS_FSB_TO_BB(mp, sbp->sb_logblocks));\n\tif (error) {\n\t\txfs_warn(mp, \"log mount failed\");\n\t\tgoto out_fail_wait;\n\t}\n\n\t/*\n\t * Now the log is mounted, we know if it was an unclean shutdown or\n\t * not. If it was, with the first phase of recovery has completed, we\n\t * have consistent AG blocks on disk. We have not recovered EFIs yet,\n\t * but they are recovered transactionally in the second recovery phase\n\t * later.\n\t *\n\t * Hence we can safely re-initialise incore superblock counters from\n\t * the per-ag data. These may not be correct if the filesystem was not\n\t * cleanly unmounted, so we need to wait for recovery to finish before\n\t * doing this.\n\t *\n\t * If the filesystem was cleanly unmounted, then we can trust the\n\t * values in the superblock to be correct and we don't need to do\n\t * anything here.\n\t *\n\t * If we are currently making the filesystem, the initialisation will\n\t * fail as the perag data is in an undefined state.\n\t */\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    !XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\n\t     !mp->m_sb.sb_inprogress) {\n\t\terror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\n\t\tif (error)\n\t\t\tgoto out_log_dealloc;\n\t}\n\n\t/*\n\t * Get and sanity-check the root inode.\n\t * Save the pointer to it in the mount structure.\n\t */\n\terror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\n\tif (error) {\n\t\txfs_warn(mp, \"failed to read root inode\");\n\t\tgoto out_log_dealloc;\n\t}\n\n\tASSERT(rip != NULL);\n\n\tif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\n\t\txfs_warn(mp, \"corrupted root inode %llu: not a directory\",\n\t\t\t(unsigned long long)rip->i_ino);\n\t\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\t\tXFS_ERROR_REPORT(\"xfs_mountfs_int(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_rele_rip;\n\t}\n\tmp->m_rootip = rip;\t/* save it */\n\n\txfs_iunlock(rip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Initialize realtime inode pointers in the mount structure\n\t */\n\terror = xfs_rtmount_inodes(mp);\n\tif (error) {\n\t\t/*\n\t\t * Free up the root inode.\n\t\t */\n\t\txfs_warn(mp, \"failed to read RT inodes\");\n\t\tgoto out_rele_rip;\n\t}\n\n\t/*\n\t * If this is a read-only mount defer the superblock updates until\n\t * the next remount into writeable mode.  Otherwise we would never\n\t * perform the update e.g. for the root filesystem.\n\t */\n\tif (mp->m_update_sb && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\terror = xfs_sync_sb(mp, false);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"failed to write sb changes\");\n\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Initialise the XFS quota management subsystem for this mount\n\t */\n\tif (XFS_IS_QUOTA_RUNNING(mp)) {\n\t\terror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\n\t\tif (error)\n\t\t\tgoto out_rtunmount;\n\t} else {\n\t\tASSERT(!XFS_IS_QUOTA_ON(mp));\n\n\t\t/*\n\t\t * If a file system had quotas running earlier, but decided to\n\t\t * mount without -o uquota/pquota/gquota options, revoke the\n\t\t * quotachecked license.\n\t\t */\n\t\tif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\n\t\t\txfs_notice(mp, \"resetting quota flags\");\n\t\t\terror = xfs_mount_reset_sbqflags(mp);\n\t\t\tif (error)\n\t\t\t\tgoto out_rtunmount;\n\t\t}\n\t}\n\n\t/*\n\t * Finish recovering the file system.  This part needed to be\n\t * delayed until after the root and real-time bitmap inodes\n\t * were consistently read in.\n\t */\n\terror = xfs_log_mount_finish(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"log mount finish failed\");\n\t\tgoto out_rtunmount;\n\t}\n\n\t/*\n\t * Complete the quota initialisation, post-log-replay component.\n\t */\n\tif (quotamount) {\n\t\tASSERT(mp->m_qflags == 0);\n\t\tmp->m_qflags = quotaflags;\n\n\t\txfs_qm_mount_quotas(mp);\n\t}\n\n\t/*\n\t * Now we are mounted, reserve a small amount of unused space for\n\t * privileged transactions. This is needed so that transaction\n\t * space required for critical operations can dip into this pool\n\t * when at ENOSPC. This is needed for operations like create with\n\t * attr, unwritten extent conversion at ENOSPC, etc. Data allocations\n\t * are not allowed to use this reserved space.\n\t *\n\t * This may drive us straight to ENOSPC on mount, but that implies\n\t * we were already there on the last unmount. Warn if this occurs.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\tresblks = xfs_default_resblks(mp);\n\t\terror = xfs_reserve_blocks(mp, &resblks, NULL);\n\t\tif (error)\n\t\t\txfs_warn(mp,\n\t\"Unable to allocate reserve blocks. Continuing without reserve pool.\");\n\t}\n\n\treturn 0;\n\n out_rtunmount:\n\txfs_rtunmount_inodes(mp);\n out_rele_rip:\n\tIRELE(rip);\n out_log_dealloc:\n\txfs_log_unmount(mp);\n out_fail_wait:\n\tif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\n\t\txfs_wait_buftarg(mp->m_logdev_targp);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n out_free_perag:\n\txfs_free_perag(mp);\n out_free_dir:\n\txfs_da_unmount(mp);\n out_remove_uuid:\n\txfs_uuid_unmount(mp);\n out_remove_sysfs:\n\txfs_sysfs_del(&mp->m_kobj);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_default_resblks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "601-617",
    "snippet": "__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "__uint64_t",
            "resblks",
            "8192"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "resblks",
            "20"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_default_resblks(xfs_mount_t *mp)\n{\n\t__uint64_t resblks;\n\n\t/*\n\t * We default to 5% or 8192 fsbs of space reserved, whichever is\n\t * smaller.  This is intended to cover concurrent allocation\n\t * transactions when we initially hit enospc. These each require a 4\n\t * block reservation. Hence by default we cover roughly 2000 concurrent\n\t * allocation reservations.\n\t */\n\tresblks = mp->m_sb.sb_dblocks;\n\tdo_div(resblks, 20);\n\tresblks = min_t(__uint64_t, resblks, 8192);\n\treturn resblks;\n}"
  },
  {
    "function_name": "xfs_mount_reset_sbqflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "582-599",
    "snippet": "int\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fs_writable",
          "args": [
            "mp",
            "SB_FREEZE_WRITE"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1061-1072",
          "snippet": "bool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}"
  },
  {
    "function_name": "xfs_check_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "538-577",
    "snippet": "STATIC int\nxfs_check_sizes(\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf\t*bp;\n\txfs_daddr_t\td;\n\tint\t\terror;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\n\t\txfs_warn(mp, \"filesystem size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\t\td - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"last sector read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\n\tif (mp->m_logdev_targp == mp->m_ddev_targp)\n\t\treturn 0;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\n\t\txfs_warn(mp, \"log size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_logdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"log device read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log device read failed\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "mp->m_logdev_targp",
            "d - XFS_FSB_TO_BB(mp, 1)",
            "XFS_FSB_TO_BB(mp, 1)",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log size mismatch detected\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "d"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_logblocks"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"last sector read failed\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"filesystem size mismatch detected\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "d"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_dblocks"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_check_sizes(\n\tstruct xfs_mount *mp)\n{\n\tstruct xfs_buf\t*bp;\n\txfs_daddr_t\td;\n\tint\t\terror;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\n\t\txfs_warn(mp, \"filesystem size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp,\n\t\t\t\t\td - XFS_FSS_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"last sector read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\n\tif (mp->m_logdev_targp == mp->m_ddev_targp)\n\t\treturn 0;\n\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\n\t\txfs_warn(mp, \"log size mismatch detected\");\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_logdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"log device read failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_set_inoalignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "515-533",
    "snippet": "STATIC void\nxfs_set_inoalignment(xfs_mount_t *mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t    XFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\tmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\n\telse\n\t\tmp->m_inoalign_mask = 0;\n\t/*\n\t * If we are using stripe alignment, check whether\n\t * the stripe unit is a multiple of the inode alignment\n\t */\n\tif (mp->m_dalign && mp->m_inoalign_mask &&\n\t    !(mp->m_dalign & mp->m_inoalign_mask))\n\t\tmp->m_sinoalign = mp->m_dalign;\n\telse\n\t\tmp->m_sinoalign = 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "mp->m_inode_cluster_size"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasalign",
          "args": [
            "&mp->m_sb"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "399-403",
          "snippet": "static inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_inoalignment(xfs_mount_t *mp)\n{\n\tif (xfs_sb_version_hasalign(&mp->m_sb) &&\n\t    mp->m_sb.sb_inoalignmt >=\n\t    XFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\n\t\tmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\n\telse\n\t\tmp->m_inoalign_mask = 0;\n\t/*\n\t * If we are using stripe alignment, check whether\n\t * the stripe unit is a multiple of the inode alignment\n\t */\n\tif (mp->m_dalign && mp->m_inoalign_mask &&\n\t    !(mp->m_dalign & mp->m_inoalign_mask))\n\t\tmp->m_sinoalign = mp->m_dalign;\n\telse\n\t\tmp->m_sinoalign = 0;\n}"
  },
  {
    "function_name": "xfs_set_low_space_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "497-509",
    "snippet": "void\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "space",
            "100"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_set_low_space_thresholds(\n\tstruct xfs_mount\t*mp)\n{\n\tint i;\n\n\tfor (i = 0; i < XFS_LOWSP_MAX; i++) {\n\t\t__uint64_t space = mp->m_sb.sb_dblocks;\n\n\t\tdo_div(space, 100);\n\t\tmp->m_low_space[i] = space * (i + 1);\n\t}\n}"
  },
  {
    "function_name": "xfs_set_rw_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "461-492",
    "snippet": "STATIC void\nxfs_set_rw_sizes(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\tint\t\treadio_log, writeio_log;\n\n\tif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\n\t\tif (mp->m_flags & XFS_MOUNT_WSYNC) {\n\t\t\treadio_log = XFS_WSYNC_READIO_LOG;\n\t\t\twriteio_log = XFS_WSYNC_WRITEIO_LOG;\n\t\t} else {\n\t\t\treadio_log = XFS_READIO_LOG_LARGE;\n\t\t\twriteio_log = XFS_WRITEIO_LOG_LARGE;\n\t\t}\n\t} else {\n\t\treadio_log = mp->m_readio_log;\n\t\twriteio_log = mp->m_writeio_log;\n\t}\n\n\tif (sbp->sb_blocklog > readio_log) {\n\t\tmp->m_readio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_readio_log = readio_log;\n\t}\n\tmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\n\tif (sbp->sb_blocklog > writeio_log) {\n\t\tmp->m_writeio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_writeio_log = writeio_log;\n\t}\n\tmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_rw_sizes(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\tint\t\treadio_log, writeio_log;\n\n\tif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\n\t\tif (mp->m_flags & XFS_MOUNT_WSYNC) {\n\t\t\treadio_log = XFS_WSYNC_READIO_LOG;\n\t\t\twriteio_log = XFS_WSYNC_WRITEIO_LOG;\n\t\t} else {\n\t\t\treadio_log = XFS_READIO_LOG_LARGE;\n\t\t\twriteio_log = XFS_WRITEIO_LOG_LARGE;\n\t\t}\n\t} else {\n\t\treadio_log = mp->m_readio_log;\n\t\twriteio_log = mp->m_writeio_log;\n\t}\n\n\tif (sbp->sb_blocklog > readio_log) {\n\t\tmp->m_readio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_readio_log = readio_log;\n\t}\n\tmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\n\tif (sbp->sb_blocklog > writeio_log) {\n\t\tmp->m_writeio_log = sbp->sb_blocklog;\n\t} else {\n\t\tmp->m_writeio_log = writeio_log;\n\t}\n\tmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\n}"
  },
  {
    "function_name": "xfs_set_maxicount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "434-453",
    "snippet": "STATIC void\nxfs_set_maxicount(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\t__uint64_t\ticount;\n\n\tif (sbp->sb_imax_pct) {\n\t\t/*\n\t\t * Make sure the maximum inode count is a multiple\n\t\t * of the units we allocate inodes in.\n\t\t */\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tdo_div(icount, mp->m_ialloc_blks);\n\t\tmp->m_maxicount = (icount * mp->m_ialloc_blks)  <<\n\t\t\t\t   sbp->sb_inopblog;\n\t} else {\n\t\tmp->m_maxicount = 0;\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "icount",
            "mp->m_ialloc_blks"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "icount",
            "100"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_set_maxicount(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\t__uint64_t\ticount;\n\n\tif (sbp->sb_imax_pct) {\n\t\t/*\n\t\t * Make sure the maximum inode count is a multiple\n\t\t * of the units we allocate inodes in.\n\t\t */\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\tdo_div(icount, mp->m_ialloc_blks);\n\t\tmp->m_maxicount = (icount * mp->m_ialloc_blks)  <<\n\t\t\t\t   sbp->sb_inopblog;\n\t} else {\n\t\tmp->m_maxicount = 0;\n\t}\n}"
  },
  {
    "function_name": "xfs_update_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "368-429",
    "snippet": "STATIC int\nxfs_update_alignment(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\n\tif (mp->m_dalign) {\n\t\t/*\n\t\t * If stripe unit and stripe width are not multiples\n\t\t * of the fs blocksize turn off alignment.\n\t\t */\n\t\tif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\n\t\t    (BBTOB(mp->m_swidth) & mp->m_blockmask)) {\n\t\t\txfs_warn(mp,\n\t\t\"alignment check failed: sunit/swidth vs. blocksize(%d)\",\n\t\t\t\tsbp->sb_blocksize);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Convert the stripe unit and width to FSBs.\n\t\t\t */\n\t\t\tmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\n\t\t\tif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit/swidth vs. agsize(%d)\",\n\t\t\t\t\t sbp->sb_agblocks);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (mp->m_dalign) {\n\t\t\t\tmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\n\t\t\t} else {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit(%d) less than bsize(%d)\",\n\t\t\t\t\t mp->m_dalign, sbp->sb_blocksize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Update superblock with new values\n\t\t * and log changes\n\t\t */\n\t\tif (xfs_sb_version_hasdalign(sbp)) {\n\t\t\tif (sbp->sb_unit != mp->m_dalign) {\n\t\t\t\tsbp->sb_unit = mp->m_dalign;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t\tif (sbp->sb_width != mp->m_swidth) {\n\t\t\t\tsbp->sb_width = mp->m_swidth;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_warn(mp,\n\t\"cannot change alignment: superblock does not support data alignment\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\n\t\t    xfs_sb_version_hasdalign(&mp->m_sb)) {\n\t\t\tmp->m_dalign = sbp->sb_unit;\n\t\t\tmp->m_swidth = sbp->sb_width;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hasdalign",
          "args": [
            "&mp->m_sb"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasdalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "405-408",
          "snippet": "static inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100\n\nstatic inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"cannot change alignment: superblock does not support data alignment\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"alignment check failed: sunit(%d) less than bsize(%d)\"",
            "mp->m_dalign",
            "sbp->sb_blocksize"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSBT",
          "args": [
            "mp",
            "mp->m_swidth"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"alignment check failed: sunit/swidth vs. agsize(%d)\"",
            "sbp->sb_agblocks"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSBT",
          "args": [
            "mp",
            "mp->m_dalign"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"alignment check failed: sunit/swidth vs. blocksize(%d)\"",
            "sbp->sb_blocksize"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "mp->m_swidth"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "mp->m_dalign"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_update_alignment(xfs_mount_t *mp)\n{\n\txfs_sb_t\t*sbp = &(mp->m_sb);\n\n\tif (mp->m_dalign) {\n\t\t/*\n\t\t * If stripe unit and stripe width are not multiples\n\t\t * of the fs blocksize turn off alignment.\n\t\t */\n\t\tif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\n\t\t    (BBTOB(mp->m_swidth) & mp->m_blockmask)) {\n\t\t\txfs_warn(mp,\n\t\t\"alignment check failed: sunit/swidth vs. blocksize(%d)\",\n\t\t\t\tsbp->sb_blocksize);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Convert the stripe unit and width to FSBs.\n\t\t\t */\n\t\t\tmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\n\t\t\tif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit/swidth vs. agsize(%d)\",\n\t\t\t\t\t sbp->sb_agblocks);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (mp->m_dalign) {\n\t\t\t\tmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\n\t\t\t} else {\n\t\t\t\txfs_warn(mp,\n\t\t\t\"alignment check failed: sunit(%d) less than bsize(%d)\",\n\t\t\t\t\t mp->m_dalign, sbp->sb_blocksize);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Update superblock with new values\n\t\t * and log changes\n\t\t */\n\t\tif (xfs_sb_version_hasdalign(sbp)) {\n\t\t\tif (sbp->sb_unit != mp->m_dalign) {\n\t\t\t\tsbp->sb_unit = mp->m_dalign;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t\tif (sbp->sb_width != mp->m_swidth) {\n\t\t\t\tsbp->sb_width = mp->m_swidth;\n\t\t\t\tmp->m_update_sb = true;\n\t\t\t}\n\t\t} else {\n\t\t\txfs_warn(mp,\n\t\"cannot change alignment: superblock does not support data alignment\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\n\t\t    xfs_sb_version_hasdalign(&mp->m_sb)) {\n\t\t\tmp->m_dalign = sbp->sb_unit;\n\t\t\tmp->m_swidth = sbp->sb_width;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_readsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "270-363",
    "snippet": "int\nxfs_readsb(\n\tstruct xfs_mount *mp,\n\tint\t\tflags)\n{\n\tunsigned int\tsector_size;\n\tstruct xfs_buf\t*bp;\n\tstruct xfs_sb\t*sbp = &mp->m_sb;\n\tint\t\terror;\n\tint\t\tloud = !(flags & XFS_MFSI_QUIET);\n\tconst struct xfs_buf_ops *buf_ops;\n\n\tASSERT(mp->m_sb_bp == NULL);\n\tASSERT(mp->m_ddev_targp != NULL);\n\n\t/*\n\t * For the initial read, we must guess at the sector\n\t * size based on the block device.  It's enough to\n\t * get the sb_sectsize out of the superblock and\n\t * then reread with the proper length.\n\t * We don't verify it yet, because it may not be complete.\n\t */\n\tsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\n\tbuf_ops = NULL;\n\n\t/*\n\t * Allocate a (locked) buffer to hold the superblock.\n\t * This will be kept around at all times to optimize\n\t * access to the superblock.\n\t */\nreread:\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\n\t\t\t\t   BTOBB(sector_size), 0, &bp, buf_ops);\n\tif (error) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"SB validate failed with error %d.\", error);\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\t/*\n\t * Initialize the mount structure from the superblock.\n\t */\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\n\t/*\n\t * If we haven't validated the superblock, do so now before we try\n\t * to check the sector size and reread the superblock appropriately.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"Invalid superblock magic number\");\n\t\terror = -EINVAL;\n\t\tgoto release_buf;\n\t}\n\n\t/*\n\t * We must be able to do sector-sized and sector-aligned IO.\n\t */\n\tif (sector_size > sbp->sb_sectsize) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"device supports %u byte sectors (not %u)\",\n\t\t\t\tsector_size, sbp->sb_sectsize);\n\t\terror = -ENOSYS;\n\t\tgoto release_buf;\n\t}\n\n\tif (buf_ops == NULL) {\n\t\t/*\n\t\t * Re-read the superblock so the buffer is correctly sized,\n\t\t * and properly verified.\n\t\t */\n\t\txfs_buf_relse(bp);\n\t\tsector_size = sbp->sb_sectsize;\n\t\tbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\n\t\tgoto reread;\n\t}\n\n\t/* Initialize per-cpu counters */\n\txfs_icsb_reinit_counters(mp);\n\n\t/* no need to be quiet anymore, so reset the buf ops */\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\tmp->m_sb_bp = bp;\n\txfs_buf_unlock(bp);\n\treturn 0;\n\nrelease_buf:\n\txfs_buf_relse(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_reinit_counters",
          "args": [
            "mp"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_reinit_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1562-1576",
          "snippet": "void\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"device supports %u byte sectors (not %u)\"",
            "sector_size",
            "sbp->sb_sectsize"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Invalid superblock magic number\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_from_disk",
          "args": [
            "sbp",
            "XFS_BUF_TO_SBP(bp)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "393-399",
          "snippet": "void\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"SB validate failed with error %d.\"",
            "error"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "mp->m_ddev_targp",
            "XFS_SB_DADDR",
            "BTOBB(sector_size)",
            "0",
            "&bp",
            "buf_ops"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "sector_size"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_getsize_buftarg",
          "args": [
            "mp->m_ddev_targp"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_ddev_targp != NULL"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb_bp == NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_readsb(\n\tstruct xfs_mount *mp,\n\tint\t\tflags)\n{\n\tunsigned int\tsector_size;\n\tstruct xfs_buf\t*bp;\n\tstruct xfs_sb\t*sbp = &mp->m_sb;\n\tint\t\terror;\n\tint\t\tloud = !(flags & XFS_MFSI_QUIET);\n\tconst struct xfs_buf_ops *buf_ops;\n\n\tASSERT(mp->m_sb_bp == NULL);\n\tASSERT(mp->m_ddev_targp != NULL);\n\n\t/*\n\t * For the initial read, we must guess at the sector\n\t * size based on the block device.  It's enough to\n\t * get the sb_sectsize out of the superblock and\n\t * then reread with the proper length.\n\t * We don't verify it yet, because it may not be complete.\n\t */\n\tsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\n\tbuf_ops = NULL;\n\n\t/*\n\t * Allocate a (locked) buffer to hold the superblock.\n\t * This will be kept around at all times to optimize\n\t * access to the superblock.\n\t */\nreread:\n\terror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\n\t\t\t\t   BTOBB(sector_size), 0, &bp, buf_ops);\n\tif (error) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"SB validate failed with error %d.\", error);\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\t/*\n\t * Initialize the mount structure from the superblock.\n\t */\n\txfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\n\n\t/*\n\t * If we haven't validated the superblock, do so now before we try\n\t * to check the sector size and reread the superblock appropriately.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"Invalid superblock magic number\");\n\t\terror = -EINVAL;\n\t\tgoto release_buf;\n\t}\n\n\t/*\n\t * We must be able to do sector-sized and sector-aligned IO.\n\t */\n\tif (sector_size > sbp->sb_sectsize) {\n\t\tif (loud)\n\t\t\txfs_warn(mp, \"device supports %u byte sectors (not %u)\",\n\t\t\t\tsector_size, sbp->sb_sectsize);\n\t\terror = -ENOSYS;\n\t\tgoto release_buf;\n\t}\n\n\tif (buf_ops == NULL) {\n\t\t/*\n\t\t * Re-read the superblock so the buffer is correctly sized,\n\t\t * and properly verified.\n\t\t */\n\t\txfs_buf_relse(bp);\n\t\tsector_size = sbp->sb_sectsize;\n\t\tbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\n\t\tgoto reread;\n\t}\n\n\t/* Initialize per-cpu counters */\n\txfs_icsb_reinit_counters(mp);\n\n\t/* no need to be quiet anymore, so reset the buf ops */\n\tbp->b_ops = &xfs_sb_buf_ops;\n\n\tmp->m_sb_bp = bp;\n\txfs_buf_unlock(bp);\n\treturn 0;\n\nrelease_buf:\n\txfs_buf_relse(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_initialize_perag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "181-263",
    "snippet": "int\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "pag"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&mp->m_perag_tree",
            "index"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_set_inode64",
          "args": [
            "mp",
            "agcount"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_inode64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "652-674",
          "snippet": "xfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode64(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t index = 0;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tstruct xfs_perag\t*pag;\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tpag->pagf_metadata = 0;\n\t\txfs_perag_put(pag);\n\t}\n\n\t/* There is no need for lock protection on m_flags,\n\t * the rw_semaphore of the VFS superblock is locked\n\t * during mount/umount/remount operations, so this is\n\t * enough to avoid concurency on the m_flags field\n\t */\n\tmp->m_flags &= ~(XFS_MOUNT_32BITINODES |\n\t\t\t XFS_MOUNT_SMALL_INUMS);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_inode32",
          "args": [
            "mp",
            "agcount"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_inode32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "600-650",
          "snippet": "xfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_agnumber_t\nxfs_set_inode32(struct xfs_mount *mp, xfs_agnumber_t agcount)\n{\n\txfs_agnumber_t\tindex = 0;\n\txfs_agnumber_t\tmaxagi = 0;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\txfs_agnumber_t\tmax_metadata;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_perag_t\t*pag;\n\n\t/* Calculate how much should be reserved for inodes to meet\n\t * the max inode percentage.\n\t */\n\tif (mp->m_maxicount) {\n\t\t__uint64_t\ticount;\n\n\t\ticount = sbp->sb_dblocks * sbp->sb_imax_pct;\n\t\tdo_div(icount, 100);\n\t\ticount += sbp->sb_agblocks - 1;\n\t\tdo_div(icount, sbp->sb_agblocks);\n\t\tmax_metadata = icount;\n\t} else {\n\t\tmax_metadata = agcount;\n\t}\n\n\tagino =\tXFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\n\tfor (index = 0; index < agcount; index++) {\n\t\tino = XFS_AGINO_TO_INO(mp, index, agino);\n\n\t\tif (ino > XFS_MAXINUMBER_32) {\n\t\t\tpag = xfs_perag_get(mp, index);\n\t\t\tpag->pagi_inodeok = 0;\n\t\t\tpag->pagf_metadata = 0;\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpag = xfs_perag_get(mp, index);\n\t\tpag->pagi_inodeok = 1;\n\t\tmaxagi++;\n\t\tif (index < max_metadata)\n\t\t\tpag->pagf_metadata = 1;\n\t\txfs_perag_put(pag);\n\t}\n\tmp->m_flags |= (XFS_MOUNT_32BITINODES |\n\t\t\tXFS_MOUNT_SMALL_INUMS);\n\n\treturn maxagi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agcount - 1",
            "agino"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_OFFBNO_TO_AGINO",
          "args": [
            "mp",
            "sbp->sb_agblocks - 1",
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_perag_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&mp->m_perag_tree",
            "index",
            "pag"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_perag_lock"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pag->pag_buf_lock"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&pag->pag_ici_root",
            "GFP_ATOMIC"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pag->pag_ici_reclaim_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*pag)",
            "KM_MAYFAIL"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "index"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_initialize_perag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagcount,\n\txfs_agnumber_t\t*maxagi)\n{\n\txfs_agnumber_t\tindex;\n\txfs_agnumber_t\tfirst_initialised = 0;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\txfs_ino_t\tino;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tint\t\terror = -ENOMEM;\n\n\t/*\n\t * Walk the current per-ag tree so we don't try to initialise AGs\n\t * that already exist (growfs case). Allocate and insert all the\n\t * AGs we don't find ready for initialisation.\n\t */\n\tfor (index = 0; index < agcount; index++) {\n\t\tpag = xfs_perag_get(mp, index);\n\t\tif (pag) {\n\t\t\txfs_perag_put(pag);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first_initialised)\n\t\t\tfirst_initialised = index;\n\n\t\tpag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\n\t\tif (!pag)\n\t\t\tgoto out_unwind;\n\t\tpag->pag_agno = index;\n\t\tpag->pag_mount = mp;\n\t\tspin_lock_init(&pag->pag_ici_lock);\n\t\tmutex_init(&pag->pag_ici_reclaim_lock);\n\t\tINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\n\t\tspin_lock_init(&pag->pag_buf_lock);\n\t\tpag->pag_buf_tree = RB_ROOT;\n\n\t\tif (radix_tree_preload(GFP_NOFS))\n\t\t\tgoto out_unwind;\n\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\n\t\t\tBUG();\n\t\t\tspin_unlock(&mp->m_perag_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_unwind;\n\t\t}\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tradix_tree_preload_end();\n\t}\n\n\t/*\n\t * If we mount with the inode64 option, or no inode overflows\n\t * the legacy 32-bit address space clear the inode32 option.\n\t */\n\tagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\n\tino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\n\n\tif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\n\t\tmp->m_flags |= XFS_MOUNT_32BITINODES;\n\telse\n\t\tmp->m_flags &= ~XFS_MOUNT_32BITINODES;\n\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES)\n\t\tindex = xfs_set_inode32(mp, agcount);\n\telse\n\t\tindex = xfs_set_inode64(mp, agcount);\n\n\tif (maxagi)\n\t\t*maxagi = index;\n\treturn 0;\n\nout_unwind:\n\tkmem_free(pag);\n\tfor (; index > first_initialised; index--) {\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, index);\n\t\tkmem_free(pag);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_sb_validate_fsb_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "167-179",
    "snippet": "int\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sbp->sb_blocklog >= BBSHIFT"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PAGE_SHIFT >= sbp->sb_blocklog"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_free_perag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "146-161",
    "snippet": "STATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&pag->rcu_head",
            "__xfs_free_perag"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&pag->pag_ref) == 0"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_perag_lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&mp->m_perag_tree",
            "agno"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_perag_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_free_perag(\n\txfs_mount_t\t*mp)\n{\n\txfs_agnumber_t\tagno;\n\tstruct xfs_perag *pag;\n\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\tspin_lock(&mp->m_perag_lock);\n\t\tpag = radix_tree_delete(&mp->m_perag_tree, agno);\n\t\tspin_unlock(&mp->m_perag_lock);\n\t\tASSERT(pag);\n\t\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\t\tcall_rcu(&pag->rcu_head, __xfs_free_perag);\n\t}\n}"
  },
  {
    "function_name": "__xfs_free_perag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "133-141",
    "snippet": "STATIC void\n__xfs_free_perag(\n\tstruct rcu_head\t*head)\n{\n\tstruct xfs_perag *pag = container_of(head, struct xfs_perag, rcu_head);\n\n\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\tkmem_free(pag);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "pag"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&pag->pag_ref) == 0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structxfs_perag",
            "rcu_head"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\n__xfs_free_perag(\n\tstruct rcu_head\t*head)\n{\n\tstruct xfs_perag *pag = container_of(head, struct xfs_perag, rcu_head);\n\n\tASSERT(atomic_read(&pag->pag_ref) == 0);\n\tkmem_free(pag);\n}"
  },
  {
    "function_name": "xfs_uuid_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "109-130",
    "snippet": "STATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(xfs_uuid_table_mutex);",
      "static int xfs_uuid_table_size;",
      "static uuid_t *xfs_uuid_table;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xfs_uuid_table_mutex"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i < xfs_uuid_table_size"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xfs_uuid_table[i]",
            "0",
            "sizeof(uuid_t)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "uuid",
            "&xfs_uuid_table[i]"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_is_nil",
          "args": [
            "&xfs_uuid_table[i]"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_is_nil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "45-57",
          "snippet": "int\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&xfs_uuid_table_mutex"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nSTATIC void\nxfs_uuid_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\ti;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn;\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tif (!uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tcontinue;\n\t\tmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\n\t\tbreak;\n\t}\n\tASSERT(i < xfs_uuid_table_size);\n\tmutex_unlock(&xfs_uuid_table_mutex);\n}"
  },
  {
    "function_name": "xfs_uuid_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
    "lines": "66-107",
    "snippet": "STATIC int\nxfs_uuid_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\thole, i;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn 0;\n\n\tif (uuid_is_nil(uuid)) {\n\t\txfs_warn(mp, \"Filesystem has nil UUID - can't mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i])) {\n\t\t\thole = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tgoto out_duplicate;\n\t}\n\n\tif (hole < 0) {\n\t\txfs_uuid_table = kmem_realloc(xfs_uuid_table,\n\t\t\t(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\n\t\t\txfs_uuid_table_size  * sizeof(*xfs_uuid_table),\n\t\t\tKM_SLEEP);\n\t\thole = xfs_uuid_table_size++;\n\t}\n\txfs_uuid_table[hole] = *uuid;\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\n\treturn 0;\n\n out_duplicate:\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\txfs_warn(mp, \"Filesystem has duplicate UUID %pU - can't mount\", uuid);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(xfs_uuid_table_mutex);",
      "static int xfs_uuid_table_size;",
      "static uuid_t *xfs_uuid_table;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Filesystem has duplicate UUID %pU - can't mount\"",
            "uuid"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xfs_uuid_table_mutex"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xfs_uuid_table_mutex"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "xfs_uuid_table",
            "(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table)",
            "xfs_uuid_table_size  * sizeof(*xfs_uuid_table)",
            "KM_SLEEP"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "uuid",
            "&xfs_uuid_table[i]"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_is_nil",
          "args": [
            "&xfs_uuid_table[i]"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_is_nil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "45-57",
          "snippet": "int\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_is_nil(uuid_t *uuid)\n{\n\tint\ti;\n\tchar\t*cp = (char *)uuid;\n\n\tif (uuid == NULL)\n\t\treturn 0;\n\t/* implied check of version number here... */\n\tfor (i = 0; i < sizeof *uuid; i++)\n\t\tif (*cp++) return 0;\t/* not nil */\n\treturn 1;\t/* is nil */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&xfs_uuid_table_mutex"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Filesystem has nil UUID - can't mount\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic DEFINE_MUTEX(xfs_uuid_table_mutex);\nstatic int xfs_uuid_table_size;\nstatic uuid_t *xfs_uuid_table;\n\nSTATIC int\nxfs_uuid_mount(\n\tstruct xfs_mount\t*mp)\n{\n\tuuid_t\t\t\t*uuid = &mp->m_sb.sb_uuid;\n\tint\t\t\thole, i;\n\n\tif (mp->m_flags & XFS_MOUNT_NOUUID)\n\t\treturn 0;\n\n\tif (uuid_is_nil(uuid)) {\n\t\txfs_warn(mp, \"Filesystem has nil UUID - can't mount\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&xfs_uuid_table_mutex);\n\tfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\n\t\tif (uuid_is_nil(&xfs_uuid_table[i])) {\n\t\t\thole = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uuid_equal(uuid, &xfs_uuid_table[i]))\n\t\t\tgoto out_duplicate;\n\t}\n\n\tif (hole < 0) {\n\t\txfs_uuid_table = kmem_realloc(xfs_uuid_table,\n\t\t\t(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\n\t\t\txfs_uuid_table_size  * sizeof(*xfs_uuid_table),\n\t\t\tKM_SLEEP);\n\t\thole = xfs_uuid_table_size++;\n\t}\n\txfs_uuid_table[hole] = *uuid;\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\n\treturn 0;\n\n out_duplicate:\n\tmutex_unlock(&xfs_uuid_table_mutex);\n\txfs_warn(mp, \"Filesystem has duplicate UUID %pU - can't mount\", uuid);\n\treturn -EINVAL;\n}"
  }
]