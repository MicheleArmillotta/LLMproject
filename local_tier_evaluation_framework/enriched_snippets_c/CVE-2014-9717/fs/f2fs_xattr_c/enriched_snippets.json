[
  {
    "function_name": "f2fs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "595-616",
    "snippet": "int f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__f2fs_setxattr",
          "args": [
            "inode",
            "index",
            "name",
            "value",
            "size",
            "ipage",
            "flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "480-593",
          "snippet": "static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = -ENOMEM;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN || size > MAX_VALUE_LEN(inode))\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\tgoto exit;\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, index, len, name);\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif ((flags & XATTR_REPLACE) && !found) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t} else if ((flags & XATTR_CREATE) && found) {\n\t\terror = -EEXIST;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tmemset(last, 0, newsize);\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\tinode->i_mode = fi->i_acl_mode;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t}\n\n\tif (ipage)\n\t\tupdate_inode(inode, ipage);\n\telse\n\t\tupdate_inode_page(inode);\nexit:\n\tkzfree(base_addr);\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = -ENOMEM;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN || size > MAX_VALUE_LEN(inode))\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\tgoto exit;\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, index, len, name);\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif ((flags & XATTR_REPLACE) && !found) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t} else if ((flags & XATTR_CREATE) && found) {\n\t\terror = -EEXIST;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tmemset(last, 0, newsize);\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\tinode->i_mode = fi->i_acl_mode;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t}\n\n\tif (ipage)\n\t\tupdate_inode(inode, ipage);\n\telse\n\t\tupdate_inode_page(inode);\nexit:\n\tkzfree(base_addr);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__f2fs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "480-593",
    "snippet": "static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = -ENOMEM;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN || size > MAX_VALUE_LEN(inode))\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\tgoto exit;\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, index, len, name);\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif ((flags & XATTR_REPLACE) && !found) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t} else if ((flags & XATTR_CREATE) && found) {\n\t\terror = -EEXIST;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tmemset(last, 0, newsize);\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\tinode->i_mode = fi->i_acl_mode;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t}\n\n\tif (ipage)\n\t\tupdate_inode(inode, ipage);\n\telse\n\t\tupdate_inode_page(inode);\nexit:\n\tkzfree(base_addr);\n\treturn error;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "base_addr"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "fi",
            "FI_ACL_MODE"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "fi",
            "FI_ACL_MODE"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_all_xattrs",
          "args": [
            "inode",
            "new_hsize",
            "base_addr",
            "ipage"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "write_all_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "325-398",
          "snippet": "static inline int write_all_xattrs(struct inode *inode, __u32 hsize,\n\t\t\t\tvoid *txattr_addr, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tsize_t inline_size = 0;\n\tvoid *xattr_addr;\n\tstruct page *xpage;\n\tnid_t new_nid = 0;\n\tint err;\n\n\tinline_size = inline_xattr_size(inode);\n\n\tif (hsize > inline_size && !F2FS_I(inode)->i_xattr_nid)\n\t\tif (!alloc_nid(sbi, &new_nid))\n\t\t\treturn -ENOSPC;\n\n\t/* write to inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t}\n\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\n\t\t/* no need to use xattr node block */\n\t\tif (hsize <= inline_size) {\n\t\t\terr = truncate_xattr_node(inode, ipage);\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* write to xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\tf2fs_bug_on(sbi, new_nid);\n\t\tf2fs_wait_on_page_writeback(xpage, NODE);\n\t} else {\n\t\tstruct dnode_of_data dn;\n\t\tset_new_dnode(&dn, inode, NULL, NULL, new_nid);\n\t\txpage = new_node_page(&dn, XATTR_NODE_OFFSET, ipage);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\talloc_nid_done(sbi, new_nid);\n\t}\n\n\txattr_addr = page_address(xpage);\n\tmemcpy(xattr_addr, txattr_addr + inline_size, PAGE_SIZE -\n\t\t\t\t\t\tsizeof(struct node_footer));\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\t/* need to checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic inline int write_all_xattrs(struct inode *inode, __u32 hsize,\n\t\t\t\tvoid *txattr_addr, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tsize_t inline_size = 0;\n\tvoid *xattr_addr;\n\tstruct page *xpage;\n\tnid_t new_nid = 0;\n\tint err;\n\n\tinline_size = inline_xattr_size(inode);\n\n\tif (hsize > inline_size && !F2FS_I(inode)->i_xattr_nid)\n\t\tif (!alloc_nid(sbi, &new_nid))\n\t\t\treturn -ENOSPC;\n\n\t/* write to inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t}\n\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\n\t\t/* no need to use xattr node block */\n\t\tif (hsize <= inline_size) {\n\t\t\terr = truncate_xattr_node(inode, ipage);\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* write to xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\tf2fs_bug_on(sbi, new_nid);\n\t\tf2fs_wait_on_page_writeback(xpage, NODE);\n\t} else {\n\t\tstruct dnode_of_data dn;\n\t\tset_new_dnode(&dn, inode, NULL, NULL, new_nid);\n\t\txpage = new_node_page(&dn, XATTR_NODE_OFFSET, ipage);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\talloc_nid_done(sbi, new_nid);\n\t}\n\n\txattr_addr = page_address(xpage);\n\tmemcpy(xattr_addr, txattr_addr + inline_size, PAGE_SIZE -\n\t\t\t\t\t\tsizeof(struct node_footer));\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\t/* need to checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "size"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pval",
            "value",
            "size"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "last->e_name",
            "name",
            "len"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "newsize"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "oldsize"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "here",
            "next",
            "(char *)last - (char *)next"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_SIZE",
          "args": [
            "here"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR_NEXT_ENTRY",
          "args": [
            "here"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "free < newsize"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_SIZE",
          "args": [
            "here"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN_OFFSET",
          "args": [
            "inode"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR_ALIGN",
          "args": [
            "sizeof(struct f2fs_xattr_entry) + len + size"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XATTR_NEXT_ENTRY",
          "args": [
            "last"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_XATTR_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_XATTR_LAST_ENTRY",
          "args": [
            "here"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_xattr",
          "args": [
            "base_addr",
            "index",
            "len",
            "name"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__find_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "251-265",
          "snippet": "static struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_all_xattrs",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "read_all_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "267-323",
          "snippet": "static void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_VALUE_LEN",
          "args": [
            "inode"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = -ENOMEM;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN || size > MAX_VALUE_LEN(inode))\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\tgoto exit;\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, index, len, name);\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif ((flags & XATTR_REPLACE) && !found) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t} else if ((flags & XATTR_CREATE) && found) {\n\t\terror = -EEXIST;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tmemset(last, 0, newsize);\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\tinode->i_mode = fi->i_acl_mode;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t}\n\n\tif (ipage)\n\t\tupdate_inode(inode, ipage);\n\telse\n\t\tupdate_inode_page(inode);\nexit:\n\tkzfree(base_addr);\n\treturn error;\n}"
  },
  {
    "function_name": "f2fs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "443-478",
    "snippet": "ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tbase_addr = read_all_xattrs(inode, NULL);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tsize_t size;\n\n\t\tif (!handler)\n\t\t\tcontinue;\n\n\t\tsize = handler->list(dentry, buffer, rest, entry->e_name,\n\t\t\t\tentry->e_name_len, handler->flags);\n\t\tif (buffer && size > rest) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (buffer)\n\t\t\tbuffer += size;\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "base_addr"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "buffer",
            "rest",
            "entry->e_name",
            "entry->e_name_len",
            "handler->flags"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_xattr_handler",
          "args": [
            "entry->e_name_index"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_xattr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "242-249",
          "snippet": "static inline const struct xattr_handler *f2fs_xattr_handler(int index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (index > 0 && index < ARRAY_SIZE(f2fs_xattr_handler_map))\n\t\thandler = f2fs_xattr_handler_map[index];\n\treturn handler;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *f2fs_xattr_handler_map[] = {\n\t[F2FS_XATTR_INDEX_USER] = &f2fs_xattr_user_handler,\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t[F2FS_XATTR_INDEX_POSIX_ACL_ACCESS] = &posix_acl_access_xattr_handler,\n\t[F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[F2FS_XATTR_INDEX_TRUSTED] = &f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t[F2FS_XATTR_INDEX_SECURITY] = &f2fs_xattr_security_handler,\n#endif\n\t[F2FS_XATTR_INDEX_ADVISE] = &f2fs_xattr_advise_handler,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic const struct xattr_handler *f2fs_xattr_handler_map[] = {\n\t[F2FS_XATTR_INDEX_USER] = &f2fs_xattr_user_handler,\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t[F2FS_XATTR_INDEX_POSIX_ACL_ACCESS] = &posix_acl_access_xattr_handler,\n\t[F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[F2FS_XATTR_INDEX_TRUSTED] = &f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t[F2FS_XATTR_INDEX_SECURITY] = &f2fs_xattr_security_handler,\n#endif\n\t[F2FS_XATTR_INDEX_ADVISE] = &f2fs_xattr_advise_handler,\n};\n\nstatic inline const struct xattr_handler *f2fs_xattr_handler(int index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (index > 0 && index < ARRAY_SIZE(f2fs_xattr_handler_map))\n\t\thandler = f2fs_xattr_handler_map[index];\n\treturn handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_xattr",
          "args": [
            "entry",
            "base_addr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_all_xattrs",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "read_all_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "267-323",
          "snippet": "static void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tbase_addr = read_all_xattrs(inode, NULL);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tsize_t size;\n\n\t\tif (!handler)\n\t\t\tcontinue;\n\n\t\tsize = handler->list(dentry, buffer, rest, entry->e_name,\n\t\t\t\tentry->e_name_len, handler->flags);\n\t\tif (buffer && size > rest) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (buffer)\n\t\t\tbuffer += size;\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}"
  },
  {
    "function_name": "f2fs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "400-441",
    "snippet": "int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t size, len;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tentry = __find_xattr(base_addr, index, len, name);\n\tif (IS_XATTR_LAST_ENTRY(entry)) {\n\t\terror = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto cleanup;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\n\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "base_addr"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "pval",
            "size"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_XATTR_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_xattr",
          "args": [
            "base_addr",
            "index",
            "len",
            "name"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__find_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "251-265",
          "snippet": "static struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_all_xattrs",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "read_all_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "267-323",
          "snippet": "static void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t size, len;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tentry = __find_xattr(base_addr, index, len, name);\n\tif (IS_XATTR_LAST_ENTRY(entry)) {\n\t\terror = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto cleanup;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\n\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}"
  },
  {
    "function_name": "write_all_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "325-398",
    "snippet": "static inline int write_all_xattrs(struct inode *inode, __u32 hsize,\n\t\t\t\tvoid *txattr_addr, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tsize_t inline_size = 0;\n\tvoid *xattr_addr;\n\tstruct page *xpage;\n\tnid_t new_nid = 0;\n\tint err;\n\n\tinline_size = inline_xattr_size(inode);\n\n\tif (hsize > inline_size && !F2FS_I(inode)->i_xattr_nid)\n\t\tif (!alloc_nid(sbi, &new_nid))\n\t\t\treturn -ENOSPC;\n\n\t/* write to inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t}\n\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\n\t\t/* no need to use xattr node block */\n\t\tif (hsize <= inline_size) {\n\t\t\terr = truncate_xattr_node(inode, ipage);\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* write to xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\tf2fs_bug_on(sbi, new_nid);\n\t\tf2fs_wait_on_page_writeback(xpage, NODE);\n\t} else {\n\t\tstruct dnode_of_data dn;\n\t\tset_new_dnode(&dn, inode, NULL, NULL, new_nid);\n\t\txpage = new_node_page(&dn, XATTR_NODE_OFFSET, ipage);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\talloc_nid_done(sbi, new_nid);\n\t}\n\n\txattr_addr = page_address(xpage);\n\tmemcpy(xattr_addr, txattr_addr + inline_size, PAGE_SIZE -\n\t\t\t\t\t\tsizeof(struct node_footer));\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\t/* need to checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "F2FS_CKPT(sbi)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "xpage",
            "1"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "xpage"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xattr_addr",
            "txattr_addr + inline_size",
            "PAGE_SIZE -\n\t\t\t\t\t\tsizeof(struct node_footer)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "xpage"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "new_nid"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "xpage"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_failed",
          "args": [
            "sbi",
            "new_nid"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1599-1622",
          "snippet": "void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xpage"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_node_page",
          "args": [
            "&dn",
            "XATTR_NODE_OFFSET",
            "ipage"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "new_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "927-978",
          "snippet": "struct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "new_nid"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "xpage",
            "NODE"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "new_nid"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "xpage"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xpage"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "F2FS_I(inode)->i_xattr_nid"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_xattr_node",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_xattr_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "859-884",
          "snippet": "int truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "inline_addr",
            "txattr_addr",
            "inline_size"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_xattr_addr",
          "args": [
            "page"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1236-1241",
          "snippet": "static inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_xattr_size",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1243-1249",
          "snippet": "static inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic inline int write_all_xattrs(struct inode *inode, __u32 hsize,\n\t\t\t\tvoid *txattr_addr, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tsize_t inline_size = 0;\n\tvoid *xattr_addr;\n\tstruct page *xpage;\n\tnid_t new_nid = 0;\n\tint err;\n\n\tinline_size = inline_xattr_size(inode);\n\n\tif (hsize > inline_size && !F2FS_I(inode)->i_xattr_nid)\n\t\tif (!alloc_nid(sbi, &new_nid))\n\t\t\treturn -ENOSPC;\n\n\t/* write to inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t}\n\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\n\t\t/* no need to use xattr node block */\n\t\tif (hsize <= inline_size) {\n\t\t\terr = truncate_xattr_node(inode, ipage);\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* write to xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\tf2fs_bug_on(sbi, new_nid);\n\t\tf2fs_wait_on_page_writeback(xpage, NODE);\n\t} else {\n\t\tstruct dnode_of_data dn;\n\t\tset_new_dnode(&dn, inode, NULL, NULL, new_nid);\n\t\txpage = new_node_page(&dn, XATTR_NODE_OFFSET, ipage);\n\t\tif (IS_ERR(xpage)) {\n\t\t\talloc_nid_failed(sbi, new_nid);\n\t\t\treturn PTR_ERR(xpage);\n\t\t}\n\t\talloc_nid_done(sbi, new_nid);\n\t}\n\n\txattr_addr = page_address(xpage);\n\tmemcpy(xattr_addr, txattr_addr + inline_size, PAGE_SIZE -\n\t\t\t\t\t\tsizeof(struct node_footer));\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\t/* need to checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\treturn 0;\n}"
  },
  {
    "function_name": "read_all_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "267-323",
    "snippet": "static void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "txattr_addr"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_XATTR_MAGIC"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "header->h_magic"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XATTR_HDR",
          "args": [
            "txattr_addr"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "xpage",
            "1"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "txattr_addr + inline_size",
            "xattr_addr",
            "PAGE_SIZE"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "xpage"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xpage"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "F2FS_I(inode)->i_xattr_nid"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "txattr_addr",
            "inline_addr",
            "inline_size"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_xattr_addr",
          "args": [
            "page"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1236-1241",
          "snippet": "static inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "inline_size + size",
            "GFP_F2FS_ZERO"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_xattr_size",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1243-1249",
          "snippet": "static inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic void *read_all_xattrs(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_xattr_header *header;\n\tsize_t size = PAGE_SIZE, inline_size = 0;\n\tvoid *txattr_addr;\n\n\tinline_size = inline_xattr_size(inode);\n\n\ttxattr_addr = kzalloc(inline_size + size, GFP_F2FS_ZERO);\n\tif (!txattr_addr)\n\t\treturn NULL;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\tstruct page *page = NULL;\n\t\tvoid *inline_addr;\n\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(ipage);\n\t\t} else {\n\t\t\tpage = get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(page))\n\t\t\t\tgoto fail;\n\t\t\tinline_addr = inline_xattr_addr(page);\n\t\t}\n\t\tmemcpy(txattr_addr, inline_addr, inline_size);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t/* read from xattr node block */\n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\tstruct page *xpage;\n\t\tvoid *xattr_addr;\n\n\t\t/* The inode already has an extended attribute block. */\n\t\txpage = get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage))\n\t\t\tgoto fail;\n\n\t\txattr_addr = page_address(xpage);\n\t\tmemcpy(txattr_addr + inline_size, xattr_addr, PAGE_SIZE);\n\t\tf2fs_put_page(xpage, 1);\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t/* never been allocated xattrs */\n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\treturn txattr_addr;\nfail:\n\tkzfree(txattr_addr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__find_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "251-265",
    "snippet": "static struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "entry->e_name",
            "name",
            "len"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_xattr",
          "args": [
            "entry",
            "base_addr"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,\n\t\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}"
  },
  {
    "function_name": "f2fs_xattr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "242-249",
    "snippet": "static inline const struct xattr_handler *f2fs_xattr_handler(int index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (index > 0 && index < ARRAY_SIZE(f2fs_xattr_handler_map))\n\t\thandler = f2fs_xattr_handler_map[index];\n\treturn handler;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *f2fs_xattr_handler_map[] = {\n\t[F2FS_XATTR_INDEX_USER] = &f2fs_xattr_user_handler,\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t[F2FS_XATTR_INDEX_POSIX_ACL_ACCESS] = &posix_acl_access_xattr_handler,\n\t[F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[F2FS_XATTR_INDEX_TRUSTED] = &f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t[F2FS_XATTR_INDEX_SECURITY] = &f2fs_xattr_security_handler,\n#endif\n\t[F2FS_XATTR_INDEX_ADVISE] = &f2fs_xattr_advise_handler,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "f2fs_xattr_handler_map"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic const struct xattr_handler *f2fs_xattr_handler_map[] = {\n\t[F2FS_XATTR_INDEX_USER] = &f2fs_xattr_user_handler,\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t[F2FS_XATTR_INDEX_POSIX_ACL_ACCESS] = &posix_acl_access_xattr_handler,\n\t[F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[F2FS_XATTR_INDEX_TRUSTED] = &f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t[F2FS_XATTR_INDEX_SECURITY] = &f2fs_xattr_security_handler,\n#endif\n\t[F2FS_XATTR_INDEX_ADVISE] = &f2fs_xattr_advise_handler,\n};\n\nstatic inline const struct xattr_handler *f2fs_xattr_handler(int index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (index > 0 && index < ARRAY_SIZE(f2fs_xattr_handler_map))\n\t\thandler = f2fs_xattr_handler_map[index];\n\treturn handler;\n}"
  },
  {
    "function_name": "f2fs_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "175-180",
    "snippet": "int f2fs_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr, struct page *ipage)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t&f2fs_initxattrs, ipage);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&f2fs_initxattrs",
            "ipage"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr, struct page *ipage)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t&f2fs_initxattrs, ipage);\n}"
  },
  {
    "function_name": "f2fs_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "159-173",
    "snippet": "static int f2fs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\tvoid *page)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = f2fs_setxattr(inode, F2FS_XATTR_INDEX_SECURITY,\n\t\t\t\txattr->name, xattr->value,\n\t\t\t\txattr->value_len, (struct page *)page, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_setxattr",
          "args": [
            "inode",
            "F2FS_XATTR_INDEX_SECURITY",
            "xattr->name",
            "xattr->value",
            "xattr->value_len",
            "(struct page *)page",
            "0"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "595-616",
          "snippet": "int f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int f2fs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\tvoid *page)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = f2fs_setxattr(inode, F2FS_XATTR_INDEX_SECURITY,\n\t\t\t\txattr->name, xattr->value,\n\t\t\t\txattr->value_len, (struct page *)page, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_xattr_advise_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "142-156",
    "snippet": "static int f2fs_xattr_advise_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value == NULL)\n\t\treturn -EINVAL;\n\n\tF2FS_I(inode)->i_advise |= *(char *)value;\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int f2fs_xattr_advise_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value == NULL)\n\t\treturn -EINVAL;\n\n\tF2FS_I(inode)->i_advise |= *(char *)value;\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_xattr_advise_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "130-140",
    "snippet": "static int f2fs_xattr_advise_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\t*((char *)buffer) = F2FS_I(inode)->i_advise;\n\treturn sizeof(char);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int f2fs_xattr_advise_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(name, \"\") != 0)\n\t\treturn -EINVAL;\n\n\t*((char *)buffer) = F2FS_I(inode)->i_advise;\n\treturn sizeof(char);\n}"
  },
  {
    "function_name": "f2fs_xattr_advise_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "115-128",
    "snippet": "static size_t f2fs_xattr_advise_list(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t len, int type)\n{\n\tconst char *xname = F2FS_SYSTEM_ADVISE_PREFIX;\n\tsize_t size;\n\n\tif (type != F2FS_XATTR_INDEX_ADVISE)\n\t\treturn 0;\n\n\tsize = strlen(xname) + 1;\n\tif (list && size <= list_size)\n\t\tmemcpy(list, xname, size);\n\treturn size;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "xname",
            "size"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xname"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic size_t f2fs_xattr_advise_list(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t len, int type)\n{\n\tconst char *xname = F2FS_SYSTEM_ADVISE_PREFIX;\n\tsize_t size;\n\n\tif (type != F2FS_XATTR_INDEX_ADVISE)\n\t\treturn 0;\n\n\tsize = strlen(xname) + 1;\n\tif (list && size <= list_size)\n\t\tmemcpy(list, xname, size);\n\treturn size;\n}"
  },
  {
    "function_name": "f2fs_xattr_generic_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "89-113",
    "snippet": "static int f2fs_xattr_generic_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn f2fs_setxattr(dentry->d_inode, type, name,\n\t\t\t\t\tvalue, size, NULL, flags);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_setxattr",
          "args": [
            "dentry->d_inode",
            "type",
            "name",
            "value",
            "size",
            "NULL",
            "flags"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "595-616",
          "snippet": "int f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "XATTR_USER"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int f2fs_xattr_generic_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn f2fs_setxattr(dentry->d_inode, type, name,\n\t\t\t\t\tvalue, size, NULL, flags);\n}"
  },
  {
    "function_name": "f2fs_xattr_generic_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "65-87",
    "snippet": "static int f2fs_xattr_generic_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn f2fs_getxattr(dentry->d_inode, type, name, buffer, size, NULL);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_getxattr",
          "args": [
            "dentry->d_inode",
            "type",
            "name",
            "buffer",
            "size",
            "NULL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "400-441",
          "snippet": "int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t size, len;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tentry = __find_xattr(base_addr, index, len, name);\n\tif (IS_XATTR_LAST_ENTRY(entry)) {\n\t\terror = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto cleanup;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\n\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t size, len;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tbase_addr = read_all_xattrs(inode, ipage);\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tentry = __find_xattr(base_addr, index, len, name);\n\tif (IS_XATTR_LAST_ENTRY(entry)) {\n\t\terror = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto cleanup;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\n\ncleanup:\n\tkzfree(base_addr);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "XATTR_USER"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic int f2fs_xattr_generic_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn f2fs_getxattr(dentry->d_inode, type, name, buffer, size, NULL);\n}"
  },
  {
    "function_name": "f2fs_xattr_generic_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
    "lines": "28-63",
    "snippet": "static size_t f2fs_xattr_generic_list(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t len, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\tint total_len, prefix_len = 0;\n\tconst char *prefix = NULL;\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tprefix = XATTR_USER_PREFIX;\n\t\tprefix_len = XATTR_USER_PREFIX_LEN;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tprefix = XATTR_TRUSTED_PREFIX;\n\t\tprefix_len = XATTR_TRUSTED_PREFIX_LEN;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tprefix = XATTR_SECURITY_PREFIX;\n\t\tprefix_len = XATTR_SECURITY_PREFIX_LEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttotal_len = prefix_len + len + 1;\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, prefix, prefix_len);\n\t\tmemcpy(list + prefix_len, name, len);\n\t\tlist[prefix_len + len] = '\\0';\n\t}\n\treturn total_len;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/rwsem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list + prefix_len",
            "name",
            "len"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "prefix",
            "prefix_len"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "XATTR_USER"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nstatic size_t f2fs_xattr_generic_list(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t len, int type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\tint total_len, prefix_len = 0;\n\tconst char *prefix = NULL;\n\n\tswitch (type) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tprefix = XATTR_USER_PREFIX;\n\t\tprefix_len = XATTR_USER_PREFIX_LEN;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tprefix = XATTR_TRUSTED_PREFIX;\n\t\tprefix_len = XATTR_TRUSTED_PREFIX_LEN;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tprefix = XATTR_SECURITY_PREFIX;\n\t\tprefix_len = XATTR_SECURITY_PREFIX_LEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttotal_len = prefix_len + len + 1;\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, prefix, prefix_len);\n\t\tmemcpy(list + prefix_len, name, len);\n\t\tlist[prefix_len + len] = '\\0';\n\t}\n\treturn total_len;\n}"
  }
]