[
  {
    "function_name": "ecryptfs_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "325-347",
    "snippet": "static long\necryptfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOIOCTLCMD;\n\n\tif (!lower_file->f_op->compat_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC32_GETFLAGS:\n\tcase FS_IOC32_SETFLAGS:\n\tcase FS_IOC32_GETVERSION:\n\tcase FS_IOC32_SETVERSION:\n\t\trc = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "file_inode(file)",
            "file_inode(lower_file)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "lower_file"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lower_file->f_op->compat_ioctl",
          "args": [
            "lower_file",
            "cmd",
            "arg"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic long\necryptfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOIOCTLCMD;\n\n\tif (!lower_file->f_op->compat_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC32_GETFLAGS:\n\tcase FS_IOC32_SETFLAGS:\n\tcase FS_IOC32_GETVERSION:\n\tcase FS_IOC32_SETVERSION:\n\t\trc = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_unlocked_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "300-322",
    "snippet": "static long\necryptfs_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOTTY;\n\n\tif (!lower_file->f_op->unlocked_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC_GETFLAGS:\n\tcase FS_IOC_SETFLAGS:\n\tcase FS_IOC_GETVERSION:\n\tcase FS_IOC_SETVERSION:\n\t\trc = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "file_inode(file)",
            "file_inode(lower_file)"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "lower_file"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lower_file->f_op->unlocked_ioctl",
          "args": [
            "lower_file",
            "cmd",
            "arg"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic long\necryptfs_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tlong rc = -ENOTTY;\n\n\tif (!lower_file->f_op->unlocked_ioctl)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\tcase FS_IOC_GETFLAGS:\n\tcase FS_IOC_SETFLAGS:\n\tcase FS_IOC_GETVERSION:\n\tcase FS_IOC_SETVERSION:\n\t\trc = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);\n\t\tfsstack_copy_attr_all(file_inode(file), file_inode(lower_file));\n\n\t\treturn rc;\n\tdefault:\n\t\treturn rc;\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_fasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "289-298",
    "snippet": "static int ecryptfs_fasync(int fd, struct file *file, int flag)\n{\n\tint rc = 0;\n\tstruct file *lower_file = NULL;\n\n\tlower_file = ecryptfs_file_to_lower(file);\n\tif (lower_file->f_op->fasync)\n\t\trc = lower_file->f_op->fasync(fd, lower_file, flag);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lower_file->f_op->fasync",
          "args": [
            "fd",
            "lower_file",
            "flag"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_fasync(int fd, struct file *file, int flag)\n{\n\tint rc = 0;\n\tstruct file *lower_file = NULL;\n\n\tlower_file = ecryptfs_file_to_lower(file);\n\tif (lower_file->f_op->fasync)\n\t\trc = lower_file->f_op->fasync(fd, lower_file, flag);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "277-287",
    "snippet": "static int\necryptfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint rc;\n\n\trc = filemap_write_and_wait(file->f_mapping);\n\tif (rc)\n\t\treturn rc;\n\n\treturn vfs_fsync(ecryptfs_file_to_lower(file), datasync);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "ecryptfs_file_to_lower(file)",
            "datasync"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "file->f_mapping"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint rc;\n\n\trc = filemap_write_and_wait(file->f_mapping);\n\tif (rc)\n\t\treturn rc;\n\n\treturn vfs_fsync(ecryptfs_file_to_lower(file), datasync);\n}"
  },
  {
    "function_name": "ecryptfs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "269-275",
    "snippet": "static int ecryptfs_release(struct inode *inode, struct file *file)\n{\n\tecryptfs_put_lower_file(inode);\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_file_info_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_file_info_cache",
            "ecryptfs_file_to_private(file)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_private",
          "args": [
            "file"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "431-435",
          "snippet": "static inline struct ecryptfs_file_info *\necryptfs_file_to_private(struct file *file)\n{\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_file_info *\necryptfs_file_to_private(struct file *file)\n{\n\treturn file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "inode"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct kmem_cache *ecryptfs_file_info_cache;\n\nstatic int ecryptfs_release(struct inode *inode, struct file *file)\n{\n\tecryptfs_put_lower_file(inode);\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "257-267",
    "snippet": "static int ecryptfs_flush(struct file *file, fl_owner_t td)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\n\tif (lower_file->f_op->flush) {\n\t\tfilemap_write_and_wait(file->f_mapping);\n\t\treturn lower_file->f_op->flush(lower_file, td);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lower_file->f_op->flush",
          "args": [
            "lower_file",
            "td"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "file->f_mapping"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_flush(struct file *file, fl_owner_t td)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\n\tif (lower_file->f_op->flush) {\n\t\tfilemap_write_and_wait(file->f_mapping);\n\t\treturn lower_file->f_op->flush(lower_file, td);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "189-255",
    "snippet": "static int ecryptfs_open(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tstruct ecryptfs_crypt_stat *crypt_stat = NULL;\n\tstruct dentry *ecryptfs_dentry = file->f_path.dentry;\n\t/* Private value of ecryptfs_dentry allocated in\n\t * ecryptfs_lookup() */\n\tstruct ecryptfs_file_info *file_info;\n\n\t/* Released in ecryptfs_release or end of function if failure */\n\tfile_info = kmem_cache_zalloc(ecryptfs_file_info_cache, GFP_KERNEL);\n\tecryptfs_set_file_private(file, file_info);\n\tif (!file_info) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"Error attempting to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Setting flags for stat...\\n\");\n\t\t/* Policy code enabled in future release */\n\t\tcrypt_stat->flags |= (ECRYPTFS_POLICY_APPLIED\n\t\t\t\t      | ECRYPTFS_ENCRYPTED);\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out_free;\n\t}\n\tif ((ecryptfs_inode_to_private(inode)->lower_file->f_flags & O_ACCMODE)\n\t    == O_RDONLY && (file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_WARNING \"%s: Lower file is RO; eCryptfs \"\n\t\t       \"file must hence be opened RO\\n\", __func__);\n\t\tgoto out_put;\n\t}\n\tecryptfs_set_file_lower(\n\t\tfile, ecryptfs_inode_to_private(inode)->lower_file);\n\tif (d_is_dir(ecryptfs_dentry)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tmutex_lock(&crypt_stat->cs_mutex);\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\trc = read_or_initialize_metadata(ecryptfs_dentry);\n\tif (rc)\n\t\tgoto out_put;\n\tecryptfs_printk(KERN_DEBUG, \"inode w/ addr = [0x%p], i_ino = \"\n\t\t\t\"[0x%.16lx] size: [0x%.16llx]\\n\", inode, inode->i_ino,\n\t\t\t(unsigned long long)i_size_read(inode));\n\tgoto out;\nout_put:\n\tecryptfs_put_lower_file(inode);\nout_free:\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_file_info_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_file_info_cache",
            "ecryptfs_file_to_private(file)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_private",
          "args": [
            "file"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "431-435",
          "snippet": "static inline struct ecryptfs_file_info *\necryptfs_file_to_private(struct file *file)\n{\n\treturn file->private_data;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_file_info *\necryptfs_file_to_private(struct file *file)\n{\n\treturn file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"inode w/ addr = [0x%p], i_ino = \"\n\t\t\t\"[0x%.16lx] size: [0x%.16llx]\\n\"",
            "inode",
            "inode->i_ino",
            "(unsigned long long)i_size_read(inode)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_or_initialize_metadata",
          "args": [
            "ecryptfs_dentry"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "read_or_initialize_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
          "lines": "138-178",
          "snippet": "static int read_or_initialize_metadata(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tinode->i_sb)->mount_crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\n\tif (crypt_stat->flags & ECRYPTFS_POLICY_APPLIED &&\n\t    crypt_stat->flags & ECRYPTFS_KEY_VALID) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_read_metadata(dentry);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED) {\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED) &&\n\t    !i_size_read(ecryptfs_inode_to_lower(inode))) {\n\t\trc = ecryptfs_initialize_file(dentry, inode);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -EIO;\nout:\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/aio.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/compat.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int read_or_initialize_metadata(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tinode->i_sb)->mount_crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\n\tif (crypt_stat->flags & ECRYPTFS_POLICY_APPLIED &&\n\t    crypt_stat->flags & ECRYPTFS_KEY_VALID) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_read_metadata(dentry);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED) {\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED) &&\n\t    !i_size_read(ecryptfs_inode_to_lower(inode))) {\n\t\trc = ecryptfs_initialize_file(dentry, inode);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -EIO;\nout:\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "ecryptfs_dentry"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_file_lower",
          "args": [
            "file",
            "ecryptfs_inode_to_private(inode)->lower_file"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_file_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "449-454",
          "snippet": "static inline void\necryptfs_set_file_lower(struct file *file, struct file *lower_file)\n{\n\t((struct ecryptfs_file_info *)file->private_data)->wfi_file =\n\t\tlower_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_file_lower(struct file *file, struct file *lower_file)\n{\n\t((struct ecryptfs_file_info *)file->private_data)->wfi_file =\n\t\tlower_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_lower_file",
          "args": [
            "ecryptfs_dentry",
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "137-155",
          "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_file_private",
          "args": [
            "file",
            "file_info"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_file_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "437-442",
          "snippet": "static inline void\necryptfs_set_file_private(struct file *file,\n\t\t\t  struct ecryptfs_file_info *file_info)\n{\n\tfile->private_data = file_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_file_private(struct file *file,\n\t\t\t  struct ecryptfs_file_info *file_info)\n{\n\tfile->private_data = file_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_file_info_cache",
            "GFP_KERNEL"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct kmem_cache *ecryptfs_file_info_cache;\n\nstatic int ecryptfs_open(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tstruct ecryptfs_crypt_stat *crypt_stat = NULL;\n\tstruct dentry *ecryptfs_dentry = file->f_path.dentry;\n\t/* Private value of ecryptfs_dentry allocated in\n\t * ecryptfs_lookup() */\n\tstruct ecryptfs_file_info *file_info;\n\n\t/* Released in ecryptfs_release or end of function if failure */\n\tfile_info = kmem_cache_zalloc(ecryptfs_file_info_cache, GFP_KERNEL);\n\tecryptfs_set_file_private(file, file_info);\n\tif (!file_info) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"Error attempting to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Setting flags for stat...\\n\");\n\t\t/* Policy code enabled in future release */\n\t\tcrypt_stat->flags |= (ECRYPTFS_POLICY_APPLIED\n\t\t\t\t      | ECRYPTFS_ENCRYPTED);\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out_free;\n\t}\n\tif ((ecryptfs_inode_to_private(inode)->lower_file->f_flags & O_ACCMODE)\n\t    == O_RDONLY && (file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_WARNING \"%s: Lower file is RO; eCryptfs \"\n\t\t       \"file must hence be opened RO\\n\", __func__);\n\t\tgoto out_put;\n\t}\n\tecryptfs_set_file_lower(\n\t\tfile, ecryptfs_inode_to_private(inode)->lower_file);\n\tif (d_is_dir(ecryptfs_dentry)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tmutex_lock(&crypt_stat->cs_mutex);\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\trc = read_or_initialize_metadata(ecryptfs_dentry);\n\tif (rc)\n\t\tgoto out_put;\n\tecryptfs_printk(KERN_DEBUG, \"inode w/ addr = [0x%p], i_ino = \"\n\t\t\t\"[0x%.16lx] size: [0x%.16llx]\\n\", inode, inode->i_ino,\n\t\t\t(unsigned long long)i_size_read(inode));\n\tgoto out;\nout_put:\n\tecryptfs_put_lower_file(inode);\nout_free:\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "read_or_initialize_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "138-178",
    "snippet": "static int read_or_initialize_metadata(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tinode->i_sb)->mount_crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\n\tif (crypt_stat->flags & ECRYPTFS_POLICY_APPLIED &&\n\t    crypt_stat->flags & ECRYPTFS_KEY_VALID) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_read_metadata(dentry);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED) {\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED) &&\n\t    !i_size_read(ecryptfs_inode_to_lower(inode))) {\n\t\trc = ecryptfs_initialize_file(dentry, inode);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -EIO;\nout:\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_initialize_file",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_initialize_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "220-253",
          "snippet": "int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode_to_lower(inode)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_metadata",
          "args": [
            "dentry"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1424-1490",
          "snippet": "int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_VALIDATE_HEADER_SIZE 1",
            "#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0"
          ],
          "globals_used": [
            "struct kmem_cache *ecryptfs_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\n#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0\n\nstruct kmem_cache *ecryptfs_header_cache;\n\nint ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "inode->i_sb"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int read_or_initialize_metadata(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tinode->i_sb)->mount_crypt_stat;\n\tmutex_lock(&crypt_stat->cs_mutex);\n\n\tif (crypt_stat->flags & ECRYPTFS_POLICY_APPLIED &&\n\t    crypt_stat->flags & ECRYPTFS_KEY_VALID) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_read_metadata(dentry);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED) {\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED) &&\n\t    !i_size_read(ecryptfs_inode_to_lower(inode))) {\n\t\trc = ecryptfs_initialize_file(dentry, inode);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -EIO;\nout:\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "111-134",
    "snippet": "static int ecryptfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc;\n\tstruct file *lower_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct ecryptfs_getdents_callback buf = {\n\t\t.ctx.actor = ecryptfs_filldir,\n\t\t.caller = ctx,\n\t\t.sb = inode->i_sb,\n\t};\n\tlower_file = ecryptfs_file_to_lower(file);\n\tlower_file->f_pos = ctx->pos;\n\trc = iterate_dir(lower_file, &buf.ctx);\n\tctx->pos = buf.ctx.pos;\n\tif (rc < 0)\n\t\tgoto out;\n\tif (buf.filldir_called && !buf.entries_written)\n\t\tgoto out;\n\tif (rc >= 0)\n\t\tfsstack_copy_attr_atime(inode,\n\t\t\t\t\tfile_inode(lower_file));\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsstack_copy_attr_atime",
          "args": [
            "inode",
            "file_inode(lower_file)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "lower_file"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "lower_file",
            "&buf.ctx"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "file"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc;\n\tstruct file *lower_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct ecryptfs_getdents_callback buf = {\n\t\t.ctx.actor = ecryptfs_filldir,\n\t\t.caller = ctx,\n\t\t.sb = inode->i_sb,\n\t};\n\tlower_file = ecryptfs_file_to_lower(file);\n\tlower_file->f_pos = ctx->pos;\n\trc = iterate_dir(lower_file, &buf.ctx);\n\tctx->pos = buf.ctx.pos;\n\tif (rc < 0)\n\t\tgoto out;\n\tif (buf.filldir_called && !buf.entries_written)\n\t\tgoto out;\n\tif (rc >= 0)\n\t\tfsstack_copy_attr_atime(inode,\n\t\t\t\t\tfile_inode(lower_file));\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "77-104",
    "snippet": "static int\necryptfs_filldir(struct dir_context *ctx, const char *lower_name,\n\t\t int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ecryptfs_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct ecryptfs_getdents_callback, ctx);\n\tsize_t name_size;\n\tchar *name;\n\tint rc;\n\n\tbuf->filldir_called++;\n\trc = ecryptfs_decode_and_decrypt_filename(&name, &name_size,\n\t\t\t\t\t\t  buf->sb, lower_name,\n\t\t\t\t\t\t  lower_namelen);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decode and decrypt \"\n\t\t       \"filename [%s]; rc = [%d]\\n\", __func__, lower_name,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tbuf->caller->pos = buf->ctx.pos;\n\trc = !dir_emit(buf->caller, name, name_size, ino, d_type);\n\tkfree(name);\n\tif (!rc)\n\t\tbuf->entries_written++;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "buf->caller",
            "name",
            "name_size",
            "ino",
            "d_type"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to decode and decrypt \"\n\t\t       \"filename [%s]; rc = [%d]\\n\"",
            "__func__",
            "lower_name",
            "rc"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_decode_and_decrypt_filename",
          "args": [
            "&name",
            "&name_size",
            "buf->sb",
            "lower_name",
            "lower_namelen"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_decode_and_decrypt_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "2058-2117",
          "snippet": "int ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structecryptfs_getdents_callback",
            "ctx"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_filldir(struct dir_context *ctx, const char *lower_name,\n\t\t int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ecryptfs_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct ecryptfs_getdents_callback, ctx);\n\tsize_t name_size;\n\tchar *name;\n\tint rc;\n\n\tbuf->filldir_called++;\n\trc = ecryptfs_decode_and_decrypt_filename(&name, &name_size,\n\t\t\t\t\t\t  buf->sb, lower_name,\n\t\t\t\t\t\t  lower_namelen);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decode and decrypt \"\n\t\t       \"filename [%s]; rc = [%d]\\n\", __func__, lower_name,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tbuf->caller->pos = buf->ctx.pos;\n\trc = !dir_emit(buf->caller, name, name_size, ino, d_type);\n\tkfree(name);\n\tif (!rc)\n\t\tbuf->entries_written++;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_update_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/file.c",
    "lines": "47-66",
    "snippet": "static ssize_t ecryptfs_read_update_atime(struct kiocb *iocb,\n\t\t\t\tstruct iov_iter *to)\n{\n\tssize_t rc;\n\tstruct path *path;\n\tstruct file *file = iocb->ki_filp;\n\n\trc = generic_file_read_iter(iocb, to);\n\t/*\n\t * Even though this is a async interface, we need to wait\n\t * for IO to finish to update atime\n\t */\n\tif (-EIOCBQUEUED == rc)\n\t\trc = wait_on_sync_kiocb(iocb);\n\tif (rc >= 0) {\n\t\tpath = ecryptfs_dentry_to_lower_path(file->f_path.dentry);\n\t\ttouch_atime(path);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/aio.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/compat.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_atime",
          "args": [
            "path"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "touch_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1587-1631",
          "snippet": "void touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower_path",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/aio.h>\n#include <linux/fs_stack.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t ecryptfs_read_update_atime(struct kiocb *iocb,\n\t\t\t\tstruct iov_iter *to)\n{\n\tssize_t rc;\n\tstruct path *path;\n\tstruct file *file = iocb->ki_filp;\n\n\trc = generic_file_read_iter(iocb, to);\n\t/*\n\t * Even though this is a async interface, we need to wait\n\t * for IO to finish to update atime\n\t */\n\tif (-EIOCBQUEUED == rc)\n\t\trc = wait_on_sync_kiocb(iocb);\n\tif (rc >= 0) {\n\t\tpath = ecryptfs_dentry_to_lower_path(file->f_path.dentry);\n\t\ttouch_atime(path);\n\t}\n\treturn rc;\n}"
  }
]