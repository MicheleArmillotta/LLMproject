[
  {
    "function_name": "exit_fat_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1852-1856",
    "snippet": "static void __exit exit_fat_fs(void)\n{\n\tfat_cache_destroy();\n\tfat_destroy_inodecache();\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_destroy_inodecache",
          "args": [],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "fat_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "696-704",
          "snippet": "static void __exit fat_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fat_inode_cachep);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic void __exit fat_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fat_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_destroy",
          "args": [],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "58-61",
          "snippet": "void fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nvoid fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void __exit exit_fat_fs(void)\n{\n\tfat_cache_destroy();\n\tfat_destroy_inodecache();\n}"
  },
  {
    "function_name": "init_fat_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1833-1850",
    "snippet": "static int __init init_fat_fs(void)\n{\n\tint err;\n\n\terr = fat_cache_init();\n\tif (err)\n\t\treturn err;\n\n\terr = fat_init_inodecache();\n\tif (err)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tfat_cache_destroy();\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_cache_destroy",
          "args": [],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "58-61",
          "snippet": "void fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nvoid fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_init_inodecache",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "fat_init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "684-694",
          "snippet": "static int __init fat_init_inodecache(void)\n{\n\tfat_inode_cachep = kmem_cache_create(\"fat_inode_cache\",\n\t\t\t\t\t     sizeof(struct msdos_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (fat_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic int __init fat_init_inodecache(void)\n{\n\tfat_inode_cachep = kmem_cache_create(\"fat_inode_cache\",\n\t\t\t\t\t     sizeof(struct msdos_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (fat_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_init",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "47-56",
          "snippet": "int __init fat_cache_init(void)\n{\n\tfat_cache_cachep = kmem_cache_create(\"fat_cache\",\n\t\t\t\tsizeof(struct fat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (fat_cache_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nint __init fat_cache_init(void)\n{\n\tfat_cache_cachep = kmem_cache_create(\"fat_cache\",\n\t\t\t\tsizeof(struct fat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (fat_cache_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int __init init_fat_fs(void)\n{\n\tint err;\n\n\terr = fat_cache_init();\n\tif (err)\n\t\treturn err;\n\n\terr = fat_init_inodecache();\n\tif (err)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tfat_cache_destroy();\n\treturn err;\n}"
  },
  {
    "function_name": "fat_flush_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1816-1830",
    "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "mapping"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_inode",
          "args": [
            "i2"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1793-1806",
          "snippet": "static int writeback_inode(struct inode *inode)\n{\n\n\tint ret;\n\n\t/* if we used wait=1, sync_inode_metadata waits for the io for the\n\t* inode to finish.  So wait=0 is sent down to sync_inode_metadata\n\t* and filemap_fdatawrite is used for the data blocks\n\t*/\n\tret = sync_inode_metadata(inode, 0);\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int writeback_inode(struct inode *inode)\n{\n\n\tint ret;\n\n\t/* if we used wait=1, sync_inode_metadata waits for the io for the\n\t* inode to finish.  So wait=0 is sent down to sync_inode_metadata\n\t* and filemap_fdatawrite is used for the data blocks\n\t*/\n\tret = sync_inode_metadata(inode, 0);\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "writeback_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1793-1806",
    "snippet": "static int writeback_inode(struct inode *inode)\n{\n\n\tint ret;\n\n\t/* if we used wait=1, sync_inode_metadata waits for the io for the\n\t* inode to finish.  So wait=0 is sent down to sync_inode_metadata\n\t* and filemap_fdatawrite is used for the data blocks\n\t*/\n\tret = sync_inode_metadata(inode, 0);\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "0"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int writeback_inode(struct inode *inode)\n{\n\n\tint ret;\n\n\t/* if we used wait=1, sync_inode_metadata waits for the io for the\n\t* inode to finish.  So wait=0 is sent down to sync_inode_metadata\n\t* and filemap_fdatawrite is used for the data blocks\n\t*/\n\tret = sync_inode_metadata(inode, 0);\n\tif (!ret)\n\t\tret = filemap_fdatawrite(inode->i_mapping);\n\treturn ret;\n}"
  },
  {
    "function_name": "fat_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1496-1783",
    "snippet": "int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;",
      "static int fat_show_options(struct seq_file *m, struct dentry *root);",
      "static const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->options.iocharset"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->nls_disk"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "fat_inode"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"Can't find a valid FAT filesystem\""
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_state",
          "args": [
            "sb",
            "1",
            "0"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "578-623",
          "snippet": "static void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_attach",
          "args": [
            "root_inode",
            "0"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "fat_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "369-395",
          "snippet": "void fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fat_show_options(struct seq_file *m, struct dentry *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "root_inode"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_read_root",
          "args": [
            "root_inode"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "fat_read_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1281-1315",
          "snippet": "static int fat_read_root(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = 0;\n\tinode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);\n\tinode->i_op = sbi->dir_ops;\n\tinode->i_fop = &fat_dir_operations;\n\tif (sbi->fat_bits == 32) {\n\t\tMSDOS_I(inode)->i_start = sbi->root_cluster;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tinode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);\n\t}\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\tMSDOS_I(inode)->i_logstart = 0;\n\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\tfat_save_attrs(inode, ATTR_DIR);\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;\n\tinode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tset_nlink(inode, fat_subdirs(inode)+2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_read_root(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = 0;\n\tinode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);\n\tinode->i_op = sbi->dir_ops;\n\tinode->i_fop = &fat_dir_operations;\n\tif (sbi->fat_bits == 32) {\n\t\tMSDOS_I(inode)->i_start = sbi->root_cluster;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tinode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);\n\t}\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\tMSDOS_I(inode)->i_logstart = 0;\n\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\tfat_save_attrs(inode, ATTR_DIR);\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;\n\tinode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tset_nlink(inode, fat_subdirs(inode)+2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "fat_inode"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"cp%d\"",
            "sbi->options.codepage"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_ent_access_init",
          "args": [
            "sb"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_access_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "289-309",
          "snippet": "void fat_ent_access_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tmutex_init(&sbi->fat_lock);\n\n\tswitch (sbi->fat_bits) {\n\tcase 32:\n\t\tsbi->fatent_shift = 2;\n\t\tsbi->fatent_ops = &fat32_ops;\n\t\tbreak;\n\tcase 16:\n\t\tsbi->fatent_shift = 1;\n\t\tsbi->fatent_ops = &fat16_ops;\n\t\tbreak;\n\tcase 12:\n\t\tsbi->fatent_shift = -1;\n\t\tsbi->fatent_ops = &fat12_ops;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fatent_operations fat12_ops = {\n\t.ent_blocknr\t= fat12_ent_blocknr,\n\t.ent_set_ptr\t= fat12_ent_set_ptr,\n\t.ent_bread\t= fat12_ent_bread,\n\t.ent_get\t= fat12_ent_get,\n\t.ent_put\t= fat12_ent_put,\n\t.ent_next\t= fat12_ent_next,\n};",
            "static struct fatent_operations fat16_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat16_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat16_ent_get,\n\t.ent_put\t= fat16_ent_put,\n\t.ent_next\t= fat16_ent_next,\n};",
            "static struct fatent_operations fat32_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat32_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat32_ent_get,\n\t.ent_put\t= fat32_ent_put,\n\t.ent_next\t= fat32_ent_next,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct fatent_operations fat12_ops = {\n\t.ent_blocknr\t= fat12_ent_blocknr,\n\t.ent_set_ptr\t= fat12_ent_set_ptr,\n\t.ent_bread\t= fat12_ent_bread,\n\t.ent_get\t= fat12_ent_get,\n\t.ent_put\t= fat12_ent_put,\n\t.ent_next\t= fat12_ent_next,\n};\nstatic struct fatent_operations fat16_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat16_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat16_ent_get,\n\t.ent_put\t= fat16_ent_put,\n\t.ent_next\t= fat16_ent_next,\n};\nstatic struct fatent_operations fat32_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat32_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat32_ent_get,\n\t.ent_put\t= fat32_ent_put,\n\t.ent_next\t= fat32_ent_next,\n};\n\nvoid fat_ent_access_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tmutex_init(&sbi->fat_lock);\n\n\tswitch (sbi->fat_bits) {\n\tcase 32:\n\t\tsbi->fatent_shift = 2;\n\t\tsbi->fatent_ops = &fat32_ops;\n\t\tbreak;\n\tcase 16:\n\t\tsbi->fatent_shift = 1;\n\t\tsbi->fatent_ops = &fat16_ops;\n\t\tbreak;\n\tcase 12:\n\t\tsbi->fatent_shift = -1;\n\t\tsbi->fatent_ops = &fat12_ops;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_hash_init",
          "args": [
            "sb"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "dir_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "359-367",
          "snippet": "static void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_hash_init",
          "args": [
            "sb"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "fat_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "344-352",
          "snippet": "static void fat_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_FAT",
          "args": [
            "sb"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "total_clusters",
            "fat_clusters - FAT_START_ENT"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_fat_clusters",
          "args": [
            "sb"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "calc_fat_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1317-1328",
          "snippet": "static unsigned long calc_fat_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* Divide first to avoid overflow */\n\tif (sbi->fat_bits != 12) {\n\t\tunsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;\n\t\treturn ent_per_sec * sbi->fat_length;\n\t}\n\n\treturn sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned long calc_fat_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* Divide first to avoid overflow */\n\tif (sbi->fat_bits != 12) {\n\t\tunsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;\n\t\treturn ent_per_sec * sbi->fat_length;\n\t}\n\n\treturn sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "sbi->dir_per_block"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fsinfo_bh"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fsinfo->next_cluster"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FSINFO",
          "args": [
            "fsinfo"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "sbi->fsinfo_sector"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "logical_sector_size"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_read_static_bpb",
          "args": [
            "sb",
            "(struct fat_boot_sector *)bh->b_data",
            "silent",
            "&bpb"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "fat_read_static_bpb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1427-1491",
          "snippet": "static int fat_read_static_bpb(struct super_block *sb,\n\tstruct fat_boot_sector *b, int silent,\n\tstruct fat_bios_param_block *bpb)\n{\n\tstatic const char *notdos1x = \"This doesn't look like a DOS 1.x volume\";\n\n\tstruct fat_floppy_defaults *fdefaults = NULL;\n\tint error = -EINVAL;\n\tsector_t bd_sects;\n\tunsigned i;\n\n\tbd_sects = i_size_read(sb->s_bdev->bd_inode) / SECTOR_SIZE;\n\n\t/* 16-bit DOS 1.x reliably wrote bootstrap short-jmp code */\n\tif (b->ignored[0] != 0xeb || b->ignored[2] != 0x90) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; no bootstrapping code\", notdos1x);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If any value in this region is non-zero, it isn't archaic\n\t * DOS.\n\t */\n\tif (!fat_bpb_is_zero(b)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; DOS 2.x BPB is non-zero\", notdos1x);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(floppy_defaults); i++) {\n\t\tif (floppy_defaults[i].nr_sectors == bd_sects) {\n\t\t\tfdefaults = &floppy_defaults[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdefaults == NULL) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\"This looks like a DOS 1.x volume, but isn't a recognized floppy size (%llu sectors)\",\n\t\t\t\t(u64)bd_sects);\n\t\tgoto out;\n\t}\n\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO,\n\t\t\t\"This looks like a DOS 1.x volume; assuming default BPB values\");\n\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = SECTOR_SIZE;\n\tbpb->fat_sec_per_clus = fdefaults->sec_per_clus;\n\tbpb->fat_reserved = 1;\n\tbpb->fat_fats = 2;\n\tbpb->fat_dir_entries = fdefaults->dir_entries;\n\tbpb->fat_sectors = fdefaults->nr_sectors;\n\tbpb->fat_fat_length = fdefaults->fat_length;\n\n\terror = 0;\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fat_floppy_defaults {\n\tunsigned nr_sectors;\n\tunsigned sec_per_clus;\n\tunsigned dir_entries;\n\tunsigned media;\n\tunsigned fat_length;\n} floppy_defaults[] = {\n{\n\t.nr_sectors = 160 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFE,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 180 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFC,\n\t.fat_length = 2,\n},\n{\n\t.nr_sectors = 320 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFF,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 360 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFD,\n\t.fat_length = 2,\n},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct fat_floppy_defaults {\n\tunsigned nr_sectors;\n\tunsigned sec_per_clus;\n\tunsigned dir_entries;\n\tunsigned media;\n\tunsigned fat_length;\n} floppy_defaults[] = {\n{\n\t.nr_sectors = 160 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFE,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 180 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFC,\n\t.fat_length = 2,\n},\n{\n\t.nr_sectors = 320 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFF,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 360 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFD,\n\t.fat_length = 2,\n},\n};\n\nstatic int fat_read_static_bpb(struct super_block *sb,\n\tstruct fat_boot_sector *b, int silent,\n\tstruct fat_bios_param_block *bpb)\n{\n\tstatic const char *notdos1x = \"This doesn't look like a DOS 1.x volume\";\n\n\tstruct fat_floppy_defaults *fdefaults = NULL;\n\tint error = -EINVAL;\n\tsector_t bd_sects;\n\tunsigned i;\n\n\tbd_sects = i_size_read(sb->s_bdev->bd_inode) / SECTOR_SIZE;\n\n\t/* 16-bit DOS 1.x reliably wrote bootstrap short-jmp code */\n\tif (b->ignored[0] != 0xeb || b->ignored[2] != 0x90) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; no bootstrapping code\", notdos1x);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If any value in this region is non-zero, it isn't archaic\n\t * DOS.\n\t */\n\tif (!fat_bpb_is_zero(b)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; DOS 2.x BPB is non-zero\", notdos1x);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(floppy_defaults); i++) {\n\t\tif (floppy_defaults[i].nr_sectors == bd_sects) {\n\t\t\tfdefaults = &floppy_defaults[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdefaults == NULL) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\"This looks like a DOS 1.x volume, but isn't a recognized floppy size (%llu sectors)\",\n\t\t\t\t(u64)bd_sects);\n\t\tgoto out;\n\t}\n\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO,\n\t\t\t\"This looks like a DOS 1.x volume; assuming default BPB values\");\n\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = SECTOR_SIZE;\n\tbpb->fat_sec_per_clus = fdefaults->sec_per_clus;\n\tbpb->fat_reserved = 1;\n\tbpb->fat_fats = 2;\n\tbpb->fat_dir_entries = fdefaults->dir_entries;\n\tbpb->fat_sectors = fdefaults->nr_sectors;\n\tbpb->fat_fat_length = fdefaults->fat_length;\n\n\terror = 0;\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_read_bpb",
          "args": [
            "sb",
            "(struct fat_boot_sector *)bh->b_data",
            "silent",
            "&bpb"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "fat_read_bpb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1355-1425",
          "snippet": "static int fat_read_bpb(struct super_block *sb, struct fat_boot_sector *b,\n\tint silent, struct fat_bios_param_block *bpb)\n{\n\tint error = -EINVAL;\n\n\t/* Read in BPB ... */\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = get_unaligned_le16(&b->sector_size);\n\tbpb->fat_sec_per_clus = b->sec_per_clus;\n\tbpb->fat_reserved = le16_to_cpu(b->reserved);\n\tbpb->fat_fats = b->fats;\n\tbpb->fat_dir_entries = get_unaligned_le16(&b->dir_entries);\n\tbpb->fat_sectors = get_unaligned_le16(&b->sectors);\n\tbpb->fat_fat_length = le16_to_cpu(b->fat_length);\n\tbpb->fat_total_sect = le32_to_cpu(b->total_sect);\n\n\tbpb->fat16_state = b->fat16.state;\n\tbpb->fat16_vol_id = get_unaligned_le32(b->fat16.vol_id);\n\n\tbpb->fat32_length = le32_to_cpu(b->fat32.length);\n\tbpb->fat32_root_cluster = le32_to_cpu(b->fat32.root_cluster);\n\tbpb->fat32_info_sector = le16_to_cpu(b->fat32.info_sector);\n\tbpb->fat32_state = b->fat32.state;\n\tbpb->fat32_vol_id = get_unaligned_le32(b->fat32.vol_id);\n\n\t/* Validate this looks like a FAT filesystem BPB */\n\tif (!bpb->fat_reserved) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"bogus number of reserved sectors\");\n\t\tgoto out;\n\t}\n\tif (!bpb->fat_fats) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT structure\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Earlier we checked here that b->secs_track and b->head are nonzero,\n\t * but it turns out valid FAT filesystems can have zero there.\n\t */\n\n\tif (!fat_valid_media(b->media)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"invalid media value (0x%02x)\",\n\t\t\t\t(unsigned)b->media);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sector_size)\n\t    || (bpb->fat_sector_size < 512)\n\t    || (bpb->fat_sector_size > 4096)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus logical sector size %u\",\n\t\t\t       (unsigned)bpb->fat_sector_size);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sec_per_clus)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus sectors per cluster %u\",\n\t\t\t\t(unsigned)bpb->fat_sec_per_clus);\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_read_bpb(struct super_block *sb, struct fat_boot_sector *b,\n\tint silent, struct fat_bios_param_block *bpb)\n{\n\tint error = -EINVAL;\n\n\t/* Read in BPB ... */\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = get_unaligned_le16(&b->sector_size);\n\tbpb->fat_sec_per_clus = b->sec_per_clus;\n\tbpb->fat_reserved = le16_to_cpu(b->reserved);\n\tbpb->fat_fats = b->fats;\n\tbpb->fat_dir_entries = get_unaligned_le16(&b->dir_entries);\n\tbpb->fat_sectors = get_unaligned_le16(&b->sectors);\n\tbpb->fat_fat_length = le16_to_cpu(b->fat_length);\n\tbpb->fat_total_sect = le32_to_cpu(b->total_sect);\n\n\tbpb->fat16_state = b->fat16.state;\n\tbpb->fat16_vol_id = get_unaligned_le32(b->fat16.vol_id);\n\n\tbpb->fat32_length = le32_to_cpu(b->fat32.length);\n\tbpb->fat32_root_cluster = le32_to_cpu(b->fat32.root_cluster);\n\tbpb->fat32_info_sector = le16_to_cpu(b->fat32.info_sector);\n\tbpb->fat32_state = b->fat32.state;\n\tbpb->fat32_vol_id = get_unaligned_le32(b->fat32.vol_id);\n\n\t/* Validate this looks like a FAT filesystem BPB */\n\tif (!bpb->fat_reserved) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"bogus number of reserved sectors\");\n\t\tgoto out;\n\t}\n\tif (!bpb->fat_fats) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT structure\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Earlier we checked here that b->secs_track and b->head are nonzero,\n\t * but it turns out valid FAT filesystems can have zero there.\n\t */\n\n\tif (!fat_valid_media(b->media)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"invalid media value (0x%02x)\",\n\t\t\t\t(unsigned)b->media);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sector_size)\n\t    || (bpb->fat_sector_size < 512)\n\t    || (bpb->fat_sector_size > 4096)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus logical sector size %u\",\n\t\t\t       (unsigned)bpb->fat_sector_size);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sec_per_clus)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus sectors per cluster %u\",\n\t\t\t\t(unsigned)bpb->fat_sec_per_clus);\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "512"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup",
          "args": [
            "sb"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "1046-1053",
          "snippet": "static void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};",
            "static const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};",
            "static const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};\nstatic const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};\nstatic const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "sb",
            "data",
            "isvfat",
            "silent",
            "&debug",
            "&sbi->options"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1031-1279",
          "snippet": "static int parse_options(struct super_block *sb, char *options, int is_vfat,\n\t\t\t int silent, int *debug, struct fat_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *iocharset;\n\n\topts->isvfat = is_vfat;\n\n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask = opts->fs_dmask = current_umask();\n\topts->allow_utime = -1;\n\topts->codepage = fat_default_codepage;\n\topts->iocharset = fat_default_iocharset;\n\tif (is_vfat) {\n\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT|VFAT_SFN_CREATE_WIN95;\n\t\topts->rodir = 0;\n\t} else {\n\t\topts->shortname = 0;\n\t\topts->rodir = 1;\n\t}\n\topts->name_check = 'n';\n\topts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;\n\topts->utf8 = opts->unicode_xlate = 0;\n\topts->numtail = 1;\n\topts->usefree = opts->nocase = 0;\n\topts->tz_set = 0;\n\topts->nfs = 0;\n\topts->errors = FAT_ERRORS_RO;\n\t*debug = 0;\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, fat_tokens, args);\n\t\tif (token == Opt_err) {\n\t\t\tif (is_vfat)\n\t\t\t\ttoken = match_token(p, vfat_tokens, args);\n\t\t\telse\n\t\t\t\ttoken = match_token(p, msdos_tokens, args);\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_check_s:\n\t\t\topts->name_check = 's';\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\topts->name_check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_n:\n\t\t\topts->name_check = 'n';\n\t\t\tbreak;\n\t\tcase Opt_usefree:\n\t\t\topts->usefree = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tif (!is_vfat)\n\t\t\t\topts->nocase = 1;\n\t\t\telse {\n\t\t\t\t/* for backward compatibility */\n\t\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quiet:\n\t\t\topts->quiet = 1;\n\t\t\tbreak;\n\t\tcase Opt_showexec:\n\t\t\topts->showexec = 1;\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\t*debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_immutable:\n\t\t\topts->sys_immutable = 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(opts->fs_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(opts->fs_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = opts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = option;\n\t\t\tbreak;\n\t\tcase Opt_allow_utime:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->allow_utime = option & (S_IWGRP | S_IWOTH);\n\t\t\tbreak;\n\t\tcase Opt_codepage:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->codepage = option;\n\t\t\tbreak;\n\t\tcase Opt_flush:\n\t\t\topts->flush = 1;\n\t\t\tbreak;\n\t\tcase Opt_time_offset:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option < -12 * 60 || option > 12 * 60)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = option;\n\t\t\tbreak;\n\t\tcase Opt_tz_utc:\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\topts->errors = FAT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\topts->errors = FAT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\topts->errors = FAT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_nfs_stale_rw:\n\t\t\topts->nfs = FAT_NFS_STALE_RW;\n\t\t\tbreak;\n\t\tcase Opt_nfs_nostale_ro:\n\t\t\topts->nfs = FAT_NFS_NOSTALE_RO;\n\t\t\tbreak;\n\t\tcase Opt_dos1xfloppy:\n\t\t\topts->dos1xfloppy = 1;\n\t\t\tbreak;\n\n\t\t/* msdos specific */\n\t\tcase Opt_dots:\n\t\t\topts->dotsOK = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodots:\n\t\t\topts->dotsOK = 0;\n\t\t\tbreak;\n\n\t\t/* vfat specific */\n\t\tcase Opt_charset:\n\t\t\tif (opts->iocharset != fat_default_iocharset)\n\t\t\t\tkfree(opts->iocharset);\n\t\t\tiocharset = match_strdup(&args[0]);\n\t\t\tif (!iocharset)\n\t\t\t\treturn -ENOMEM;\n\t\t\topts->iocharset = iocharset;\n\t\t\tbreak;\n\t\tcase Opt_shortname_lower:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_LOWER\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_win95:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_winnt:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WINNT;\n\t\t\tbreak;\n\t\tcase Opt_shortname_mixed:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_utf8_no:\t\t/* 0 or no or false */\n\t\t\topts->utf8 = 0;\n\t\t\tbreak;\n\t\tcase Opt_utf8_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->utf8 = 1;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_no:\t\t/* 0 or no or false */\n\t\t\topts->unicode_xlate = 0;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->unicode_xlate = 1;\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_no:\t\t/* 0 or no or false */\n\t\t\topts->numtail = 1;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->numtail = 0;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_rodir:\n\t\t\topts->rodir = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\topts->discard = 1;\n\t\t\tbreak;\n\n\t\t/* obsolete mount options */\n\t\tcase Opt_obsolete:\n\t\t\tfat_msg(sb, KERN_INFO, \"\\\"%s\\\" option is obsolete, \"\n\t\t\t       \"not supported now\", p);\n\t\t\tbreak;\n\t\t/* unknown option */\n\t\tdefault:\n\t\t\tif (!silent) {\n\t\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t       \"or missing value\", p);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\t/* UTF-8 doesn't provide FAT semantics */\n\tif (!strcmp(opts->iocharset, \"utf8\")) {\n\t\tfat_msg(sb, KERN_WARNING, \"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\");\n\t}\n\n\t/* If user doesn't specify allow_utime, it's initialized from dmask. */\n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);\n\tif (opts->unicode_xlate)\n\t\topts->utf8 = 0;\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tsb->s_export_op = &fat_export_ops_nostale;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;",
            "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;",
            "static const match_table_t fat_tokens = {\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_n, \"check=normal\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_check_n, \"check=n\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_allow_utime, \"allow_utime=%o\"},\n\t{Opt_codepage, \"codepage=%u\"},\n\t{Opt_usefree, \"usefree\"},\n\t{Opt_nocase, \"nocase\"},\n\t{Opt_quiet, \"quiet\"},\n\t{Opt_showexec, \"showexec\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_immutable, \"sys_immutable\"},\n\t{Opt_flush, \"flush\"},\n\t{Opt_tz_utc, \"tz=UTC\"},\n\t{Opt_time_offset, \"time_offset=%d\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nfs_stale_rw, \"nfs\"},\n\t{Opt_nfs_stale_rw, \"nfs=stale_rw\"},\n\t{Opt_nfs_nostale_ro, \"nfs=nostale_ro\"},\n\t{Opt_dos1xfloppy, \"dos1xfloppy\"},\n\t{Opt_obsolete, \"conv=binary\"},\n\t{Opt_obsolete, \"conv=text\"},\n\t{Opt_obsolete, \"conv=auto\"},\n\t{Opt_obsolete, \"conv=b\"},\n\t{Opt_obsolete, \"conv=t\"},\n\t{Opt_obsolete, \"conv=a\"},\n\t{Opt_obsolete, \"fat=%u\"},\n\t{Opt_obsolete, \"blocksize=%u\"},\n\t{Opt_obsolete, \"cvf_format=%20s\"},\n\t{Opt_obsolete, \"cvf_options=%100s\"},\n\t{Opt_obsolete, \"posix\"},\n\t{Opt_err, NULL},\n};",
            "static const match_table_t msdos_tokens = {\n\t{Opt_nodots, \"nodots\"},\n\t{Opt_nodots, \"dotsOK=no\"},\n\t{Opt_dots, \"dots\"},\n\t{Opt_dots, \"dotsOK=yes\"},\n\t{Opt_err, NULL}\n};",
            "static const match_table_t vfat_tokens = {\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_shortname_lower, \"shortname=lower\"},\n\t{Opt_shortname_win95, \"shortname=win95\"},\n\t{Opt_shortname_winnt, \"shortname=winnt\"},\n\t{Opt_shortname_mixed, \"shortname=mixed\"},\n\t{Opt_utf8_no, \"utf8=0\"},\t\t/* 0 or no or false */\n\t{Opt_utf8_no, \"utf8=no\"},\n\t{Opt_utf8_no, \"utf8=false\"},\n\t{Opt_utf8_yes, \"utf8=1\"},\t\t/* empty or 1 or yes or true */\n\t{Opt_utf8_yes, \"utf8=yes\"},\n\t{Opt_utf8_yes, \"utf8=true\"},\n\t{Opt_utf8_yes, \"utf8\"},\n\t{Opt_uni_xl_no, \"uni_xlate=0\"},\t\t/* 0 or no or false */\n\t{Opt_uni_xl_no, \"uni_xlate=no\"},\n\t{Opt_uni_xl_no, \"uni_xlate=false\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_uni_xl_yes, \"uni_xlate=yes\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=true\"},\n\t{Opt_uni_xl_yes, \"uni_xlate\"},\n\t{Opt_nonumtail_no, \"nonumtail=0\"},\t/* 0 or no or false */\n\t{Opt_nonumtail_no, \"nonumtail=no\"},\n\t{Opt_nonumtail_no, \"nonumtail=false\"},\n\t{Opt_nonumtail_yes, \"nonumtail=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_nonumtail_yes, \"nonumtail=yes\"},\n\t{Opt_nonumtail_yes, \"nonumtail=true\"},\n\t{Opt_nonumtail_yes, \"nonumtail\"},\n\t{Opt_rodir, \"rodir\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\nstatic const match_table_t fat_tokens = {\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_n, \"check=normal\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_check_n, \"check=n\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_allow_utime, \"allow_utime=%o\"},\n\t{Opt_codepage, \"codepage=%u\"},\n\t{Opt_usefree, \"usefree\"},\n\t{Opt_nocase, \"nocase\"},\n\t{Opt_quiet, \"quiet\"},\n\t{Opt_showexec, \"showexec\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_immutable, \"sys_immutable\"},\n\t{Opt_flush, \"flush\"},\n\t{Opt_tz_utc, \"tz=UTC\"},\n\t{Opt_time_offset, \"time_offset=%d\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nfs_stale_rw, \"nfs\"},\n\t{Opt_nfs_stale_rw, \"nfs=stale_rw\"},\n\t{Opt_nfs_nostale_ro, \"nfs=nostale_ro\"},\n\t{Opt_dos1xfloppy, \"dos1xfloppy\"},\n\t{Opt_obsolete, \"conv=binary\"},\n\t{Opt_obsolete, \"conv=text\"},\n\t{Opt_obsolete, \"conv=auto\"},\n\t{Opt_obsolete, \"conv=b\"},\n\t{Opt_obsolete, \"conv=t\"},\n\t{Opt_obsolete, \"conv=a\"},\n\t{Opt_obsolete, \"fat=%u\"},\n\t{Opt_obsolete, \"blocksize=%u\"},\n\t{Opt_obsolete, \"cvf_format=%20s\"},\n\t{Opt_obsolete, \"cvf_options=%100s\"},\n\t{Opt_obsolete, \"posix\"},\n\t{Opt_err, NULL},\n};\nstatic const match_table_t msdos_tokens = {\n\t{Opt_nodots, \"nodots\"},\n\t{Opt_nodots, \"dotsOK=no\"},\n\t{Opt_dots, \"dots\"},\n\t{Opt_dots, \"dotsOK=yes\"},\n\t{Opt_err, NULL}\n};\nstatic const match_table_t vfat_tokens = {\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_shortname_lower, \"shortname=lower\"},\n\t{Opt_shortname_win95, \"shortname=win95\"},\n\t{Opt_shortname_winnt, \"shortname=winnt\"},\n\t{Opt_shortname_mixed, \"shortname=mixed\"},\n\t{Opt_utf8_no, \"utf8=0\"},\t\t/* 0 or no or false */\n\t{Opt_utf8_no, \"utf8=no\"},\n\t{Opt_utf8_no, \"utf8=false\"},\n\t{Opt_utf8_yes, \"utf8=1\"},\t\t/* empty or 1 or yes or true */\n\t{Opt_utf8_yes, \"utf8=yes\"},\n\t{Opt_utf8_yes, \"utf8=true\"},\n\t{Opt_utf8_yes, \"utf8\"},\n\t{Opt_uni_xl_no, \"uni_xlate=0\"},\t\t/* 0 or no or false */\n\t{Opt_uni_xl_no, \"uni_xlate=no\"},\n\t{Opt_uni_xl_no, \"uni_xlate=false\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_uni_xl_yes, \"uni_xlate=yes\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=true\"},\n\t{Opt_uni_xl_yes, \"uni_xlate\"},\n\t{Opt_nonumtail_no, \"nonumtail=0\"},\t/* 0 or no or false */\n\t{Opt_nonumtail_no, \"nonumtail=no\"},\n\t{Opt_nonumtail_no, \"nonumtail=false\"},\n\t{Opt_nonumtail_yes, \"nonumtail=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_nonumtail_yes, \"nonumtail=yes\"},\n\t{Opt_nonumtail_yes, \"nonumtail=true\"},\n\t{Opt_nonumtail_yes, \"nonumtail\"},\n\t{Opt_rodir, \"rodir\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options, int is_vfat,\n\t\t\t int silent, int *debug, struct fat_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *iocharset;\n\n\topts->isvfat = is_vfat;\n\n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask = opts->fs_dmask = current_umask();\n\topts->allow_utime = -1;\n\topts->codepage = fat_default_codepage;\n\topts->iocharset = fat_default_iocharset;\n\tif (is_vfat) {\n\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT|VFAT_SFN_CREATE_WIN95;\n\t\topts->rodir = 0;\n\t} else {\n\t\topts->shortname = 0;\n\t\topts->rodir = 1;\n\t}\n\topts->name_check = 'n';\n\topts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;\n\topts->utf8 = opts->unicode_xlate = 0;\n\topts->numtail = 1;\n\topts->usefree = opts->nocase = 0;\n\topts->tz_set = 0;\n\topts->nfs = 0;\n\topts->errors = FAT_ERRORS_RO;\n\t*debug = 0;\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, fat_tokens, args);\n\t\tif (token == Opt_err) {\n\t\t\tif (is_vfat)\n\t\t\t\ttoken = match_token(p, vfat_tokens, args);\n\t\t\telse\n\t\t\t\ttoken = match_token(p, msdos_tokens, args);\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_check_s:\n\t\t\topts->name_check = 's';\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\topts->name_check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_n:\n\t\t\topts->name_check = 'n';\n\t\t\tbreak;\n\t\tcase Opt_usefree:\n\t\t\topts->usefree = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tif (!is_vfat)\n\t\t\t\topts->nocase = 1;\n\t\t\telse {\n\t\t\t\t/* for backward compatibility */\n\t\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quiet:\n\t\t\topts->quiet = 1;\n\t\t\tbreak;\n\t\tcase Opt_showexec:\n\t\t\topts->showexec = 1;\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\t*debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_immutable:\n\t\t\topts->sys_immutable = 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(opts->fs_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(opts->fs_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = opts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = option;\n\t\t\tbreak;\n\t\tcase Opt_allow_utime:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->allow_utime = option & (S_IWGRP | S_IWOTH);\n\t\t\tbreak;\n\t\tcase Opt_codepage:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->codepage = option;\n\t\t\tbreak;\n\t\tcase Opt_flush:\n\t\t\topts->flush = 1;\n\t\t\tbreak;\n\t\tcase Opt_time_offset:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option < -12 * 60 || option > 12 * 60)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = option;\n\t\t\tbreak;\n\t\tcase Opt_tz_utc:\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\topts->errors = FAT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\topts->errors = FAT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\topts->errors = FAT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_nfs_stale_rw:\n\t\t\topts->nfs = FAT_NFS_STALE_RW;\n\t\t\tbreak;\n\t\tcase Opt_nfs_nostale_ro:\n\t\t\topts->nfs = FAT_NFS_NOSTALE_RO;\n\t\t\tbreak;\n\t\tcase Opt_dos1xfloppy:\n\t\t\topts->dos1xfloppy = 1;\n\t\t\tbreak;\n\n\t\t/* msdos specific */\n\t\tcase Opt_dots:\n\t\t\topts->dotsOK = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodots:\n\t\t\topts->dotsOK = 0;\n\t\t\tbreak;\n\n\t\t/* vfat specific */\n\t\tcase Opt_charset:\n\t\t\tif (opts->iocharset != fat_default_iocharset)\n\t\t\t\tkfree(opts->iocharset);\n\t\t\tiocharset = match_strdup(&args[0]);\n\t\t\tif (!iocharset)\n\t\t\t\treturn -ENOMEM;\n\t\t\topts->iocharset = iocharset;\n\t\t\tbreak;\n\t\tcase Opt_shortname_lower:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_LOWER\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_win95:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_winnt:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WINNT;\n\t\t\tbreak;\n\t\tcase Opt_shortname_mixed:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_utf8_no:\t\t/* 0 or no or false */\n\t\t\topts->utf8 = 0;\n\t\t\tbreak;\n\t\tcase Opt_utf8_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->utf8 = 1;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_no:\t\t/* 0 or no or false */\n\t\t\topts->unicode_xlate = 0;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->unicode_xlate = 1;\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_no:\t\t/* 0 or no or false */\n\t\t\topts->numtail = 1;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->numtail = 0;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_rodir:\n\t\t\topts->rodir = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\topts->discard = 1;\n\t\t\tbreak;\n\n\t\t/* obsolete mount options */\n\t\tcase Opt_obsolete:\n\t\t\tfat_msg(sb, KERN_INFO, \"\\\"%s\\\" option is obsolete, \"\n\t\t\t       \"not supported now\", p);\n\t\t\tbreak;\n\t\t/* unknown option */\n\t\tdefault:\n\t\t\tif (!silent) {\n\t\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t       \"or missing value\", p);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\t/* UTF-8 doesn't provide FAT semantics */\n\tif (!strcmp(opts->iocharset, \"utf8\")) {\n\t\tfat_msg(sb, KERN_WARNING, \"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\");\n\t}\n\n\t/* If user doesn't specify allow_utime, it's initialized from dmask. */\n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);\n\tif (opts->unicode_xlate)\n\t\topts->utf8 = 0;\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tsb->s_export_op = &fat_export_ops_nostale;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ratelimit_state_init",
          "args": [
            "&sbi->ratelimit",
            "DEFAULT_RATELIMIT_INTERVAL",
            "DEFAULT_RATELIMIT_BURST"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->nfs_build_inode_lock"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct msdos_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\nstatic const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};\n\nint fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}"
  },
  {
    "function_name": "fat_read_static_bpb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1427-1491",
    "snippet": "static int fat_read_static_bpb(struct super_block *sb,\n\tstruct fat_boot_sector *b, int silent,\n\tstruct fat_bios_param_block *bpb)\n{\n\tstatic const char *notdos1x = \"This doesn't look like a DOS 1.x volume\";\n\n\tstruct fat_floppy_defaults *fdefaults = NULL;\n\tint error = -EINVAL;\n\tsector_t bd_sects;\n\tunsigned i;\n\n\tbd_sects = i_size_read(sb->s_bdev->bd_inode) / SECTOR_SIZE;\n\n\t/* 16-bit DOS 1.x reliably wrote bootstrap short-jmp code */\n\tif (b->ignored[0] != 0xeb || b->ignored[2] != 0x90) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; no bootstrapping code\", notdos1x);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If any value in this region is non-zero, it isn't archaic\n\t * DOS.\n\t */\n\tif (!fat_bpb_is_zero(b)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; DOS 2.x BPB is non-zero\", notdos1x);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(floppy_defaults); i++) {\n\t\tif (floppy_defaults[i].nr_sectors == bd_sects) {\n\t\t\tfdefaults = &floppy_defaults[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdefaults == NULL) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\"This looks like a DOS 1.x volume, but isn't a recognized floppy size (%llu sectors)\",\n\t\t\t\t(u64)bd_sects);\n\t\tgoto out;\n\t}\n\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO,\n\t\t\t\"This looks like a DOS 1.x volume; assuming default BPB values\");\n\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = SECTOR_SIZE;\n\tbpb->fat_sec_per_clus = fdefaults->sec_per_clus;\n\tbpb->fat_reserved = 1;\n\tbpb->fat_fats = 2;\n\tbpb->fat_dir_entries = fdefaults->dir_entries;\n\tbpb->fat_sectors = fdefaults->nr_sectors;\n\tbpb->fat_fat_length = fdefaults->fat_length;\n\n\terror = 0;\n\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fat_floppy_defaults {\n\tunsigned nr_sectors;\n\tunsigned sec_per_clus;\n\tunsigned dir_entries;\n\tunsigned media;\n\tunsigned fat_length;\n} floppy_defaults[] = {\n{\n\t.nr_sectors = 160 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFE,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 180 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFC,\n\t.fat_length = 2,\n},\n{\n\t.nr_sectors = 320 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFF,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 360 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFD,\n\t.fat_length = 2,\n},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bpb",
            "0",
            "sizeof(*bpb)"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"This looks like a DOS 1.x volume; assuming default BPB values\""
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "floppy_defaults"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_bpb_is_zero",
          "args": [
            "b"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "fat_bpb_is_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1330-1353",
          "snippet": "static bool fat_bpb_is_zero(struct fat_boot_sector *b)\n{\n\tif (get_unaligned_le16(&b->sector_size))\n\t\treturn false;\n\tif (b->sec_per_clus)\n\t\treturn false;\n\tif (b->reserved)\n\t\treturn false;\n\tif (b->fats)\n\t\treturn false;\n\tif (get_unaligned_le16(&b->dir_entries))\n\t\treturn false;\n\tif (get_unaligned_le16(&b->sectors))\n\t\treturn false;\n\tif (b->media)\n\t\treturn false;\n\tif (b->fat_length)\n\t\treturn false;\n\tif (b->secs_track)\n\t\treturn false;\n\tif (b->heads)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool fat_bpb_is_zero(struct fat_boot_sector *b)\n{\n\tif (get_unaligned_le16(&b->sector_size))\n\t\treturn false;\n\tif (b->sec_per_clus)\n\t\treturn false;\n\tif (b->reserved)\n\t\treturn false;\n\tif (b->fats)\n\t\treturn false;\n\tif (get_unaligned_le16(&b->dir_entries))\n\t\treturn false;\n\tif (get_unaligned_le16(&b->sectors))\n\t\treturn false;\n\tif (b->media)\n\t\treturn false;\n\tif (b->fat_length)\n\t\treturn false;\n\tif (b->secs_track)\n\t\treturn false;\n\tif (b->heads)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct fat_floppy_defaults {\n\tunsigned nr_sectors;\n\tunsigned sec_per_clus;\n\tunsigned dir_entries;\n\tunsigned media;\n\tunsigned fat_length;\n} floppy_defaults[] = {\n{\n\t.nr_sectors = 160 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFE,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 180 * KB_IN_SECTORS,\n\t.sec_per_clus = 1,\n\t.dir_entries = 64,\n\t.media = 0xFC,\n\t.fat_length = 2,\n},\n{\n\t.nr_sectors = 320 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFF,\n\t.fat_length = 1,\n},\n{\n\t.nr_sectors = 360 * KB_IN_SECTORS,\n\t.sec_per_clus = 2,\n\t.dir_entries = 112,\n\t.media = 0xFD,\n\t.fat_length = 2,\n},\n};\n\nstatic int fat_read_static_bpb(struct super_block *sb,\n\tstruct fat_boot_sector *b, int silent,\n\tstruct fat_bios_param_block *bpb)\n{\n\tstatic const char *notdos1x = \"This doesn't look like a DOS 1.x volume\";\n\n\tstruct fat_floppy_defaults *fdefaults = NULL;\n\tint error = -EINVAL;\n\tsector_t bd_sects;\n\tunsigned i;\n\n\tbd_sects = i_size_read(sb->s_bdev->bd_inode) / SECTOR_SIZE;\n\n\t/* 16-bit DOS 1.x reliably wrote bootstrap short-jmp code */\n\tif (b->ignored[0] != 0xeb || b->ignored[2] != 0x90) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; no bootstrapping code\", notdos1x);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If any value in this region is non-zero, it isn't archaic\n\t * DOS.\n\t */\n\tif (!fat_bpb_is_zero(b)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"%s; DOS 2.x BPB is non-zero\", notdos1x);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(floppy_defaults); i++) {\n\t\tif (floppy_defaults[i].nr_sectors == bd_sects) {\n\t\t\tfdefaults = &floppy_defaults[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdefaults == NULL) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\"This looks like a DOS 1.x volume, but isn't a recognized floppy size (%llu sectors)\",\n\t\t\t\t(u64)bd_sects);\n\t\tgoto out;\n\t}\n\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO,\n\t\t\t\"This looks like a DOS 1.x volume; assuming default BPB values\");\n\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = SECTOR_SIZE;\n\tbpb->fat_sec_per_clus = fdefaults->sec_per_clus;\n\tbpb->fat_reserved = 1;\n\tbpb->fat_fats = 2;\n\tbpb->fat_dir_entries = fdefaults->dir_entries;\n\tbpb->fat_sectors = fdefaults->nr_sectors;\n\tbpb->fat_fat_length = fdefaults->fat_length;\n\n\terror = 0;\n\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "fat_read_bpb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1355-1425",
    "snippet": "static int fat_read_bpb(struct super_block *sb, struct fat_boot_sector *b,\n\tint silent, struct fat_bios_param_block *bpb)\n{\n\tint error = -EINVAL;\n\n\t/* Read in BPB ... */\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = get_unaligned_le16(&b->sector_size);\n\tbpb->fat_sec_per_clus = b->sec_per_clus;\n\tbpb->fat_reserved = le16_to_cpu(b->reserved);\n\tbpb->fat_fats = b->fats;\n\tbpb->fat_dir_entries = get_unaligned_le16(&b->dir_entries);\n\tbpb->fat_sectors = get_unaligned_le16(&b->sectors);\n\tbpb->fat_fat_length = le16_to_cpu(b->fat_length);\n\tbpb->fat_total_sect = le32_to_cpu(b->total_sect);\n\n\tbpb->fat16_state = b->fat16.state;\n\tbpb->fat16_vol_id = get_unaligned_le32(b->fat16.vol_id);\n\n\tbpb->fat32_length = le32_to_cpu(b->fat32.length);\n\tbpb->fat32_root_cluster = le32_to_cpu(b->fat32.root_cluster);\n\tbpb->fat32_info_sector = le16_to_cpu(b->fat32.info_sector);\n\tbpb->fat32_state = b->fat32.state;\n\tbpb->fat32_vol_id = get_unaligned_le32(b->fat32.vol_id);\n\n\t/* Validate this looks like a FAT filesystem BPB */\n\tif (!bpb->fat_reserved) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"bogus number of reserved sectors\");\n\t\tgoto out;\n\t}\n\tif (!bpb->fat_fats) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT structure\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Earlier we checked here that b->secs_track and b->head are nonzero,\n\t * but it turns out valid FAT filesystems can have zero there.\n\t */\n\n\tif (!fat_valid_media(b->media)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"invalid media value (0x%02x)\",\n\t\t\t\t(unsigned)b->media);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sector_size)\n\t    || (bpb->fat_sector_size < 512)\n\t    || (bpb->fat_sector_size > 4096)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus logical sector size %u\",\n\t\t\t       (unsigned)bpb->fat_sector_size);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sec_per_clus)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus sectors per cluster %u\",\n\t\t\t\t(unsigned)bpb->fat_sec_per_clus);\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"bogus sectors per cluster %u\"",
            "(unsigned)bpb->fat_sec_per_clus"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "bpb->fat_sec_per_clus"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "bpb->fat_sector_size"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_valid_media",
          "args": [
            "b->media"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le32",
          "args": [
            "b->fat32.vol_id"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "b->fat32.info_sector"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "b->fat32.root_cluster"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_le32",
          "args": [
            "b->fat16.vol_id"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->sectors"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->dir_entries"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->sector_size"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bpb",
            "0",
            "sizeof(*bpb)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_read_bpb(struct super_block *sb, struct fat_boot_sector *b,\n\tint silent, struct fat_bios_param_block *bpb)\n{\n\tint error = -EINVAL;\n\n\t/* Read in BPB ... */\n\tmemset(bpb, 0, sizeof(*bpb));\n\tbpb->fat_sector_size = get_unaligned_le16(&b->sector_size);\n\tbpb->fat_sec_per_clus = b->sec_per_clus;\n\tbpb->fat_reserved = le16_to_cpu(b->reserved);\n\tbpb->fat_fats = b->fats;\n\tbpb->fat_dir_entries = get_unaligned_le16(&b->dir_entries);\n\tbpb->fat_sectors = get_unaligned_le16(&b->sectors);\n\tbpb->fat_fat_length = le16_to_cpu(b->fat_length);\n\tbpb->fat_total_sect = le32_to_cpu(b->total_sect);\n\n\tbpb->fat16_state = b->fat16.state;\n\tbpb->fat16_vol_id = get_unaligned_le32(b->fat16.vol_id);\n\n\tbpb->fat32_length = le32_to_cpu(b->fat32.length);\n\tbpb->fat32_root_cluster = le32_to_cpu(b->fat32.root_cluster);\n\tbpb->fat32_info_sector = le16_to_cpu(b->fat32.info_sector);\n\tbpb->fat32_state = b->fat32.state;\n\tbpb->fat32_vol_id = get_unaligned_le32(b->fat32.vol_id);\n\n\t/* Validate this looks like a FAT filesystem BPB */\n\tif (!bpb->fat_reserved) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"bogus number of reserved sectors\");\n\t\tgoto out;\n\t}\n\tif (!bpb->fat_fats) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus number of FAT structure\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Earlier we checked here that b->secs_track and b->head are nonzero,\n\t * but it turns out valid FAT filesystems can have zero there.\n\t */\n\n\tif (!fat_valid_media(b->media)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"invalid media value (0x%02x)\",\n\t\t\t\t(unsigned)b->media);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sector_size)\n\t    || (bpb->fat_sector_size < 512)\n\t    || (bpb->fat_sector_size > 4096)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus logical sector size %u\",\n\t\t\t       (unsigned)bpb->fat_sector_size);\n\t\tgoto out;\n\t}\n\n\tif (!is_power_of_2(bpb->fat_sec_per_clus)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus sectors per cluster %u\",\n\t\t\t\t(unsigned)bpb->fat_sec_per_clus);\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "fat_bpb_is_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1330-1353",
    "snippet": "static bool fat_bpb_is_zero(struct fat_boot_sector *b)\n{\n\tif (get_unaligned_le16(&b->sector_size))\n\t\treturn false;\n\tif (b->sec_per_clus)\n\t\treturn false;\n\tif (b->reserved)\n\t\treturn false;\n\tif (b->fats)\n\t\treturn false;\n\tif (get_unaligned_le16(&b->dir_entries))\n\t\treturn false;\n\tif (get_unaligned_le16(&b->sectors))\n\t\treturn false;\n\tif (b->media)\n\t\treturn false;\n\tif (b->fat_length)\n\t\treturn false;\n\tif (b->secs_track)\n\t\treturn false;\n\tif (b->heads)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->sectors"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->dir_entries"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&b->sector_size"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool fat_bpb_is_zero(struct fat_boot_sector *b)\n{\n\tif (get_unaligned_le16(&b->sector_size))\n\t\treturn false;\n\tif (b->sec_per_clus)\n\t\treturn false;\n\tif (b->reserved)\n\t\treturn false;\n\tif (b->fats)\n\t\treturn false;\n\tif (get_unaligned_le16(&b->dir_entries))\n\t\treturn false;\n\tif (get_unaligned_le16(&b->sectors))\n\t\treturn false;\n\tif (b->media)\n\t\treturn false;\n\tif (b->fat_length)\n\t\treturn false;\n\tif (b->secs_track)\n\t\treturn false;\n\tif (b->heads)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "calc_fat_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1317-1328",
    "snippet": "static unsigned long calc_fat_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* Divide first to avoid overflow */\n\tif (sbi->fat_bits != 12) {\n\t\tunsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;\n\t\treturn ent_per_sec * sbi->fat_length;\n\t}\n\n\treturn sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned long calc_fat_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* Divide first to avoid overflow */\n\tif (sbi->fat_bits != 12) {\n\t\tunsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;\n\t\treturn ent_per_sec * sbi->fat_length;\n\t}\n\n\treturn sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;\n}"
  },
  {
    "function_name": "fat_read_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1281-1315",
    "snippet": "static int fat_read_root(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = 0;\n\tinode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);\n\tinode->i_op = sbi->dir_ops;\n\tinode->i_fop = &fat_dir_operations;\n\tif (sbi->fat_bits == 32) {\n\t\tMSDOS_I(inode)->i_start = sbi->root_cluster;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tinode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);\n\t}\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\tMSDOS_I(inode)->i_logstart = 0;\n\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\tfat_save_attrs(inode, ATTR_DIR);\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;\n\tinode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tset_nlink(inode, fat_subdirs(inode)+2);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "fat_subdirs(inode)+2"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_subdirs",
          "args": [
            "inode"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "fat_subdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "931-946",
          "snippet": "int fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_save_attrs",
          "args": [
            "inode",
            "ATTR_DIR"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "fat_save_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "200-206",
          "snippet": "static inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_calc_dir_size",
          "args": [
            "inode"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "fat_calc_dir_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "444-459",
          "snippet": "static int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_mode",
          "args": [
            "sbi",
            "ATTR_DIR",
            "S_IRWXUGO"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "177-187",
          "snippet": "static inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_read_root(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = 0;\n\tinode->i_mode = fat_make_mode(sbi, ATTR_DIR, S_IRWXUGO);\n\tinode->i_op = sbi->dir_ops;\n\tinode->i_fop = &fat_dir_operations;\n\tif (sbi->fat_bits == 32) {\n\t\tMSDOS_I(inode)->i_start = sbi->root_cluster;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tinode->i_size = sbi->dir_entries * sizeof(struct msdos_dir_entry);\n\t}\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\tMSDOS_I(inode)->i_logstart = 0;\n\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\tfat_save_attrs(inode, ATTR_DIR);\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;\n\tinode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tset_nlink(inode, fat_subdirs(inode)+2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "1031-1279",
    "snippet": "static int parse_options(struct super_block *sb, char *options, int is_vfat,\n\t\t\t int silent, int *debug, struct fat_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *iocharset;\n\n\topts->isvfat = is_vfat;\n\n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask = opts->fs_dmask = current_umask();\n\topts->allow_utime = -1;\n\topts->codepage = fat_default_codepage;\n\topts->iocharset = fat_default_iocharset;\n\tif (is_vfat) {\n\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT|VFAT_SFN_CREATE_WIN95;\n\t\topts->rodir = 0;\n\t} else {\n\t\topts->shortname = 0;\n\t\topts->rodir = 1;\n\t}\n\topts->name_check = 'n';\n\topts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;\n\topts->utf8 = opts->unicode_xlate = 0;\n\topts->numtail = 1;\n\topts->usefree = opts->nocase = 0;\n\topts->tz_set = 0;\n\topts->nfs = 0;\n\topts->errors = FAT_ERRORS_RO;\n\t*debug = 0;\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, fat_tokens, args);\n\t\tif (token == Opt_err) {\n\t\t\tif (is_vfat)\n\t\t\t\ttoken = match_token(p, vfat_tokens, args);\n\t\t\telse\n\t\t\t\ttoken = match_token(p, msdos_tokens, args);\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_check_s:\n\t\t\topts->name_check = 's';\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\topts->name_check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_n:\n\t\t\topts->name_check = 'n';\n\t\t\tbreak;\n\t\tcase Opt_usefree:\n\t\t\topts->usefree = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tif (!is_vfat)\n\t\t\t\topts->nocase = 1;\n\t\t\telse {\n\t\t\t\t/* for backward compatibility */\n\t\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quiet:\n\t\t\topts->quiet = 1;\n\t\t\tbreak;\n\t\tcase Opt_showexec:\n\t\t\topts->showexec = 1;\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\t*debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_immutable:\n\t\t\topts->sys_immutable = 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(opts->fs_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(opts->fs_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = opts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = option;\n\t\t\tbreak;\n\t\tcase Opt_allow_utime:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->allow_utime = option & (S_IWGRP | S_IWOTH);\n\t\t\tbreak;\n\t\tcase Opt_codepage:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->codepage = option;\n\t\t\tbreak;\n\t\tcase Opt_flush:\n\t\t\topts->flush = 1;\n\t\t\tbreak;\n\t\tcase Opt_time_offset:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option < -12 * 60 || option > 12 * 60)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = option;\n\t\t\tbreak;\n\t\tcase Opt_tz_utc:\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\topts->errors = FAT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\topts->errors = FAT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\topts->errors = FAT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_nfs_stale_rw:\n\t\t\topts->nfs = FAT_NFS_STALE_RW;\n\t\t\tbreak;\n\t\tcase Opt_nfs_nostale_ro:\n\t\t\topts->nfs = FAT_NFS_NOSTALE_RO;\n\t\t\tbreak;\n\t\tcase Opt_dos1xfloppy:\n\t\t\topts->dos1xfloppy = 1;\n\t\t\tbreak;\n\n\t\t/* msdos specific */\n\t\tcase Opt_dots:\n\t\t\topts->dotsOK = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodots:\n\t\t\topts->dotsOK = 0;\n\t\t\tbreak;\n\n\t\t/* vfat specific */\n\t\tcase Opt_charset:\n\t\t\tif (opts->iocharset != fat_default_iocharset)\n\t\t\t\tkfree(opts->iocharset);\n\t\t\tiocharset = match_strdup(&args[0]);\n\t\t\tif (!iocharset)\n\t\t\t\treturn -ENOMEM;\n\t\t\topts->iocharset = iocharset;\n\t\t\tbreak;\n\t\tcase Opt_shortname_lower:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_LOWER\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_win95:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_winnt:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WINNT;\n\t\t\tbreak;\n\t\tcase Opt_shortname_mixed:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_utf8_no:\t\t/* 0 or no or false */\n\t\t\topts->utf8 = 0;\n\t\t\tbreak;\n\t\tcase Opt_utf8_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->utf8 = 1;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_no:\t\t/* 0 or no or false */\n\t\t\topts->unicode_xlate = 0;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->unicode_xlate = 1;\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_no:\t\t/* 0 or no or false */\n\t\t\topts->numtail = 1;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->numtail = 0;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_rodir:\n\t\t\topts->rodir = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\topts->discard = 1;\n\t\t\tbreak;\n\n\t\t/* obsolete mount options */\n\t\tcase Opt_obsolete:\n\t\t\tfat_msg(sb, KERN_INFO, \"\\\"%s\\\" option is obsolete, \"\n\t\t\t       \"not supported now\", p);\n\t\t\tbreak;\n\t\t/* unknown option */\n\t\tdefault:\n\t\t\tif (!silent) {\n\t\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t       \"or missing value\", p);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\t/* UTF-8 doesn't provide FAT semantics */\n\tif (!strcmp(opts->iocharset, \"utf8\")) {\n\t\tfat_msg(sb, KERN_WARNING, \"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\");\n\t}\n\n\t/* If user doesn't specify allow_utime, it's initialized from dmask. */\n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);\n\tif (opts->unicode_xlate)\n\t\topts->utf8 = 0;\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tsb->s_export_op = &fat_export_ops_nostale;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;",
      "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;",
      "static const match_table_t fat_tokens = {\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_n, \"check=normal\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_check_n, \"check=n\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_allow_utime, \"allow_utime=%o\"},\n\t{Opt_codepage, \"codepage=%u\"},\n\t{Opt_usefree, \"usefree\"},\n\t{Opt_nocase, \"nocase\"},\n\t{Opt_quiet, \"quiet\"},\n\t{Opt_showexec, \"showexec\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_immutable, \"sys_immutable\"},\n\t{Opt_flush, \"flush\"},\n\t{Opt_tz_utc, \"tz=UTC\"},\n\t{Opt_time_offset, \"time_offset=%d\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nfs_stale_rw, \"nfs\"},\n\t{Opt_nfs_stale_rw, \"nfs=stale_rw\"},\n\t{Opt_nfs_nostale_ro, \"nfs=nostale_ro\"},\n\t{Opt_dos1xfloppy, \"dos1xfloppy\"},\n\t{Opt_obsolete, \"conv=binary\"},\n\t{Opt_obsolete, \"conv=text\"},\n\t{Opt_obsolete, \"conv=auto\"},\n\t{Opt_obsolete, \"conv=b\"},\n\t{Opt_obsolete, \"conv=t\"},\n\t{Opt_obsolete, \"conv=a\"},\n\t{Opt_obsolete, \"fat=%u\"},\n\t{Opt_obsolete, \"blocksize=%u\"},\n\t{Opt_obsolete, \"cvf_format=%20s\"},\n\t{Opt_obsolete, \"cvf_options=%100s\"},\n\t{Opt_obsolete, \"posix\"},\n\t{Opt_err, NULL},\n};",
      "static const match_table_t msdos_tokens = {\n\t{Opt_nodots, \"nodots\"},\n\t{Opt_nodots, \"dotsOK=no\"},\n\t{Opt_dots, \"dots\"},\n\t{Opt_dots, \"dotsOK=yes\"},\n\t{Opt_err, NULL}\n};",
      "static const match_table_t vfat_tokens = {\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_shortname_lower, \"shortname=lower\"},\n\t{Opt_shortname_win95, \"shortname=win95\"},\n\t{Opt_shortname_winnt, \"shortname=winnt\"},\n\t{Opt_shortname_mixed, \"shortname=mixed\"},\n\t{Opt_utf8_no, \"utf8=0\"},\t\t/* 0 or no or false */\n\t{Opt_utf8_no, \"utf8=no\"},\n\t{Opt_utf8_no, \"utf8=false\"},\n\t{Opt_utf8_yes, \"utf8=1\"},\t\t/* empty or 1 or yes or true */\n\t{Opt_utf8_yes, \"utf8=yes\"},\n\t{Opt_utf8_yes, \"utf8=true\"},\n\t{Opt_utf8_yes, \"utf8\"},\n\t{Opt_uni_xl_no, \"uni_xlate=0\"},\t\t/* 0 or no or false */\n\t{Opt_uni_xl_no, \"uni_xlate=no\"},\n\t{Opt_uni_xl_no, \"uni_xlate=false\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_uni_xl_yes, \"uni_xlate=yes\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=true\"},\n\t{Opt_uni_xl_yes, \"uni_xlate\"},\n\t{Opt_nonumtail_no, \"nonumtail=0\"},\t/* 0 or no or false */\n\t{Opt_nonumtail_no, \"nonumtail=no\"},\n\t{Opt_nonumtail_no, \"nonumtail=false\"},\n\t{Opt_nonumtail_yes, \"nonumtail=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_nonumtail_yes, \"nonumtail=yes\"},\n\t{Opt_nonumtail_yes, \"nonumtail=true\"},\n\t{Opt_nonumtail_yes, \"nonumtail\"},\n\t{Opt_rodir, \"rodir\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\""
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->iocharset",
            "\"utf8\""
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "opts->iocharset"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "opts->fs_gid"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "opts->fs_uid"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "msdos_tokens",
            "args"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "vfat_tokens",
            "args"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "fat_tokens",
            "args"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_default_codepage = CONFIG_FAT_DEFAULT_CODEPAGE;\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\nstatic const match_table_t fat_tokens = {\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_n, \"check=normal\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_check_n, \"check=n\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_allow_utime, \"allow_utime=%o\"},\n\t{Opt_codepage, \"codepage=%u\"},\n\t{Opt_usefree, \"usefree\"},\n\t{Opt_nocase, \"nocase\"},\n\t{Opt_quiet, \"quiet\"},\n\t{Opt_showexec, \"showexec\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_immutable, \"sys_immutable\"},\n\t{Opt_flush, \"flush\"},\n\t{Opt_tz_utc, \"tz=UTC\"},\n\t{Opt_time_offset, \"time_offset=%d\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nfs_stale_rw, \"nfs\"},\n\t{Opt_nfs_stale_rw, \"nfs=stale_rw\"},\n\t{Opt_nfs_nostale_ro, \"nfs=nostale_ro\"},\n\t{Opt_dos1xfloppy, \"dos1xfloppy\"},\n\t{Opt_obsolete, \"conv=binary\"},\n\t{Opt_obsolete, \"conv=text\"},\n\t{Opt_obsolete, \"conv=auto\"},\n\t{Opt_obsolete, \"conv=b\"},\n\t{Opt_obsolete, \"conv=t\"},\n\t{Opt_obsolete, \"conv=a\"},\n\t{Opt_obsolete, \"fat=%u\"},\n\t{Opt_obsolete, \"blocksize=%u\"},\n\t{Opt_obsolete, \"cvf_format=%20s\"},\n\t{Opt_obsolete, \"cvf_options=%100s\"},\n\t{Opt_obsolete, \"posix\"},\n\t{Opt_err, NULL},\n};\nstatic const match_table_t msdos_tokens = {\n\t{Opt_nodots, \"nodots\"},\n\t{Opt_nodots, \"dotsOK=no\"},\n\t{Opt_dots, \"dots\"},\n\t{Opt_dots, \"dotsOK=yes\"},\n\t{Opt_err, NULL}\n};\nstatic const match_table_t vfat_tokens = {\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_shortname_lower, \"shortname=lower\"},\n\t{Opt_shortname_win95, \"shortname=win95\"},\n\t{Opt_shortname_winnt, \"shortname=winnt\"},\n\t{Opt_shortname_mixed, \"shortname=mixed\"},\n\t{Opt_utf8_no, \"utf8=0\"},\t\t/* 0 or no or false */\n\t{Opt_utf8_no, \"utf8=no\"},\n\t{Opt_utf8_no, \"utf8=false\"},\n\t{Opt_utf8_yes, \"utf8=1\"},\t\t/* empty or 1 or yes or true */\n\t{Opt_utf8_yes, \"utf8=yes\"},\n\t{Opt_utf8_yes, \"utf8=true\"},\n\t{Opt_utf8_yes, \"utf8\"},\n\t{Opt_uni_xl_no, \"uni_xlate=0\"},\t\t/* 0 or no or false */\n\t{Opt_uni_xl_no, \"uni_xlate=no\"},\n\t{Opt_uni_xl_no, \"uni_xlate=false\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_uni_xl_yes, \"uni_xlate=yes\"},\n\t{Opt_uni_xl_yes, \"uni_xlate=true\"},\n\t{Opt_uni_xl_yes, \"uni_xlate\"},\n\t{Opt_nonumtail_no, \"nonumtail=0\"},\t/* 0 or no or false */\n\t{Opt_nonumtail_no, \"nonumtail=no\"},\n\t{Opt_nonumtail_no, \"nonumtail=false\"},\n\t{Opt_nonumtail_yes, \"nonumtail=1\"},\t/* empty or 1 or yes or true */\n\t{Opt_nonumtail_yes, \"nonumtail=yes\"},\n\t{Opt_nonumtail_yes, \"nonumtail=true\"},\n\t{Opt_nonumtail_yes, \"nonumtail\"},\n\t{Opt_rodir, \"rodir\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options, int is_vfat,\n\t\t\t int silent, int *debug, struct fat_mount_options *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tchar *iocharset;\n\n\topts->isvfat = is_vfat;\n\n\topts->fs_uid = current_uid();\n\topts->fs_gid = current_gid();\n\topts->fs_fmask = opts->fs_dmask = current_umask();\n\topts->allow_utime = -1;\n\topts->codepage = fat_default_codepage;\n\topts->iocharset = fat_default_iocharset;\n\tif (is_vfat) {\n\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT|VFAT_SFN_CREATE_WIN95;\n\t\topts->rodir = 0;\n\t} else {\n\t\topts->shortname = 0;\n\t\topts->rodir = 1;\n\t}\n\topts->name_check = 'n';\n\topts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;\n\topts->utf8 = opts->unicode_xlate = 0;\n\topts->numtail = 1;\n\topts->usefree = opts->nocase = 0;\n\topts->tz_set = 0;\n\topts->nfs = 0;\n\topts->errors = FAT_ERRORS_RO;\n\t*debug = 0;\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, fat_tokens, args);\n\t\tif (token == Opt_err) {\n\t\t\tif (is_vfat)\n\t\t\t\ttoken = match_token(p, vfat_tokens, args);\n\t\t\telse\n\t\t\t\ttoken = match_token(p, msdos_tokens, args);\n\t\t}\n\t\tswitch (token) {\n\t\tcase Opt_check_s:\n\t\t\topts->name_check = 's';\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\topts->name_check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_n:\n\t\t\topts->name_check = 'n';\n\t\t\tbreak;\n\t\tcase Opt_usefree:\n\t\t\topts->usefree = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tif (!is_vfat)\n\t\t\t\topts->nocase = 1;\n\t\t\telse {\n\t\t\t\t/* for backward compatibility */\n\t\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quiet:\n\t\t\topts->quiet = 1;\n\t\t\tbreak;\n\t\tcase Opt_showexec:\n\t\t\topts->showexec = 1;\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\t*debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_immutable:\n\t\t\topts->sys_immutable = 1;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(opts->fs_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(opts->fs_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = opts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->fs_fmask = option;\n\t\t\tbreak;\n\t\tcase Opt_allow_utime:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->allow_utime = option & (S_IWGRP | S_IWOTH);\n\t\t\tbreak;\n\t\tcase Opt_codepage:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->codepage = option;\n\t\t\tbreak;\n\t\tcase Opt_flush:\n\t\t\topts->flush = 1;\n\t\t\tbreak;\n\t\tcase Opt_time_offset:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option < -12 * 60 || option > 12 * 60)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = option;\n\t\t\tbreak;\n\t\tcase Opt_tz_utc:\n\t\t\topts->tz_set = 1;\n\t\t\topts->time_offset = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\topts->errors = FAT_ERRORS_CONT;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\topts->errors = FAT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\topts->errors = FAT_ERRORS_RO;\n\t\t\tbreak;\n\t\tcase Opt_nfs_stale_rw:\n\t\t\topts->nfs = FAT_NFS_STALE_RW;\n\t\t\tbreak;\n\t\tcase Opt_nfs_nostale_ro:\n\t\t\topts->nfs = FAT_NFS_NOSTALE_RO;\n\t\t\tbreak;\n\t\tcase Opt_dos1xfloppy:\n\t\t\topts->dos1xfloppy = 1;\n\t\t\tbreak;\n\n\t\t/* msdos specific */\n\t\tcase Opt_dots:\n\t\t\topts->dotsOK = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodots:\n\t\t\topts->dotsOK = 0;\n\t\t\tbreak;\n\n\t\t/* vfat specific */\n\t\tcase Opt_charset:\n\t\t\tif (opts->iocharset != fat_default_iocharset)\n\t\t\t\tkfree(opts->iocharset);\n\t\t\tiocharset = match_strdup(&args[0]);\n\t\t\tif (!iocharset)\n\t\t\t\treturn -ENOMEM;\n\t\t\topts->iocharset = iocharset;\n\t\t\tbreak;\n\t\tcase Opt_shortname_lower:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_LOWER\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_win95:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WIN95\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_shortname_winnt:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WINNT;\n\t\t\tbreak;\n\t\tcase Opt_shortname_mixed:\n\t\t\topts->shortname = VFAT_SFN_DISPLAY_WINNT\n\t\t\t\t\t| VFAT_SFN_CREATE_WIN95;\n\t\t\tbreak;\n\t\tcase Opt_utf8_no:\t\t/* 0 or no or false */\n\t\t\topts->utf8 = 0;\n\t\t\tbreak;\n\t\tcase Opt_utf8_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->utf8 = 1;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_no:\t\t/* 0 or no or false */\n\t\t\topts->unicode_xlate = 0;\n\t\t\tbreak;\n\t\tcase Opt_uni_xl_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->unicode_xlate = 1;\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_no:\t\t/* 0 or no or false */\n\t\t\topts->numtail = 1;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_nonumtail_yes:\t\t/* empty or 1 or yes or true */\n\t\t\topts->numtail = 0;\t/* negated option */\n\t\t\tbreak;\n\t\tcase Opt_rodir:\n\t\t\topts->rodir = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\topts->discard = 1;\n\t\t\tbreak;\n\n\t\t/* obsolete mount options */\n\t\tcase Opt_obsolete:\n\t\t\tfat_msg(sb, KERN_INFO, \"\\\"%s\\\" option is obsolete, \"\n\t\t\t       \"not supported now\", p);\n\t\t\tbreak;\n\t\t/* unknown option */\n\t\tdefault:\n\t\t\tif (!silent) {\n\t\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t       \"or missing value\", p);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\t/* UTF-8 doesn't provide FAT semantics */\n\tif (!strcmp(opts->iocharset, \"utf8\")) {\n\t\tfat_msg(sb, KERN_WARNING, \"utf8 is not a recommended IO charset\"\n\t\t       \" for FAT filesystems, filesystem will be \"\n\t\t       \"case sensitive!\");\n\t}\n\n\t/* If user doesn't specify allow_utime, it's initialized from dmask. */\n\tif (opts->allow_utime == (unsigned short)-1)\n\t\topts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);\n\tif (opts->unicode_xlate)\n\t\topts->utf8 = 0;\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tsb->s_export_op = &fat_export_ops_nostale;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "844-934",
    "snippet": "static int fat_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(root->d_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tint isvfat = opts->isvfat;\n\n\tif (!uid_eq(opts->fs_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, opts->fs_uid));\n\tif (!gid_eq(opts->fs_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, opts->fs_gid));\n\tseq_printf(m, \",fmask=%04o\", opts->fs_fmask);\n\tseq_printf(m, \",dmask=%04o\", opts->fs_dmask);\n\tif (opts->allow_utime)\n\t\tseq_printf(m, \",allow_utime=%04o\", opts->allow_utime);\n\tif (sbi->nls_disk)\n\t\t/* strip \"cp\" prefix from displayed option */\n\t\tseq_printf(m, \",codepage=%s\", &sbi->nls_disk->charset[2]);\n\tif (isvfat) {\n\t\tif (sbi->nls_io)\n\t\t\tseq_printf(m, \",iocharset=%s\", sbi->nls_io->charset);\n\n\t\tswitch (opts->shortname) {\n\t\tcase VFAT_SFN_DISPLAY_WIN95 | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=win95\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WINNT:\n\t\t\tseq_puts(m, \",shortname=winnt\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=mixed\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_LOWER | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=lower\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \",shortname=unknown\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts->name_check != 'n')\n\t\tseq_printf(m, \",check=%c\", opts->name_check);\n\tif (opts->usefree)\n\t\tseq_puts(m, \",usefree\");\n\tif (opts->quiet)\n\t\tseq_puts(m, \",quiet\");\n\tif (opts->showexec)\n\t\tseq_puts(m, \",showexec\");\n\tif (opts->sys_immutable)\n\t\tseq_puts(m, \",sys_immutable\");\n\tif (!isvfat) {\n\t\tif (opts->dotsOK)\n\t\t\tseq_puts(m, \",dotsOK=yes\");\n\t\tif (opts->nocase)\n\t\t\tseq_puts(m, \",nocase\");\n\t} else {\n\t\tif (opts->utf8)\n\t\t\tseq_puts(m, \",utf8\");\n\t\tif (opts->unicode_xlate)\n\t\t\tseq_puts(m, \",uni_xlate\");\n\t\tif (!opts->numtail)\n\t\t\tseq_puts(m, \",nonumtail\");\n\t\tif (opts->rodir)\n\t\t\tseq_puts(m, \",rodir\");\n\t}\n\tif (opts->flush)\n\t\tseq_puts(m, \",flush\");\n\tif (opts->tz_set) {\n\t\tif (opts->time_offset)\n\t\t\tseq_printf(m, \",time_offset=%d\", opts->time_offset);\n\t\telse\n\t\t\tseq_puts(m, \",tz=UTC\");\n\t}\n\tif (opts->errors == FAT_ERRORS_CONT)\n\t\tseq_puts(m, \",errors=continue\");\n\telse if (opts->errors == FAT_ERRORS_PANIC)\n\t\tseq_puts(m, \",errors=panic\");\n\telse\n\t\tseq_puts(m, \",errors=remount-ro\");\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO)\n\t\tseq_puts(m, \",nfs=nostale_ro\");\n\telse if (opts->nfs)\n\t\tseq_puts(m, \",nfs=stale_rw\");\n\tif (opts->discard)\n\t\tseq_puts(m, \",discard\");\n\tif (opts->dos1xfloppy)\n\t\tseq_puts(m, \",dos1xfloppy\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fat_show_options(struct seq_file *m, struct dentry *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",dos1xfloppy\""
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",time_offset=%d\"",
            "opts->time_offset"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "opts->fs_gid"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "opts->fs_gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "opts->fs_uid"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "opts->fs_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(root->d_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tint isvfat = opts->isvfat;\n\n\tif (!uid_eq(opts->fs_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, opts->fs_uid));\n\tif (!gid_eq(opts->fs_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, opts->fs_gid));\n\tseq_printf(m, \",fmask=%04o\", opts->fs_fmask);\n\tseq_printf(m, \",dmask=%04o\", opts->fs_dmask);\n\tif (opts->allow_utime)\n\t\tseq_printf(m, \",allow_utime=%04o\", opts->allow_utime);\n\tif (sbi->nls_disk)\n\t\t/* strip \"cp\" prefix from displayed option */\n\t\tseq_printf(m, \",codepage=%s\", &sbi->nls_disk->charset[2]);\n\tif (isvfat) {\n\t\tif (sbi->nls_io)\n\t\t\tseq_printf(m, \",iocharset=%s\", sbi->nls_io->charset);\n\n\t\tswitch (opts->shortname) {\n\t\tcase VFAT_SFN_DISPLAY_WIN95 | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=win95\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WINNT:\n\t\t\tseq_puts(m, \",shortname=winnt\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_WINNT | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=mixed\");\n\t\t\tbreak;\n\t\tcase VFAT_SFN_DISPLAY_LOWER | VFAT_SFN_CREATE_WIN95:\n\t\t\tseq_puts(m, \",shortname=lower\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \",shortname=unknown\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts->name_check != 'n')\n\t\tseq_printf(m, \",check=%c\", opts->name_check);\n\tif (opts->usefree)\n\t\tseq_puts(m, \",usefree\");\n\tif (opts->quiet)\n\t\tseq_puts(m, \",quiet\");\n\tif (opts->showexec)\n\t\tseq_puts(m, \",showexec\");\n\tif (opts->sys_immutable)\n\t\tseq_puts(m, \",sys_immutable\");\n\tif (!isvfat) {\n\t\tif (opts->dotsOK)\n\t\t\tseq_puts(m, \",dotsOK=yes\");\n\t\tif (opts->nocase)\n\t\t\tseq_puts(m, \",nocase\");\n\t} else {\n\t\tif (opts->utf8)\n\t\t\tseq_puts(m, \",utf8\");\n\t\tif (opts->unicode_xlate)\n\t\t\tseq_puts(m, \",uni_xlate\");\n\t\tif (!opts->numtail)\n\t\t\tseq_puts(m, \",nonumtail\");\n\t\tif (opts->rodir)\n\t\t\tseq_puts(m, \",rodir\");\n\t}\n\tif (opts->flush)\n\t\tseq_puts(m, \",flush\");\n\tif (opts->tz_set) {\n\t\tif (opts->time_offset)\n\t\t\tseq_printf(m, \",time_offset=%d\", opts->time_offset);\n\t\telse\n\t\t\tseq_puts(m, \",tz=UTC\");\n\t}\n\tif (opts->errors == FAT_ERRORS_CONT)\n\t\tseq_puts(m, \",errors=continue\");\n\telse if (opts->errors == FAT_ERRORS_PANIC)\n\t\tseq_puts(m, \",errors=panic\");\n\telse\n\t\tseq_puts(m, \",errors=remount-ro\");\n\tif (opts->nfs == FAT_NFS_NOSTALE_RO)\n\t\tseq_puts(m, \",nfs=nostale_ro\");\n\telse if (opts->nfs)\n\t\tseq_puts(m, \",nfs=stale_rw\");\n\tif (opts->discard)\n\t\tseq_puts(m, \",discard\");\n\tif (opts->dos1xfloppy)\n\t\tseq_puts(m, \",dos1xfloppy\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "824-827",
    "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_write_inode",
          "args": [
            "inode",
            "1"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "751-806",
          "snippet": "static int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
  },
  {
    "function_name": "fat_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "808-822",
    "snippet": "static int fat_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (inode->i_ino == MSDOS_FSINFO_INO) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\t\terr = fat_clusters_flush(sb);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t} else\n\t\terr = __fat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_write_inode",
          "args": [
            "inode",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "751-806",
          "snippet": "static int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_clusters_flush",
          "args": [
            "sb"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clusters_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "64-97",
          "snippet": "int fat_clusters_flush(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct fat_boot_fsinfo *fsinfo;\n\n\tif (sbi->fat_bits != 32)\n\t\treturn 0;\n\n\tbh = sb_bread(sb, sbi->fsinfo_sector);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"bread failed in fat_clusters_flush\");\n\t\treturn -EIO;\n\t}\n\n\tfsinfo = (struct fat_boot_fsinfo *)bh->b_data;\n\t/* Sanity check */\n\tif (!IS_FSINFO(fsinfo)) {\n\t\tfat_msg(sb, KERN_ERR, \"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t       sbi->fsinfo_sector);\n\t} else {\n\t\tif (sbi->free_clusters != -1)\n\t\t\tfsinfo->free_clusters = cpu_to_le32(sbi->free_clusters);\n\t\tif (sbi->prev_free != -1)\n\t\t\tfsinfo->next_cluster = cpu_to_le32(sbi->prev_free);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_clusters_flush(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct fat_boot_fsinfo *fsinfo;\n\n\tif (sbi->fat_bits != 32)\n\t\treturn 0;\n\n\tbh = sb_bread(sb, sbi->fsinfo_sector);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"bread failed in fat_clusters_flush\");\n\t\treturn -EIO;\n\t}\n\n\tfsinfo = (struct fat_boot_fsinfo *)bh->b_data;\n\t/* Sanity check */\n\tif (!IS_FSINFO(fsinfo)) {\n\t\tfat_msg(sb, KERN_ERR, \"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t       sbi->fsinfo_sector);\n\t} else {\n\t\tif (sbi->free_clusters != -1)\n\t\t\tfsinfo->free_clusters = cpu_to_le32(sbi->free_clusters);\n\t\tif (sbi->prev_free != -1)\n\t\t\tfsinfo->next_cluster = cpu_to_le32(sbi->prev_free);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (inode->i_ino == MSDOS_FSINFO_INO) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\t\terr = fat_clusters_flush(sb);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t} else\n\t\terr = __fat_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__fat_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "751-806",
    "snippet": "static int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->inode_hash_lock"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_time_unix2fat",
          "args": [
            "sbi",
            "&inode->i_atime",
            "&atime",
            "&raw_entry->adate",
            "NULL"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "fat_time_unix2fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "231-266",
          "snippet": "void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SECS_PER_MIN\t60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define SECS_PER_MIN\t60\n\nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "raw_entry",
            "MSDOS_I(inode)->i_logstart"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_attrs",
          "args": [
            "inode"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "190-198",
          "snippet": "static inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_size"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->inode_hash_lock"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\"",
            "i_pos"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_blknr_offset",
          "args": [
            "sbi",
            "i_pos",
            "&blocknr",
            "&offset"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_blknr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "225-230",
          "snippet": "static inline void fat_get_blknr_offset(struct msdos_sb_info *sbi,\n\t\t\t\tloff_t i_pos, sector_t *blknr, int *offset)\n{\n\t*blknr = i_pos >> sbi->dir_per_block_bits;\n\t*offset = i_pos & (sbi->dir_per_block - 1);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_get_blknr_offset(struct msdos_sb_info *sbi,\n\t\t\t\tloff_t i_pos, sector_t *blknr, int *offset)\n{\n\t*blknr = i_pos >> sbi->dir_per_block_bits;\n\t*offset = i_pos & (sbi->dir_per_block - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_i_pos_read",
          "args": [
            "sbi",
            "inode"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "fat_i_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "232-244",
          "snippet": "static inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int __fat_write_inode(struct inode *inode, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *raw_entry;\n\tloff_t i_pos;\n\tsector_t blocknr;\n\tint err, offset;\n\n\tif (inode->i_ino == MSDOS_ROOT_INO)\n\t\treturn 0;\n\nretry:\n\ti_pos = fat_i_pos_read(sbi, inode);\n\tif (!i_pos)\n\t\treturn 0;\n\n\tfat_get_blknr_offset(sbi, i_pos, &blocknr, &offset);\n\tbh = sb_bread(sb, blocknr);\n\tif (!bh) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read inode block \"\n\t\t       \"for updating (i_pos %lld)\", i_pos);\n\t\treturn -EIO;\n\t}\n\tspin_lock(&sbi->inode_hash_lock);\n\tif (i_pos != MSDOS_I(inode)->i_pos) {\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t\tbrelse(bh);\n\t\tgoto retry;\n\t}\n\n\traw_entry = &((struct msdos_dir_entry *) (bh->b_data))[offset];\n\tif (S_ISDIR(inode->i_mode))\n\t\traw_entry->size = 0;\n\telse\n\t\traw_entry->size = cpu_to_le32(inode->i_size);\n\traw_entry->attr = fat_make_attrs(inode);\n\tfat_set_start(raw_entry, MSDOS_I(inode)->i_logstart);\n\tfat_time_unix2fat(sbi, &inode->i_mtime, &raw_entry->time,\n\t\t\t  &raw_entry->date, NULL);\n\tif (sbi->options.isvfat) {\n\t\t__le16 atime;\n\t\tfat_time_unix2fat(sbi, &inode->i_ctime, &raw_entry->ctime,\n\t\t\t\t  &raw_entry->cdate, &raw_entry->ctime_cs);\n\t\tfat_time_unix2fat(sbi, &inode->i_atime, &atime,\n\t\t\t\t  &raw_entry->adate, NULL);\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\tif (wait)\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\treturn err;\n}"
  },
  {
    "function_name": "fat_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "725-749",
    "snippet": "static int fat_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\t/* If the count of free cluster is still unknown, counts it here. */\n\tif (sbi->free_clusters == -1 || !sbi->free_clus_valid) {\n\t\tint err = fat_count_free_clusters(dentry->d_sb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = sbi->cluster_size;\n\tbuf->f_blocks = sbi->max_cluster - FAT_START_ENT;\n\tbuf->f_bfree = sbi->free_clusters;\n\tbuf->f_bavail = sbi->free_clusters;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen =\n\t\t(sbi->options.isvfat ? FAT_LFN_LEN : 12) * NLS_MAX_CHARSET_SIZE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_count_free_clusters",
          "args": [
            "dentry->d_sb"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "fat_count_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "652-695",
          "snippet": "int fat_count_free_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tunsigned long reada_blocks, reada_mask, cur_block;\n\tint err = 0, free;\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid)\n\t\tgoto out;\n\n\treada_blocks = FAT_READA_SIZE >> sb->s_blocksize_bits;\n\treada_mask = reada_blocks - 1;\n\tcur_block = 0;\n\n\tfree = 0;\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, FAT_START_ENT);\n\twhile (fatent.entry < sbi->max_cluster) {\n\t\t/* readahead of fat blocks */\n\t\tif ((cur_block & reada_mask) == 0) {\n\t\t\tunsigned long rest = sbi->fat_length - cur_block;\n\t\t\tfat_ent_reada(sb, &fatent, min(reada_blocks, rest));\n\t\t}\n\t\tcur_block++;\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE)\n\t\t\t\tfree++;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\tsbi->free_clusters = free;\n\tsbi->free_clus_valid = 1;\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\nout:\n\tunlock_fat(sbi);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_READA_SIZE\t\t(128 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define FAT_READA_SIZE\t\t(128 * 1024)\n\nint fat_count_free_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tunsigned long reada_blocks, reada_mask, cur_block;\n\tint err = 0, free;\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid)\n\t\tgoto out;\n\n\treada_blocks = FAT_READA_SIZE >> sb->s_blocksize_bits;\n\treada_mask = reada_blocks - 1;\n\tcur_block = 0;\n\n\tfree = 0;\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, FAT_START_ENT);\n\twhile (fatent.entry < sbi->max_cluster) {\n\t\t/* readahead of fat blocks */\n\t\tif ((cur_block & reada_mask) == 0) {\n\t\t\tunsigned long rest = sbi->fat_length - cur_block;\n\t\t\tfat_ent_reada(sb, &fatent, min(reada_blocks, rest));\n\t\t}\n\t\tcur_block++;\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE)\n\t\t\t\tfree++;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\tsbi->free_clusters = free;\n\tsbi->free_clus_valid = 1;\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\nout:\n\tunlock_fat(sbi);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\t/* If the count of free cluster is still unknown, counts it here. */\n\tif (sbi->free_clusters == -1 || !sbi->free_clus_valid) {\n\t\tint err = fat_count_free_clusters(dentry->d_sb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = sbi->cluster_size;\n\tbuf->f_blocks = sbi->max_cluster - FAT_START_ENT;\n\tbuf->f_bfree = sbi->free_clusters;\n\tbuf->f_bavail = sbi->free_clusters;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen =\n\t\t(sbi->options.isvfat ? FAT_LFN_LEN : 12) * NLS_MAX_CHARSET_SIZE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "706-723",
    "snippet": "static int fat_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint new_rdonly;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\t*flags |= MS_NODIRATIME | (sbi->options.isvfat ? 0 : MS_NOATIME);\n\n\tsync_filesystem(sb);\n\n\t/* make sure we update state on remount. */\n\tnew_rdonly = *flags & MS_RDONLY;\n\tif (new_rdonly != (sb->s_flags & MS_RDONLY)) {\n\t\tif (new_rdonly)\n\t\t\tfat_set_state(sb, 0, 0);\n\t\telse\n\t\t\tfat_set_state(sb, 1, 1);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_set_state",
          "args": [
            "sb",
            "1",
            "1"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "578-623",
          "snippet": "static void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint new_rdonly;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\t*flags |= MS_NODIRATIME | (sbi->options.isvfat ? 0 : MS_NOATIME);\n\n\tsync_filesystem(sb);\n\n\t/* make sure we update state on remount. */\n\tnew_rdonly = *flags & MS_RDONLY;\n\tif (new_rdonly != (sb->s_flags & MS_RDONLY)) {\n\t\tif (new_rdonly)\n\t\t\tfat_set_state(sb, 0, 0);\n\t\telse\n\t\t\tfat_set_state(sb, 1, 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "696-704",
    "snippet": "static void __exit fat_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fat_inode_cachep);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fat_inode_cachep"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic void __exit fat_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(fat_inode_cachep);\n}"
  },
  {
    "function_name": "fat_init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "684-694",
    "snippet": "static int __init fat_init_inodecache(void)\n{\n\tfat_inode_cachep = kmem_cache_create(\"fat_inode_cache\",\n\t\t\t\t\t     sizeof(struct msdos_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (fat_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"fat_inode_cache\"",
            "sizeof(struct msdos_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic int __init fat_init_inodecache(void)\n{\n\tfat_inode_cachep = kmem_cache_create(\"fat_inode_cache\",\n\t\t\t\t\t     sizeof(struct msdos_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (fat_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "671-682",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct msdos_inode_info *ei = (struct msdos_inode_info *)foo;\n\n\tspin_lock_init(&ei->cache_lru_lock);\n\tei->nr_caches = 0;\n\tei->cache_valid_id = FAT_CACHE_VALID + 1;\n\tINIT_LIST_HEAD(&ei->cache_lru);\n\tINIT_HLIST_NODE(&ei->i_fat_hash);\n\tINIT_HLIST_NODE(&ei->i_dir_hash);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ei->i_dir_hash"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ei->i_fat_hash"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->cache_lru"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ei->cache_lru_lock"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct msdos_inode_info *ei = (struct msdos_inode_info *)foo;\n\n\tspin_lock_init(&ei->cache_lru_lock);\n\tei->nr_caches = 0;\n\tei->cache_valid_id = FAT_CACHE_VALID + 1;\n\tINIT_LIST_HEAD(&ei->cache_lru);\n\tINIT_HLIST_NODE(&ei->i_fat_hash);\n\tINIT_HLIST_NODE(&ei->i_dir_hash);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "fat_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "666-669",
    "snippet": "static void fat_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, fat_i_callback);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "fat_i_callback"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, fat_i_callback);\n}"
  },
  {
    "function_name": "fat_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "660-664",
    "snippet": "static void fat_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(fat_inode_cachep, MSDOS_I(inode));\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fat_inode_cachep",
            "MSDOS_I(inode)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic void fat_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(fat_inode_cachep, MSDOS_I(inode));\n}"
  },
  {
    "function_name": "fat_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "649-658",
    "snippet": "static struct inode *fat_alloc_inode(struct super_block *sb)\n{\n\tstruct msdos_inode_info *ei;\n\tei = kmem_cache_alloc(fat_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinit_rwsem(&ei->truncate_lock);\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->truncate_lock"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fat_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *fat_inode_cachep;\n\nstatic struct inode *fat_alloc_inode(struct super_block *sb)\n{\n\tstruct msdos_inode_info *ei;\n\tei = kmem_cache_alloc(fat_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinit_rwsem(&ei->truncate_lock);\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "fat_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "635-645",
    "snippet": "static void fat_put_super(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tfat_set_state(sb, 0, 0);\n\n\tiput(sbi->fsinfo_inode);\n\tiput(sbi->fat_inode);\n\n\tcall_rcu(&sbi->rcu, delayed_free);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&sbi->rcu",
            "delayed_free"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->fat_inode"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_state",
          "args": [
            "sb",
            "0",
            "0"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "578-623",
          "snippet": "static void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_put_super(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tfat_set_state(sb, 0, 0);\n\n\tiput(sbi->fsinfo_inode);\n\tiput(sbi->fat_inode);\n\n\tcall_rcu(&sbi->rcu, delayed_free);\n}"
  },
  {
    "function_name": "delayed_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "625-633",
    "snippet": "static void delayed_free(struct rcu_head *p)\n{\n\tstruct msdos_sb_info *sbi = container_of(p, struct msdos_sb_info, rcu);\n\tunload_nls(sbi->nls_disk);\n\tunload_nls(sbi->nls_io);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->options.iocharset"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->nls_io"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structmsdos_sb_info",
            "rcu"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct msdos_sb_info *sbi = container_of(p, struct msdos_sb_info, rcu);\n\tunload_nls(sbi->nls_disk);\n\tunload_nls(sbi->nls_io);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "fat_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "578-623",
    "snippet": "static void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_set_state(struct super_block *sb,\n\t\t\tunsigned int set, unsigned int force)\n{\n\tstruct buffer_head *bh;\n\tstruct fat_boot_sector *b;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\t/* do not change any thing if mounted read only */\n\tif ((sb->s_flags & MS_RDONLY) && !force)\n\t\treturn;\n\n\t/* do not change state if fs was dirty */\n\tif (sbi->dirty) {\n\t\t/* warn only on set (mount). */\n\t\tif (set)\n\t\t\tfat_msg(sb, KERN_WARNING, \"Volume was not properly \"\n\t\t\t\t\"unmounted. Some data may be corrupt. \"\n\t\t\t\t\"Please run fsck.\");\n\t\treturn;\n\t}\n\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector \"\n\t\t\t\"to mark fs as dirty\");\n\t\treturn;\n\t}\n\n\tb = (struct fat_boot_sector *) bh->b_data;\n\n\tif (sbi->fat_bits == 32) {\n\t\tif (set)\n\t\t\tb->fat32.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat32.state &= ~FAT_STATE_DIRTY;\n\t} else /* fat 16 and 12 */ {\n\t\tif (set)\n\t\t\tb->fat16.state |= FAT_STATE_DIRTY;\n\t\telse\n\t\t\tb->fat16.state &= ~FAT_STATE_DIRTY;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "fat_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "565-576",
    "snippet": "static void fat_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tfat_truncate_blocks(inode, 0);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tfat_cache_inval_inode(inode);\n\tfat_detach(inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_inval_inode",
          "args": [
            "inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "205-210",
          "snippet": "void fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_truncate_blocks",
          "args": [
            "inode",
            "0"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "fat_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "293-310",
          "snippet": "void fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nvoid fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tfat_truncate_blocks(inode, 0);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tfat_cache_inval_inode(inode);\n\tfat_detach(inode);\n}"
  },
  {
    "function_name": "fat_build_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "533-561",
    "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_unlock_build_inode",
          "args": [
            "MSDOS_SB(sb)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "fat_unlock_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "527-531",
          "snippet": "static inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_unlock(&sbi->nfs_build_inode_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_unlock(&sbi->nfs_build_inode_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_attach",
          "args": [
            "inode",
            "i_pos"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "fat_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "369-395",
          "snippet": "void fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fat_show_options(struct seq_file *m, struct dentry *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fill_inode",
          "args": [
            "inode",
            "de"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "fat_fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "462-519",
          "snippet": "int fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};\n\nint fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "MSDOS_ROOT_INO"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_iget",
          "args": [
            "sb",
            "i_pos"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "fat_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "414-432",
          "snippet": "struct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_lock_build_inode",
          "args": [
            "MSDOS_SB(sb)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "fat_lock_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "521-525",
          "snippet": "static inline void fat_lock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_lock(&sbi->nfs_build_inode_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void fat_lock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_lock(&sbi->nfs_build_inode_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
  },
  {
    "function_name": "fat_unlock_build_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "527-531",
    "snippet": "static inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_unlock(&sbi->nfs_build_inode_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->nfs_build_inode_lock"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void fat_unlock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_unlock(&sbi->nfs_build_inode_lock);\n}"
  },
  {
    "function_name": "fat_lock_build_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "521-525",
    "snippet": "static inline void fat_lock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_lock(&sbi->nfs_build_inode_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->nfs_build_inode_lock"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void fat_lock_build_inode(struct msdos_sb_info *sbi)\n{\n\tif (sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\tmutex_lock(&sbi->nfs_build_inode_lock);\n}"
  },
  {
    "function_name": "fat_fill_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "462-519",
    "snippet": "int fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_time_fat2unix",
          "args": [
            "sbi",
            "&inode->i_atime",
            "0",
            "de->adate",
            "0"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fat_time_fat2unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "193-228",
          "snippet": "void fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 __time, __le16 __date, u8 time_cs)\n{\n\tu16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);\n\ttime_t second, day, leap_day, month, year;\n\n\tyear  = date >> 9;\n\tmonth = max(1, (date >> 5) & 0xf);\n\tday   = max(1, date & 0x1f) - 1;\n\n\tleap_day = (year + 3) / 4;\n\tif (year > YEAR_2100)\t\t/* 2100 isn't leap year */\n\t\tleap_day--;\n\tif (IS_LEAP_YEAR(year) && month > 2)\n\t\tleap_day++;\n\n\tsecond =  (time & 0x1f) << 1;\n\tsecond += ((time >> 5) & 0x3f) * SECS_PER_MIN;\n\tsecond += (time >> 11) * SECS_PER_HOUR;\n\tsecond += (year * 365 + leap_day\n\t\t   + days_in_year[month] + day\n\t\t   + DAYS_DELTA) * SECS_PER_DAY;\n\n\tif (!sbi->options.tz_set)\n\t\tsecond += sys_tz.tz_minuteswest * SECS_PER_MIN;\n\telse\n\t\tsecond -= sbi->options.time_offset * SECS_PER_MIN;\n\n\tif (time_cs) {\n\t\tts->tv_sec = second + (time_cs / 100);\n\t\tts->tv_nsec = (time_cs % 100) * 10000000;\n\t} else {\n\t\tts->tv_sec = second;\n\t\tts->tv_nsec = 0;\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define YEAR_2100\t120",
            "#define DAYS_DELTA\t(365 * 10 + 2)",
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)",
            "#define SECS_PER_MIN\t60"
          ],
          "globals_used": [
            "static time_t days_in_year[] = {\n\t/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */\n\t0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define YEAR_2100\t120\n#define DAYS_DELTA\t(365 * 10 + 2)\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n#define SECS_PER_MIN\t60\n\nstatic time_t days_in_year[] = {\n\t/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */\n\t0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,\n};\n\nvoid fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 __time, __le16 __date, u8 time_cs)\n{\n\tu16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);\n\ttime_t second, day, leap_day, month, year;\n\n\tyear  = date >> 9;\n\tmonth = max(1, (date >> 5) & 0xf);\n\tday   = max(1, date & 0x1f) - 1;\n\n\tleap_day = (year + 3) / 4;\n\tif (year > YEAR_2100)\t\t/* 2100 isn't leap year */\n\t\tleap_day--;\n\tif (IS_LEAP_YEAR(year) && month > 2)\n\t\tleap_day++;\n\n\tsecond =  (time & 0x1f) << 1;\n\tsecond += ((time >> 5) & 0x3f) * SECS_PER_MIN;\n\tsecond += (time >> 11) * SECS_PER_HOUR;\n\tsecond += (year * 365 + leap_day\n\t\t   + days_in_year[month] + day\n\t\t   + DAYS_DELTA) * SECS_PER_DAY;\n\n\tif (!sbi->options.tz_set)\n\t\tsecond += sys_tz.tz_minuteswest * SECS_PER_MIN;\n\telse\n\t\tsecond -= sbi->options.time_offset * SECS_PER_MIN;\n\n\tif (time_cs) {\n\t\tts->tv_sec = second + (time_cs / 100);\n\t\tts->tv_nsec = (time_cs % 100) * 10000000;\n\t} else {\n\t\tts->tv_sec = second;\n\t\tts->tv_nsec = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_save_attrs",
          "args": [
            "inode",
            "de->attr"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "fat_save_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "200-206",
          "snippet": "static inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->size"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_start",
          "args": [
            "sbi",
            "de"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "258-265",
          "snippet": "static inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_mode",
          "args": [
            "sbi",
            "de->attr",
            "((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "177-187",
          "snippet": "static inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_exec",
          "args": [
            "de->name + 8"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "is_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "434-442",
          "snippet": "static int is_exec(unsigned char *extension)\n{\n\tunsigned char exe_extensions[] = \"EXECOMBAT\", *walk;\n\n\tfor (walk = exe_extensions; *walk; walk += 3)\n\t\tif (!strncmp(extension, walk, 3))\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int is_exec(unsigned char *extension)\n{\n\tunsigned char exe_extensions[] = \"EXECOMBAT\", *walk;\n\n\tfor (walk = exe_extensions; *walk; walk += 3)\n\t\tif (!strncmp(extension, walk, 3))\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "fat_subdirs(inode)"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_subdirs",
          "args": [
            "inode"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "fat_subdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "931-946",
          "snippet": "int fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_subdirs(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint count = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (de->attr & ATTR_DIR)\n\t\t\tcount++;\n\t}\n\tbrelse(bh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_calc_dir_size",
          "args": [
            "inode"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "fat_calc_dir_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "444-459",
          "snippet": "static int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de->name"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};\n\nint fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_calc_dir_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "444-459",
    "snippet": "static int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_get_cluster",
          "args": [
            "inode",
            "FAT_ENT_EOF",
            "&fclus",
            "&dclus"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "226-285",
          "snippet": "int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_calc_dir_size(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint ret, fclus, dclus;\n\n\tinode->i_size = 0;\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\tinode->i_size = (fclus + 1) << sbi->cluster_bits;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "434-442",
    "snippet": "static int is_exec(unsigned char *extension)\n{\n\tunsigned char exe_extensions[] = \"EXECOMBAT\", *walk;\n\n\tfor (walk = exe_extensions; *walk; walk += 3)\n\t\tif (!strncmp(extension, walk, 3))\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "extension",
            "walk",
            "3"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int is_exec(unsigned char *extension)\n{\n\tunsigned char exe_extensions[] = \"EXECOMBAT\", *walk;\n\n\tfor (walk = exe_extensions; *walk; walk += 3)\n\t\tif (!strncmp(extension, walk, 3))\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "414-432",
    "snippet": "struct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->inode_hash_lock"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&i->vfs_inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i->vfs_inode.i_sb != sb"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "i",
            "head",
            "i_fat_hash"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->inode_hash_lock"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_hash",
          "args": [
            "i_pos"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "fat_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "354-357",
          "snippet": "static inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}"
  },
  {
    "function_name": "fat_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "398-411",
    "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&MSDOS_I(inode)->i_dir_hash"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&MSDOS_I(inode)->i_fat_hash"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
  },
  {
    "function_name": "fat_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "369-395",
    "snippet": "void fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fat_show_options(struct seq_file *m, struct dentry *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&MSDOS_I(inode)->i_dir_hash",
            "d_head"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_hash",
          "args": [
            "MSDOS_I(inode)->i_logstart"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "386-389",
          "snippet": "static inline unsigned long fat_dir_hash(int logstart)\n{\n\treturn hash_32(logstart, FAT_HASH_BITS);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define FAT_HASH_BITS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\n#define FAT_HASH_BITS\t8\n\nstatic inline unsigned long fat_dir_hash(int logstart)\n{\n\treturn hash_32(logstart, FAT_HASH_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&MSDOS_I(inode)->i_fat_hash",
            "head"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_hash",
          "args": [
            "i_pos"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "fat_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "354-357",
          "snippet": "static inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
  },
  {
    "function_name": "dir_hash_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "359-367",
    "snippet": "static void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&sbi->dir_hashtable[i]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void dir_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->dir_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->dir_hashtable[i]);\n}"
  },
  {
    "function_name": "fat_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "354-357",
    "snippet": "static inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "i_pos",
            "FAT_HASH_BITS"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline unsigned long fat_hash(loff_t i_pos)\n{\n\treturn hash_32(i_pos, FAT_HASH_BITS);\n}"
  },
  {
    "function_name": "fat_hash_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "344-352",
    "snippet": "static void fat_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&sbi->inode_hashtable[i]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->inode_hash_lock"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_hash_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint i;\n\n\tspin_lock_init(&sbi->inode_hash_lock);\n\tfor (i = 0; i < FAT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&sbi->inode_hashtable[i]);\n}"
  },
  {
    "function_name": "fat_block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "304-307",
    "snippet": "int fat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, fat_get_block);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "from",
            "fat_get_block"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3323-3335",
          "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, fat_get_block);\n}"
  },
  {
    "function_name": "_fat_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "285-295",
    "snippet": "static sector_t _fat_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t blocknr;\n\n\t/* fat_get_cluster() assumes the requested blocknr isn't truncated. */\n\tdown_read(&MSDOS_I(mapping->host)->truncate_lock);\n\tblocknr = generic_block_bmap(mapping, block, fat_get_block);\n\tup_read(&MSDOS_I(mapping->host)->truncate_lock);\n\n\treturn blocknr;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&MSDOS_I(mapping->host)->truncate_lock"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "mapping->host"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "fat_get_block"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&MSDOS_I(mapping->host)->truncate_lock"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic sector_t _fat_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t blocknr;\n\n\t/* fat_get_cluster() assumes the requested blocknr isn't truncated. */\n\tdown_read(&MSDOS_I(mapping->host)->truncate_lock);\n\tblocknr = generic_block_bmap(mapping, block, fat_get_block);\n\tup_read(&MSDOS_I(mapping->host)->truncate_lock);\n\n\treturn blocknr;\n}"
  },
  {
    "function_name": "fat_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "249-283",
    "snippet": "static ssize_t fat_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t     struct iov_iter *iter,\n\t\t\t     loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (rw == WRITE) {\n\t\t/*\n\t\t * FIXME: blockdev_direct_IO() doesn't use ->write_begin(),\n\t\t * so we need to update the ->mmu_private to block boundary.\n\t\t *\n\t\t * But we must fill the remaining area or hole by nul for\n\t\t * updating ->mmu_private.\n\t\t *\n\t\t * Return 0, and fallback to normal buffered write.\n\t\t */\n\t\tloff_t size = offset + count;\n\t\tif (MSDOS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * FAT need to use the DIO_LOCKING for avoiding the race\n\t * condition of fat_get_block() and ->truncate().\n\t */\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, fat_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\tfat_write_failed(mapping, offset + count);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_write_failed",
          "args": [
            "mapping",
            "offset + count"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fat_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "207-215",
          "snippet": "static void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "fat_get_block"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic ssize_t fat_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t     struct iov_iter *iter,\n\t\t\t     loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (rw == WRITE) {\n\t\t/*\n\t\t * FIXME: blockdev_direct_IO() doesn't use ->write_begin(),\n\t\t * so we need to update the ->mmu_private to block boundary.\n\t\t *\n\t\t * But we must fill the remaining area or hole by nul for\n\t\t * updating ->mmu_private.\n\t\t *\n\t\t * Return 0, and fallback to normal buffered write.\n\t\t */\n\t\tloff_t size = offset + count;\n\t\tif (MSDOS_I(inode)->mmu_private < size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * FAT need to use the DIO_LOCKING for avoiding the race\n\t * condition of fat_get_block() and ->truncate().\n\t */\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, fat_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\tfat_write_failed(mapping, offset + count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fat_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "232-247",
    "snippet": "static int fat_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\tfat_write_failed(mapping, pos + len);\n\tif (!(err < 0) && !(MSDOS_I(inode)->i_attrs & ATTR_ARCH)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\t\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "fat_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "207-215",
          "snippet": "static void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "pagep",
            "fsdata"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\tfat_write_failed(mapping, pos + len);\n\tif (!(err < 0) && !(MSDOS_I(inode)->i_attrs & ATTR_ARCH)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\t\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fat_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "217-230",
    "snippet": "static int fat_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint err;\n\n\t*pagep = NULL;\n\terr = cont_write_begin(file, mapping, pos, len, flags,\n\t\t\t\tpagep, fsdata, fat_get_block,\n\t\t\t\t&MSDOS_I(mapping->host)->mmu_private);\n\tif (err < 0)\n\t\tfat_write_failed(mapping, pos + len);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "fat_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "207-215",
          "snippet": "static void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "fat_get_block",
            "&MSDOS_I(mapping->host)->mmu_private"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "mapping->host"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint err;\n\n\t*pagep = NULL;\n\terr = cont_write_begin(file, mapping, pos, len, flags,\n\t\t\t\tpagep, fsdata, fat_get_block,\n\t\t\t\t&MSDOS_I(mapping->host)->mmu_private);\n\tif (err < 0)\n\t\tfat_write_failed(mapping, pos + len);\n\treturn err;\n}"
  },
  {
    "function_name": "fat_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "207-215",
    "snippet": "static void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_truncate_blocks",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "fat_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "293-310",
          "snippet": "void fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nvoid fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void fat_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tfat_truncate_blocks(inode, inode->i_size);\n\t}\n}"
  },
  {
    "function_name": "fat_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "201-205",
    "snippet": "static int fat_readpages(struct file *file, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, fat_get_block);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "fat_get_block"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_readpages(struct file *file, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, fat_get_block);\n}"
  },
  {
    "function_name": "fat_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "196-199",
    "snippet": "static int fat_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, fat_get_block);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "fat_get_block"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, fat_get_block);\n}"
  },
  {
    "function_name": "fat_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "190-194",
    "snippet": "static int fat_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, fat_get_block);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "fat_get_block"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, fat_get_block);\n}"
  },
  {
    "function_name": "fat_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "185-188",
    "snippet": "static int fat_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, fat_get_block, wbc);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "fat_get_block",
            "wbc"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, fat_get_block, wbc);\n}"
  },
  {
    "function_name": "fat_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "171-183",
    "snippet": "static int fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint err;\n\n\terr = __fat_get_block(inode, iblock, &max_blocks, bh_result, create);\n\tif (err)\n\t\treturn err;\n\tbh_result->b_size = max_blocks << sb->s_blocksize_bits;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_get_block",
          "args": [
            "inode",
            "iblock",
            "&max_blocks",
            "bh_result",
            "create"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "119-169",
          "snippet": "static inline int __fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t  unsigned long *max_blocks,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tunsigned long mapped_blocks;\n\tsector_t phys;\n\tint err, offset;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\tif (phys) {\n\t\tmap_bh(bh_result, sb, phys);\n\t\t*max_blocks = min(mapped_blocks, *max_blocks);\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn 0;\n\n\tif (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {\n\t\tfat_fs_error(sb, \"corrupted file size (i_pos %lld, %lld)\",\n\t\t\tMSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);\n\t\treturn -EIO;\n\t}\n\n\toffset = (unsigned long)iblock & (sbi->sec_per_clus - 1);\n\tif (!offset) {\n\t\t/* TODO: multiple cluster allocation would be desirable. */\n\t\terr = fat_add_cluster(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* available blocks on this cluster */\n\tmapped_blocks = sbi->sec_per_clus - offset;\n\n\t*max_blocks = min(mapped_blocks, *max_blocks);\n\tMSDOS_I(inode)->mmu_private += *max_blocks << sb->s_blocksize_bits;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!phys);\n\tBUG_ON(*max_blocks != mapped_blocks);\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline int __fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t  unsigned long *max_blocks,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tunsigned long mapped_blocks;\n\tsector_t phys;\n\tint err, offset;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\tif (phys) {\n\t\tmap_bh(bh_result, sb, phys);\n\t\t*max_blocks = min(mapped_blocks, *max_blocks);\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn 0;\n\n\tif (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {\n\t\tfat_fs_error(sb, \"corrupted file size (i_pos %lld, %lld)\",\n\t\t\tMSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);\n\t\treturn -EIO;\n\t}\n\n\toffset = (unsigned long)iblock & (sbi->sec_per_clus - 1);\n\tif (!offset) {\n\t\t/* TODO: multiple cluster allocation would be desirable. */\n\t\terr = fat_add_cluster(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* available blocks on this cluster */\n\tmapped_blocks = sbi->sec_per_clus - offset;\n\n\t*max_blocks = min(mapped_blocks, *max_blocks);\n\tMSDOS_I(inode)->mmu_private += *max_blocks << sb->s_blocksize_bits;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!phys);\n\tBUG_ON(*max_blocks != mapped_blocks);\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint err;\n\n\terr = __fat_get_block(inode, iblock, &max_blocks, bh_result, create);\n\tif (err)\n\t\treturn err;\n\tbh_result->b_size = max_blocks << sb->s_blocksize_bits;\n\treturn 0;\n}"
  },
  {
    "function_name": "__fat_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "119-169",
    "snippet": "static inline int __fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t  unsigned long *max_blocks,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tunsigned long mapped_blocks;\n\tsector_t phys;\n\tint err, offset;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\tif (phys) {\n\t\tmap_bh(bh_result, sb, phys);\n\t\t*max_blocks = min(mapped_blocks, *max_blocks);\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn 0;\n\n\tif (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {\n\t\tfat_fs_error(sb, \"corrupted file size (i_pos %lld, %lld)\",\n\t\t\tMSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);\n\t\treturn -EIO;\n\t}\n\n\toffset = (unsigned long)iblock & (sbi->sec_per_clus - 1);\n\tif (!offset) {\n\t\t/* TODO: multiple cluster allocation would be desirable. */\n\t\terr = fat_add_cluster(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* available blocks on this cluster */\n\tmapped_blocks = sbi->sec_per_clus - offset;\n\n\t*max_blocks = min(mapped_blocks, *max_blocks);\n\tMSDOS_I(inode)->mmu_private += *max_blocks << sb->s_blocksize_bits;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!phys);\n\tBUG_ON(*max_blocks != mapped_blocks);\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*max_blocks != mapped_blocks"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!phys"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_bmap",
          "args": [
            "inode",
            "iblock",
            "&phys",
            "&mapped_blocks",
            "create"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "fat_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "306-353",
          "snippet": "int fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "mapped_blocks",
            "*max_blocks"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_add_cluster",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fat_add_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "104-117",
          "snippet": "static int fat_add_cluster(struct inode *inode)\n{\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(inode, &cluster, 1);\n\tif (err)\n\t\treturn err;\n\t/* FIXME: this cluster should be added after data of this\n\t * cluster is writed */\n\terr = fat_chain_add(inode, cluster, 1);\n\tif (err)\n\t\tfat_free_clusters(inode, cluster);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_add_cluster(struct inode *inode)\n{\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(inode, &cluster, 1);\n\tif (err)\n\t\treturn err;\n\t/* FIXME: this cluster should be added after data of this\n\t * cluster is writed */\n\terr = fat_chain_add(inode, cluster, 1);\n\tif (err)\n\t\tfat_free_clusters(inode, cluster);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"corrupted file size (i_pos %lld, %lld)\"",
            "MSDOS_I(inode)->i_pos",
            "MSDOS_I(inode)->mmu_private"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline int __fat_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t  unsigned long *max_blocks,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tunsigned long mapped_blocks;\n\tsector_t phys;\n\tint err, offset;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\tif (phys) {\n\t\tmap_bh(bh_result, sb, phys);\n\t\t*max_blocks = min(mapped_blocks, *max_blocks);\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn 0;\n\n\tif (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {\n\t\tfat_fs_error(sb, \"corrupted file size (i_pos %lld, %lld)\",\n\t\t\tMSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);\n\t\treturn -EIO;\n\t}\n\n\toffset = (unsigned long)iblock & (sbi->sec_per_clus - 1);\n\tif (!offset) {\n\t\t/* TODO: multiple cluster allocation would be desirable. */\n\t\terr = fat_add_cluster(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* available blocks on this cluster */\n\tmapped_blocks = sbi->sec_per_clus - offset;\n\n\t*max_blocks = min(mapped_blocks, *max_blocks);\n\tMSDOS_I(inode)->mmu_private += *max_blocks << sb->s_blocksize_bits;\n\n\terr = fat_bmap(inode, iblock, &phys, &mapped_blocks, create);\n\tif (err)\n\t\treturn err;\n\n\tBUG_ON(!phys);\n\tBUG_ON(*max_blocks != mapped_blocks);\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_add_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
    "lines": "104-117",
    "snippet": "static int fat_add_cluster(struct inode *inode)\n{\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(inode, &cluster, 1);\n\tif (err)\n\t\treturn err;\n\t/* FIXME: this cluster should be added after data of this\n\t * cluster is writed */\n\terr = fat_chain_add(inode, cluster, 1);\n\tif (err)\n\t\tfat_free_clusters(inode, cluster);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/aio.h>",
      "#include <linux/mount.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_chain_add",
          "args": [
            "inode",
            "cluster",
            "1"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "fat_chain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "103-165",
          "snippet": "int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_alloc_clusters",
          "args": [
            "inode",
            "&cluster",
            "1"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fat_alloc_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "465-551",
          "snippet": "int fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_add_cluster(struct inode *inode)\n{\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(inode, &cluster, 1);\n\tif (err)\n\t\treturn err;\n\t/* FIXME: this cluster should be added after data of this\n\t * cluster is writed */\n\terr = fat_chain_add(inode, cluster, 1);\n\tif (err)\n\t\tfat_free_clusters(inode, cluster);\n\treturn err;\n}"
  }
]