[
  {
    "function_name": "nlmsvc_encode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "333-337",
    "snippet": "int\nnlmsvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "327-331",
    "snippet": "int\nnlmsvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "318-325",
    "snippet": "int\nnlmsvc_decode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_decode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\tresp->status = *p++;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&resp->cookie"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_decode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\tresp->status = *p++;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "307-316",
    "snippet": "int\nnlmsvc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)\n{\n\tif (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))\n\t\treturn 0;\n\targp->state = ntohl(*p++);\n\tmemcpy(&argp->priv.data, p, sizeof(argp->priv.data));\n\tp += XDR_QUADLEN(SM_PRIV_SIZE);\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "SM_PRIV_SIZE"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&argp->priv.data",
            "p",
            "sizeof(argp->priv.data)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "&argp->mon",
            "&argp->len",
            "SM_MAXSTRLEN"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)\n{\n\tif (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))\n\t\treturn 0;\n\targp->state = ntohl(*p++);\n\tmemcpy(&argp->priv.data, p, sizeof(argp->priv.data));\n\tp += XDR_QUADLEN(SM_PRIV_SIZE);\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "295-305",
    "snippet": "int\nnlmsvc_decode_notify(struct svc_rqst *rqstp, __be32 *p, struct nlm_args *argp)\n{\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len, NLM_MAXSTRLEN)))\n\t\treturn 0;\n\targp->state = ntohl(*p++);\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "&lock->caller",
            "&lock->len",
            "NLM_MAXSTRLEN"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_notify(struct svc_rqst *rqstp, __be32 *p, struct nlm_args *argp)\n{\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len, NLM_MAXSTRLEN)))\n\t\treturn 0;\n\targp->state = ntohl(*p++);\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_encode_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "286-293",
    "snippet": "int\nnlmsvc_encode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\t*p++ = resp->status;\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_encode_cookie",
          "args": [
            "p",
            "&resp->cookie"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "73-80",
          "snippet": "static inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_encode_res(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\t*p++ = resp->status;\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_encode_shareres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "276-284",
    "snippet": "int\nnlmsvc_encode_shareres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\t*p++ = resp->status;\n\t*p++ = xdr_zero;\t\t/* sequence argument */\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_encode_cookie",
          "args": [
            "p",
            "&resp->cookie"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "73-80",
          "snippet": "static inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_encode_shareres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn 0;\n\t*p++ = resp->status;\n\t*p++ = xdr_zero;\t\t/* sequence argument */\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_shareargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "255-274",
    "snippet": "int\nnlmsvc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(&lock->fl);\n\tlock->svid = ~(u32) 0;\n\tlock->fl.fl_pid = (pid_t)lock->svid;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie))\n\t || !(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len, NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn 0;\n\targp->fsm_mode = ntohl(*p++);\n\targp->fsm_access = ntohl(*p++);\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_oh",
          "args": [
            "p",
            "&lock->oh"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_oh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "101-105",
          "snippet": "static inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_decode_fh",
          "args": [
            "p",
            "&lock->fh"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "82-96",
          "snippet": "static __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "&lock->caller",
            "&lock->len",
            "NLM_MAXSTRLEN"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&argp->cookie"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&lock->fl"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lock",
            "0",
            "sizeof(*lock)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(&lock->fl);\n\tlock->svid = ~(u32) 0;\n\tlock->fl.fl_pid = (pid_t)lock->svid;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie))\n\t || !(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len, NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn 0;\n\targp->fsm_mode = ntohl(*p++);\n\targp->fsm_access = ntohl(*p++);\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_unlockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "245-253",
    "snippet": "int\nnlmsvc_decode_unlockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie))\n\t || !(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\targp->lock.fl.fl_type = F_UNLCK;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_lock",
          "args": [
            "p",
            "&argp->lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "113-143",
          "snippet": "static __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&argp->cookie"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_unlockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie))\n\t || !(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\targp->lock.fl.fl_type = F_UNLCK;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_cancargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "229-243",
    "snippet": "int\nnlmsvc_decode_cancargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\targp->block = ntohl(*p++);\n\texclusive = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_lock",
          "args": [
            "p",
            "&argp->lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "113-143",
          "snippet": "static __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&argp->cookie"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_cancargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\targp->block = ntohl(*p++);\n\texclusive = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_lockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "209-227",
    "snippet": "int\nnlmsvc_decode_lockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\targp->block  = ntohl(*p++);\n\texclusive    = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\targp->reclaim = ntohl(*p++);\n\targp->state   = ntohl(*p++);\n\targp->monitor = 1;\t\t/* monitor client by default */\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_lock",
          "args": [
            "p",
            "&argp->lock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "113-143",
          "snippet": "static __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&argp->cookie"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_lockargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\targp->block  = ntohl(*p++);\n\texclusive    = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\targp->reclaim = ntohl(*p++);\n\targp->state   = ntohl(*p++);\n\targp->monitor = 1;\t\t/* monitor client by default */\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_encode_testres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "201-207",
    "snippet": "int\nnlmsvc_encode_testres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_testres(p, resp)))\n\t\treturn 0;\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_encode_testres",
          "args": [
            "p",
            "resp"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_encode_testres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "148-178",
          "snippet": "static __be32 *\nnlm_encode_testres(__be32 *p, struct nlm_res *resp)\n{\n\ts32\t\tstart, len;\n\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn NULL;\n\t*p++ = resp->status;\n\n\tif (resp->status == nlm_lck_denied) {\n\t\tstruct file_lock\t*fl = &resp->lock.fl;\n\n\t\t*p++ = (fl->fl_type == F_RDLCK)? xdr_zero : xdr_one;\n\t\t*p++ = htonl(resp->lock.svid);\n\n\t\t/* Encode owner handle. */\n\t\tif (!(p = xdr_encode_netobj(p, &resp->lock.oh)))\n\t\t\treturn NULL;\n\n\t\tstart = loff_t_to_s32(fl->fl_start);\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n\n\t\t*p++ = htonl(start);\n\t\t*p++ = htonl(len);\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_encode_testres(__be32 *p, struct nlm_res *resp)\n{\n\ts32\t\tstart, len;\n\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn NULL;\n\t*p++ = resp->status;\n\n\tif (resp->status == nlm_lck_denied) {\n\t\tstruct file_lock\t*fl = &resp->lock.fl;\n\n\t\t*p++ = (fl->fl_type == F_RDLCK)? xdr_zero : xdr_one;\n\t\t*p++ = htonl(resp->lock.svid);\n\n\t\t/* Encode owner handle. */\n\t\tif (!(p = xdr_encode_netobj(p, &resp->lock.oh)))\n\t\t\treturn NULL;\n\n\t\tstart = loff_t_to_s32(fl->fl_start);\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n\n\t\t*p++ = htonl(start);\n\t\t*p++ = htonl(len);\n\t}\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_encode_testres(struct svc_rqst *rqstp, __be32 *p, struct nlm_res *resp)\n{\n\tif (!(p = nlm_encode_testres(p, resp)))\n\t\treturn 0;\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlmsvc_decode_testargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "184-199",
    "snippet": "int\nnlmsvc_decode_testargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\n\texclusive = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_lock",
          "args": [
            "p",
            "&argp->lock"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "113-143",
          "snippet": "static __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_cookie",
          "args": [
            "p",
            "&argp->cookie"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "46-71",
          "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint\nnlmsvc_decode_testargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)\n{\n\tu32\texclusive;\n\n\tif (!(p = nlm_decode_cookie(p, &argp->cookie)))\n\t\treturn 0;\n\n\texclusive = ntohl(*p++);\n\tif (!(p = nlm_decode_lock(p, &argp->lock)))\n\t\treturn 0;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nlm_encode_testres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "148-178",
    "snippet": "static __be32 *\nnlm_encode_testres(__be32 *p, struct nlm_res *resp)\n{\n\ts32\t\tstart, len;\n\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn NULL;\n\t*p++ = resp->status;\n\n\tif (resp->status == nlm_lck_denied) {\n\t\tstruct file_lock\t*fl = &resp->lock.fl;\n\n\t\t*p++ = (fl->fl_type == F_RDLCK)? xdr_zero : xdr_one;\n\t\t*p++ = htonl(resp->lock.svid);\n\n\t\t/* Encode owner handle. */\n\t\tif (!(p = xdr_encode_netobj(p, &resp->lock.oh)))\n\t\t\treturn NULL;\n\n\t\tstart = loff_t_to_s32(fl->fl_start);\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n\n\t\t*p++ = htonl(start);\n\t\t*p++ = htonl(len);\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "len"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "start"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loff_t_to_s32",
          "args": [
            "fl->fl_end - fl->fl_start + 1"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "loff_t_to_s32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "30-41",
          "snippet": "static inline __s32\nloff_t_to_s32(loff_t offset)\n{\n\t__s32 res;\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __s32\nloff_t_to_s32(loff_t offset)\n{\n\t__s32 res;\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_netobj",
          "args": [
            "p",
            "&resp->lock.oh"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->lock.svid"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_encode_cookie",
          "args": [
            "p",
            "&resp->cookie"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "73-80",
          "snippet": "static inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_encode_testres(__be32 *p, struct nlm_res *resp)\n{\n\ts32\t\tstart, len;\n\n\tif (!(p = nlm_encode_cookie(p, &resp->cookie)))\n\t\treturn NULL;\n\t*p++ = resp->status;\n\n\tif (resp->status == nlm_lck_denied) {\n\t\tstruct file_lock\t*fl = &resp->lock.fl;\n\n\t\t*p++ = (fl->fl_type == F_RDLCK)? xdr_zero : xdr_one;\n\t\t*p++ = htonl(resp->lock.svid);\n\n\t\t/* Encode owner handle. */\n\t\tif (!(p = xdr_encode_netobj(p, &resp->lock.oh)))\n\t\t\treturn NULL;\n\n\t\tstart = loff_t_to_s32(fl->fl_start);\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n\n\t\t*p++ = htonl(start);\n\t\t*p++ = htonl(len);\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "nlm_decode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "113-143",
    "snippet": "static __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s32_to_loff_t",
          "args": [
            "end"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "s32_to_loff_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "24-28",
          "snippet": "static inline loff_t\ns32_to_loff_t(__s32 offset)\n{\n\treturn (loff_t)offset;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline loff_t\ns32_to_loff_t(__s32 offset)\n{\n\treturn (loff_t)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "fl"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_decode_oh",
          "args": [
            "p",
            "&lock->oh"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_oh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "101-105",
          "snippet": "static inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_decode_fh",
          "args": [
            "p",
            "&lock->fh"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
          "lines": "82-96",
          "snippet": "static __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "&lock->caller",
            "&lock->len",
            "NLM_MAXSTRLEN"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_lock(__be32 *p, struct nlm_lock *lock)\n{\n\tstruct file_lock\t*fl = &lock->fl;\n\ts32\t\t\tstart, len, end;\n\n\tif (!(p = xdr_decode_string_inplace(p, &lock->caller,\n\t\t\t\t\t    &lock->len,\n\t\t\t\t\t    NLM_MAXSTRLEN))\n\t || !(p = nlm_decode_fh(p, &lock->fh))\n\t || !(p = nlm_decode_oh(p, &lock->oh)))\n\t\treturn NULL;\n\tlock->svid  = ntohl(*p++);\n\n\tlocks_init_lock(fl);\n\tfl->fl_owner = current->files;\n\tfl->fl_pid   = (pid_t)lock->svid;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\t\t/* as good as anything else */\n\tstart = ntohl(*p++);\n\tlen = ntohl(*p++);\n\tend = start + len - 1;\n\n\tfl->fl_start = s32_to_loff_t(start);\n\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\treturn p;\n}"
  },
  {
    "function_name": "nlm_encode_oh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "107-111",
    "snippet": "static inline __be32 *\nnlm_encode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_encode_netobj(p, oh);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_netobj",
          "args": [
            "p",
            "oh"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_encode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_encode_netobj(p, oh);\n}"
  },
  {
    "function_name": "nlm_decode_oh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "101-105",
    "snippet": "static inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_netobj",
          "args": [
            "p",
            "oh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_decode_oh(__be32 *p, struct xdr_netobj *oh)\n{\n\treturn xdr_decode_netobj(p, oh);\n}"
  },
  {
    "function_name": "nlm_decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "82-96",
    "snippet": "static __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS2_FHSIZE"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "f->data",
            "p",
            "NFS2_FHSIZE"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "f->data",
            "0",
            "sizeof(f->data)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: bad fhandle size %d (should be %d)\\n\"",
            "len",
            "NFS2_FHSIZE"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *\nnlm_decode_fh(__be32 *p, struct nfs_fh *f)\n{\n\tunsigned int\tlen;\n\n\tif ((len = ntohl(*p++)) != NFS2_FHSIZE) {\n\t\tdprintk(\"lockd: bad fhandle size %d (should be %d)\\n\",\n\t\t\tlen, NFS2_FHSIZE);\n\t\treturn NULL;\n\t}\n\tf->size = NFS2_FHSIZE;\n\tmemset(f->data, 0, sizeof(f->data));\n\tmemcpy(f->data, p, NFS2_FHSIZE);\n\treturn p + XDR_QUADLEN(NFS2_FHSIZE);\n}"
  },
  {
    "function_name": "nlm_encode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "73-80",
    "snippet": "static inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "c->len"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "c->data",
            "c->len"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "c->len"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __be32 *\nnlm_encode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\t*p++ = htonl(c->len);\n\tmemcpy(p, c->data, c->len);\n\tp+=XDR_QUADLEN(c->len);\n\treturn p;\n}"
  },
  {
    "function_name": "nlm_decode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "46-71",
    "snippet": "static __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\"",
            "len",
            "NLM_MAXCOOKIELEN"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "len"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c->data",
            "p",
            "len"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "c->data",
            "0",
            "4"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic __be32 *nlm_decode_cookie(__be32 *p, struct nlm_cookie *c)\n{\n\tunsigned int\tlen;\n\n\tlen = ntohl(*p++);\n\t\n\tif(len==0)\n\t{\n\t\tc->len=4;\n\t\tmemset(c->data, 0, 4);\t/* hockeypux brain damage */\n\t}\n\telse if(len<=NLM_MAXCOOKIELEN)\n\t{\n\t\tc->len=len;\n\t\tmemcpy(c->data, p, len);\n\t\tp+=XDR_QUADLEN(len);\n\t}\n\telse \n\t{\n\t\tdprintk(\"lockd: bad cookie size %d (only cookies under \"\n\t\t\t\"%d bytes are supported.)\\n\",\n\t\t\t\tlen, NLM_MAXCOOKIELEN);\n\t\treturn NULL;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "loff_t_to_s32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "30-41",
    "snippet": "static inline __s32\nloff_t_to_s32(loff_t offset)\n{\n\t__s32 res;\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline __s32\nloff_t_to_s32(loff_t offset)\n{\n\t__s32 res;\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}"
  },
  {
    "function_name": "s32_to_loff_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/xdr.c",
    "lines": "24-28",
    "snippet": "static inline loff_t\ns32_to_loff_t(__s32 offset)\n{\n\treturn (loff_t)offset;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/nfs.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic inline loff_t\ns32_to_loff_t(__s32 offset)\n{\n\treturn (loff_t)offset;\n}"
  }
]