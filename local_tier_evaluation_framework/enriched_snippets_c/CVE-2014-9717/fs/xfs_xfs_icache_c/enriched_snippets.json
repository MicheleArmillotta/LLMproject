[
  {
    "function_name": "xfs_inode_clear_eofblocks_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1390-1417",
    "snippet": "void\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_perag_clear_eofblocks",
          "args": [
            "ip->i_mount",
            "pag->pag_agno",
            "-1",
            "_RET_IP_"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&ip->i_mount->m_perag_tree",
            "XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tagged",
          "args": [
            "&pag->pag_ici_root",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_clear_eofblocks_tag",
          "args": [
            "ip"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, ip->i_ino)"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
  },
  {
    "function_name": "xfs_inode_set_eofblocks_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1354-1388",
    "snippet": "void\nxfs_inode_set_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\tint tagged;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_set_eofblocks_tag(ip);\n\n\ttagged = radix_tree_tagged(&pag->pag_ici_root,\n\t\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\tif (!tagged) {\n\t\t/* propagate the eofblocks tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\t   XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* kick off background trimming */\n\t\txfs_queue_eofblocks(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t      -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_perag_set_eofblocks",
          "args": [
            "ip->i_mount",
            "pag->pag_agno",
            "-1",
            "_RET_IP_"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_queue_eofblocks",
          "args": [
            "ip->i_mount"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_queue_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "615-625",
          "snippet": "STATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&ip->i_mount->m_perag_tree",
            "XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tagged",
          "args": [
            "&pag->pag_ici_root",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_set_eofblocks_tag",
          "args": [
            "ip"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, ip->i_ino)"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_set_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\tint tagged;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_set_eofblocks_tag(ip);\n\n\ttagged = radix_tree_tagged(&pag->pag_ici_root,\n\t\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\tif (!tagged) {\n\t\t/* propagate the eofblocks tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\t   XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t   XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* kick off background trimming */\n\t\txfs_queue_eofblocks(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t      -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
  },
  {
    "function_name": "xfs_inode_free_quota_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1311-1352",
    "snippet": "int\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icache_free_eofblocks",
          "args": [
            "ip->i_mount",
            "&eofb"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icache_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1291-1303",
          "snippet": "int\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dquot_lowsp",
          "args": [
            "dq"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_lowsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "146-155",
          "snippet": "static inline bool xfs_dquot_lowsp(struct xfs_dquot *dqp)\n{\n\tint64_t freesp;\n\n\tfreesp = be64_to_cpu(dqp->q_core.d_blk_hardlimit) - dqp->q_res_bcount;\n\tif (freesp < dqp->q_low_space[XFS_QLOWSP_1_PCNT])\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_dquot_lowsp(struct xfs_dquot *dqp)\n{\n\tint64_t freesp;\n\n\tfreesp = be64_to_cpu(dqp->q_core.d_blk_hardlimit) - dqp->q_res_bcount;\n\tif (freesp < dqp->q_low_space[XFS_QLOWSP_1_PCNT])\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_dquot",
          "args": [
            "ip",
            "XFS_DQ_GROUP"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "128-140",
          "snippet": "static inline xfs_dquot_t *xfs_inode_dquot(struct xfs_inode *ip, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn ip->i_udquot;\n\tcase XFS_DQ_GROUP:\n\t\treturn ip->i_gdquot;\n\tcase XFS_DQ_PROJ:\n\t\treturn ip->i_pdquot;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dquot_t *xfs_inode_dquot(struct xfs_inode *ip, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn ip->i_udquot;\n\tcase XFS_DQ_GROUP:\n\t\treturn ip->i_gdquot;\n\tcase XFS_DQ_PROJ:\n\t\treturn ip->i_pdquot;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ENFORCED",
          "args": [
            "ip->i_mount"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ENFORCED",
          "args": [
            "ip->i_mount"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}"
  },
  {
    "function_name": "xfs_icache_free_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1291-1303",
    "snippet": "int\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_ag_iterator_tag",
          "args": [
            "mp",
            "xfs_inode_free_eofblocks",
            "flags",
            "eofb",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_ag_iterator_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "664-690",
          "snippet": "int\nxfs_inode_ag_iterator_tag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, tag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, tag);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_ag_iterator_tag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, tag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, tag);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}"
  },
  {
    "function_name": "xfs_inode_free_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1232-1289",
    "snippet": "STATIC int\nxfs_inode_free_eofblocks(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tint ret;\n\tstruct xfs_eofblocks *eofb = args;\n\tbool need_iolock = true;\n\tint match;\n\n\tASSERT(!eofb || (eofb && eofb->eof_scan_owner != 0));\n\n\tif (!xfs_can_free_eofblocks(ip, false)) {\n\t\t/* inode could be preallocated or append-only */\n\t\ttrace_xfs_inode_free_eofblocks_invalid(ip);\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the mapping is dirty the operation can block and wait for some\n\t * time. Unless we are waiting, skip it.\n\t */\n\tif (!(flags & SYNC_WAIT) &&\n\t    mapping_tagged(VFS_I(ip)->i_mapping, PAGECACHE_TAG_DIRTY))\n\t\treturn 0;\n\n\tif (eofb) {\n\t\tif (eofb->eof_flags & XFS_EOF_FLAGS_UNION)\n\t\t\tmatch = xfs_inode_match_id_union(ip, eofb);\n\t\telse\n\t\t\tmatch = xfs_inode_match_id(ip, eofb);\n\t\tif (!match)\n\t\t\treturn 0;\n\n\t\t/* skip the inode if the file size is too small */\n\t\tif (eofb->eof_flags & XFS_EOF_FLAGS_MINFILESIZE &&\n\t\t    XFS_ISIZE(ip) < eofb->eof_min_file_size)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * A scan owner implies we already hold the iolock. Skip it in\n\t\t * xfs_free_eofblocks() to avoid deadlock. This also eliminates\n\t\t * the possibility of EAGAIN being returned.\n\t\t */\n\t\tif (eofb->eof_scan_owner == ip->i_ino)\n\t\t\tneed_iolock = false;\n\t}\n\n\tret = xfs_free_eofblocks(ip->i_mount, ip, need_iolock);\n\n\t/* don't revisit the inode if we're not waiting */\n\tif (ret == -EAGAIN && !(flags & SYNC_WAIT))\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_free_eofblocks",
          "args": [
            "ip->i_mount",
            "ip",
            "need_iolock"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "833-926",
          "snippet": "int\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_match_id",
          "args": [
            "ip",
            "eofb"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_match_id_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1212-1230",
          "snippet": "STATIC int\nxfs_inode_match_id_union(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) == eofb->eof_prid)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_match_id_union(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) == eofb->eof_prid)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "VFS_I(ip)->i_mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_clear_eofblocks_tag",
          "args": [
            "ip"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clear_eofblocks_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1390-1417",
          "snippet": "void\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_inode_free_eofblocks_invalid",
          "args": [
            "ip"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_can_free_eofblocks",
          "args": [
            "ip",
            "false"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_can_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "797-826",
          "snippet": "bool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!eofb || (eofb && eofb->eof_scan_owner != 0)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_free_eofblocks(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tint ret;\n\tstruct xfs_eofblocks *eofb = args;\n\tbool need_iolock = true;\n\tint match;\n\n\tASSERT(!eofb || (eofb && eofb->eof_scan_owner != 0));\n\n\tif (!xfs_can_free_eofblocks(ip, false)) {\n\t\t/* inode could be preallocated or append-only */\n\t\ttrace_xfs_inode_free_eofblocks_invalid(ip);\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the mapping is dirty the operation can block and wait for some\n\t * time. Unless we are waiting, skip it.\n\t */\n\tif (!(flags & SYNC_WAIT) &&\n\t    mapping_tagged(VFS_I(ip)->i_mapping, PAGECACHE_TAG_DIRTY))\n\t\treturn 0;\n\n\tif (eofb) {\n\t\tif (eofb->eof_flags & XFS_EOF_FLAGS_UNION)\n\t\t\tmatch = xfs_inode_match_id_union(ip, eofb);\n\t\telse\n\t\t\tmatch = xfs_inode_match_id(ip, eofb);\n\t\tif (!match)\n\t\t\treturn 0;\n\n\t\t/* skip the inode if the file size is too small */\n\t\tif (eofb->eof_flags & XFS_EOF_FLAGS_MINFILESIZE &&\n\t\t    XFS_ISIZE(ip) < eofb->eof_min_file_size)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * A scan owner implies we already hold the iolock. Skip it in\n\t\t * xfs_free_eofblocks() to avoid deadlock. This also eliminates\n\t\t * the possibility of EAGAIN being returned.\n\t\t */\n\t\tif (eofb->eof_scan_owner == ip->i_ino)\n\t\t\tneed_iolock = false;\n\t}\n\n\tret = xfs_free_eofblocks(ip->i_mount, ip, need_iolock);\n\n\t/* don't revisit the inode if we're not waiting */\n\tif (ret == -EAGAIN && !(flags & SYNC_WAIT))\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_inode_match_id_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1212-1230",
    "snippet": "STATIC int\nxfs_inode_match_id_union(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) == eofb->eof_prid)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "VFS_I(ip)->i_gid",
            "eofb->eof_gid"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "VFS_I(ip)->i_uid",
            "eofb->eof_uid"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_match_id_union(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 1;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) == eofb->eof_prid)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inode_match_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1188-1206",
    "snippet": "STATIC int\nxfs_inode_match_id(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    !uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 0;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    !gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 0;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) != eofb->eof_prid)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "VFS_I(ip)->i_gid",
            "eofb->eof_gid"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "VFS_I(ip)->i_uid",
            "eofb->eof_uid"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_match_id(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_UID) &&\n\t    !uid_eq(VFS_I(ip)->i_uid, eofb->eof_uid))\n\t\treturn 0;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_GID) &&\n\t    !gid_eq(VFS_I(ip)->i_gid, eofb->eof_gid))\n\t\treturn 0;\n\n\tif ((eofb->eof_flags & XFS_EOF_FLAGS_PRID) &&\n\t    xfs_get_projid(ip) != eofb->eof_prid)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_reclaim_inodes_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1172-1186",
    "snippet": "int\nxfs_reclaim_inodes_count(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tag = 0;\n\tint\t\t\treclaimable = 0;\n\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tag = pag->pag_agno + 1;\n\t\treclaimable += pag->pag_ici_reclaimable;\n\t\txfs_perag_put(pag);\n\t}\n\treturn reclaimable;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get_tag",
          "args": [
            "mp",
            "ag",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "70-91",
          "snippet": "struct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reclaim_inodes_count(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_perag\t*pag;\n\txfs_agnumber_t\t\tag = 0;\n\tint\t\t\treclaimable = 0;\n\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tag = pag->pag_agno + 1;\n\t\treclaimable += pag->pag_ici_reclaimable;\n\t\txfs_perag_put(pag);\n\t}\n\treturn reclaimable;\n}"
  },
  {
    "function_name": "xfs_reclaim_inodes_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1156-1166",
    "snippet": "long\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes_ag",
          "args": [
            "mp",
            "SYNC_TRYLOCK | SYNC_WAIT",
            "&nr_to_scan"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1017-1135",
          "snippet": "STATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_push_all",
          "args": [
            "mp->m_ail"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push_all_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "594-613",
          "snippet": "void\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_work_queue",
          "args": [
            "mp"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "699-710",
          "snippet": "static void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nlong\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}"
  },
  {
    "function_name": "xfs_reclaim_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1137-1145",
    "snippet": "int\nxfs_reclaim_inodes(\n\txfs_mount_t\t*mp,\n\tint\t\tmode)\n{\n\tint\t\tnr_to_scan = INT_MAX;\n\n\treturn xfs_reclaim_inodes_ag(mp, mode, &nr_to_scan);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes_ag",
          "args": [
            "mp",
            "mode",
            "&nr_to_scan"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1017-1135",
          "snippet": "STATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reclaim_inodes(\n\txfs_mount_t\t*mp,\n\tint\t\tmode)\n{\n\tint\t\tnr_to_scan = INT_MAX;\n\n\treturn xfs_reclaim_inodes_ag(mp, mode, &nr_to_scan);\n}"
  },
  {
    "function_name": "xfs_reclaim_inodes_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "1017-1135",
    "snippet": "STATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_LOOKUP_BATCH\t32"
    ],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pag->pag_ici_reclaim_lock"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_inode",
          "args": [
            "batch[i]",
            "pag",
            "flags"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1017-1135",
          "snippet": "STATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino + 1"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_inode_grab",
          "args": [
            "ip",
            "flags"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inode_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "811-851",
          "snippet": "STATIC int\nxfs_reclaim_inode_grab(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tASSERT(rcu_read_lock_held());\n\n\t/* quick check for stale RCU freed inode */\n\tif (!ip->i_ino)\n\t\treturn 1;\n\n\t/*\n\t * If we are asked for non-blocking operation, do unlocked checks to\n\t * see if the inode already is being flushed or in reclaim to avoid\n\t * lock traffic.\n\t */\n\tif ((flags & SYNC_TRYLOCK) &&\n\t    __xfs_iflags_test(ip, XFS_IFLOCK | XFS_IRECLAIM))\n\t\treturn 1;\n\n\t/*\n\t * The radix tree lock here protects a thread in xfs_iget from racing\n\t * with us starting reclaim on the inode.  Once we have the\n\t * XFS_IRECLAIM flag set it will not touch us.\n\t *\n\t * Due to RCU lookup, we may find inodes that have been freed and only\n\t * have XFS_IRECLAIM set.  Indeed, we may see reallocated inodes that\n\t * aren't candidates for reclaim at all, so we must check the\n\t * XFS_IRECLAIMABLE is set first before proceeding to reclaim.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!__xfs_iflags_test(ip, XFS_IRECLAIMABLE) ||\n\t    __xfs_iflags_test(ip, XFS_IRECLAIM)) {\n\t\t/* not a reclaim candidate. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\treturn 1;\n\t}\n\t__xfs_iflags_set(ip, XFS_IRECLAIM);\n\tspin_unlock(&ip->i_flags_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inode_grab(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tASSERT(rcu_read_lock_held());\n\n\t/* quick check for stale RCU freed inode */\n\tif (!ip->i_ino)\n\t\treturn 1;\n\n\t/*\n\t * If we are asked for non-blocking operation, do unlocked checks to\n\t * see if the inode already is being flushed or in reclaim to avoid\n\t * lock traffic.\n\t */\n\tif ((flags & SYNC_TRYLOCK) &&\n\t    __xfs_iflags_test(ip, XFS_IFLOCK | XFS_IRECLAIM))\n\t\treturn 1;\n\n\t/*\n\t * The radix tree lock here protects a thread in xfs_iget from racing\n\t * with us starting reclaim on the inode.  Once we have the\n\t * XFS_IRECLAIM flag set it will not touch us.\n\t *\n\t * Due to RCU lookup, we may find inodes that have been freed and only\n\t * have XFS_IRECLAIM set.  Indeed, we may see reallocated inodes that\n\t * aren't candidates for reclaim at all, so we must check the\n\t * XFS_IRECLAIMABLE is set first before proceeding to reclaim.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!__xfs_iflags_test(ip, XFS_IRECLAIMABLE) ||\n\t    __xfs_iflags_test(ip, XFS_IRECLAIM)) {\n\t\t/* not a reclaim candidate. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\treturn 1;\n\t}\n\t__xfs_iflags_set(ip, XFS_IRECLAIM);\n\tspin_unlock(&ip->i_flags_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&pag->pag_ici_root",
            "(void **)batch",
            "first_index",
            "XFS_LOOKUP_BATCH",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pag->pag_ici_reclaim_lock"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&pag->pag_ici_reclaim_lock"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get_tag",
          "args": [
            "mp",
            "ag",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "70-91",
          "snippet": "struct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inodes_ag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags,\n\tint\t\t\t*nr_to_scan)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\ttrylock = flags & SYNC_TRYLOCK;\n\tint\t\t\tskipped;\n\nrestart:\n\tag = 0;\n\tskipped = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, XFS_ICI_RECLAIM_TAG))) {\n\t\tunsigned long\tfirst_index = 0;\n\t\tint\t\tdone = 0;\n\t\tint\t\tnr_found = 0;\n\n\t\tag = pag->pag_agno + 1;\n\n\t\tif (trylock) {\n\t\t\tif (!mutex_trylock(&pag->pag_ici_reclaim_lock)) {\n\t\t\t\tskipped++;\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirst_index = pag->pag_ici_reclaim_cursor;\n\t\t} else\n\t\t\tmutex_lock(&pag->pag_ici_reclaim_lock);\n\n\t\tdo {\n\t\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\t\tint\ti;\n\n\t\t\trcu_read_lock();\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH,\n\t\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\t\tif (!nr_found) {\n\t\t\t\tdone = 1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grab the inodes before we drop the lock. if we found\n\t\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t\t */\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\t\tif (done || xfs_reclaim_inode_grab(ip, flags))\n\t\t\t\t\tbatch[i] = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Update the index for the next lookup. Catch\n\t\t\t\t * overflows into the next AG range which can\n\t\t\t\t * occur if we have inodes in the last block of\n\t\t\t\t * the AG and we are currently pointing to the\n\t\t\t\t * last inode.\n\t\t\t\t *\n\t\t\t\t * Because we may see inodes that are from the\n\t\t\t\t * wrong AG due to RCU freeing and\n\t\t\t\t * reallocation, only update the index if it\n\t\t\t\t * lies in this AG. It was a race that lead us\n\t\t\t\t * to see this inode, so another lookup from\n\t\t\t\t * the same index will not find it again.\n\t\t\t\t */\n\t\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) !=\n\t\t\t\t\t\t\t\tpag->pag_agno)\n\t\t\t\t\tcontinue;\n\t\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\n\t\t\t/* unlock now we've grabbed the inodes. */\n\t\t\trcu_read_unlock();\n\n\t\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\t\tif (!batch[i])\n\t\t\t\t\tcontinue;\n\t\t\t\terror = xfs_reclaim_inode(batch[i], pag, flags);\n\t\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\t\tlast_error = error;\n\t\t\t}\n\n\t\t\t*nr_to_scan -= XFS_LOOKUP_BATCH;\n\n\t\t\tcond_resched();\n\n\t\t} while (nr_found && !done && *nr_to_scan > 0);\n\n\t\tif (trylock && !done)\n\t\t\tpag->pag_ici_reclaim_cursor = first_index;\n\t\telse\n\t\t\tpag->pag_ici_reclaim_cursor = 0;\n\t\tmutex_unlock(&pag->pag_ici_reclaim_lock);\n\t\txfs_perag_put(pag);\n\t}\n\n\t/*\n\t * if we skipped any AG, and we still have scan count remaining, do\n\t * another pass this time using blocking reclaim semantics (i.e\n\t * waiting on the reclaim locks and ignoring the reclaim cursors). This\n\t * ensure that when we get more reclaimers than AGs we block rather\n\t * than spin trying to execute reclaim.\n\t */\n\tif (skipped && (flags & SYNC_WAIT) && *nr_to_scan > 0) {\n\t\ttrylock = 0;\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
  },
  {
    "function_name": "xfs_reclaim_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "892-1009",
    "snippet": "STATIC int\nxfs_reclaim_inode(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\tsync_mode)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tint\t\t\terror;\n\nrestart:\n\terror = 0;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (!xfs_iflock_nowait(ip)) {\n\t\tif (!(sync_mode & SYNC_WAIT))\n\t\t\tgoto out;\n\t\txfs_iflock(ip);\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\txfs_iunpin_wait(ip);\n\t\txfs_iflush_abort(ip, false);\n\t\tgoto reclaim;\n\t}\n\tif (xfs_ipincount(ip)) {\n\t\tif (!(sync_mode & SYNC_WAIT))\n\t\t\tgoto out_ifunlock;\n\t\txfs_iunpin_wait(ip);\n\t}\n\tif (xfs_iflags_test(ip, XFS_ISTALE))\n\t\tgoto reclaim;\n\tif (xfs_inode_clean(ip))\n\t\tgoto reclaim;\n\n\t/*\n\t * Never flush out dirty data during non-blocking reclaim, as it would\n\t * just contend with AIL pushing trying to do the same job.\n\t */\n\tif (!(sync_mode & SYNC_WAIT))\n\t\tgoto out_ifunlock;\n\n\t/*\n\t * Now we have an inode that needs flushing.\n\t *\n\t * Note that xfs_iflush will never block on the inode buffer lock, as\n\t * xfs_ifree_cluster() can lock the inode buffer before it locks the\n\t * ip->i_lock, and we are doing the exact opposite here.  As a result,\n\t * doing a blocking xfs_imap_to_bp() to get the cluster buffer would\n\t * result in an ABBA deadlock with xfs_ifree_cluster().\n\t *\n\t * As xfs_ifree_cluser() must gather all inodes that are active in the\n\t * cache to mark them stale, if we hit this case we don't actually want\n\t * to do IO here - we want the inode marked stale so we can simply\n\t * reclaim it.  Hence if we get an EAGAIN error here,  just unlock the\n\t * inode, back off and try again.  Hopefully the next pass through will\n\t * see the stale flag set on the inode.\n\t */\n\terror = xfs_iflush(ip, &bp);\n\tif (error == -EAGAIN) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t/* backoff longer than in xfs_ifree_cluster */\n\t\tdelay(2);\n\t\tgoto restart;\n\t}\n\n\tif (!error) {\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t}\n\n\txfs_iflock(ip);\nreclaim:\n\txfs_ifunlock(ip);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\tXFS_STATS_INC(xs_ig_reclaims);\n\t/*\n\t * Remove the inode from the per-AG radix tree.\n\t *\n\t * Because radix_tree_delete won't complain even if the item was never\n\t * added to the tree assert that it's been there before to catch\n\t * problems with the inode life time early on.\n\t */\n\tspin_lock(&pag->pag_ici_lock);\n\tif (!radix_tree_delete(&pag->pag_ici_root,\n\t\t\t\tXFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)))\n\t\tASSERT(0);\n\t__xfs_inode_clear_reclaim(pag, ip);\n\tspin_unlock(&pag->pag_ici_lock);\n\n\t/*\n\t * Here we do an (almost) spurious inode lock in order to coordinate\n\t * with inode cache radix tree lookups.  This is because the lookup\n\t * can reference the inodes in the cache without taking references.\n\t *\n\t * We make that OK here by ensuring that we wait until the inode is\n\t * unlocked after the lookup before we go ahead and free it.\n\t */\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_qm_dqdetach(ip);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\txfs_inode_free(ip);\n\treturn error;\n\nout_ifunlock:\n\txfs_ifunlock(ip);\nout:\n\txfs_iflags_clear(ip, XFS_IRECLAIM);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t/*\n\t * We could return -EAGAIN here to make reclaim rescan the inode tree in\n\t * a short while. However, this just burns CPU time scanning the tree\n\t * waiting for IO to complete and the reclaim work never goes back to\n\t * the idle state. Instead, return 0 to let the next scheduled\n\t * background reclaim attempt to reclaim the inode again.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "ip",
            "XFS_IRECLAIM"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ifunlock",
          "args": [
            "ip"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ifunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "245-250",
          "snippet": "static inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)",
            "#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n#define __XFS_IFLOCK_BIT\t7\t /* inode is being flushed right now */\n\nstatic inline void xfs_ifunlock(struct xfs_inode *ip)\n{\n\txfs_iflags_clear(ip, XFS_IFLOCK);\n\tsmp_mb();\n\twake_up_bit(&ip->i_flags, __XFS_IFLOCK_BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_free",
          "args": [
            "ip"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_free_quota_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1311-1352",
          "snippet": "int\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqdetach",
          "args": [
            "ip"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "401-423",
          "snippet": "void\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_inode_clear_reclaim",
          "args": [
            "pag",
            "ip"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_inode_clear_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "778-794",
          "snippet": "STATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_reclaims"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflock",
          "args": [
            "ip"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "239-243",
          "snippet": "static inline void xfs_iflock(struct xfs_inode *ip)\n{\n\tif (!xfs_iflock_nowait(ip))\n\t\t__xfs_iflock(ip);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void xfs_iflock(struct xfs_inode *ip)\n{\n\tif (!xfs_iflock_nowait(ip))\n\t\t__xfs_iflock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflush",
          "args": [
            "ip",
            "&bp"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflush_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "698-734",
          "snippet": "void\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_iflush_abort(\n\txfs_inode_t\t\t*ip,\n\tbool\t\t\tstale)\n{\n\txfs_inode_log_item_t\t*iip = ip->i_itemp;\n\n\tif (iip) {\n\t\tstruct xfs_ail\t*ailp = iip->ili_item.li_ailp;\n\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (iip->ili_item.li_flags & XFS_LI_IN_AIL) {\n\t\t\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\t\t\txfs_trans_ail_delete(ailp, &iip->ili_item,\n\t\t\t\t\t\tstale ?\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR :\n\t\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\t\t} else\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t}\n\t\tiip->ili_logged = 0;\n\t\t/*\n\t\t * Clear the ili_last_fields bits now that we know that the\n\t\t * data corresponding to them is safely on disk.\n\t\t */\n\t\tiip->ili_last_fields = 0;\n\t\t/*\n\t\t * Clear the inode logging fields so no more flushes are\n\t\t * attempted.\n\t\t */\n\t\tiip->ili_fields = 0;\n\t}\n\t/*\n\t * Release the inode's flush lock since we're done with it.\n\t */\n\txfs_ifunlock(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_clean",
          "args": [
            "ip"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.h",
          "lines": "39-42",
          "snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_inode_clean(xfs_inode_t *ip)\n{\n\treturn !ip->i_itemp || !(ip->i_itemp->ili_fields & XFS_ILOG_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_ISTALE"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunpin_wait",
          "args": [
            "ip"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunpin_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2439-2445",
          "snippet": "void\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iunpin_wait(\n\tstruct xfs_inode\t*ip)\n{\n\tif (xfs_ipincount(ip))\n\t\t__xfs_iunpin_wait(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflock_nowait",
          "args": [
            "ip"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "234-237",
          "snippet": "static inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_iflock_nowait(struct xfs_inode *ip)\n{\n\treturn !xfs_iflags_test_and_set(ip, XFS_IFLOCK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inode(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\tsync_mode)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tint\t\t\terror;\n\nrestart:\n\terror = 0;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (!xfs_iflock_nowait(ip)) {\n\t\tif (!(sync_mode & SYNC_WAIT))\n\t\t\tgoto out;\n\t\txfs_iflock(ip);\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\txfs_iunpin_wait(ip);\n\t\txfs_iflush_abort(ip, false);\n\t\tgoto reclaim;\n\t}\n\tif (xfs_ipincount(ip)) {\n\t\tif (!(sync_mode & SYNC_WAIT))\n\t\t\tgoto out_ifunlock;\n\t\txfs_iunpin_wait(ip);\n\t}\n\tif (xfs_iflags_test(ip, XFS_ISTALE))\n\t\tgoto reclaim;\n\tif (xfs_inode_clean(ip))\n\t\tgoto reclaim;\n\n\t/*\n\t * Never flush out dirty data during non-blocking reclaim, as it would\n\t * just contend with AIL pushing trying to do the same job.\n\t */\n\tif (!(sync_mode & SYNC_WAIT))\n\t\tgoto out_ifunlock;\n\n\t/*\n\t * Now we have an inode that needs flushing.\n\t *\n\t * Note that xfs_iflush will never block on the inode buffer lock, as\n\t * xfs_ifree_cluster() can lock the inode buffer before it locks the\n\t * ip->i_lock, and we are doing the exact opposite here.  As a result,\n\t * doing a blocking xfs_imap_to_bp() to get the cluster buffer would\n\t * result in an ABBA deadlock with xfs_ifree_cluster().\n\t *\n\t * As xfs_ifree_cluser() must gather all inodes that are active in the\n\t * cache to mark them stale, if we hit this case we don't actually want\n\t * to do IO here - we want the inode marked stale so we can simply\n\t * reclaim it.  Hence if we get an EAGAIN error here,  just unlock the\n\t * inode, back off and try again.  Hopefully the next pass through will\n\t * see the stale flag set on the inode.\n\t */\n\terror = xfs_iflush(ip, &bp);\n\tif (error == -EAGAIN) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t/* backoff longer than in xfs_ifree_cluster */\n\t\tdelay(2);\n\t\tgoto restart;\n\t}\n\n\tif (!error) {\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t}\n\n\txfs_iflock(ip);\nreclaim:\n\txfs_ifunlock(ip);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\tXFS_STATS_INC(xs_ig_reclaims);\n\t/*\n\t * Remove the inode from the per-AG radix tree.\n\t *\n\t * Because radix_tree_delete won't complain even if the item was never\n\t * added to the tree assert that it's been there before to catch\n\t * problems with the inode life time early on.\n\t */\n\tspin_lock(&pag->pag_ici_lock);\n\tif (!radix_tree_delete(&pag->pag_ici_root,\n\t\t\t\tXFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)))\n\t\tASSERT(0);\n\t__xfs_inode_clear_reclaim(pag, ip);\n\tspin_unlock(&pag->pag_ici_lock);\n\n\t/*\n\t * Here we do an (almost) spurious inode lock in order to coordinate\n\t * with inode cache radix tree lookups.  This is because the lookup\n\t * can reference the inodes in the cache without taking references.\n\t *\n\t * We make that OK here by ensuring that we wait until the inode is\n\t * unlocked after the lookup before we go ahead and free it.\n\t */\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_qm_dqdetach(ip);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\txfs_inode_free(ip);\n\treturn error;\n\nout_ifunlock:\n\txfs_ifunlock(ip);\nout:\n\txfs_iflags_clear(ip, XFS_IRECLAIM);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t/*\n\t * We could return -EAGAIN here to make reclaim rescan the inode tree in\n\t * a short while. However, this just burns CPU time scanning the tree\n\t * waiting for IO to complete and the reclaim work never goes back to\n\t * the idle state. Instead, return 0 to let the next scheduled\n\t * background reclaim attempt to reclaim the inode again.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_reclaim_inode_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "811-851",
    "snippet": "STATIC int\nxfs_reclaim_inode_grab(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tASSERT(rcu_read_lock_held());\n\n\t/* quick check for stale RCU freed inode */\n\tif (!ip->i_ino)\n\t\treturn 1;\n\n\t/*\n\t * If we are asked for non-blocking operation, do unlocked checks to\n\t * see if the inode already is being flushed or in reclaim to avoid\n\t * lock traffic.\n\t */\n\tif ((flags & SYNC_TRYLOCK) &&\n\t    __xfs_iflags_test(ip, XFS_IFLOCK | XFS_IRECLAIM))\n\t\treturn 1;\n\n\t/*\n\t * The radix tree lock here protects a thread in xfs_iget from racing\n\t * with us starting reclaim on the inode.  Once we have the\n\t * XFS_IRECLAIM flag set it will not touch us.\n\t *\n\t * Due to RCU lookup, we may find inodes that have been freed and only\n\t * have XFS_IRECLAIM set.  Indeed, we may see reallocated inodes that\n\t * aren't candidates for reclaim at all, so we must check the\n\t * XFS_IRECLAIMABLE is set first before proceeding to reclaim.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!__xfs_iflags_test(ip, XFS_IRECLAIMABLE) ||\n\t    __xfs_iflags_test(ip, XFS_IRECLAIM)) {\n\t\t/* not a reclaim candidate. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\treturn 1;\n\t}\n\t__xfs_iflags_set(ip, XFS_IRECLAIM);\n\tspin_unlock(&ip->i_flags_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_iflags_set",
          "args": [
            "ip",
            "XFS_IRECLAIM"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "112-116",
          "snippet": "static inline void\n__xfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tip->i_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\n__xfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tip->i_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_iflags_test",
          "args": [
            "ip",
            "XFS_IRECLAIM"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflags_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "134-138",
          "snippet": "static inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rcu_read_lock_held()"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_reclaim_inode_grab(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tASSERT(rcu_read_lock_held());\n\n\t/* quick check for stale RCU freed inode */\n\tif (!ip->i_ino)\n\t\treturn 1;\n\n\t/*\n\t * If we are asked for non-blocking operation, do unlocked checks to\n\t * see if the inode already is being flushed or in reclaim to avoid\n\t * lock traffic.\n\t */\n\tif ((flags & SYNC_TRYLOCK) &&\n\t    __xfs_iflags_test(ip, XFS_IFLOCK | XFS_IRECLAIM))\n\t\treturn 1;\n\n\t/*\n\t * The radix tree lock here protects a thread in xfs_iget from racing\n\t * with us starting reclaim on the inode.  Once we have the\n\t * XFS_IRECLAIM flag set it will not touch us.\n\t *\n\t * Due to RCU lookup, we may find inodes that have been freed and only\n\t * have XFS_IRECLAIM set.  Indeed, we may see reallocated inodes that\n\t * aren't candidates for reclaim at all, so we must check the\n\t * XFS_IRECLAIMABLE is set first before proceeding to reclaim.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!__xfs_iflags_test(ip, XFS_IRECLAIMABLE) ||\n\t    __xfs_iflags_test(ip, XFS_IRECLAIM)) {\n\t\t/* not a reclaim candidate. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\treturn 1;\n\t}\n\t__xfs_iflags_set(ip, XFS_IRECLAIM);\n\tspin_unlock(&ip->i_flags_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__xfs_inode_clear_reclaim_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "796-805",
    "snippet": "STATIC void\n__xfs_inode_clear_reclaim_tag(\n\txfs_mount_t\t*mp,\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\tXFS_INO_TO_AGINO(mp, ip->i_ino), XFS_ICI_RECLAIM_TAG);\n\t__xfs_inode_clear_reclaim(pag, ip);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_inode_clear_reclaim",
          "args": [
            "pag",
            "ip"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_inode_clear_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "778-794",
          "snippet": "STATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(mp, ip->i_ino)",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\n__xfs_inode_clear_reclaim_tag(\n\txfs_mount_t\t*mp,\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\tXFS_INO_TO_AGINO(mp, ip->i_ino), XFS_ICI_RECLAIM_TAG);\n\t__xfs_inode_clear_reclaim(pag, ip);\n}"
  },
  {
    "function_name": "__xfs_inode_clear_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "778-794",
    "snippet": "STATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_perag_clear_reclaim",
          "args": [
            "ip->i_mount",
            "pag->pag_agno",
            "-1",
            "_RET_IP_"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&ip->i_mount->m_perag_tree",
            "XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\n__xfs_inode_clear_reclaim(\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tpag->pag_ici_reclaimable--;\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* clear the reclaim tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n}"
  },
  {
    "function_name": "xfs_inode_set_reclaim_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "761-776",
    "snippet": "void\nxfs_inode_set_reclaim_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_inode_set_reclaim_tag(pag, ip);\n\t__xfs_iflags_set(ip, XFS_IRECLAIMABLE);\n\tspin_unlock(&ip->i_flags_lock);\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_iflags_set",
          "args": [
            "ip",
            "XFS_IRECLAIMABLE"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "112-116",
          "snippet": "static inline void\n__xfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tip->i_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\n__xfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tip->i_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_inode_set_reclaim_tag",
          "args": [
            "pag",
            "ip"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_inode_set_reclaim_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "730-754",
          "snippet": "static void\n__xfs_inode_set_reclaim_tag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip)\n{\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* propagate the reclaim tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* schedule periodic background inode reclaim */\n\t\txfs_reclaim_work_queue(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n\tpag->pag_ici_reclaimable++;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic void\n__xfs_inode_set_reclaim_tag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip)\n{\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* propagate the reclaim tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* schedule periodic background inode reclaim */\n\t\txfs_reclaim_work_queue(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n\tpag->pag_ici_reclaimable++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, ip->i_ino)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_set_reclaim_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_inode_set_reclaim_tag(pag, ip);\n\t__xfs_iflags_set(ip, XFS_IRECLAIMABLE);\n\tspin_unlock(&ip->i_flags_lock);\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
  },
  {
    "function_name": "__xfs_inode_set_reclaim_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "730-754",
    "snippet": "static void\n__xfs_inode_set_reclaim_tag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip)\n{\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* propagate the reclaim tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* schedule periodic background inode reclaim */\n\t\txfs_reclaim_work_queue(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n\tpag->pag_ici_reclaimable++;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_perag_set_reclaim",
          "args": [
            "ip->i_mount",
            "pag->pag_agno",
            "-1",
            "_RET_IP_"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_work_queue",
          "args": [
            "ip->i_mount"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "699-710",
          "snippet": "static void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&ip->i_mount->m_perag_tree",
            "XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_mount->m_perag_lock"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&pag->pag_ici_root",
            "XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino)",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "ip->i_mount",
            "ip->i_ino"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic void\n__xfs_inode_set_reclaim_tag(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip)\n{\n\tradix_tree_tag_set(&pag->pag_ici_root,\n\t\t\t   XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\n\tif (!pag->pag_ici_reclaimable) {\n\t\t/* propagate the reclaim tag up into the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_set(&ip->i_mount->m_perag_tree,\n\t\t\t\tXFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\tXFS_ICI_RECLAIM_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\n\t\t/* schedule periodic background inode reclaim */\n\t\txfs_reclaim_work_queue(ip->i_mount);\n\n\t\ttrace_xfs_perag_set_reclaim(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t\t\t-1, _RET_IP_);\n\t}\n\tpag->pag_ici_reclaimable++;\n}"
  },
  {
    "function_name": "xfs_reclaim_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "719-728",
    "snippet": "void\nxfs_reclaim_worker(\n\tstruct work_struct *work)\n{\n\tstruct xfs_mount *mp = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct xfs_mount, m_reclaim_work);\n\n\txfs_reclaim_inodes(mp, SYNC_TRYLOCK);\n\txfs_reclaim_work_queue(mp);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_reclaim_work_queue",
          "args": [
            "mp"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "699-710",
          "snippet": "static void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_reclaim_inodes",
          "args": [
            "mp",
            "SYNC_TRYLOCK"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reclaim_inodes_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1156-1166",
          "snippet": "long\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nlong\nxfs_reclaim_inodes_nr(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tnr_to_scan)\n{\n\t/* kick background reclaimer and push the AIL */\n\txfs_reclaim_work_queue(mp);\n\txfs_ail_push_all(mp->m_ail);\n\n\treturn xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_delayed_work(work)",
            "structxfs_mount",
            "m_reclaim_work"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_reclaim_worker(\n\tstruct work_struct *work)\n{\n\tstruct xfs_mount *mp = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct xfs_mount, m_reclaim_work);\n\n\txfs_reclaim_inodes(mp, SYNC_TRYLOCK);\n\txfs_reclaim_work_queue(mp);\n}"
  },
  {
    "function_name": "xfs_reclaim_work_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "699-710",
    "snippet": "static void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "mp->m_reclaim_workqueue",
            "&mp->m_reclaim_work",
            "msecs_to_jiffies(xfs_syncd_centisecs / 6 * 10)"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "xfs_syncd_centisecs / 6 * 10"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tagged",
          "args": [
            "&mp->m_perag_tree",
            "XFS_ICI_RECLAIM_TAG"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_reclaim_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {\n\t\tqueue_delayed_work(mp->m_reclaim_workqueue, &mp->m_reclaim_work,\n\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "xfs_inode_ag_iterator_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "664-690",
    "snippet": "int\nxfs_inode_ag_iterator_tag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, tag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, tag);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_ag_walk",
          "args": [
            "mp",
            "pag",
            "execute",
            "flags",
            "args",
            "tag"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_ag_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "508-609",
          "snippet": "STATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get_tag",
          "args": [
            "mp",
            "ag",
            "tag"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "70-91",
          "snippet": "struct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_ag_iterator_tag(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get_tag(mp, ag, tag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, tag);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}"
  },
  {
    "function_name": "xfs_inode_ag_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "637-662",
    "snippet": "int\nxfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_ag_walk",
          "args": [
            "mp",
            "pag",
            "execute",
            "flags",
            "args",
            "-1"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_ag_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "508-609",
          "snippet": "STATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "ag"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}"
  },
  {
    "function_name": "xfs_eofblocks_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "627-635",
    "snippet": "void\nxfs_eofblocks_worker(\n\tstruct work_struct *work)\n{\n\tstruct xfs_mount *mp = container_of(to_delayed_work(work),\n\t\t\t\tstruct xfs_mount, m_eofblocks_work);\n\txfs_icache_free_eofblocks(mp, NULL);\n\txfs_queue_eofblocks(mp);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_queue_eofblocks",
          "args": [
            "mp"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_queue_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "615-625",
          "snippet": "STATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icache_free_eofblocks",
          "args": [
            "mp",
            "NULL"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icache_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1291-1303",
          "snippet": "int\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_delayed_work(work)",
            "structxfs_mount",
            "m_eofblocks_work"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_eofblocks_worker(\n\tstruct work_struct *work)\n{\n\tstruct xfs_mount *mp = container_of(to_delayed_work(work),\n\t\t\t\tstruct xfs_mount, m_eofblocks_work);\n\txfs_icache_free_eofblocks(mp, NULL);\n\txfs_queue_eofblocks(mp);\n}"
  },
  {
    "function_name": "xfs_queue_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "615-625",
    "snippet": "STATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "mp->m_eofblocks_workqueue",
            "&mp->m_eofblocks_work",
            "msecs_to_jiffies(xfs_eofb_secs * 1000)"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "xfs_eofb_secs * 1000"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tagged",
          "args": [
            "&mp->m_perag_tree",
            "XFS_ICI_EOFBLOCKS_TAG"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "xfs_inode_ag_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "508-609",
    "snippet": "STATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_LOOKUP_BATCH\t32"
    ],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "batch[i]"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "batch[i]",
            "flags",
            "args"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ip->i_ino + 1"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_ag_walk_grab",
          "args": [
            "ip"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_ag_walk_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "466-506",
          "snippet": "STATIC int\nxfs_inode_ag_walk_grab(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(rcu_read_lock_held());\n\n\t/*\n\t * check for stale RCU freed inode\n\t *\n\t * If the inode has been reallocated, it doesn't matter if it's not in\n\t * the AG we are walking - we are walking for writeback, so if it\n\t * passes all the \"valid inode\" checks and is dirty, then we'll write\n\t * it back anyway.  If it has been reallocated and still being\n\t * initialised, the XFS_INEW check below will catch it.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!ip->i_ino)\n\t\tgoto out_unlock_noent;\n\n\t/* avoid new or reclaimable inodes. Leave for reclaim code to flush */\n\tif (__xfs_iflags_test(ip, XFS_INEW | XFS_IRECLAIMABLE | XFS_IRECLAIM))\n\t\tgoto out_unlock_noent;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* nothing to sync during shutdown */\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EFSCORRUPTED;\n\n\t/* If we can't grab the inode, it must on it's way to reclaim. */\n\tif (!igrab(inode))\n\t\treturn -ENOENT;\n\n\t/* inode is valid */\n\treturn 0;\n\nout_unlock_noent:\n\tspin_unlock(&ip->i_flags_lock);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_ag_walk_grab(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(rcu_read_lock_held());\n\n\t/*\n\t * check for stale RCU freed inode\n\t *\n\t * If the inode has been reallocated, it doesn't matter if it's not in\n\t * the AG we are walking - we are walking for writeback, so if it\n\t * passes all the \"valid inode\" checks and is dirty, then we'll write\n\t * it back anyway.  If it has been reallocated and still being\n\t * initialised, the XFS_INEW check below will catch it.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!ip->i_ino)\n\t\tgoto out_unlock_noent;\n\n\t/* avoid new or reclaimable inodes. Leave for reclaim code to flush */\n\tif (__xfs_iflags_test(ip, XFS_INEW | XFS_IRECLAIMABLE | XFS_IRECLAIM))\n\t\tgoto out_unlock_noent;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* nothing to sync during shutdown */\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EFSCORRUPTED;\n\n\t/* If we can't grab the inode, it must on it's way to reclaim. */\n\tif (!igrab(inode))\n\t\treturn -ENOENT;\n\n\t/* inode is valid */\n\treturn 0;\n\nout_unlock_noent:\n\tspin_unlock(&ip->i_flags_lock);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&pag->pag_ici_root",
            "(void **) batch",
            "first_index",
            "XFS_LOOKUP_BATCH",
            "tag"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&pag->pag_ici_root",
            "(void **)batch",
            "first_index",
            "XFS_LOOKUP_BATCH"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_LOOKUP_BATCH\t32\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}"
  },
  {
    "function_name": "xfs_inode_ag_walk_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "466-506",
    "snippet": "STATIC int\nxfs_inode_ag_walk_grab(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(rcu_read_lock_held());\n\n\t/*\n\t * check for stale RCU freed inode\n\t *\n\t * If the inode has been reallocated, it doesn't matter if it's not in\n\t * the AG we are walking - we are walking for writeback, so if it\n\t * passes all the \"valid inode\" checks and is dirty, then we'll write\n\t * it back anyway.  If it has been reallocated and still being\n\t * initialised, the XFS_INEW check below will catch it.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!ip->i_ino)\n\t\tgoto out_unlock_noent;\n\n\t/* avoid new or reclaimable inodes. Leave for reclaim code to flush */\n\tif (__xfs_iflags_test(ip, XFS_INEW | XFS_IRECLAIMABLE | XFS_IRECLAIM))\n\t\tgoto out_unlock_noent;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* nothing to sync during shutdown */\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EFSCORRUPTED;\n\n\t/* If we can't grab the inode, it must on it's way to reclaim. */\n\tif (!igrab(inode))\n\t\treturn -ENOENT;\n\n\t/* inode is valid */\n\treturn 0;\n\nout_unlock_noent:\n\tspin_unlock(&ip->i_flags_lock);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xfs_iflags_test",
          "args": [
            "ip",
            "XFS_INEW | XFS_IRECLAIMABLE | XFS_IRECLAIM"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_iflags_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "134-138",
          "snippet": "static inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\n__xfs_iflags_test(xfs_inode_t *ip, unsigned short flags)\n{\n\treturn (ip->i_flags & flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rcu_read_lock_held()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC int\nxfs_inode_ag_walk_grab(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(rcu_read_lock_held());\n\n\t/*\n\t * check for stale RCU freed inode\n\t *\n\t * If the inode has been reallocated, it doesn't matter if it's not in\n\t * the AG we are walking - we are walking for writeback, so if it\n\t * passes all the \"valid inode\" checks and is dirty, then we'll write\n\t * it back anyway.  If it has been reallocated and still being\n\t * initialised, the XFS_INEW check below will catch it.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (!ip->i_ino)\n\t\tgoto out_unlock_noent;\n\n\t/* avoid new or reclaimable inodes. Leave for reclaim code to flush */\n\tif (__xfs_iflags_test(ip, XFS_INEW | XFS_IRECLAIMABLE | XFS_IRECLAIM))\n\t\tgoto out_unlock_noent;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* nothing to sync during shutdown */\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EFSCORRUPTED;\n\n\t/* If we can't grab the inode, it must on it's way to reclaim. */\n\tif (!igrab(inode))\n\t\treturn -ENOENT;\n\n\t/* inode is valid */\n\treturn 0;\n\nout_unlock_noent:\n\tspin_unlock(&ip->i_flags_lock);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "xfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "388-456",
    "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setup_inode",
          "args": [
            "ip"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "1242-1332",
          "snippet": "void\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key xfs_nondir_ilock_class;",
            "static struct lock_class_key xfs_dir_ilock_class;",
            "STATIC struct",
            "STATIC struct",
            "static const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};",
            "static const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
            "static const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
            "static const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\nSTATIC struct;\nSTATIC struct;\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_test",
          "args": [
            "ip",
            "XFS_INEW"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_test_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "163-174",
          "snippet": "static inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline int\nxfs_iflags_test_and_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tint ret;\n\n\tspin_lock(&ip->i_flags_lock);\n\tret = ip->i_flags & flags;\n\tif (!ret)\n\t\tip->i_flags |= flags;\n\tspin_unlock(&ip->i_flags_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iget_cache_miss",
          "args": [
            "mp",
            "pag",
            "tp",
            "ino",
            "&ip",
            "flags",
            "lock_flags"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget_cache_miss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "273-364",
          "snippet": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\ttrace_xfs_iget_miss(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\ttrace_xfs_iget_miss(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_missed"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget_cache_hit",
          "args": [
            "pag",
            "ip",
            "ino",
            "flags",
            "lock_flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget_cache_hit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "140-270",
          "snippet": "static int\nxfs_iget_cache_hit(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip,\n\txfs_ino_t\t\tino,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags) __releases(RCU)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t/*\n\t * check for re-use of an inode within an RCU grace period due to the\n\t * radix tree nodes not being updated yet. We monitor for this by\n\t * setting the inode number to zero before freeing the inode structure.\n\t * If the inode has been reallocated and set up, then the inode number\n\t * will not match, so check for that, too.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != ino) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\n\t/*\n\t * If we are racing with another cache hit that is currently\n\t * instantiating this inode or currently recycling it out of\n\t * reclaimabe state, wait for the initialisation to complete\n\t * before continuing.\n\t *\n\t * XXX(hch): eventually we should do something equivalent to\n\t *\t     wait_on_inode to wait for these flags to be cleared\n\t *\t     instead of polling for it.\n\t */\n\tif (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If lookup is racing with unlink return an error immediately.\n\t */\n\tif (ip->i_d.di_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n\t * Need to carefully get it back into useable state.\n\t */\n\tif (ip->i_flags & XFS_IRECLAIMABLE) {\n\t\ttrace_xfs_iget_reclaim(ip);\n\n\t\t/*\n\t\t * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode\n\t\t * from stomping over us while we recycle the inode.  We can't\n\t\t * clear the radix tree reclaimable tag yet as it requires\n\t\t * pag_ici_lock to be held exclusive.\n\t\t */\n\t\tip->i_flags |= XFS_IRECLAIM;\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\n\t\terror = inode_init_always(mp->m_super, inode);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Re-initializing the inode failed, and we are in deep\n\t\t\t * trouble.  Try to re-add it to the reclaim list.\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t\tip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);\n\t\t\tASSERT(ip->i_flags & XFS_IRECLAIMABLE);\n\t\t\ttrace_xfs_iget_reclaim_fail(ip);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tspin_lock(&pag->pag_ici_lock);\n\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Clear the per-lifetime state in the inode as we are now\n\t\t * effectively a new inode and need to return to the initial\n\t\t * state before reuse occurs.\n\t\t */\n\t\tip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;\n\t\tip->i_flags |= XFS_INEW;\n\t\t__xfs_inode_clear_reclaim_tag(mp, pag, ip);\n\t\tinode->i_state = I_NEW;\n\n\t\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\t\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\tspin_unlock(&pag->pag_ici_lock);\n\t} else {\n\t\t/* If the VFS inode is being torn down, pause and try again. */\n\t\tif (!igrab(inode)) {\n\t\t\ttrace_xfs_iget_skip(ip);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* We've got a live one. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\t\ttrace_xfs_iget_hit(ip);\n\t}\n\n\tif (lock_flags != 0)\n\t\txfs_ilock(ip, lock_flags);\n\n\txfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);\n\tXFS_STATS_INC(xs_ig_found);\n\n\treturn 0;\n\nout_error:\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic int\nxfs_iget_cache_hit(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip,\n\txfs_ino_t\t\tino,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags) __releases(RCU)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t/*\n\t * check for re-use of an inode within an RCU grace period due to the\n\t * radix tree nodes not being updated yet. We monitor for this by\n\t * setting the inode number to zero before freeing the inode structure.\n\t * If the inode has been reallocated and set up, then the inode number\n\t * will not match, so check for that, too.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != ino) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\n\t/*\n\t * If we are racing with another cache hit that is currently\n\t * instantiating this inode or currently recycling it out of\n\t * reclaimabe state, wait for the initialisation to complete\n\t * before continuing.\n\t *\n\t * XXX(hch): eventually we should do something equivalent to\n\t *\t     wait_on_inode to wait for these flags to be cleared\n\t *\t     instead of polling for it.\n\t */\n\tif (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If lookup is racing with unlink return an error immediately.\n\t */\n\tif (ip->i_d.di_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n\t * Need to carefully get it back into useable state.\n\t */\n\tif (ip->i_flags & XFS_IRECLAIMABLE) {\n\t\ttrace_xfs_iget_reclaim(ip);\n\n\t\t/*\n\t\t * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode\n\t\t * from stomping over us while we recycle the inode.  We can't\n\t\t * clear the radix tree reclaimable tag yet as it requires\n\t\t * pag_ici_lock to be held exclusive.\n\t\t */\n\t\tip->i_flags |= XFS_IRECLAIM;\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\n\t\terror = inode_init_always(mp->m_super, inode);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Re-initializing the inode failed, and we are in deep\n\t\t\t * trouble.  Try to re-add it to the reclaim list.\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t\tip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);\n\t\t\tASSERT(ip->i_flags & XFS_IRECLAIMABLE);\n\t\t\ttrace_xfs_iget_reclaim_fail(ip);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tspin_lock(&pag->pag_ici_lock);\n\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Clear the per-lifetime state in the inode as we are now\n\t\t * effectively a new inode and need to return to the initial\n\t\t * state before reuse occurs.\n\t\t */\n\t\tip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;\n\t\tip->i_flags |= XFS_INEW;\n\t\t__xfs_inode_clear_reclaim_tag(mp, pag, ip);\n\t\tinode->i_state = I_NEW;\n\n\t\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\t\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\tspin_unlock(&pag->pag_ici_lock);\n\t} else {\n\t\t/* If the VFS inode is being torn down, pause and try again. */\n\t\tif (!igrab(inode)) {\n\t\t\ttrace_xfs_iget_skip(ip);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* We've got a live one. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\t\ttrace_xfs_iget_hit(ip);\n\t}\n\n\tif (lock_flags != 0)\n\t\txfs_ilock(ip, lock_flags);\n\n\txfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);\n\tXFS_STATS_INC(xs_ig_found);\n\n\treturn 0;\n\nout_error:\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&pag->pag_ici_root",
            "agino"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "XFS_INO_TO_AGNO(mp, ino)"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_iget_cache_miss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "273-364",
    "snippet": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\ttrace_xfs_iget_miss(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inode_free",
          "args": [
            "ip"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_free_quota_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1311-1352",
          "snippet": "int\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__destroy_inode",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "223-241",
          "snippet": "void __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock_flags"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_dup"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "error != -EEXIST"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&pag->pag_ici_root",
            "agino",
            "ip"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pag_ici_lock"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_set",
          "args": [
            "ip",
            "iflags"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "118-124",
          "snippet": "static inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip",
            "lock_flags"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_miss",
          "args": [
            "ip"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iread",
          "args": [
            "mp",
            "tp",
            "ip",
            "flags"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_buf.c",
          "lines": "342-476",
          "snippet": "int\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tip->i_d.di_magic = XFS_DINODE_MAGIC;\n\t\tip->i_d.di_gen = prandom_u32();\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tip->i_d.di_version = 3;\n\t\t\tip->i_d.di_ino = ip->i_ino;\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid);\n\t\t} else\n\t\t\tip->i_d.di_version = 2;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tif (!xfs_dinode_verify(mp, ip, dip)) {\n\t\txfs_alert(mp, \"%s: validation failed for inode %lld failed\",\n\t\t\t\t__func__, ip->i_ino);\n\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, dip);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_dinode_from_disk(&ip->i_d, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_magic = be16_to_cpu(dip->di_magic);\n\t\tip->i_d.di_version = dip->di_version;\n\t\tip->i_d.di_gen = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\tif (dip->di_version == 3) {\n\t\t\tip->i_d.di_ino = be64_to_cpu(dip->di_ino);\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &dip->di_uuid);\n\t\t}\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tip->i_d.di_mode = 0;\n\t}\n\n\t/*\n\t * Automatically convert version 1 inode formats in memory to version 2\n\t * inode format. If the inode is modified, it will get logged and\n\t * rewritten as a version 2 inode. We can do this because we set the\n\t * superblock feature bit for v2 inodes unconditionally during mount\n\t * and it means the reast of the code can assume the inode version is 2\n\t * or higher.\n\t */\n\tif (ip->i_d.di_version == 1) {\n\t\tip->i_d.di_version = 2;\n\t\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\t\tip->i_d.di_nlink = ip->i_d.di_onlink;\n\t\tip->i_d.di_onlink = 0;\n\t\txfs_set_projid(ip, 0);\n\t}\n\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tip->i_d.di_magic = XFS_DINODE_MAGIC;\n\t\tip->i_d.di_gen = prandom_u32();\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tip->i_d.di_version = 3;\n\t\t\tip->i_d.di_ino = ip->i_ino;\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &mp->m_sb.sb_uuid);\n\t\t} else\n\t\t\tip->i_d.di_version = 2;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tif (!xfs_dinode_verify(mp, ip, dip)) {\n\t\txfs_alert(mp, \"%s: validation failed for inode %lld failed\",\n\t\t\t\t__func__, ip->i_ino);\n\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, dip);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_dinode_from_disk(&ip->i_d, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_magic = be16_to_cpu(dip->di_magic);\n\t\tip->i_d.di_version = dip->di_version;\n\t\tip->i_d.di_gen = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\tif (dip->di_version == 3) {\n\t\t\tip->i_d.di_ino = be64_to_cpu(dip->di_ino);\n\t\t\tuuid_copy(&ip->i_d.di_uuid, &dip->di_uuid);\n\t\t}\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tip->i_d.di_mode = 0;\n\t}\n\n\t/*\n\t * Automatically convert version 1 inode formats in memory to version 2\n\t * inode format. If the inode is modified, it will get logged and\n\t * rewritten as a version 2 inode. We can do this because we set the\n\t * superblock feature bit for v2 inodes unconditionally during mount\n\t * and it means the reast of the code can assume the inode version is 2\n\t * or higher.\n\t */\n\tif (ip->i_d.di_version == 1) {\n\t\tip->i_d.di_version = 2;\n\t\tmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\n\t\tip->i_d.di_nlink = ip->i_d.di_onlink;\n\t\tip->i_d.di_onlink = 0;\n\t\txfs_set_projid(ip, 0);\n\t}\n\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_alloc",
          "args": [
            "mp",
            "ino"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "46-85",
          "snippet": "struct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstruct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "ino"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\ttrace_xfs_iget_miss(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_iget_cache_hit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "140-270",
    "snippet": "static int\nxfs_iget_cache_hit(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip,\n\txfs_ino_t\t\tino,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags) __releases(RCU)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t/*\n\t * check for re-use of an inode within an RCU grace period due to the\n\t * radix tree nodes not being updated yet. We monitor for this by\n\t * setting the inode number to zero before freeing the inode structure.\n\t * If the inode has been reallocated and set up, then the inode number\n\t * will not match, so check for that, too.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != ino) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\n\t/*\n\t * If we are racing with another cache hit that is currently\n\t * instantiating this inode or currently recycling it out of\n\t * reclaimabe state, wait for the initialisation to complete\n\t * before continuing.\n\t *\n\t * XXX(hch): eventually we should do something equivalent to\n\t *\t     wait_on_inode to wait for these flags to be cleared\n\t *\t     instead of polling for it.\n\t */\n\tif (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If lookup is racing with unlink return an error immediately.\n\t */\n\tif (ip->i_d.di_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n\t * Need to carefully get it back into useable state.\n\t */\n\tif (ip->i_flags & XFS_IRECLAIMABLE) {\n\t\ttrace_xfs_iget_reclaim(ip);\n\n\t\t/*\n\t\t * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode\n\t\t * from stomping over us while we recycle the inode.  We can't\n\t\t * clear the radix tree reclaimable tag yet as it requires\n\t\t * pag_ici_lock to be held exclusive.\n\t\t */\n\t\tip->i_flags |= XFS_IRECLAIM;\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\n\t\terror = inode_init_always(mp->m_super, inode);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Re-initializing the inode failed, and we are in deep\n\t\t\t * trouble.  Try to re-add it to the reclaim list.\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t\tip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);\n\t\t\tASSERT(ip->i_flags & XFS_IRECLAIMABLE);\n\t\t\ttrace_xfs_iget_reclaim_fail(ip);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tspin_lock(&pag->pag_ici_lock);\n\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Clear the per-lifetime state in the inode as we are now\n\t\t * effectively a new inode and need to return to the initial\n\t\t * state before reuse occurs.\n\t\t */\n\t\tip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;\n\t\tip->i_flags |= XFS_INEW;\n\t\t__xfs_inode_clear_reclaim_tag(mp, pag, ip);\n\t\tinode->i_state = I_NEW;\n\n\t\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\t\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\tspin_unlock(&pag->pag_ici_lock);\n\t} else {\n\t\t/* If the VFS inode is being torn down, pause and try again. */\n\t\tif (!igrab(inode)) {\n\t\t\ttrace_xfs_iget_skip(ip);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* We've got a live one. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\t\ttrace_xfs_iget_hit(ip);\n\t}\n\n\tif (lock_flags != 0)\n\t\txfs_ilock(ip, lock_flags);\n\n\txfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);\n\tXFS_STATS_INC(xs_ig_found);\n\n\treturn 0;\n\nout_error:\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n\treturn error;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_found"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "ip",
            "XFS_ISTALE | XFS_IDONTCACHE"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "lock_flags"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_hit",
          "args": [
            "ip"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_skip",
          "args": [
            "ip"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mrlock_init",
          "args": [
            "&ip->i_iolock",
            "MRLOCK_BARRIER",
            "\"xfsio\"",
            "ip->i_ino"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!rwsem_is_locked(&ip->i_iolock.mr_lock)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&ip->i_iolock.mr_lock"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xfs_inode_clear_reclaim_tag",
          "args": [
            "mp",
            "pag",
            "ip"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_inode_clear_reclaim_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "796-805",
          "snippet": "STATIC void\n__xfs_inode_clear_reclaim_tag(\n\txfs_mount_t\t*mp,\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\tXFS_INO_TO_AGINO(mp, ip->i_ino), XFS_ICI_RECLAIM_TAG);\n\t__xfs_inode_clear_reclaim(pag, ip);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\n__xfs_inode_clear_reclaim_tag(\n\txfs_mount_t\t*mp,\n\txfs_perag_t\t*pag,\n\txfs_inode_t\t*ip)\n{\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\tXFS_INO_TO_AGINO(mp, ip->i_ino), XFS_ICI_RECLAIM_TAG);\n\t__xfs_inode_clear_reclaim(pag, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_reclaim_fail",
          "args": [
            "ip"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_flags & XFS_IRECLAIMABLE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_always",
          "args": [
            "mp->m_super",
            "inode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "131-191",
          "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations empty_aops = {\n};",
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_reclaim",
          "args": [
            "ip"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_frecycle"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_skip",
          "args": [
            "ip"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_frecycle"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iget_skip",
          "args": [
            "ip"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstatic int\nxfs_iget_cache_hit(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_inode\t*ip,\n\txfs_ino_t\t\tino,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags) __releases(RCU)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror;\n\n\t/*\n\t * check for re-use of an inode within an RCU grace period due to the\n\t * radix tree nodes not being updated yet. We monitor for this by\n\t * setting the inode number to zero before freeing the inode structure.\n\t * If the inode has been reallocated and set up, then the inode number\n\t * will not match, so check for that, too.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tif (ip->i_ino != ino) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\n\t/*\n\t * If we are racing with another cache hit that is currently\n\t * instantiating this inode or currently recycling it out of\n\t * reclaimabe state, wait for the initialisation to complete\n\t * before continuing.\n\t *\n\t * XXX(hch): eventually we should do something equivalent to\n\t *\t     wait_on_inode to wait for these flags to be cleared\n\t *\t     instead of polling for it.\n\t */\n\tif (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {\n\t\ttrace_xfs_iget_skip(ip);\n\t\tXFS_STATS_INC(xs_ig_frecycle);\n\t\terror = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If lookup is racing with unlink return an error immediately.\n\t */\n\tif (ip->i_d.di_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n\t\terror = -ENOENT;\n\t\tgoto out_error;\n\t}\n\n\t/*\n\t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n\t * Need to carefully get it back into useable state.\n\t */\n\tif (ip->i_flags & XFS_IRECLAIMABLE) {\n\t\ttrace_xfs_iget_reclaim(ip);\n\n\t\t/*\n\t\t * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode\n\t\t * from stomping over us while we recycle the inode.  We can't\n\t\t * clear the radix tree reclaimable tag yet as it requires\n\t\t * pag_ici_lock to be held exclusive.\n\t\t */\n\t\tip->i_flags |= XFS_IRECLAIM;\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\n\t\terror = inode_init_always(mp->m_super, inode);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Re-initializing the inode failed, and we are in deep\n\t\t\t * trouble.  Try to re-add it to the reclaim list.\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t\tip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);\n\t\t\tASSERT(ip->i_flags & XFS_IRECLAIMABLE);\n\t\t\ttrace_xfs_iget_reclaim_fail(ip);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tspin_lock(&pag->pag_ici_lock);\n\t\tspin_lock(&ip->i_flags_lock);\n\n\t\t/*\n\t\t * Clear the per-lifetime state in the inode as we are now\n\t\t * effectively a new inode and need to return to the initial\n\t\t * state before reuse occurs.\n\t\t */\n\t\tip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;\n\t\tip->i_flags |= XFS_INEW;\n\t\t__xfs_inode_clear_reclaim_tag(mp, pag, ip);\n\t\tinode->i_state = I_NEW;\n\n\t\tASSERT(!rwsem_is_locked(&ip->i_iolock.mr_lock));\n\t\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\tspin_unlock(&pag->pag_ici_lock);\n\t} else {\n\t\t/* If the VFS inode is being torn down, pause and try again. */\n\t\tif (!igrab(inode)) {\n\t\t\ttrace_xfs_iget_skip(ip);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* We've got a live one. */\n\t\tspin_unlock(&ip->i_flags_lock);\n\t\trcu_read_unlock();\n\t\ttrace_xfs_iget_hit(ip);\n\t}\n\n\tif (lock_flags != 0)\n\t\txfs_ilock(ip, lock_flags);\n\n\txfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);\n\tXFS_STATS_INC(xs_ig_found);\n\n\treturn 0;\n\nout_error:\n\tspin_unlock(&ip->i_flags_lock);\n\trcu_read_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_inode_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "97-135",
    "snippet": "void\nxfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\n\t/*\n\t * Because we use RCU freeing we need to ensure the inode always\n\t * appears to be reclaimed with an invalid inode number when in the\n\t * free state. The ip->i_flags_lock provides the barrier against lookup\n\t * races.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags = XFS_IRECLAIM;\n\tip->i_ino = 0;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* asserts to verify all state is correct here */\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!xfs_isiflocked(ip));\n\tXFS_STATS_DEC(vn_active);\n\n\tcall_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&VFS_I(ip)->i_rcu",
            "xfs_inode_free_callback"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_DEC",
          "args": [
            "vn_active"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_isiflocked(ip)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isiflocked",
          "args": [
            "ip"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isiflocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "252-255",
          "snippet": "static inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&ip->i_pincount) == 0"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ip->i_pincount"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_item_destroy",
          "args": [
            "ip"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_item_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode_item.c",
          "lines": "576-581",
          "snippet": "void\nxfs_inode_item_destroy(\n\txfs_inode_t\t*ip)\n{\n\tkmem_zone_free(xfs_ili_zone, ip->i_itemp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_ili_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_ili_zone;\n\nvoid\nxfs_inode_item_destroy(\n\txfs_inode_t\t*ip)\n{\n\tkmem_zone_free(xfs_ili_zone, ip->i_itemp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idestroy_fork",
          "args": [
            "ip",
            "XFS_ATTR_FORK"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idestroy_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "678-719",
          "snippet": "void\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\n\nvoid\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\n\t/*\n\t * Because we use RCU freeing we need to ensure the inode always\n\t * appears to be reclaimed with an invalid inode number when in the\n\t * free state. The ip->i_flags_lock provides the barrier against lookup\n\t * races.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags = XFS_IRECLAIM;\n\tip->i_ino = 0;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t/* asserts to verify all state is correct here */\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!xfs_isiflocked(ip));\n\tXFS_STATS_DEC(vn_active);\n\n\tcall_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);\n}"
  },
  {
    "function_name": "xfs_inode_free_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "87-95",
    "snippet": "STATIC void\nxfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\tkmem_zone_free(xfs_inode_zone, ip);\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_inode_zone",
            "ip"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nSTATIC void\nxfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\tkmem_zone_free(xfs_inode_zone, ip);\n}"
  },
  {
    "function_name": "xfs_inode_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
    "lines": "46-85",
    "snippet": "struct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}",
    "includes": [
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include \"xfs_dquot.h\"",
      "#include \"xfs_dquot_item.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ip->i_d",
            "0",
            "sizeof(xfs_icdinode_t)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ip->i_df",
            "0",
            "sizeof(xfs_ifork_t)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ip->i_imap",
            "0",
            "sizeof(struct xfs_imap)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mrlock_init",
          "args": [
            "&ip->i_iolock",
            "MRLOCK_BARRIER",
            "\"xfsio\"",
            "ip->i_ino"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_ino == 0"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_isiflocked(ip)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isiflocked",
          "args": [
            "ip"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isiflocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "252-255",
          "snippet": "static inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [
            "#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\n#define XFS_IFLOCK\t\t(1 << __XFS_IFLOCK_BIT)\n\nstatic inline int xfs_isiflocked(struct xfs_inode *ip)\n{\n\treturn xfs_iflags_test(ip, XFS_IFLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!spin_is_locked(&ip->i_flags_lock)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&ip->i_flags_lock"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&ip->i_pincount) == 0"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ip->i_pincount"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "vn_active"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_inode_zone",
            "ip"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_always",
          "args": [
            "mp->m_super",
            "VFS_I(ip)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "131-191",
          "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations empty_aops = {\n};",
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_alloc",
          "args": [
            "xfs_inode_zone",
            "KM_SLEEP"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "110-127",
          "snippet": "void *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nstruct xfs_inode *\nxfs_inode_alloc(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino)\n{\n\tstruct xfs_inode\t*ip;\n\n\t/*\n\t * if this didn't occur in transactions, we could use\n\t * KM_MAYFAIL and return NULL here on ENOMEM. Set the\n\t * code up to do this anyway.\n\t */\n\tip = kmem_zone_alloc(xfs_inode_zone, KM_SLEEP);\n\tif (!ip)\n\t\treturn NULL;\n\tif (inode_init_always(mp->m_super, VFS_I(ip))) {\n\t\tkmem_zone_free(xfs_inode_zone, ip);\n\t\treturn NULL;\n\t}\n\n\tXFS_STATS_INC(vn_active);\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tASSERT(!spin_is_locked(&ip->i_flags_lock));\n\tASSERT(!xfs_isiflocked(ip));\n\tASSERT(ip->i_ino == 0);\n\n\tmrlock_init(&ip->i_iolock, MRLOCK_BARRIER, \"xfsio\", ip->i_ino);\n\n\t/* initialise the xfs inode */\n\tip->i_ino = ino;\n\tip->i_mount = mp;\n\tmemset(&ip->i_imap, 0, sizeof(struct xfs_imap));\n\tip->i_afp = NULL;\n\tmemset(&ip->i_df, 0, sizeof(xfs_ifork_t));\n\tip->i_flags = 0;\n\tip->i_delayed_blks = 0;\n\tmemset(&ip->i_d, 0, sizeof(xfs_icdinode_t));\n\n\treturn ip;\n}"
  }
]