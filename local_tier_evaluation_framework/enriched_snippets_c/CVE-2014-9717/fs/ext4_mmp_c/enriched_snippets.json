[
  {
    "function_name": "ext4_multi_mount_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "269-391",
    "snippet": "int ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Unable to create kmmpd thread for %s.\"",
            "sb->s_id"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mmpd_data"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "EXT4_SB(sb)->s_mmp_tsk"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kmmpd",
            "mmpd_data",
            "\"kmmpd-%s\"",
            "bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bh->b_bdev",
            "mmp->mmp_bdevname"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"not enough memory for mmpd_data\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct mmpd_data)",
            "GFP_KERNEL"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_mmp_msg",
          "args": [
            "sb",
            "mmp",
            "\"Device is already active on another node.\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "mmp->mmp_seq"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_mmp_block",
          "args": [
            "sb",
            "&bh",
            "mmp_block"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "read_mmp_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "68-106",
          "snippet": "static int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"MMP startup interrupted, failing mount\\n\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ * wait_time"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_mmp_block",
          "args": [
            "sb",
            "bh"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "write_mmp_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "41-62",
          "snippet": "static int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "seq"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmp_new_seq",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "mmp_new_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "255-264",
          "snippet": "static unsigned int mmp_new_seq(void)\n{\n\tu32 new_seq;\n\n\tdo {\n\t\tnew_seq = prandom_u32();\n\t} while (new_seq > EXT4_MMP_SEQ_MAX);\n\n\treturn new_seq;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic unsigned int mmp_new_seq(void)\n{\n\tu32 new_seq;\n\n\tdo {\n\t\tnew_seq = prandom_u32();\n\t} while (new_seq > EXT4_MMP_SEQ_MAX);\n\n\treturn new_seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_mmp_msg",
          "args": [
            "sb",
            "mmp",
            "\"Device is already active on another node.\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"MMP startup interrupted, failing mount\\n\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ * wait_time"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\"",
            "wait_time * 2"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "mmp_check_interval * 2 + 1",
            "mmp_check_interval + 60"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_mmp_msg",
          "args": [
            "sb",
            "mmp",
            "\"fsck is running on the filesystem\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "mmp->mmp_check_interval"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Invalid MMP block in superblock\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nint ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}"
  },
  {
    "function_name": "mmp_new_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "255-264",
    "snippet": "static unsigned int mmp_new_seq(void)\n{\n\tu32 new_seq;\n\n\tdo {\n\t\tnew_seq = prandom_u32();\n\t} while (new_seq > EXT4_MMP_SEQ_MAX);\n\n\treturn new_seq;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic unsigned int mmp_new_seq(void)\n{\n\tu32 new_seq;\n\n\tdo {\n\t\tnew_seq = prandom_u32();\n\t} while (new_seq > EXT4_MMP_SEQ_MAX);\n\n\treturn new_seq;\n}"
  },
  {
    "function_name": "kmmpd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "125-249",
    "snippet": "static int kmmpd(void *data)\n{\n\tstruct super_block *sb = ((struct mmpd_data *) data)->sb;\n\tstruct buffer_head *bh = ((struct mmpd_data *) data)->bh;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct mmp_struct *mmp;\n\text4_fsblk_t mmp_block;\n\tu32 seq = 0;\n\tunsigned long failed_writes = 0;\n\tint mmp_update_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned mmp_check_interval;\n\tunsigned long last_update_time;\n\tunsigned long diff;\n\tint retval;\n\n\tmmp_block = le64_to_cpu(es->s_mmp_block);\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\t/*\n\t * Start with the higher mmp_check_interval and reduce it if\n\t * the MMP block is being updated on time.\n\t */\n\tmmp_check_interval = max(EXT4_MMP_CHECK_MULT * mmp_update_interval,\n\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\tbdevname(bh->b_bdev, mmp->mmp_bdevname);\n\n\tmemcpy(mmp->mmp_nodename, init_utsname()->nodename,\n\t       sizeof(mmp->mmp_nodename));\n\n\twhile (!kthread_should_stop()) {\n\t\tif (++seq > EXT4_MMP_SEQ_MAX)\n\t\t\tseq = 1;\n\n\t\tmmp->mmp_seq = cpu_to_le32(seq);\n\t\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\t\tlast_update_time = jiffies;\n\n\t\tretval = write_mmp_block(sb, bh);\n\t\t/*\n\t\t * Don't spew too many error messages. Print one every\n\t\t * (s_mmp_update_interval * 60) seconds.\n\t\t */\n\t\tif (retval) {\n\t\t\tif ((failed_writes % 60) == 0)\n\t\t\t\text4_error(sb, \"Error writing to MMP block\");\n\t\t\tfailed_writes++;\n\t\t}\n\n\t\tif (!(le32_to_cpu(es->s_feature_incompat) &\n\t\t    EXT4_FEATURE_INCOMPAT_MMP)) {\n\t\t\text4_warning(sb, \"kmmpd being stopped since MMP feature\"\n\t\t\t\t     \" has been disabled.\");\n\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_warning(sb, \"kmmpd being stopped since filesystem \"\n\t\t\t\t     \"has been remounted as readonly.\");\n\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff < mmp_update_interval * HZ)\n\t\t\tschedule_timeout_interruptible(mmp_update_interval *\n\t\t\t\t\t\t       HZ - diff);\n\n\t\t/*\n\t\t * We need to make sure that more than mmp_check_interval\n\t\t * seconds have not passed since writing. If that has happened\n\t\t * we need to check if the MMP block is as we left it.\n\t\t */\n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff > mmp_check_interval * HZ) {\n\t\t\tstruct buffer_head *bh_check = NULL;\n\t\t\tstruct mmp_struct *mmp_check;\n\n\t\t\tretval = read_mmp_block(sb, &bh_check, mmp_block);\n\t\t\tif (retval) {\n\t\t\t\text4_error(sb, \"error reading MMP data: %d\",\n\t\t\t\t\t   retval);\n\n\t\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tmmp_check = (struct mmp_struct *)(bh_check->b_data);\n\t\t\tif (mmp->mmp_seq != mmp_check->mmp_seq ||\n\t\t\t    memcmp(mmp->mmp_nodename, mmp_check->mmp_nodename,\n\t\t\t\t   sizeof(mmp->mmp_nodename))) {\n\t\t\t\tdump_mmp_msg(sb, mmp_check,\n\t\t\t\t\t     \"Error while updating MMP info. \"\n\t\t\t\t\t     \"The filesystem seems to have been\"\n\t\t\t\t\t     \" multiply mounted.\");\n\t\t\t\text4_error(sb, \"abort\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tput_bh(bh_check);\n\t\t}\n\n\t\t /*\n\t\t * Adjust the mmp_check_interval depending on how much time\n\t\t * it took for the MMP block to be written.\n\t\t */\n\t\tmmp_check_interval = max(min(EXT4_MMP_CHECK_MULT * diff / HZ,\n\t\t\t\t\t     EXT4_MMP_MAX_CHECK_INTERVAL),\n\t\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\t\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\t}\n\n\t/*\n\t * Unmount seems to be clean.\n\t */\n\tmmp->mmp_seq = cpu_to_le32(EXT4_MMP_SEQ_CLEAN);\n\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\n\tretval = write_mmp_block(sb, bh);\n\nfailed:\n\tkfree(data);\n\tbrelse(bh);\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_mmp_block",
          "args": [
            "sb",
            "bh"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "write_mmp_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "41-62",
          "snippet": "static int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "get_seconds()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_MMP_SEQ_CLEAN"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "mmp_check_interval"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "min(EXT4_MMP_CHECK_MULT * diff / HZ,\n\t\t\t\t\t     EXT4_MMP_MAX_CHECK_INTERVAL)",
            "EXT4_MMP_MIN_CHECK_INTERVAL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_max_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "353-371",
          "snippet": "static int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "EXT4_MMP_CHECK_MULT * diff / HZ",
            "EXT4_MMP_MAX_CHECK_INTERVAL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh_check"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"abort\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_mmp_msg",
          "args": [
            "sb",
            "mmp_check",
            "\"Error while updating MMP info. \"\n\t\t\t\t\t     \"The filesystem seems to have been\"\n\t\t\t\t\t     \" multiply mounted.\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mmp->mmp_nodename",
            "mmp_check->mmp_nodename",
            "sizeof(mmp->mmp_nodename)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"error reading MMP data: %d\"",
            "retval"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mmp_block",
          "args": [
            "sb",
            "&bh_check",
            "mmp_block"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "read_mmp_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "68-106",
          "snippet": "static int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "mmp_update_interval *\n\t\t\t\t\t\t       HZ - diff"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"kmmpd being stopped since filesystem \"\n\t\t\t\t     \"has been remounted as readonly.\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"kmmpd being stopped since MMP feature\"\n\t\t\t\t     \" has been disabled.\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_feature_incompat"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error writing to MMP block\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "get_seconds()"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "seq"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mmp->mmp_nodename",
            "init_utsname()->nodename",
            "sizeof(mmp->mmp_nodename)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bh->b_bdev",
            "mmp->mmp_bdevname"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "mmp_check_interval"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "get_seconds()"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "es->s_mmp_block"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_mmp_update_interval"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int kmmpd(void *data)\n{\n\tstruct super_block *sb = ((struct mmpd_data *) data)->sb;\n\tstruct buffer_head *bh = ((struct mmpd_data *) data)->bh;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct mmp_struct *mmp;\n\text4_fsblk_t mmp_block;\n\tu32 seq = 0;\n\tunsigned long failed_writes = 0;\n\tint mmp_update_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned mmp_check_interval;\n\tunsigned long last_update_time;\n\tunsigned long diff;\n\tint retval;\n\n\tmmp_block = le64_to_cpu(es->s_mmp_block);\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\t/*\n\t * Start with the higher mmp_check_interval and reduce it if\n\t * the MMP block is being updated on time.\n\t */\n\tmmp_check_interval = max(EXT4_MMP_CHECK_MULT * mmp_update_interval,\n\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\tbdevname(bh->b_bdev, mmp->mmp_bdevname);\n\n\tmemcpy(mmp->mmp_nodename, init_utsname()->nodename,\n\t       sizeof(mmp->mmp_nodename));\n\n\twhile (!kthread_should_stop()) {\n\t\tif (++seq > EXT4_MMP_SEQ_MAX)\n\t\t\tseq = 1;\n\n\t\tmmp->mmp_seq = cpu_to_le32(seq);\n\t\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\t\tlast_update_time = jiffies;\n\n\t\tretval = write_mmp_block(sb, bh);\n\t\t/*\n\t\t * Don't spew too many error messages. Print one every\n\t\t * (s_mmp_update_interval * 60) seconds.\n\t\t */\n\t\tif (retval) {\n\t\t\tif ((failed_writes % 60) == 0)\n\t\t\t\text4_error(sb, \"Error writing to MMP block\");\n\t\t\tfailed_writes++;\n\t\t}\n\n\t\tif (!(le32_to_cpu(es->s_feature_incompat) &\n\t\t    EXT4_FEATURE_INCOMPAT_MMP)) {\n\t\t\text4_warning(sb, \"kmmpd being stopped since MMP feature\"\n\t\t\t\t     \" has been disabled.\");\n\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_warning(sb, \"kmmpd being stopped since filesystem \"\n\t\t\t\t     \"has been remounted as readonly.\");\n\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff < mmp_update_interval * HZ)\n\t\t\tschedule_timeout_interruptible(mmp_update_interval *\n\t\t\t\t\t\t       HZ - diff);\n\n\t\t/*\n\t\t * We need to make sure that more than mmp_check_interval\n\t\t * seconds have not passed since writing. If that has happened\n\t\t * we need to check if the MMP block is as we left it.\n\t\t */\n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff > mmp_check_interval * HZ) {\n\t\t\tstruct buffer_head *bh_check = NULL;\n\t\t\tstruct mmp_struct *mmp_check;\n\n\t\t\tretval = read_mmp_block(sb, &bh_check, mmp_block);\n\t\t\tif (retval) {\n\t\t\t\text4_error(sb, \"error reading MMP data: %d\",\n\t\t\t\t\t   retval);\n\n\t\t\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tmmp_check = (struct mmp_struct *)(bh_check->b_data);\n\t\t\tif (mmp->mmp_seq != mmp_check->mmp_seq ||\n\t\t\t    memcmp(mmp->mmp_nodename, mmp_check->mmp_nodename,\n\t\t\t\t   sizeof(mmp->mmp_nodename))) {\n\t\t\t\tdump_mmp_msg(sb, mmp_check,\n\t\t\t\t\t     \"Error while updating MMP info. \"\n\t\t\t\t\t     \"The filesystem seems to have been\"\n\t\t\t\t\t     \" multiply mounted.\");\n\t\t\t\text4_error(sb, \"abort\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tput_bh(bh_check);\n\t\t}\n\n\t\t /*\n\t\t * Adjust the mmp_check_interval depending on how much time\n\t\t * it took for the MMP block to be written.\n\t\t */\n\t\tmmp_check_interval = max(min(EXT4_MMP_CHECK_MULT * diff / HZ,\n\t\t\t\t\t     EXT4_MMP_MAX_CHECK_INTERVAL),\n\t\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\t\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\t}\n\n\t/*\n\t * Unmount seems to be clean.\n\t */\n\tmmp->mmp_seq = cpu_to_le32(EXT4_MMP_SEQ_CLEAN);\n\tmmp->mmp_time = cpu_to_le64(get_seconds());\n\n\tretval = write_mmp_block(sb, bh);\n\nfailed:\n\tkfree(data);\n\tbrelse(bh);\n\treturn retval;\n}"
  },
  {
    "function_name": "__dump_mmp_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "111-120",
    "snippet": "void __dump_mmp_msg(struct super_block *sb, struct mmp_struct *mmp,\n\t\t    const char *function, unsigned int line, const char *msg)\n{\n\t__ext4_warning(sb, function, line, msg);\n\t__ext4_warning(sb, function, line,\n\t\t       \"MMP failure info: last update time: %llu, last update \"\n\t\t       \"node: %s, last update device: %s\\n\",\n\t\t       (long long unsigned int) le64_to_cpu(mmp->mmp_time),\n\t\t       mmp->mmp_nodename, mmp->mmp_bdevname);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext4_warning",
          "args": [
            "sb",
            "function",
            "line",
            "\"MMP failure info: last update time: %llu, last update \"\n\t\t       \"node: %s, last update device: %s\\n\"",
            "(long long unsigned int) le64_to_cpu(mmp->mmp_time)",
            "mmp->mmp_nodename",
            "mmp->mmp_bdevname"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "mmp->mmp_time"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nvoid __dump_mmp_msg(struct super_block *sb, struct mmp_struct *mmp,\n\t\t    const char *function, unsigned int line, const char *msg)\n{\n\t__ext4_warning(sb, function, line, msg);\n\t__ext4_warning(sb, function, line,\n\t\t       \"MMP failure info: last update time: %llu, last update \"\n\t\t       \"node: %s, last update device: %s\\n\",\n\t\t       (long long unsigned int) le64_to_cpu(mmp->mmp_time),\n\t\t       mmp->mmp_nodename, mmp->mmp_bdevname);\n}"
  },
  {
    "function_name": "read_mmp_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "68-106",
    "snippet": "static int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mmp_csum_verify",
          "args": [
            "sb",
            "mmp"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mmp_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "21-27",
          "snippet": "static int ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "mmp->mmp_magic"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Error while reading MMP block %llu\"",
            "mmp_block"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*bh"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "*bh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "*bh"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ_SYNC | REQ_META | REQ_PRIO",
            "*bh"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "*bh"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*bh"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "mmp_block"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "*bh"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t/* This would be sb_bread(sb, mmp_block), except we need to be sure\n\t * that the MD RAID device cache has been bypassed, and that the read\n\t * is not blocked in the elevator. */\n\tif (!*bh)\n\t\t*bh = sb_getblk(sb, mmp_block);\n\tif (!*bh)\n\t\treturn -ENOMEM;\n\tif (*bh) {\n\t\tget_bh(*bh);\n\t\tlock_buffer(*bh);\n\t\t(*bh)->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, *bh);\n\t\twait_on_buffer(*bh);\n\t\tif (!buffer_uptodate(*bh)) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t}\n\tif (unlikely(!*bh)) {\n\t\text4_warning(sb, \"Error while reading MMP block %llu\",\n\t\t\t     mmp_block);\n\t\treturn -EIO;\n\t}\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\n\t    !ext4_mmp_csum_verify(sb, mmp))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_mmp_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "41-62",
    "snippet": "static int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "sb"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE_SYNC | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mmp_csum_set",
          "args": [
            "sb",
            "mmp"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mmp_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "29-35",
          "snippet": "static void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "sb"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\t/*\n\t * We protect against freezing so that we don't create dirty buffers\n\t * on frozen filesystem.\n\t */\n\tsb_start_write(sb);\n\text4_mmp_csum_set(sb, mmp);\n\tmark_buffer_dirty(bh);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(WRITE_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tsb_end_write(sb);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mmp_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "29-35",
    "snippet": "static void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mmp_csum",
          "args": [
            "sb",
            "mmp"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mmp_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "29-35",
          "snippet": "static void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}"
  },
  {
    "function_name": "ext4_mmp_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "21-27",
    "snippet": "static int ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mmp_csum",
          "args": [
            "sb",
            "mmp"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mmp_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "29-35",
          "snippet": "static void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic int ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\n}"
  },
  {
    "function_name": "ext4_mmp_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
    "lines": "10-19",
    "snippet": "static __le32 ext4_mmp_csum(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct mmp_struct, mmp_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (char *)mmp, offset);\n\n\treturn cpu_to_le32(csum);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/utsname.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "csum"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "sbi->s_csum_seed",
            "(char *)mmp",
            "offset"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 12
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nstatic __le32 ext4_mmp_csum(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct mmp_struct, mmp_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (char *)mmp, offset);\n\n\treturn cpu_to_le32(csum);\n}"
  }
]