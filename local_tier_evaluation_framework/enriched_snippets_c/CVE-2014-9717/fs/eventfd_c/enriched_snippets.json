[
  {
    "function_name": "eventfd_file_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "391-418",
    "snippet": "struct file *eventfd_file_create(unsigned int count, int flags)\n{\n\tstruct file *file;\n\tstruct eventfd_ctx *ctx;\n\n\t/* Check the EFD_* constants for consistency.  */\n\tBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~EFD_FLAGS_SET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&ctx->kref);\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->count = count;\n\tctx->flags = flags;\n\n\tfile = anon_inode_getfile(\"[eventfd]\", &eventfd_fops, ctx,\n\t\t\t\t  O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS));\n\tif (IS_ERR(file))\n\t\teventfd_free_ctx(ctx);\n\n\treturn file;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_free_ctx",
          "args": [
            "ctx"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "70-73",
          "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "\"[eventfd]\"",
            "&eventfd_fops",
            "ctx",
            "O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/anon_inodes.c",
          "lines": "70-120",
          "snippet": "struct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct qstr this;\n\tstruct path path;\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * Link the inode to a directory entry by creating a unique name\n\t * using the inode sequence number.\n\t */\n\tfile = ERR_PTR(-ENOMEM);\n\tthis.name = name;\n\tthis.len = strlen(name);\n\tthis.hash = 0;\n\tpath.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\tgoto err_module;\n\n\tpath.mnt = mntget(anon_inode_mnt);\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\n\td_instantiate(path.dentry, anon_inode_inode);\n\n\tfile = alloc_file(&path, OPEN_FMODE(flags), fops);\n\tif (IS_ERR(file))\n\t\tgoto err_dput;\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->f_flags = flags & (O_ACCMODE | O_NONBLOCK);\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr_dput:\n\tpath_put(&path);\nerr_module:\n\tmodule_put(fops->owner);\n\treturn file;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *anon_inode_mnt",
            "static struct inode *anon_inode_inode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic struct vfsmount *anon_inode_mnt;\nstatic struct inode *anon_inode_inode;\n\nstruct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct qstr this;\n\tstruct path path;\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * Link the inode to a directory entry by creating a unique name\n\t * using the inode sequence number.\n\t */\n\tfile = ERR_PTR(-ENOMEM);\n\tthis.name = name;\n\tthis.len = strlen(name);\n\tthis.hash = 0;\n\tpath.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\tgoto err_module;\n\n\tpath.mnt = mntget(anon_inode_mnt);\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\n\td_instantiate(path.dentry, anon_inode_inode);\n\n\tfile = alloc_file(&path, OPEN_FMODE(flags), fops);\n\tif (IS_ERR(file))\n\t\tgoto err_dput;\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->f_flags = flags & (O_ACCMODE | O_NONBLOCK);\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr_dput:\n\tpath_put(&path);\nerr_module:\n\tmodule_put(fops->owner);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->wqh"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&ctx->kref"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx)",
            "GFP_KERNEL"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "EFD_NONBLOCK != O_NONBLOCK"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "EFD_CLOEXEC != O_CLOEXEC"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct file *eventfd_file_create(unsigned int count, int flags)\n{\n\tstruct file *file;\n\tstruct eventfd_ctx *ctx;\n\n\t/* Check the EFD_* constants for consistency.  */\n\tBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~EFD_FLAGS_SET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&ctx->kref);\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->count = count;\n\tctx->flags = flags;\n\n\tfile = anon_inode_getfile(\"[eventfd]\", &eventfd_fops, ctx,\n\t\t\t\t  O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS));\n\tif (IS_ERR(file))\n\t\teventfd_free_ctx(ctx);\n\n\treturn file;\n}"
  },
  {
    "function_name": "eventfd_ctx_fileget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "368-374",
    "snippet": "struct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn eventfd_ctx_get(file->private_data);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_ctx_get",
          "args": [
            "file->private_data"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "88-92",
          "snippet": "struct eventfd_ctx *eventfd_ctx_get(struct eventfd_ctx *ctx)\n{\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_get(struct eventfd_ctx *ctx)\n{\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn eventfd_ctx_get(file->private_data);\n}"
  },
  {
    "function_name": "eventfd_ctx_fdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "347-356",
    "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fileget",
          "args": [
            "f.file"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fileget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "368-374",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn eventfd_ctx_get(file->private_data);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn eventfd_ctx_get(file->private_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "347-356",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}"
  },
  {
    "function_name": "eventfd_fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "322-335",
    "snippet": "struct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "fd"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_fget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "322-335",
          "snippet": "struct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}"
  },
  {
    "function_name": "eventfd_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "290-298",
    "snippet": "static void eventfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventfd_ctx *ctx = f->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-count: %16llx\\n\",\n\t\t   (unsigned long long)ctx->count);\n\tspin_unlock_irq(&ctx->wqh.lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"eventfd-count: %16llx\\n\"",
            "(unsigned long long)ctx->count"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventfd_ctx *ctx = f->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-count: %16llx\\n\",\n\t\t   (unsigned long long)ctx->count);\n\tspin_unlock_irq(&ctx->wqh.lock);\n}"
  },
  {
    "function_name": "eventfd_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "242-287",
    "snippet": "static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\n\t\treturn -EFAULT;\n\tif (ucnt == ULLONG_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ULLONG_MAX - ctx->count > ucnt)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (res = 0;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ULLONG_MAX - ctx->count > ucnt) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\tctx->count += ucnt;\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "POLLIN"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "res > 0"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ucnt",
            "buf",
            "sizeof(ucnt)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\n\t\treturn -EFAULT;\n\tif (ucnt == ULLONG_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ULLONG_MAX - ctx->count > ucnt)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (res = 0;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ULLONG_MAX - ctx->count > ucnt) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\tctx->count += ucnt;\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "eventfd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "226-240",
    "snippet": "static ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 cnt;\n\n\tif (count < sizeof(cnt))\n\t\treturn -EINVAL;\n\tres = eventfd_ctx_read(ctx, file->f_flags & O_NONBLOCK, &cnt);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn put_user(cnt, (__u64 __user *) buf) ? -EFAULT : sizeof(cnt);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cnt",
            "(__u64 __user *) buf"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_read",
          "args": [
            "ctx",
            "file->f_flags & O_NONBLOCK",
            "&cnt"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "186-223",
          "snippet": "ssize_t eventfd_ctx_read(struct eventfd_ctx *ctx, int no_wait, __u64 *cnt)\n{\n\tssize_t res;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\t*cnt = 0;\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = 0;\n\telse if (!no_wait) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res == 0)) {\n\t\teventfd_ctx_do_read(ctx, cnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nssize_t eventfd_ctx_read(struct eventfd_ctx *ctx, int no_wait, __u64 *cnt)\n{\n\tssize_t res;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\t*cnt = 0;\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = 0;\n\telse if (!no_wait) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res == 0)) {\n\t\teventfd_ctx_do_read(ctx, cnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 cnt;\n\n\tif (count < sizeof(cnt))\n\t\treturn -EINVAL;\n\tres = eventfd_ctx_read(ctx, file->f_flags & O_NONBLOCK, &cnt);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn put_user(cnt, (__u64 __user *) buf) ? -EFAULT : sizeof(cnt);\n}"
  },
  {
    "function_name": "eventfd_ctx_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "186-223",
    "snippet": "ssize_t eventfd_ctx_read(struct eventfd_ctx *ctx, int no_wait, __u64 *cnt)\n{\n\tssize_t res;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\t*cnt = 0;\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = 0;\n\telse if (!no_wait) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res == 0)) {\n\t\teventfd_ctx_do_read(ctx, cnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "POLLOUT"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_do_read",
          "args": [
            "ctx",
            "cnt"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "137-141",
          "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "res == 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nssize_t eventfd_ctx_read(struct eventfd_ctx *ctx, int no_wait, __u64 *cnt)\n{\n\tssize_t res;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\t*cnt = 0;\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = 0;\n\telse if (!no_wait) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res == 0)) {\n\t\teventfd_ctx_do_read(ctx, cnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "eventfd_ctx_remove_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "156-169",
    "snippet": "int eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_t *wait,\n\t\t\t\t  __u64 *cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\teventfd_ctx_do_read(ctx, cnt);\n\t__remove_wait_queue(&ctx->wqh, wait);\n\tif (*cnt != 0 && waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn *cnt != 0 ? 0 : -EAGAIN;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "POLLOUT"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "wait"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_do_read",
          "args": [
            "ctx",
            "cnt"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "137-141",
          "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nint eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_t *wait,\n\t\t\t\t  __u64 *cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\teventfd_ctx_do_read(ctx, cnt);\n\t__remove_wait_queue(&ctx->wqh, wait);\n\tif (*cnt != 0 && waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLOUT);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn *cnt != 0 ? 0 : -EAGAIN;\n}"
  },
  {
    "function_name": "eventfd_ctx_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "137-141",
    "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
  },
  {
    "function_name": "eventfd_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "117-135",
    "snippet": "static unsigned int eventfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\tu64 count;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\tsmp_rmb();\n\tcount = ctx->count;\n\n\tif (count > 0)\n\t\tevents |= POLLIN;\n\tif (count == ULLONG_MAX)\n\t\tevents |= POLLERR;\n\tif (ULLONG_MAX - 1 > count)\n\t\tevents |= POLLOUT;\n\n\treturn events;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ctx->wqh",
            "wait"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic unsigned int eventfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\tu64 count;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\tsmp_rmb();\n\tcount = ctx->count;\n\n\tif (count > 0)\n\t\tevents |= POLLIN;\n\tif (count == ULLONG_MAX)\n\t\tevents |= POLLERR;\n\tif (ULLONG_MAX - 1 > count)\n\t\tevents |= POLLOUT;\n\n\treturn events;\n}"
  },
  {
    "function_name": "eventfd_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "108-115",
    "snippet": "static int eventfd_release(struct inode *inode, struct file *file)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\n\twake_up_poll(&ctx->wqh, POLLHUP);\n\teventfd_ctx_put(ctx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "102-105",
          "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&ctx->wqh",
            "POLLHUP"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int eventfd_release(struct inode *inode, struct file *file)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\n\twake_up_poll(&ctx->wqh, POLLHUP);\n\teventfd_ctx_put(ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "eventfd_ctx_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "102-105",
    "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ctx->kref",
            "eventfd_free"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
  },
  {
    "function_name": "eventfd_ctx_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "88-92",
    "snippet": "struct eventfd_ctx *eventfd_ctx_get(struct eventfd_ctx *ctx)\n{\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&ctx->kref"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_get(struct eventfd_ctx *ctx)\n{\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}"
  },
  {
    "function_name": "eventfd_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "75-80",
    "snippet": "static void eventfd_free(struct kref *kref)\n{\n\tstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\n\n\teventfd_free_ctx(ctx);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_free_ctx",
          "args": [
            "ctx"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "70-73",
          "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structeventfd_ctx",
            "kref"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free(struct kref *kref)\n{\n\tstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\n\n\teventfd_free_ctx(ctx);\n}"
  },
  {
    "function_name": "eventfd_free_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "70-73",
    "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
  },
  {
    "function_name": "eventfd_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
    "lines": "54-67",
    "snippet": "__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "POLLIN"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\n__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}"
  }
]