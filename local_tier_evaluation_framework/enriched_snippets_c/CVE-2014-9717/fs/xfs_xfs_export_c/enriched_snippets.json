[
  {
    "function_name": "xfs_fs_nfs_commit_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "225-241",
    "snippet": "STATIC int\nxfs_fs_nfs_commit_metadata(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_lsn_t\t\tlsn = 0;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip))\n\t\tlsn = ip->i_itemp->ili_last_lsn;\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!lsn)\n\t\treturn 0;\n\treturn _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_xfs_log_force_lsn",
          "args": [
            "mp",
            "lsn",
            "XFS_LOG_SYNC",
            "NULL"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3332-3445",
          "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_fs_nfs_commit_metadata(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_lsn_t\t\tlsn = 0;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip))\n\t\tlsn = ip->i_itemp->ili_last_lsn;\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!lsn)\n\t\treturn 0;\n\treturn _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);\n}"
  },
  {
    "function_name": "xfs_fs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "211-223",
    "snippet": "dentry *\nxfs_fs_get_parent(\n\tstruct dentry\t\t*child)\n{\n\tint\t\t\terror;\n\tstruct xfs_inode\t*cip;\n\n\terror = xfs_lookup(XFS_I(child->d_inode), &xfs_name_dotdot, &cip, NULL);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\treturn d_obtain_alias(VFS_I(cip));\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "VFS_I(cip)"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "cip"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lookup",
          "args": [
            "XFS_I(child->d_inode)",
            "&xfs_name_dotdot",
            "&cip",
            "NULL"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "570-605",
          "snippet": "int\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "child->d_inode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_fs_get_parent(\n\tstruct dentry\t\t*child)\n{\n\tint\t\t\terror;\n\tstruct xfs_inode\t*cip;\n\n\terror = xfs_lookup(XFS_I(child->d_inode), &xfs_name_dotdot, &cip, NULL);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\treturn d_obtain_alias(VFS_I(cip));\n}"
  },
  {
    "function_name": "xfs_fs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "187-209",
    "snippet": "dentry *\nxfs_fs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t\t      fid->i32.parent_gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->parent_ino,\n\t\t\t\t\t      fid64->parent_gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_nfs_get_inode",
          "args": [
            "sb",
            "fid64->parent_ino",
            "fid64->parent_gen"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
          "lines": "120-161",
          "snippet": "inode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}",
          "includes": [
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ninode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fileid_length",
          "args": [
            "fileid_type"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fileid_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
          "lines": "40-53",
          "snippet": "static int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}",
          "includes": [
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_fs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t\t      fid->i32.parent_gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->parent_ino,\n\t\t\t\t\t      fid64->parent_gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "xfs_fs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "163-185",
    "snippet": "dentry *\nxfs_fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\tcase FILEID_INO32_GEN:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->ino, fid64->gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_nfs_get_inode",
          "args": [
            "sb",
            "fid64->ino",
            "fid64->gen"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
          "lines": "120-161",
          "snippet": "inode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}",
          "includes": [
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct",
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ninode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fileid_length",
          "args": [
            "fileid_type"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fileid_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
          "lines": "40-53",
          "snippet": "static int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}",
          "includes": [
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t int fh_len, int fileid_type)\n{\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fid;\n\tstruct inode\t\t*inode = NULL;\n\n\tif (fh_len < xfs_fileid_length(fileid_type))\n\t\treturn NULL;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\tcase FILEID_INO32_GEN:\n\t\tinode = xfs_nfs_get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tinode = xfs_nfs_get_inode(sb, fid64->ino, fid64->gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "xfs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "120-161",
    "snippet": "inode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "XFS_IGET_UNTRUSTED",
            "0",
            "&ip"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\ninode *\nxfs_nfs_get_inode(\n\tstruct super_block\t*sb,\n\tu64\t\t\tino,\n\tu32\t\t\tgeneration)\n {\n \txfs_mount_t\t\t*mp = XFS_M(sb);\n\txfs_inode_t\t\t*ip;\n\tint\t\t\terror;\n\n\t/*\n\t * NFS can sometimes send requests for ino 0.  Fail them gracefully.\n\t */\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * The XFS_IGET_UNTRUSTED means that an invalid inode number is just\n\t * fine and not an indication of a corrupted filesystem as clients can\n\t * send invalid file handles and we have to handle it gracefully..\n\t */\n\terror = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED, 0, &ip);\n\tif (error) {\n\t\t/*\n\t\t * EINVAL means the inode cluster doesn't exist anymore.\n\t\t * This implies the filehandle is stale, so we should\n\t\t * translate it here.\n\t\t * We don't use ESTALE directly down the chain to not\n\t\t * confuse applications using bulkstat that expect EINVAL.\n\t\t */\n\t\tif (error == -EINVAL || error == -ENOENT)\n\t\t\terror = -ESTALE;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (ip->i_d.di_gen != generation) {\n\t\tIRELE(ip);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn VFS_I(ip);\n}"
  },
  {
    "function_name": "xfs_fs_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "55-118",
    "snippet": "STATIC int\nxfs_fs_encode_fh(\n\tstruct inode\t*inode,\n\t__u32\t\t*fh,\n\tint\t\t*max_len,\n\tstruct inode\t*parent)\n{\n\tstruct fid\t\t*fid = (struct fid *)fh;\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fh;\n\tint\t\t\tfileid_type;\n\tint\t\t\tlen;\n\n\t/* Directories don't need their parent encoded, they have \"..\" */\n\tif (!parent)\n\t\tfileid_type = FILEID_INO32_GEN;\n\telse\n\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\n\t/*\n\t * If the the filesystem may contain 64bit inode numbers, we need\n\t * to use larger file handles that can represent them.\n\t *\n\t * While we only allocate inodes that do not fit into 32 bits any\n\t * large enough filesystem may contain them, thus the slightly\n\t * confusing looking conditional below.\n\t */\n\tif (!(XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_SMALL_INUMS) ||\n\t    (XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_32BITINODES))\n\t\tfileid_type |= XFS_FILEID_TYPE_64FLAG;\n\n\t/*\n\t * Only encode if there is enough space given.  In practice\n\t * this means we can't export a filesystem with 64bit inodes\n\t * over NFSv2 with the subtree_check export option; the other\n\t * seven combinations work.  The real answer is \"don't use v2\".\n\t */\n\tlen = xfs_fileid_length(fileid_type);\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn FILEID_INVALID;\n\t}\n\t*max_len = len;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tfid->i32.parent_ino = XFS_I(parent)->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\t/*FALLTHRU*/\n\tcase FILEID_INO32_GEN:\n\t\tfid->i32.ino = XFS_I(inode)->i_ino;\n\t\tfid->i32.gen = inode->i_generation;\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->parent_ino = XFS_I(parent)->i_ino;\n\t\tfid64->parent_gen = parent->i_generation;\n\t\t/*FALLTHRU*/\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->ino = XFS_I(inode)->i_ino;\n\t\tfid64->gen = inode->i_generation;\n\t\tbreak;\n\t}\n\n\treturn fileid_type;\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct",
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fileid_length",
          "args": [
            "fileid_type"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fileid_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
          "lines": "40-53",
          "snippet": "static int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}",
          "includes": [
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_fs_encode_fh(\n\tstruct inode\t*inode,\n\t__u32\t\t*fh,\n\tint\t\t*max_len,\n\tstruct inode\t*parent)\n{\n\tstruct fid\t\t*fid = (struct fid *)fh;\n\tstruct xfs_fid64\t*fid64 = (struct xfs_fid64 *)fh;\n\tint\t\t\tfileid_type;\n\tint\t\t\tlen;\n\n\t/* Directories don't need their parent encoded, they have \"..\" */\n\tif (!parent)\n\t\tfileid_type = FILEID_INO32_GEN;\n\telse\n\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\n\t/*\n\t * If the the filesystem may contain 64bit inode numbers, we need\n\t * to use larger file handles that can represent them.\n\t *\n\t * While we only allocate inodes that do not fit into 32 bits any\n\t * large enough filesystem may contain them, thus the slightly\n\t * confusing looking conditional below.\n\t */\n\tif (!(XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_SMALL_INUMS) ||\n\t    (XFS_M(inode->i_sb)->m_flags & XFS_MOUNT_32BITINODES))\n\t\tfileid_type |= XFS_FILEID_TYPE_64FLAG;\n\n\t/*\n\t * Only encode if there is enough space given.  In practice\n\t * this means we can't export a filesystem with 64bit inodes\n\t * over NFSv2 with the subtree_check export option; the other\n\t * seven combinations work.  The real answer is \"don't use v2\".\n\t */\n\tlen = xfs_fileid_length(fileid_type);\n\tif (*max_len < len) {\n\t\t*max_len = len;\n\t\treturn FILEID_INVALID;\n\t}\n\t*max_len = len;\n\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tfid->i32.parent_ino = XFS_I(parent)->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\t/*FALLTHRU*/\n\tcase FILEID_INO32_GEN:\n\t\tfid->i32.ino = XFS_I(inode)->i_ino;\n\t\tfid->i32.gen = inode->i_generation;\n\t\tbreak;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->parent_ino = XFS_I(parent)->i_ino;\n\t\tfid64->parent_gen = parent->i_generation;\n\t\t/*FALLTHRU*/\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\tfid64->ino = XFS_I(inode)->i_ino;\n\t\tfid64->gen = inode->i_generation;\n\t\tbreak;\n\t}\n\n\treturn fileid_type;\n}"
  },
  {
    "function_name": "xfs_fileid_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_export.c",
    "lines": "40-53",
    "snippet": "static int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}",
    "includes": [
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_pnfs.h\"\n#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_export.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int xfs_fileid_length(int fileid_type)\n{\n\tswitch (fileid_type) {\n\tcase FILEID_INO32_GEN:\n\t\treturn 2;\n\tcase FILEID_INO32_GEN_PARENT:\n\t\treturn 4;\n\tcase FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 3;\n\tcase FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:\n\t\treturn 6;\n\t}\n\treturn FILEID_INVALID;\n}"
  }
]