[
  {
    "function_name": "hfsplus_osx_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "860-868",
    "snippet": "static size_t hfsplus_osx_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic size_t hfsplus_osx_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "hfsplus_osx_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "833-858",
    "snippet": "static int hfsplus_osx_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't allow setting properly prefixed attributes\n\t * by prepending them with \"osx.\"\n\t */\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_MAC_OSX_PREFIX);\n\tstrcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_setxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size",
            "flags"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "263-397",
          "snippet": "int __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_MAC_OSX_PREFIX_LEN",
            "name"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_MAC_OSX_PREFIX"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "name"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "47-56",
          "snippet": "static inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int hfsplus_osx_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't allow setting properly prefixed attributes\n\t * by prepending them with \"osx.\"\n\t */\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_MAC_OSX_PREFIX);\n\tstrcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_osx_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "806-831",
    "snippet": "static int hfsplus_osx_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't allow retrieving properly prefixed attributes\n\t * by prepending them with \"osx.\"\n\t */\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_MAC_OSX_PREFIX);\n\tstrcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_getxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "477-561",
          "snippet": "ssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_MAC_OSX_PREFIX_LEN",
            "name"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_MAC_OSX_PREFIX"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "name"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "47-56",
          "snippet": "static inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int hfsplus_osx_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't allow retrieving properly prefixed attributes\n\t * by prepending them with \"osx.\"\n\t */\n\tif (is_known_namespace(name))\n\t\treturn -EOPNOTSUPP;\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN\n\t\t+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_MAC_OSX_PREFIX);\n\tstrcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "734-804",
    "snippet": "static int hfsplus_removexattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\tu16 flags;\n\tu16 cat_entry_type;\n\tint is_xattr_acl_deleted = 0;\n\tint is_all_xattrs_deleted = 0;\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn -EOPNOTSUPP;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_removexattr;\n\t}\n\n\terr = hfsplus_delete_attr(inode, name);\n\tif (err)\n\t\tgoto end_removexattr;\n\n\tis_xattr_acl_deleted = !strcmp_xattr_acl(name);\n\tis_all_xattrs_deleted = !hfsplus_attr_exists(inode, NULL);\n\n\tif (!is_xattr_acl_deleted && !is_all_xattrs_deleted)\n\t\tgoto end_removexattr;\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_removexattr;\n\t}\n\nend_removexattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&cat_fd"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid catalog entry type\\n\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "cat_fd.bnode",
            "cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags)",
            "flags"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "cat_fd.bnode",
            "cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags)"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_exists",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "168-191",
          "snippet": "int hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp_xattr_acl",
          "args": [
            "name"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_xattr_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "38-45",
          "snippet": "static int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_attr",
          "args": [
            "inode",
            "name"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "297-337",
          "snippet": "int hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"catalog searching failed\\n\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&cat_fd"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->cat_tree",
            "&cat_fd"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp_xattr_finder_info",
          "args": [
            "name"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_xattr_finder_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "29-36",
          "snippet": "static int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\tu16 flags;\n\tu16 cat_entry_type;\n\tint is_xattr_acl_deleted = 0;\n\tint is_all_xattrs_deleted = 0;\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn -EOPNOTSUPP;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_removexattr;\n\t}\n\n\terr = hfsplus_delete_attr(inode, name);\n\tif (err)\n\t\tgoto end_removexattr;\n\n\tis_xattr_acl_deleted = !strcmp_xattr_acl(name);\n\tis_all_xattrs_deleted = !hfsplus_attr_exists(inode, NULL);\n\n\tif (!is_xattr_acl_deleted && !is_all_xattrs_deleted)\n\t\tgoto end_removexattr;\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_removexattr;\n\t}\n\nend_removexattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "641-732",
    "snippet": "ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tssize_t err;\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 key_len = 0;\n\tstruct hfsplus_attr_key attr_key;\n\tchar *strbuf;\n\tint xattr_name_len;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tres = hfsplus_listxattr_finder_info(dentry, buffer, size);\n\tif (res < 0)\n\t\treturn res;\n\telse if (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn (res == 0) ? -EOPNOTSUPP : res;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN +\n\t\t\tXATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = hfsplus_find_attr(inode->i_sb, inode->i_ino, NULL, &fd);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tif (res == 0)\n\t\t\t\tres = -ENODATA;\n\t\t\tgoto end_listxattr;\n\t\t} else {\n\t\t\tres = err;\n\t\t\tgoto end_listxattr;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tkey_len = hfs_bnode_read_u16(fd.bnode, fd.keyoffset);\n\t\tif (key_len == 0 || key_len > fd.tree->max_key_len) {\n\t\t\tpr_err(\"invalid xattr key length: %d\\n\", key_len);\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &attr_key,\n\t\t\t\tfd.keyoffset, key_len + sizeof(key_len));\n\n\t\tif (be32_to_cpu(attr_key.cnid) != inode->i_ino)\n\t\t\tgoto end_listxattr;\n\n\t\txattr_name_len = NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN;\n\t\tif (hfsplus_uni2asc(inode->i_sb,\n\t\t\t(const struct hfsplus_unistr *)&fd.key->attr.key_name,\n\t\t\t\t\tstrbuf, &xattr_name_len)) {\n\t\t\tpr_err(\"unicode conversion failed\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(strbuf))\n\t\t\t\tres += name_len(strbuf, xattr_name_len);\n\t\t} else if (can_list(strbuf)) {\n\t\t\tif (size < (res + name_len(strbuf, xattr_name_len))) {\n\t\t\t\tres = -ERANGE;\n\t\t\t\tgoto end_listxattr;\n\t\t\t} else\n\t\t\t\tres += copy_name(buffer + res,\n\t\t\t\t\t\tstrbuf, xattr_name_len);\n\t\t}\n\n\t\tif (hfs_brec_goto(&fd, 1))\n\t\t\tgoto end_listxattr;\n\t}\n\nend_listxattr:\n\tkfree(strbuf);\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "strbuf"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_goto",
          "args": [
            "&fd",
            "1"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_goto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "232-295",
          "snippet": "int hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_name",
          "args": [
            "buffer + res",
            "strbuf",
            "xattr_name_len"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "409-425",
          "snippet": "static int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_len",
          "args": [
            "strbuf",
            "xattr_name_len"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "name_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "399-407",
          "snippet": "static int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_list",
          "args": [
            "strbuf"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "can_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "563-571",
          "snippet": "static inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unicode conversion failed\\n\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_uni2asc",
          "args": [
            "inode->i_sb",
            "(const struct hfsplus_unistr *)&fd.key->attr.key_name",
            "strbuf",
            "&xattr_name_len"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_uni2asc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "121-249",
          "snippet": "int hfsplus_uni2asc(struct super_block *sb,\n\t\tconst struct hfsplus_unistr *ustr,\n\t\tchar *astr, int *len_p)\n{\n\tconst hfsplus_unichr *ip;\n\tstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\n\tu8 *op;\n\tu16 cc, c0, c1;\n\tu16 *ce1, *ce2;\n\tint i, len, ustrlen, res, compose;\n\n\top = astr;\n\tip = ustr->unicode;\n\tustrlen = be16_to_cpu(ustr->length);\n\tlen = *len_p;\n\tce1 = NULL;\n\tcompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\n\twhile (ustrlen > 0) {\n\t\tc0 = be16_to_cpu(*ip++);\n\t\tustrlen--;\n\t\t/* search for single decomposed char */\n\t\tif (likely(compose))\n\t\t\tce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\n\t\tif (ce1)\n\t\t\tcc = ce1[0];\n\t\telse\n\t\t\tcc = 0;\n\t\tif (cc) {\n\t\t\t/* start of a possibly decomposed Hangul char */\n\t\t\tif (cc != 0xffff)\n\t\t\t\tgoto done;\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip) - Hangul_VBase;\n\t\t\tif (c1 < Hangul_VCount) {\n\t\t\t\t/* compose the Hangul char */\n\t\t\t\tcc = (c0 - Hangul_LBase) * Hangul_VCount;\n\t\t\t\tcc = (cc + c1) * Hangul_TCount;\n\t\t\t\tcc += Hangul_SBase;\n\t\t\t\tip++;\n\t\t\t\tustrlen--;\n\t\t\t\tif (!ustrlen)\n\t\t\t\t\tgoto done;\n\t\t\t\tc1 = be16_to_cpu(*ip) - Hangul_TBase;\n\t\t\t\tif (c1 > 0 && c1 < Hangul_TCount) {\n\t\t\t\t\tcc += c1;\n\t\t\t\t\tip++;\n\t\t\t\t\tustrlen--;\n\t\t\t\t}\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\t/* main loop for common case of not composed chars */\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip);\n\t\t\tif (likely(compose))\n\t\t\t\tce1 = hfsplus_compose_lookup(\n\t\t\t\t\thfsplus_compose_table, c1);\n\t\t\tif (ce1)\n\t\t\t\tbreak;\n\t\t\tswitch (c0) {\n\t\t\tcase 0:\n\t\t\t\tc0 = 0x2400;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc0 = ':';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = nls->uni2char(c0, op, len);\n\t\t\tif (res < 0) {\n\t\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*op = '?';\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t\top += res;\n\t\t\tlen -= res;\n\t\t\tc0 = c1;\n\t\t\tip++;\n\t\t\tustrlen--;\n\t\t}\n\t\tce2 = hfsplus_compose_lookup(ce1, c0);\n\t\tif (ce2) {\n\t\t\ti = 1;\n\t\t\twhile (i < ustrlen) {\n\t\t\t\tce1 = hfsplus_compose_lookup(ce2,\n\t\t\t\t\tbe16_to_cpu(ip[i]));\n\t\t\t\tif (!ce1)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\tce2 = ce1;\n\t\t\t}\n\t\t\tcc = ce2[0];\n\t\t\tif (cc) {\n\t\t\t\tip += i;\n\t\t\t\tustrlen -= i;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nsame:\n\t\tswitch (c0) {\n\t\tcase 0:\n\t\t\tcc = 0x2400;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcc = ':';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcc = c0;\n\t\t}\ndone:\n\t\tres = nls->uni2char(cc, op, len);\n\t\tif (res < 0) {\n\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\tgoto out;\n\t\t\t*op = '?';\n\t\t\tres = 1;\n\t\t}\n\t\top += res;\n\t\tlen -= res;\n\t}\n\tres = 0;\nout:\n\t*len_p = (char *)op - astr;\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define Hangul_TCount\t28",
            "#define Hangul_VCount\t21",
            "#define Hangul_TBase\t0x11a7",
            "#define Hangul_VBase\t0x1161",
            "#define Hangul_LBase\t0x1100",
            "#define Hangul_SBase\t0xac00"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\n#define Hangul_TCount\t28\n#define Hangul_VCount\t21\n#define Hangul_TBase\t0x11a7\n#define Hangul_VBase\t0x1161\n#define Hangul_LBase\t0x1100\n#define Hangul_SBase\t0xac00\n\nint hfsplus_uni2asc(struct super_block *sb,\n\t\tconst struct hfsplus_unistr *ustr,\n\t\tchar *astr, int *len_p)\n{\n\tconst hfsplus_unichr *ip;\n\tstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\n\tu8 *op;\n\tu16 cc, c0, c1;\n\tu16 *ce1, *ce2;\n\tint i, len, ustrlen, res, compose;\n\n\top = astr;\n\tip = ustr->unicode;\n\tustrlen = be16_to_cpu(ustr->length);\n\tlen = *len_p;\n\tce1 = NULL;\n\tcompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\n\twhile (ustrlen > 0) {\n\t\tc0 = be16_to_cpu(*ip++);\n\t\tustrlen--;\n\t\t/* search for single decomposed char */\n\t\tif (likely(compose))\n\t\t\tce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\n\t\tif (ce1)\n\t\t\tcc = ce1[0];\n\t\telse\n\t\t\tcc = 0;\n\t\tif (cc) {\n\t\t\t/* start of a possibly decomposed Hangul char */\n\t\t\tif (cc != 0xffff)\n\t\t\t\tgoto done;\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip) - Hangul_VBase;\n\t\t\tif (c1 < Hangul_VCount) {\n\t\t\t\t/* compose the Hangul char */\n\t\t\t\tcc = (c0 - Hangul_LBase) * Hangul_VCount;\n\t\t\t\tcc = (cc + c1) * Hangul_TCount;\n\t\t\t\tcc += Hangul_SBase;\n\t\t\t\tip++;\n\t\t\t\tustrlen--;\n\t\t\t\tif (!ustrlen)\n\t\t\t\t\tgoto done;\n\t\t\t\tc1 = be16_to_cpu(*ip) - Hangul_TBase;\n\t\t\t\tif (c1 > 0 && c1 < Hangul_TCount) {\n\t\t\t\t\tcc += c1;\n\t\t\t\t\tip++;\n\t\t\t\t\tustrlen--;\n\t\t\t\t}\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\t/* main loop for common case of not composed chars */\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip);\n\t\t\tif (likely(compose))\n\t\t\t\tce1 = hfsplus_compose_lookup(\n\t\t\t\t\thfsplus_compose_table, c1);\n\t\t\tif (ce1)\n\t\t\t\tbreak;\n\t\t\tswitch (c0) {\n\t\t\tcase 0:\n\t\t\t\tc0 = 0x2400;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc0 = ':';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = nls->uni2char(c0, op, len);\n\t\t\tif (res < 0) {\n\t\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*op = '?';\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t\top += res;\n\t\t\tlen -= res;\n\t\t\tc0 = c1;\n\t\t\tip++;\n\t\t\tustrlen--;\n\t\t}\n\t\tce2 = hfsplus_compose_lookup(ce1, c0);\n\t\tif (ce2) {\n\t\t\ti = 1;\n\t\t\twhile (i < ustrlen) {\n\t\t\t\tce1 = hfsplus_compose_lookup(ce2,\n\t\t\t\t\tbe16_to_cpu(ip[i]));\n\t\t\t\tif (!ce1)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\tce2 = ce1;\n\t\t\t}\n\t\t\tcc = ce2[0];\n\t\t\tif (cc) {\n\t\t\t\tip += i;\n\t\t\t\tustrlen -= i;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nsame:\n\t\tswitch (c0) {\n\t\tcase 0:\n\t\t\tcc = 0x2400;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcc = ':';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcc = c0;\n\t\t}\ndone:\n\t\tres = nls->uni2char(cc, op, len);\n\t\tif (res < 0) {\n\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\tgoto out;\n\t\t\t*op = '?';\n\t\t\tres = 1;\n\t\t}\n\t\top += res;\n\t\tlen -= res;\n\t}\n\tres = 0;\nout:\n\t*len_p = (char *)op - astr;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "attr_key.cnid"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&attr_key",
            "fd.keyoffset",
            "key_len + sizeof(key_len)"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid xattr key length: %d\\n\"",
            "key_len"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd.bnode",
            "fd.keyoffset"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_find_attr",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "NULL",
            "&fd"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "136-166",
          "snippet": "int hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN +\n\t\t\tXATTR_MAC_OSX_PREFIX_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->attr_tree",
            "&fd"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_listxattr_finder_info",
          "args": [
            "dentry",
            "buffer",
            "size"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_listxattr_finder_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "573-639",
          "snippet": "static ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,\n\t\t\t\t\t\tchar *buffer, size_t size)\n{\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\tunsigned long len, found_bit;\n\tint xattr_name_len, symbols_count;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn res;\n\t}\n\n\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\tif (res)\n\t\tgoto end_listxattr_finder_info;\n\n\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (entry_type == HFSPLUS_FOLDER) {\n\t\tlen = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)folder_finder_info, len*8);\n\t} else if (entry_type == HFSPLUS_FILE) {\n\t\tlen = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)file_finder_info, len*8);\n\t} else {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto end_listxattr_finder_info;\n\t}\n\n\tif (found_bit >= (len*8))\n\t\tres = 0;\n\telse {\n\t\tsymbols_count = sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME) - 1;\n\t\txattr_name_len =\n\t\t\tname_len(HFSPLUS_XATTR_FINDER_INFO_NAME, symbols_count);\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME))\n\t\t\t\tres = xattr_name_len;\n\t\t} else if (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME)) {\n\t\t\tif (size < xattr_name_len)\n\t\t\t\tres = -ERANGE;\n\t\t\telse {\n\t\t\t\tres = copy_name(buffer,\n\t\t\t\t\t\tHFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\t\t\tsymbols_count);\n\t\t\t}\n\t\t}\n\t}\n\nend_listxattr_finder_info:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,\n\t\t\t\t\t\tchar *buffer, size_t size)\n{\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\tunsigned long len, found_bit;\n\tint xattr_name_len, symbols_count;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn res;\n\t}\n\n\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\tif (res)\n\t\tgoto end_listxattr_finder_info;\n\n\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (entry_type == HFSPLUS_FOLDER) {\n\t\tlen = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)folder_finder_info, len*8);\n\t} else if (entry_type == HFSPLUS_FILE) {\n\t\tlen = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)file_finder_info, len*8);\n\t} else {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto end_listxattr_finder_info;\n\t}\n\n\tif (found_bit >= (len*8))\n\t\tres = 0;\n\telse {\n\t\tsymbols_count = sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME) - 1;\n\t\txattr_name_len =\n\t\t\tname_len(HFSPLUS_XATTR_FINDER_INFO_NAME, symbols_count);\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME))\n\t\t\t\tres = xattr_name_len;\n\t\t} else if (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME)) {\n\t\t\tif (size < xattr_name_len)\n\t\t\t\tres = -ERANGE;\n\t\t\telse {\n\t\t\t\tres = copy_name(buffer,\n\t\t\t\t\t\tHFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\t\t\tsymbols_count);\n\t\t\t}\n\t\t}\n\t}\n\nend_listxattr_finder_info:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tssize_t err;\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 key_len = 0;\n\tstruct hfsplus_attr_key attr_key;\n\tchar *strbuf;\n\tint xattr_name_len;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tres = hfsplus_listxattr_finder_info(dentry, buffer, size);\n\tif (res < 0)\n\t\treturn res;\n\telse if (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn (res == 0) ? -EOPNOTSUPP : res;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN +\n\t\t\tXATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = hfsplus_find_attr(inode->i_sb, inode->i_ino, NULL, &fd);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tif (res == 0)\n\t\t\t\tres = -ENODATA;\n\t\t\tgoto end_listxattr;\n\t\t} else {\n\t\t\tres = err;\n\t\t\tgoto end_listxattr;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tkey_len = hfs_bnode_read_u16(fd.bnode, fd.keyoffset);\n\t\tif (key_len == 0 || key_len > fd.tree->max_key_len) {\n\t\t\tpr_err(\"invalid xattr key length: %d\\n\", key_len);\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &attr_key,\n\t\t\t\tfd.keyoffset, key_len + sizeof(key_len));\n\n\t\tif (be32_to_cpu(attr_key.cnid) != inode->i_ino)\n\t\t\tgoto end_listxattr;\n\n\t\txattr_name_len = NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN;\n\t\tif (hfsplus_uni2asc(inode->i_sb,\n\t\t\t(const struct hfsplus_unistr *)&fd.key->attr.key_name,\n\t\t\t\t\tstrbuf, &xattr_name_len)) {\n\t\t\tpr_err(\"unicode conversion failed\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto end_listxattr;\n\t\t}\n\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(strbuf))\n\t\t\t\tres += name_len(strbuf, xattr_name_len);\n\t\t} else if (can_list(strbuf)) {\n\t\t\tif (size < (res + name_len(strbuf, xattr_name_len))) {\n\t\t\t\tres = -ERANGE;\n\t\t\t\tgoto end_listxattr;\n\t\t\t} else\n\t\t\t\tres += copy_name(buffer + res,\n\t\t\t\t\t\tstrbuf, xattr_name_len);\n\t\t}\n\n\t\tif (hfs_brec_goto(&fd, 1))\n\t\t\tgoto end_listxattr;\n\t}\n\nend_listxattr:\n\tkfree(strbuf);\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_listxattr_finder_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "573-639",
    "snippet": "static ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,\n\t\t\t\t\t\tchar *buffer, size_t size)\n{\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\tunsigned long len, found_bit;\n\tint xattr_name_len, symbols_count;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn res;\n\t}\n\n\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\tif (res)\n\t\tgoto end_listxattr_finder_info;\n\n\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (entry_type == HFSPLUS_FOLDER) {\n\t\tlen = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)folder_finder_info, len*8);\n\t} else if (entry_type == HFSPLUS_FILE) {\n\t\tlen = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)file_finder_info, len*8);\n\t} else {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto end_listxattr_finder_info;\n\t}\n\n\tif (found_bit >= (len*8))\n\t\tres = 0;\n\telse {\n\t\tsymbols_count = sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME) - 1;\n\t\txattr_name_len =\n\t\t\tname_len(HFSPLUS_XATTR_FINDER_INFO_NAME, symbols_count);\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME))\n\t\t\t\tres = xattr_name_len;\n\t\t} else if (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME)) {\n\t\t\tif (size < xattr_name_len)\n\t\t\t\tres = -ERANGE;\n\t\t\telse {\n\t\t\t\tres = copy_name(buffer,\n\t\t\t\t\t\tHFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\t\t\tsymbols_count);\n\t\t\t}\n\t\t}\n\t}\n\nend_listxattr_finder_info:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_name",
          "args": [
            "buffer",
            "HFSPLUS_XATTR_FINDER_INFO_NAME",
            "symbols_count"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "409-425",
          "snippet": "static int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_list",
          "args": [
            "HFSPLUS_XATTR_FINDER_INFO_NAME"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "can_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "563-571",
          "snippet": "static inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_len",
          "args": [
            "HFSPLUS_XATTR_FINDER_INFO_NAME",
            "symbols_count"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "name_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "399-407",
          "snippet": "static int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "(void *)file_finder_info",
            "len*8"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "file_finder_info",
            "fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info)",
            "len"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "(void *)folder_finder_info",
            "len*8"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd.bnode",
            "fd.entryoffset"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&fd"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic ssize_t hfsplus_listxattr_finder_info(struct dentry *dentry,\n\t\t\t\t\t\tchar *buffer, size_t size)\n{\n\tssize_t res = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\tunsigned long len, found_bit;\n\tint xattr_name_len, symbols_count;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn res;\n\t}\n\n\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\tif (res)\n\t\tgoto end_listxattr_finder_info;\n\n\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (entry_type == HFSPLUS_FOLDER) {\n\t\tlen = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)folder_finder_info, len*8);\n\t} else if (entry_type == HFSPLUS_FILE) {\n\t\tlen = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tlen);\n\t\tfound_bit = find_first_bit((void *)file_finder_info, len*8);\n\t} else {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto end_listxattr_finder_info;\n\t}\n\n\tif (found_bit >= (len*8))\n\t\tres = 0;\n\telse {\n\t\tsymbols_count = sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME) - 1;\n\t\txattr_name_len =\n\t\t\tname_len(HFSPLUS_XATTR_FINDER_INFO_NAME, symbols_count);\n\t\tif (!buffer || !size) {\n\t\t\tif (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME))\n\t\t\t\tres = xattr_name_len;\n\t\t} else if (can_list(HFSPLUS_XATTR_FINDER_INFO_NAME)) {\n\t\t\tif (size < xattr_name_len)\n\t\t\t\tres = -ERANGE;\n\t\t\telse {\n\t\t\t\tres = copy_name(buffer,\n\t\t\t\t\t\tHFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\t\t\tsymbols_count);\n\t\t\t}\n\t\t}\n\t}\n\nend_listxattr_finder_info:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
  },
  {
    "function_name": "can_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "563-571",
    "snippet": "static inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "xattr_name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic inline int can_list(const char *xattr_name)\n{\n\tif (!xattr_name)\n\t\treturn 0;\n\n\treturn strncmp(xattr_name, XATTR_TRUSTED_PREFIX,\n\t\t\tXATTR_TRUSTED_PREFIX_LEN) ||\n\t\t\t\tcapable(CAP_SYS_ADMIN);\n}"
  },
  {
    "function_name": "__hfsplus_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "477-561",
    "snippet": "ssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_entry",
          "args": [
            "entry"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "87-91",
          "snippet": "void hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "entry->inline_data.raw_bytes",
            "record_length"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "entry",
            "fd.entryoffset",
            "offsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid xattr record\\n\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"only inline data xattr are supported\\n\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid xattr record size\\n\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd.bnode",
            "fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength)"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "xattr_record_type"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"xattr searching failed\\n\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_find_attr",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "name",
            "&fd"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "136-166",
          "snippet": "int hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\n\t\t\tconst char *name, struct hfs_find_data *fd)\n{\n\tint err = 0;\n\n\thfs_dbg(ATTR_MOD, \"find_attr: %s,%d\\n\", name ? name : NULL, cnid);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t} else {\n\t\terr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t\terr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\n\t\tif (err)\n\t\t\tgoto failed_find_attr;\n\t}\n\nfailed_find_attr:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->attr_tree",
            "&fd"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't allocate xattr entry\\n\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_alloc_attr_entry",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_alloc_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "82-85",
          "snippet": "hfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_getxattr_finder_info",
          "args": [
            "inode",
            "value",
            "size"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_getxattr_finder_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "427-475",
          "snippet": "static ssize_t hfsplus_getxattr_finder_info(struct inode *inode,\n\t\t\t\t\t\tvoid *value, size_t size)\n{\n\tssize_t res = 0;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu16 folder_rec_len = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\tu16 file_rec_len = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\tu16 record_len = max(folder_rec_len, file_rec_len);\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\n\tif (size >= record_len) {\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res) {\n\t\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\t\treturn res;\n\t\t}\n\t\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\tif (res)\n\t\t\tgoto end_getxattr_finder_info;\n\t\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\n\t\tif (entry_type == HFSPLUS_FOLDER) {\n\t\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tfolder_rec_len);\n\t\t\tmemcpy(value, folder_finder_info, folder_rec_len);\n\t\t\tres = folder_rec_len;\n\t\t} else if (entry_type == HFSPLUS_FILE) {\n\t\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tfile_rec_len);\n\t\t\tmemcpy(value, file_finder_info, file_rec_len);\n\t\t\tres = file_rec_len;\n\t\t} else {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto end_getxattr_finder_info;\n\t\t}\n\t} else\n\t\tres = size ? -ERANGE : record_len;\n\nend_getxattr_finder_info:\n\tif (size >= record_len)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic ssize_t hfsplus_getxattr_finder_info(struct inode *inode,\n\t\t\t\t\t\tvoid *value, size_t size)\n{\n\tssize_t res = 0;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu16 folder_rec_len = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\tu16 file_rec_len = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\tu16 record_len = max(folder_rec_len, file_rec_len);\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\n\tif (size >= record_len) {\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res) {\n\t\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\t\treturn res;\n\t\t}\n\t\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\tif (res)\n\t\t\tgoto end_getxattr_finder_info;\n\t\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\n\t\tif (entry_type == HFSPLUS_FOLDER) {\n\t\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tfolder_rec_len);\n\t\t\tmemcpy(value, folder_finder_info, folder_rec_len);\n\t\t\tres = folder_rec_len;\n\t\t} else if (entry_type == HFSPLUS_FILE) {\n\t\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tfile_rec_len);\n\t\t\tmemcpy(value, file_finder_info, file_rec_len);\n\t\t\tres = file_rec_len;\n\t\t} else {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto end_getxattr_finder_info;\n\t\t}\n\t} else\n\t\tres = size ? -ERANGE : record_len;\n\nend_getxattr_finder_info:\n\tif (size >= record_len)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp_xattr_finder_info",
          "args": [
            "name"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_xattr_finder_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "29-36",
          "snippet": "static int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_getxattr_finder_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "427-475",
    "snippet": "static ssize_t hfsplus_getxattr_finder_info(struct inode *inode,\n\t\t\t\t\t\tvoid *value, size_t size)\n{\n\tssize_t res = 0;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu16 folder_rec_len = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\tu16 file_rec_len = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\tu16 record_len = max(folder_rec_len, file_rec_len);\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\n\tif (size >= record_len) {\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res) {\n\t\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\t\treturn res;\n\t\t}\n\t\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\tif (res)\n\t\t\tgoto end_getxattr_finder_info;\n\t\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\n\t\tif (entry_type == HFSPLUS_FOLDER) {\n\t\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tfolder_rec_len);\n\t\t\tmemcpy(value, folder_finder_info, folder_rec_len);\n\t\t\tres = folder_rec_len;\n\t\t} else if (entry_type == HFSPLUS_FILE) {\n\t\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tfile_rec_len);\n\t\t\tmemcpy(value, file_finder_info, file_rec_len);\n\t\t\tres = file_rec_len;\n\t\t} else {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto end_getxattr_finder_info;\n\t\t}\n\t} else\n\t\tres = size ? -ERANGE : record_len;\n\nend_getxattr_finder_info:\n\tif (size >= record_len)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "file_finder_info",
            "file_rec_len"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "file_finder_info",
            "fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info)",
            "file_rec_len"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "folder_finder_info",
            "folder_rec_len"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd.bnode",
            "fd.entryoffset"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&fd"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "folder_rec_len",
            "file_rec_len"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic ssize_t hfsplus_getxattr_finder_info(struct inode *inode,\n\t\t\t\t\t\tvoid *value, size_t size)\n{\n\tssize_t res = 0;\n\tstruct hfs_find_data fd;\n\tu16 entry_type;\n\tu16 folder_rec_len = sizeof(struct DInfo) + sizeof(struct DXInfo);\n\tu16 file_rec_len = sizeof(struct FInfo) + sizeof(struct FXInfo);\n\tu16 record_len = max(folder_rec_len, file_rec_len);\n\tu8 folder_finder_info[sizeof(struct DInfo) + sizeof(struct DXInfo)];\n\tu8 file_finder_info[sizeof(struct FInfo) + sizeof(struct FXInfo)];\n\n\tif (size >= record_len) {\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (res) {\n\t\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\t\treturn res;\n\t\t}\n\t\tres = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\tif (res)\n\t\t\tgoto end_getxattr_finder_info;\n\t\tentry_type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\n\t\tif (entry_type == HFSPLUS_FOLDER) {\n\t\t\thfs_bnode_read(fd.bnode, folder_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, user_info),\n\t\t\t\tfolder_rec_len);\n\t\t\tmemcpy(value, folder_finder_info, folder_rec_len);\n\t\t\tres = folder_rec_len;\n\t\t} else if (entry_type == HFSPLUS_FILE) {\n\t\t\thfs_bnode_read(fd.bnode, file_finder_info,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, user_info),\n\t\t\t\tfile_rec_len);\n\t\t\tmemcpy(value, file_finder_info, file_rec_len);\n\t\t\tres = file_rec_len;\n\t\t} else {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto end_getxattr_finder_info;\n\t\t}\n\t} else\n\t\tres = size ? -ERANGE : record_len;\n\nend_getxattr_finder_info:\n\tif (size >= record_len)\n\t\thfs_find_exit(&fd);\n\treturn res;\n}"
  },
  {
    "function_name": "copy_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "409-425",
    "snippet": "static int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer + offset + name_len",
            "0",
            "1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buffer + offset",
            "xattr_name",
            "name_len"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buffer",
            "XATTR_MAC_OSX_PREFIX",
            "XATTR_MAC_OSX_PREFIX_LEN"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "xattr_name"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "47-56",
          "snippet": "static inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int copy_name(char *buffer, const char *xattr_name, int name_len)\n{\n\tint len = name_len;\n\tint offset = 0;\n\n\tif (!is_known_namespace(xattr_name)) {\n\t\tstrncpy(buffer, XATTR_MAC_OSX_PREFIX, XATTR_MAC_OSX_PREFIX_LEN);\n\t\toffset += XATTR_MAC_OSX_PREFIX_LEN;\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\t}\n\n\tstrncpy(buffer + offset, xattr_name, name_len);\n\tmemset(buffer + offset + name_len, 0, 1);\n\tlen += 1;\n\n\treturn len;\n}"
  },
  {
    "function_name": "name_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "399-407",
    "snippet": "static int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_known_namespace",
          "args": [
            "xattr_name"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "is_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "47-56",
          "snippet": "static inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int name_len(const char *xattr_name, int xattr_name_len)\n{\n\tint len = xattr_name_len + 1;\n\n\tif (!is_known_namespace(xattr_name))\n\t\tlen += XATTR_MAC_OSX_PREFIX_LEN;\n\n\treturn len;\n}"
  },
  {
    "function_name": "__hfsplus_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "263-397",
    "snippet": "int __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&cat_fd"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid catalog entry type\\n\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "cat_fd.bnode",
            "cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags)",
            "cat_entry_flags"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp_xattr_acl",
          "args": [
            "name"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_xattr_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "38-45",
          "snippet": "static int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "cat_fd.bnode",
            "cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_create_attr",
          "args": [
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "193-258",
          "snippet": "int hfsplus_create_attr(struct inode *inode,\n\t\t\t\tconst char *name,\n\t\t\t\tconst void *value, size_t size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry_ptr;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(ATTR_MOD, \"create_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_ptr = hfsplus_alloc_attr_entry();\n\tif (!entry_ptr)\n\t\treturn -ENOMEM;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\tgoto failed_init_create_attr;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto failed_create_attr;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\t/* Mac OS X supports only inline data attributes. */\n\tentry_size = hfsplus_attr_build_record(entry_ptr,\n\t\t\t\t\tHFSPLUS_ATTR_INLINE_DATA,\n\t\t\t\t\tinode->i_ino,\n\t\t\t\t\tvalue, size);\n\tif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_insert(&fd, entry_ptr, entry_size);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\nfailed_create_attr:\n\thfs_find_exit(&fd);\n\nfailed_init_create_attr:\n\thfsplus_destroy_attr_entry(entry_ptr);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [
            "#define HFSPLUS_INVALID_ATTR_RECORD -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\n#define HFSPLUS_INVALID_ATTR_RECORD -1\n\nint hfsplus_create_attr(struct inode *inode,\n\t\t\t\tconst char *name,\n\t\t\t\tconst void *value, size_t size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry_ptr;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(ATTR_MOD, \"create_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry_ptr = hfsplus_alloc_attr_entry();\n\tif (!entry_ptr)\n\t\treturn -ENOMEM;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\tgoto failed_init_create_attr;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto failed_create_attr;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\t/* Mac OS X supports only inline data attributes. */\n\tentry_size = hfsplus_attr_build_record(entry_ptr,\n\t\t\t\t\tHFSPLUS_ATTR_INLINE_DATA,\n\t\t\t\t\tinode->i_ino,\n\t\t\t\t\tvalue, size);\n\tif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\n\t\terr = -EINVAL;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto failed_create_attr;\n\t}\n\n\terr = hfs_brec_insert(&fd, entry_ptr, entry_size);\n\tif (err)\n\t\tgoto failed_create_attr;\n\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\n\nfailed_create_attr:\n\thfs_find_exit(&fd);\n\nfailed_init_create_attr:\n\thfsplus_destroy_attr_entry(entry_ptr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot replace xattr\\n\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_attr",
          "args": [
            "inode",
            "name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "297-337",
          "snippet": "int hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_attr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_attr: %s,%ld\\n\",\n\t\tname ? name : NULL, inode->i_ino);\n\n\tif (!HFSPLUS_SB(sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (name) {\n\t\terr = hfsplus_attr_build_key(sb, fd.search_key,\n\t\t\t\t\t\tinode->i_ino, name);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid extended attribute name\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\n\tif (err)\n\t\tgoto out;\n\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"xattr exists yet\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_attr_exists",
          "args": [
            "inode",
            "name"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_attr_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "168-191",
          "snippet": "int hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_attr_exists(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\n\tif (!HFSPLUS_SB(sb)->attr_tree)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn 0;\n\n\terr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\n\tif (err)\n\t\tgoto attr_not_found;\n\n\thfs_find_exit(&fd);\n\treturn 1;\n\nattr_not_found:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_create_attributes_file",
          "args": [
            "inode->i_sb"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_attributes_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "126-261",
          "snippet": "static int hfsplus_create_attributes_file(struct super_block *sb)\n{\n\tint err = 0;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *attr_file;\n\tstruct hfsplus_inode_info *hip;\n\tu32 clump_size;\n\tu16 node_size = HFSPLUS_ATTR_TREE_NODE_SIZE;\n\tchar *buf;\n\tint index, written;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint old_state = HFSPLUS_EMPTY_ATTR_TREE;\n\n\thfs_dbg(ATTR_MOD, \"create_attr_file: ino %d\\n\", HFSPLUS_ATTR_CNID);\n\ncheck_attr_tree_state_again:\n\tswitch (atomic_read(&sbi->attr_tree_state)) {\n\tcase HFSPLUS_EMPTY_ATTR_TREE:\n\t\tif (old_state != atomic_cmpxchg(&sbi->attr_tree_state,\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tHFSPLUS_CREATING_ATTR_TREE))\n\t\t\tgoto check_attr_tree_state_again;\n\t\tbreak;\n\tcase HFSPLUS_CREATING_ATTR_TREE:\n\t\t/*\n\t\t * This state means that another thread is in process\n\t\t * of AttributesFile creation. Theoretically, it is\n\t\t * possible to be here. But really __setxattr() method\n\t\t * first of all calls hfs_find_init() for lookup in\n\t\t * B-tree of CatalogFile. This method locks mutex of\n\t\t * CatalogFile's B-tree. As a result, if some thread\n\t\t * is inside AttributedFile creation operation then\n\t\t * another threads will be waiting unlocking of\n\t\t * CatalogFile's B-tree's mutex. However, if code will\n\t\t * change then we will return error code (-EAGAIN) from\n\t\t * here. Really, it means that first try to set of xattr\n\t\t * fails with error but second attempt will have success.\n\t\t */\n\t\treturn -EAGAIN;\n\tcase HFSPLUS_VALID_ATTR_TREE:\n\t\treturn 0;\n\tcase HFSPLUS_FAILED_ATTR_TREE:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tattr_file = hfsplus_iget(sb, HFSPLUS_ATTR_CNID);\n\tif (IS_ERR(attr_file)) {\n\t\tpr_err(\"failed to load attributes file\\n\");\n\t\treturn PTR_ERR(attr_file);\n\t}\n\n\tBUG_ON(i_size_read(attr_file) != 0);\n\n\thip = HFSPLUS_I(attr_file);\n\n\tclump_size = hfsplus_calc_btree_clump_size(sb->s_blocksize,\n\t\t\t\t\t\t    node_size,\n\t\t\t\t\t\t    sbi->sect_count,\n\t\t\t\t\t\t    HFSPLUS_ATTR_CNID);\n\n\tmutex_lock(&hip->extents_lock);\n\thip->clump_blocks = clump_size >> sbi->alloc_blksz_shift;\n\tmutex_unlock(&hip->extents_lock);\n\n\tif (sbi->free_blocks <= (hip->clump_blocks << 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\twhile (hip->alloc_blocks < hip->clump_blocks) {\n\t\terr = hfsplus_file_extend(attr_file, false);\n\t\tif (unlikely(err)) {\n\t\t\tpr_err(\"failed to extend attributes file\\n\");\n\t\t\tgoto end_attr_file_creation;\n\t\t}\n\t\thip->phys_size = attr_file->i_size =\n\t\t\t(loff_t)hip->alloc_blocks << sbi->alloc_blksz_shift;\n\t\thip->fs_blocks = hip->alloc_blocks << sbi->fs_shift;\n\t\tinode_set_bytes(attr_file, attr_file->i_size);\n\t}\n\n\tbuf = kzalloc(node_size, GFP_NOFS);\n\tif (!buf) {\n\t\tpr_err(\"failed to allocate memory for header node\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\thfsplus_init_header_node(attr_file, clump_size, buf, node_size);\n\n\tmapping = attr_file->i_mapping;\n\n\tindex = 0;\n\twritten = 0;\n\tfor (; written < node_size; index++, written += PAGE_CACHE_SIZE) {\n\t\tvoid *kaddr;\n\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto failed_header_node_init;\n\t\t}\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, buf + written,\n\t\t\tmin_t(size_t, PAGE_CACHE_SIZE, node_size - written));\n\t\tkunmap_atomic(kaddr);\n\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\n\thfsplus_mark_inode_dirty(attr_file, HFSPLUS_I_ATTR_DIRTY);\n\n\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\tif (!sbi->attr_tree)\n\t\tpr_err(\"failed to load attributes file\\n\");\n\nfailed_header_node_init:\n\tkfree(buf);\n\nend_attr_file_creation:\n\tiput(attr_file);\n\n\tif (!err)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\telse if (err == -ENOSPC)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\telse\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_FAILED_ATTR_TREE);\n\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_create_attributes_file(struct super_block *sb)\n{\n\tint err = 0;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *attr_file;\n\tstruct hfsplus_inode_info *hip;\n\tu32 clump_size;\n\tu16 node_size = HFSPLUS_ATTR_TREE_NODE_SIZE;\n\tchar *buf;\n\tint index, written;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint old_state = HFSPLUS_EMPTY_ATTR_TREE;\n\n\thfs_dbg(ATTR_MOD, \"create_attr_file: ino %d\\n\", HFSPLUS_ATTR_CNID);\n\ncheck_attr_tree_state_again:\n\tswitch (atomic_read(&sbi->attr_tree_state)) {\n\tcase HFSPLUS_EMPTY_ATTR_TREE:\n\t\tif (old_state != atomic_cmpxchg(&sbi->attr_tree_state,\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tHFSPLUS_CREATING_ATTR_TREE))\n\t\t\tgoto check_attr_tree_state_again;\n\t\tbreak;\n\tcase HFSPLUS_CREATING_ATTR_TREE:\n\t\t/*\n\t\t * This state means that another thread is in process\n\t\t * of AttributesFile creation. Theoretically, it is\n\t\t * possible to be here. But really __setxattr() method\n\t\t * first of all calls hfs_find_init() for lookup in\n\t\t * B-tree of CatalogFile. This method locks mutex of\n\t\t * CatalogFile's B-tree. As a result, if some thread\n\t\t * is inside AttributedFile creation operation then\n\t\t * another threads will be waiting unlocking of\n\t\t * CatalogFile's B-tree's mutex. However, if code will\n\t\t * change then we will return error code (-EAGAIN) from\n\t\t * here. Really, it means that first try to set of xattr\n\t\t * fails with error but second attempt will have success.\n\t\t */\n\t\treturn -EAGAIN;\n\tcase HFSPLUS_VALID_ATTR_TREE:\n\t\treturn 0;\n\tcase HFSPLUS_FAILED_ATTR_TREE:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tattr_file = hfsplus_iget(sb, HFSPLUS_ATTR_CNID);\n\tif (IS_ERR(attr_file)) {\n\t\tpr_err(\"failed to load attributes file\\n\");\n\t\treturn PTR_ERR(attr_file);\n\t}\n\n\tBUG_ON(i_size_read(attr_file) != 0);\n\n\thip = HFSPLUS_I(attr_file);\n\n\tclump_size = hfsplus_calc_btree_clump_size(sb->s_blocksize,\n\t\t\t\t\t\t    node_size,\n\t\t\t\t\t\t    sbi->sect_count,\n\t\t\t\t\t\t    HFSPLUS_ATTR_CNID);\n\n\tmutex_lock(&hip->extents_lock);\n\thip->clump_blocks = clump_size >> sbi->alloc_blksz_shift;\n\tmutex_unlock(&hip->extents_lock);\n\n\tif (sbi->free_blocks <= (hip->clump_blocks << 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\twhile (hip->alloc_blocks < hip->clump_blocks) {\n\t\terr = hfsplus_file_extend(attr_file, false);\n\t\tif (unlikely(err)) {\n\t\t\tpr_err(\"failed to extend attributes file\\n\");\n\t\t\tgoto end_attr_file_creation;\n\t\t}\n\t\thip->phys_size = attr_file->i_size =\n\t\t\t(loff_t)hip->alloc_blocks << sbi->alloc_blksz_shift;\n\t\thip->fs_blocks = hip->alloc_blocks << sbi->fs_shift;\n\t\tinode_set_bytes(attr_file, attr_file->i_size);\n\t}\n\n\tbuf = kzalloc(node_size, GFP_NOFS);\n\tif (!buf) {\n\t\tpr_err(\"failed to allocate memory for header node\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\thfsplus_init_header_node(attr_file, clump_size, buf, node_size);\n\n\tmapping = attr_file->i_mapping;\n\n\tindex = 0;\n\twritten = 0;\n\tfor (; written < node_size; index++, written += PAGE_CACHE_SIZE) {\n\t\tvoid *kaddr;\n\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto failed_header_node_init;\n\t\t}\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, buf + written,\n\t\t\tmin_t(size_t, PAGE_CACHE_SIZE, node_size - written));\n\t\tkunmap_atomic(kaddr);\n\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\n\thfsplus_mark_inode_dirty(attr_file, HFSPLUS_I_ATTR_DIRTY);\n\n\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\tif (!sbi->attr_tree)\n\t\tpr_err(\"failed to load attributes file\\n\");\n\nfailed_header_node_init:\n\tkfree(buf);\n\nend_attr_file_creation:\n\tiput(attr_file);\n\n\tif (!err)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\telse if (err == -ENOSPC)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\telse\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_FAILED_ATTR_TREE);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "cat_fd.bnode",
            "&entry",
            "cat_fd.entryoffset",
            "sizeof(struct hfsplus_cat_file)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&entry.file.user_info",
            "value",
            "file_finderinfo_len"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&entry.folder.user_info",
            "value",
            "folder_finderinfo_len"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "cat_fd.bnode",
            "&entry",
            "cat_fd.entryoffset",
            "sizeof(hfsplus_cat_entry)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"xattr exists yet\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp_xattr_finder_info",
          "args": [
            "name"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_xattr_finder_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "29-36",
          "snippet": "static int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"catalog searching failed\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&cat_fd"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't init xattr find struct\\n\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->cat_tree",
            "&cat_fd"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_removexattr",
          "args": [
            "inode",
            "name"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "734-804",
          "snippet": "static int hfsplus_removexattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\tu16 flags;\n\tu16 cat_entry_type;\n\tint is_xattr_acl_deleted = 0;\n\tint is_all_xattrs_deleted = 0;\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn -EOPNOTSUPP;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_removexattr;\n\t}\n\n\terr = hfsplus_delete_attr(inode, name);\n\tif (err)\n\t\tgoto end_removexattr;\n\n\tis_xattr_acl_deleted = !strcmp_xattr_acl(name);\n\tis_all_xattrs_deleted = !hfsplus_attr_exists(inode, NULL);\n\n\tif (!is_xattr_acl_deleted && !is_all_xattrs_deleted)\n\t\tgoto end_removexattr;\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_removexattr;\n\t}\n\nend_removexattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\tu16 flags;\n\tu16 cat_entry_type;\n\tint is_xattr_acl_deleted = 0;\n\tint is_all_xattrs_deleted = 0;\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn -EOPNOTSUPP;\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_removexattr;\n\t}\n\n\terr = hfsplus_delete_attr(inode, name);\n\tif (err)\n\t\tgoto end_removexattr;\n\n\tis_xattr_acl_deleted = !strcmp_xattr_acl(name);\n\tis_all_xattrs_deleted = !hfsplus_attr_exists(inode, NULL);\n\n\tif (!is_xattr_acl_deleted && !is_all_xattrs_deleted)\n\t\tgoto end_removexattr;\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tflags = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags));\n\t\tif (is_xattr_acl_deleted)\n\t\t\tflags &= ~HFSPLUS_ACL_EXISTS;\n\t\tif (is_all_xattrs_deleted)\n\t\t\tflags &= ~HFSPLUS_XATTR_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_file, flags),\n\t\t\t\tflags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_removexattr;\n\t}\n\nend_removexattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_create_attributes_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "126-261",
    "snippet": "static int hfsplus_create_attributes_file(struct super_block *sb)\n{\n\tint err = 0;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *attr_file;\n\tstruct hfsplus_inode_info *hip;\n\tu32 clump_size;\n\tu16 node_size = HFSPLUS_ATTR_TREE_NODE_SIZE;\n\tchar *buf;\n\tint index, written;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint old_state = HFSPLUS_EMPTY_ATTR_TREE;\n\n\thfs_dbg(ATTR_MOD, \"create_attr_file: ino %d\\n\", HFSPLUS_ATTR_CNID);\n\ncheck_attr_tree_state_again:\n\tswitch (atomic_read(&sbi->attr_tree_state)) {\n\tcase HFSPLUS_EMPTY_ATTR_TREE:\n\t\tif (old_state != atomic_cmpxchg(&sbi->attr_tree_state,\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tHFSPLUS_CREATING_ATTR_TREE))\n\t\t\tgoto check_attr_tree_state_again;\n\t\tbreak;\n\tcase HFSPLUS_CREATING_ATTR_TREE:\n\t\t/*\n\t\t * This state means that another thread is in process\n\t\t * of AttributesFile creation. Theoretically, it is\n\t\t * possible to be here. But really __setxattr() method\n\t\t * first of all calls hfs_find_init() for lookup in\n\t\t * B-tree of CatalogFile. This method locks mutex of\n\t\t * CatalogFile's B-tree. As a result, if some thread\n\t\t * is inside AttributedFile creation operation then\n\t\t * another threads will be waiting unlocking of\n\t\t * CatalogFile's B-tree's mutex. However, if code will\n\t\t * change then we will return error code (-EAGAIN) from\n\t\t * here. Really, it means that first try to set of xattr\n\t\t * fails with error but second attempt will have success.\n\t\t */\n\t\treturn -EAGAIN;\n\tcase HFSPLUS_VALID_ATTR_TREE:\n\t\treturn 0;\n\tcase HFSPLUS_FAILED_ATTR_TREE:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tattr_file = hfsplus_iget(sb, HFSPLUS_ATTR_CNID);\n\tif (IS_ERR(attr_file)) {\n\t\tpr_err(\"failed to load attributes file\\n\");\n\t\treturn PTR_ERR(attr_file);\n\t}\n\n\tBUG_ON(i_size_read(attr_file) != 0);\n\n\thip = HFSPLUS_I(attr_file);\n\n\tclump_size = hfsplus_calc_btree_clump_size(sb->s_blocksize,\n\t\t\t\t\t\t    node_size,\n\t\t\t\t\t\t    sbi->sect_count,\n\t\t\t\t\t\t    HFSPLUS_ATTR_CNID);\n\n\tmutex_lock(&hip->extents_lock);\n\thip->clump_blocks = clump_size >> sbi->alloc_blksz_shift;\n\tmutex_unlock(&hip->extents_lock);\n\n\tif (sbi->free_blocks <= (hip->clump_blocks << 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\twhile (hip->alloc_blocks < hip->clump_blocks) {\n\t\terr = hfsplus_file_extend(attr_file, false);\n\t\tif (unlikely(err)) {\n\t\t\tpr_err(\"failed to extend attributes file\\n\");\n\t\t\tgoto end_attr_file_creation;\n\t\t}\n\t\thip->phys_size = attr_file->i_size =\n\t\t\t(loff_t)hip->alloc_blocks << sbi->alloc_blksz_shift;\n\t\thip->fs_blocks = hip->alloc_blocks << sbi->fs_shift;\n\t\tinode_set_bytes(attr_file, attr_file->i_size);\n\t}\n\n\tbuf = kzalloc(node_size, GFP_NOFS);\n\tif (!buf) {\n\t\tpr_err(\"failed to allocate memory for header node\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\thfsplus_init_header_node(attr_file, clump_size, buf, node_size);\n\n\tmapping = attr_file->i_mapping;\n\n\tindex = 0;\n\twritten = 0;\n\tfor (; written < node_size; index++, written += PAGE_CACHE_SIZE) {\n\t\tvoid *kaddr;\n\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto failed_header_node_init;\n\t\t}\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, buf + written,\n\t\t\tmin_t(size_t, PAGE_CACHE_SIZE, node_size - written));\n\t\tkunmap_atomic(kaddr);\n\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\n\thfsplus_mark_inode_dirty(attr_file, HFSPLUS_I_ATTR_DIRTY);\n\n\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\tif (!sbi->attr_tree)\n\t\tpr_err(\"failed to load attributes file\\n\");\n\nfailed_header_node_init:\n\tkfree(buf);\n\nend_attr_file_creation:\n\tiput(attr_file);\n\n\tif (!err)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\telse if (err == -ENOSPC)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\telse\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_FAILED_ATTR_TREE);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->attr_tree_state",
            "HFSPLUS_FAILED_ATTR_TREE"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->attr_tree_state",
            "HFSPLUS_EMPTY_ATTR_TREE"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->attr_tree_state",
            "HFSPLUS_VALID_ATTR_TREE"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "attr_file"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load attributes file\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_open",
          "args": [
            "sb",
            "HFSPLUS_ATTR_CNID"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "132-254",
          "snippet": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "attr_file",
            "HFSPLUS_I_ATTR_DIRTY"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "buf + written",
            "min_t(size_t, PAGE_CACHE_SIZE, node_size - written)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_CACHE_SIZE",
            "node_size - written"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "index",
            "NULL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_init_header_node",
          "args": [
            "attr_file",
            "clump_size",
            "buf",
            "node_size"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_header_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "58-124",
          "snippet": "static void hfsplus_init_header_node(struct inode *attr_file,\n\t\t\t\t\tu32 clump_size,\n\t\t\t\t\tchar *buf, u16 node_size)\n{\n\tstruct hfs_bnode_desc *desc;\n\tstruct hfs_btree_header_rec *head;\n\tu16 offset;\n\t__be16 *rec_offsets;\n\tu32 hdr_node_map_rec_bits;\n\tchar *bmp;\n\tu32 used_nodes;\n\tu32 used_bmp_bytes;\n\tu64 tmp;\n\n\thfs_dbg(ATTR_MOD, \"init_hdr_attr_file: clump %u, node_size %u\\n\",\n\t\tclump_size, node_size);\n\n\t/* The end of the node contains list of record offsets */\n\trec_offsets = (__be16 *)(buf + node_size);\n\n\tdesc = (struct hfs_bnode_desc *)buf;\n\tdesc->type = HFS_NODE_HEADER;\n\tdesc->num_recs = cpu_to_be16(HFSPLUS_BTREE_HDR_NODE_RECS_COUNT);\n\toffset = sizeof(struct hfs_bnode_desc);\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thead = (struct hfs_btree_header_rec *)(buf + offset);\n\thead->node_size = cpu_to_be16(node_size);\n\ttmp = i_size_read(attr_file);\n\tdo_div(tmp, node_size);\n\thead->node_count = cpu_to_be32(tmp);\n\thead->free_nodes = cpu_to_be32(be32_to_cpu(head->node_count) - 1);\n\thead->clump_size = cpu_to_be32(clump_size);\n\thead->attributes |= cpu_to_be32(HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS);\n\thead->max_key_len = cpu_to_be16(HFSPLUS_ATTR_KEYLEN - sizeof(u16));\n\toffset += sizeof(struct hfs_btree_header_rec);\n\t*--rec_offsets = cpu_to_be16(offset);\n\toffset += HFSPLUS_BTREE_HDR_USER_BYTES;\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thdr_node_map_rec_bits = 8 * (node_size - offset - (4 * sizeof(u16)));\n\tif (be32_to_cpu(head->node_count) > hdr_node_map_rec_bits) {\n\t\tu32 map_node_bits;\n\t\tu32 map_nodes;\n\n\t\tdesc->next = cpu_to_be32(be32_to_cpu(head->leaf_tail) + 1);\n\t\tmap_node_bits = 8 * (node_size - sizeof(struct hfs_bnode_desc) -\n\t\t\t\t\t(2 * sizeof(u16)) - 2);\n\t\tmap_nodes = (be32_to_cpu(head->node_count) -\n\t\t\t\thdr_node_map_rec_bits +\n\t\t\t\t(map_node_bits - 1)) / map_node_bits;\n\t\tbe32_add_cpu(&head->free_nodes, 0 - map_nodes);\n\t}\n\n\tbmp = buf + offset;\n\tused_nodes =\n\t\tbe32_to_cpu(head->node_count) - be32_to_cpu(head->free_nodes);\n\tused_bmp_bytes = used_nodes / 8;\n\tif (used_bmp_bytes) {\n\t\tmemset(bmp, 0xFF, used_bmp_bytes);\n\t\tbmp += used_bmp_bytes;\n\t\tused_nodes %= 8;\n\t}\n\t*bmp = ~(0xFF >> used_nodes);\n\toffset += hdr_node_map_rec_bits / 8;\n\t*--rec_offsets = cpu_to_be16(offset);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_init_header_node(struct inode *attr_file,\n\t\t\t\t\tu32 clump_size,\n\t\t\t\t\tchar *buf, u16 node_size)\n{\n\tstruct hfs_bnode_desc *desc;\n\tstruct hfs_btree_header_rec *head;\n\tu16 offset;\n\t__be16 *rec_offsets;\n\tu32 hdr_node_map_rec_bits;\n\tchar *bmp;\n\tu32 used_nodes;\n\tu32 used_bmp_bytes;\n\tu64 tmp;\n\n\thfs_dbg(ATTR_MOD, \"init_hdr_attr_file: clump %u, node_size %u\\n\",\n\t\tclump_size, node_size);\n\n\t/* The end of the node contains list of record offsets */\n\trec_offsets = (__be16 *)(buf + node_size);\n\n\tdesc = (struct hfs_bnode_desc *)buf;\n\tdesc->type = HFS_NODE_HEADER;\n\tdesc->num_recs = cpu_to_be16(HFSPLUS_BTREE_HDR_NODE_RECS_COUNT);\n\toffset = sizeof(struct hfs_bnode_desc);\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thead = (struct hfs_btree_header_rec *)(buf + offset);\n\thead->node_size = cpu_to_be16(node_size);\n\ttmp = i_size_read(attr_file);\n\tdo_div(tmp, node_size);\n\thead->node_count = cpu_to_be32(tmp);\n\thead->free_nodes = cpu_to_be32(be32_to_cpu(head->node_count) - 1);\n\thead->clump_size = cpu_to_be32(clump_size);\n\thead->attributes |= cpu_to_be32(HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS);\n\thead->max_key_len = cpu_to_be16(HFSPLUS_ATTR_KEYLEN - sizeof(u16));\n\toffset += sizeof(struct hfs_btree_header_rec);\n\t*--rec_offsets = cpu_to_be16(offset);\n\toffset += HFSPLUS_BTREE_HDR_USER_BYTES;\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thdr_node_map_rec_bits = 8 * (node_size - offset - (4 * sizeof(u16)));\n\tif (be32_to_cpu(head->node_count) > hdr_node_map_rec_bits) {\n\t\tu32 map_node_bits;\n\t\tu32 map_nodes;\n\n\t\tdesc->next = cpu_to_be32(be32_to_cpu(head->leaf_tail) + 1);\n\t\tmap_node_bits = 8 * (node_size - sizeof(struct hfs_bnode_desc) -\n\t\t\t\t\t(2 * sizeof(u16)) - 2);\n\t\tmap_nodes = (be32_to_cpu(head->node_count) -\n\t\t\t\thdr_node_map_rec_bits +\n\t\t\t\t(map_node_bits - 1)) / map_node_bits;\n\t\tbe32_add_cpu(&head->free_nodes, 0 - map_nodes);\n\t}\n\n\tbmp = buf + offset;\n\tused_nodes =\n\t\tbe32_to_cpu(head->node_count) - be32_to_cpu(head->free_nodes);\n\tused_bmp_bytes = used_nodes / 8;\n\tif (used_bmp_bytes) {\n\t\tmemset(bmp, 0xFF, used_bmp_bytes);\n\t\tbmp += used_bmp_bytes;\n\t\tused_nodes %= 8;\n\t}\n\t*bmp = ~(0xFF >> used_nodes);\n\toffset += hdr_node_map_rec_bits / 8;\n\t*--rec_offsets = cpu_to_be16(offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to allocate memory for header node\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "node_size",
            "GFP_NOFS"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "attr_file",
            "attr_file->i_size"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to extend attributes file\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_file_extend",
          "args": [
            "attr_file",
            "false"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "428-529",
          "snippet": "int hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_calc_btree_clump_size",
          "args": [
            "sb->s_blocksize",
            "node_size",
            "sbi->sect_count",
            "HFSPLUS_ATTR_CNID"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_calc_btree_clump_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "74-129",
          "snippet": "u32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size,\n\t\t\t\t\tu64 sectors, int file_id)\n{\n\tu32 mod = max(node_size, block_size);\n\tu32 clump_size;\n\tint column;\n\tint i;\n\n\t/* Figure out which column of the above table to use for this file. */\n\tswitch (file_id) {\n\tcase HFSPLUS_ATTR_CNID:\n\t\tcolumn = 0;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tcolumn = 1;\n\t\tbreak;\n\tdefault:\n\t\tcolumn = 2;\n\t\tbreak;\n\t}\n\n\t/*\n\t * The default clump size is 0.8% of the volume size. And\n\t * it must also be a multiple of the node and block size.\n\t */\n\tif (sectors < 0x200000) {\n\t\tclump_size = sectors << 2;\t/*  0.8 %  */\n\t\tif (clump_size < (8 * node_size))\n\t\t\tclump_size = 8 * node_size;\n\t} else {\n\t\t/* turn exponent into table index... */\n\t\tfor (i = 0, sectors = sectors >> 22;\n\t\t     sectors && (i < CLUMP_ENTRIES - 1);\n\t\t     ++i, sectors = sectors >> 1) {\n\t\t\t/* empty body */\n\t\t}\n\n\t\tclump_size = clumptbl[column + (i) * 3] * 1024 * 1024;\n\t}\n\n\t/*\n\t * Round the clump size to a multiple of node and block size.\n\t * NOTE: This rounds down.\n\t */\n\tclump_size /= mod;\n\tclump_size *= mod;\n\n\t/*\n\t * Rounding down could have rounded down to 0 if the block size was\n\t * greater than the clump size.  If so, just use one block or node.\n\t */\n\tif (clump_size == 0)\n\t\tclump_size = mod;\n\n\treturn clump_size;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define CLUMP_ENTRIES\t15"
          ],
          "globals_used": [
            "static short clumptbl[CLUMP_ENTRIES * 3] = {\n/*\n *\t    Volume\tAttributes\t Catalog\t Extents\n *\t     Size\tClump (MB)\tClump (MB)\tClump (MB)\n */\n\t/*   1GB */\t  4,\t\t  4,\t\t 4,\n\t/*   2GB */\t  6,\t\t  6,\t\t 4,\n\t/*   4GB */\t  8,\t\t  8,\t\t 4,\n\t/*   8GB */\t 11,\t\t 11,\t\t 5,\n\t/*\n\t * For volumes 16GB and larger, we want to make sure that a full OS\n\t * install won't require fragmentation of the Catalog or Attributes\n\t * B-trees.  We do this by making the clump sizes sufficiently large,\n\t * and by leaving a gap after the B-trees for them to grow into.\n\t *\n\t * For SnowLeopard 10A298, a FullNetInstall with all packages selected\n\t * results in:\n\t * Catalog B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       31616\n\t *\tfreeNodes:         1978\n\t * (used = 231.55 MB)\n\t * Attributes B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       63232\n\t *\tfreeNodes:          958\n\t * (used = 486.52 MB)\n\t *\n\t * We also want Time Machine backup volumes to have a sufficiently\n\t * large clump size to reduce fragmentation.\n\t *\n\t * The series of numbers for Catalog and Attribute form a geometric\n\t * series. For Catalog (16GB to 512GB), each term is 8**(1/5) times\n\t * the previous term.  For Attributes (16GB to 512GB), each term is\n\t * 4**(1/5) times the previous term.  For 1TB to 16TB, each term is\n\t * 2**(1/5) times the previous term.\n\t */\n\t/*  16GB */\t 64,\t\t 32,\t\t 5,\n\t/*  32GB */\t 84,\t\t 49,\t\t 6,\n\t/*  64GB */\t111,\t\t 74,\t\t 7,\n\t/* 128GB */\t147,\t\t111,\t\t 8,\n\t/* 256GB */\t194,\t\t169,\t\t 9,\n\t/* 512GB */\t256,\t\t256,\t\t11,\n\t/*   1TB */\t294,\t\t294,\t\t14,\n\t/*   2TB */\t338,\t\t338,\t\t16,\n\t/*   4TB */\t388,\t\t388,\t\t20,\n\t/*   8TB */\t446,\t\t446,\t\t25,\n\t/*  16TB */\t512,\t\t512,\t\t32\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define CLUMP_ENTRIES\t15\n\nstatic short clumptbl[CLUMP_ENTRIES * 3] = {\n/*\n *\t    Volume\tAttributes\t Catalog\t Extents\n *\t     Size\tClump (MB)\tClump (MB)\tClump (MB)\n */\n\t/*   1GB */\t  4,\t\t  4,\t\t 4,\n\t/*   2GB */\t  6,\t\t  6,\t\t 4,\n\t/*   4GB */\t  8,\t\t  8,\t\t 4,\n\t/*   8GB */\t 11,\t\t 11,\t\t 5,\n\t/*\n\t * For volumes 16GB and larger, we want to make sure that a full OS\n\t * install won't require fragmentation of the Catalog or Attributes\n\t * B-trees.  We do this by making the clump sizes sufficiently large,\n\t * and by leaving a gap after the B-trees for them to grow into.\n\t *\n\t * For SnowLeopard 10A298, a FullNetInstall with all packages selected\n\t * results in:\n\t * Catalog B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       31616\n\t *\tfreeNodes:         1978\n\t * (used = 231.55 MB)\n\t * Attributes B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       63232\n\t *\tfreeNodes:          958\n\t * (used = 486.52 MB)\n\t *\n\t * We also want Time Machine backup volumes to have a sufficiently\n\t * large clump size to reduce fragmentation.\n\t *\n\t * The series of numbers for Catalog and Attribute form a geometric\n\t * series. For Catalog (16GB to 512GB), each term is 8**(1/5) times\n\t * the previous term.  For Attributes (16GB to 512GB), each term is\n\t * 4**(1/5) times the previous term.  For 1TB to 16TB, each term is\n\t * 2**(1/5) times the previous term.\n\t */\n\t/*  16GB */\t 64,\t\t 32,\t\t 5,\n\t/*  32GB */\t 84,\t\t 49,\t\t 6,\n\t/*  64GB */\t111,\t\t 74,\t\t 7,\n\t/* 128GB */\t147,\t\t111,\t\t 8,\n\t/* 256GB */\t194,\t\t169,\t\t 9,\n\t/* 512GB */\t256,\t\t256,\t\t11,\n\t/*   1TB */\t294,\t\t294,\t\t14,\n\t/*   2TB */\t338,\t\t338,\t\t16,\n\t/*   4TB */\t388,\t\t388,\t\t20,\n\t/*   8TB */\t446,\t\t446,\t\t25,\n\t/*  16TB */\t512,\t\t512,\t\t32\n};\n\nu32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size,\n\t\t\t\t\tu64 sectors, int file_id)\n{\n\tu32 mod = max(node_size, block_size);\n\tu32 clump_size;\n\tint column;\n\tint i;\n\n\t/* Figure out which column of the above table to use for this file. */\n\tswitch (file_id) {\n\tcase HFSPLUS_ATTR_CNID:\n\t\tcolumn = 0;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tcolumn = 1;\n\t\tbreak;\n\tdefault:\n\t\tcolumn = 2;\n\t\tbreak;\n\t}\n\n\t/*\n\t * The default clump size is 0.8% of the volume size. And\n\t * it must also be a multiple of the node and block size.\n\t */\n\tif (sectors < 0x200000) {\n\t\tclump_size = sectors << 2;\t/*  0.8 %  */\n\t\tif (clump_size < (8 * node_size))\n\t\t\tclump_size = 8 * node_size;\n\t} else {\n\t\t/* turn exponent into table index... */\n\t\tfor (i = 0, sectors = sectors >> 22;\n\t\t     sectors && (i < CLUMP_ENTRIES - 1);\n\t\t     ++i, sectors = sectors >> 1) {\n\t\t\t/* empty body */\n\t\t}\n\n\t\tclump_size = clumptbl[column + (i) * 3] * 1024 * 1024;\n\t}\n\n\t/*\n\t * Round the clump size to a multiple of node and block size.\n\t * NOTE: This rounds down.\n\t */\n\tclump_size /= mod;\n\tclump_size *= mod;\n\n\t/*\n\t * Rounding down could have rounded down to 0 if the block size was\n\t * greater than the clump size.  If so, just use one block or node.\n\t */\n\tif (clump_size == 0)\n\t\tclump_size = mod;\n\n\treturn clump_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "attr_file"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i_size_read(attr_file) != 0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "attr_file"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "attr_file"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load attributes file\\n\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "attr_file"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_iget",
          "args": [
            "sb",
            "HFSPLUS_ATTR_CNID"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "56-95",
          "snippet": "struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&sbi->attr_tree_state",
            "old_state",
            "HFSPLUS_CREATING_ATTR_TREE"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->attr_tree_state"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"create_attr_file: ino %d\\n\"",
            "HFSPLUS_ATTR_CNID"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_create_attributes_file(struct super_block *sb)\n{\n\tint err = 0;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *attr_file;\n\tstruct hfsplus_inode_info *hip;\n\tu32 clump_size;\n\tu16 node_size = HFSPLUS_ATTR_TREE_NODE_SIZE;\n\tchar *buf;\n\tint index, written;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint old_state = HFSPLUS_EMPTY_ATTR_TREE;\n\n\thfs_dbg(ATTR_MOD, \"create_attr_file: ino %d\\n\", HFSPLUS_ATTR_CNID);\n\ncheck_attr_tree_state_again:\n\tswitch (atomic_read(&sbi->attr_tree_state)) {\n\tcase HFSPLUS_EMPTY_ATTR_TREE:\n\t\tif (old_state != atomic_cmpxchg(&sbi->attr_tree_state,\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tHFSPLUS_CREATING_ATTR_TREE))\n\t\t\tgoto check_attr_tree_state_again;\n\t\tbreak;\n\tcase HFSPLUS_CREATING_ATTR_TREE:\n\t\t/*\n\t\t * This state means that another thread is in process\n\t\t * of AttributesFile creation. Theoretically, it is\n\t\t * possible to be here. But really __setxattr() method\n\t\t * first of all calls hfs_find_init() for lookup in\n\t\t * B-tree of CatalogFile. This method locks mutex of\n\t\t * CatalogFile's B-tree. As a result, if some thread\n\t\t * is inside AttributedFile creation operation then\n\t\t * another threads will be waiting unlocking of\n\t\t * CatalogFile's B-tree's mutex. However, if code will\n\t\t * change then we will return error code (-EAGAIN) from\n\t\t * here. Really, it means that first try to set of xattr\n\t\t * fails with error but second attempt will have success.\n\t\t */\n\t\treturn -EAGAIN;\n\tcase HFSPLUS_VALID_ATTR_TREE:\n\t\treturn 0;\n\tcase HFSPLUS_FAILED_ATTR_TREE:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tattr_file = hfsplus_iget(sb, HFSPLUS_ATTR_CNID);\n\tif (IS_ERR(attr_file)) {\n\t\tpr_err(\"failed to load attributes file\\n\");\n\t\treturn PTR_ERR(attr_file);\n\t}\n\n\tBUG_ON(i_size_read(attr_file) != 0);\n\n\thip = HFSPLUS_I(attr_file);\n\n\tclump_size = hfsplus_calc_btree_clump_size(sb->s_blocksize,\n\t\t\t\t\t\t    node_size,\n\t\t\t\t\t\t    sbi->sect_count,\n\t\t\t\t\t\t    HFSPLUS_ATTR_CNID);\n\n\tmutex_lock(&hip->extents_lock);\n\thip->clump_blocks = clump_size >> sbi->alloc_blksz_shift;\n\tmutex_unlock(&hip->extents_lock);\n\n\tif (sbi->free_blocks <= (hip->clump_blocks << 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\twhile (hip->alloc_blocks < hip->clump_blocks) {\n\t\terr = hfsplus_file_extend(attr_file, false);\n\t\tif (unlikely(err)) {\n\t\t\tpr_err(\"failed to extend attributes file\\n\");\n\t\t\tgoto end_attr_file_creation;\n\t\t}\n\t\thip->phys_size = attr_file->i_size =\n\t\t\t(loff_t)hip->alloc_blocks << sbi->alloc_blksz_shift;\n\t\thip->fs_blocks = hip->alloc_blocks << sbi->fs_shift;\n\t\tinode_set_bytes(attr_file, attr_file->i_size);\n\t}\n\n\tbuf = kzalloc(node_size, GFP_NOFS);\n\tif (!buf) {\n\t\tpr_err(\"failed to allocate memory for header node\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto end_attr_file_creation;\n\t}\n\n\thfsplus_init_header_node(attr_file, clump_size, buf, node_size);\n\n\tmapping = attr_file->i_mapping;\n\n\tindex = 0;\n\twritten = 0;\n\tfor (; written < node_size; index++, written += PAGE_CACHE_SIZE) {\n\t\tvoid *kaddr;\n\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto failed_header_node_init;\n\t\t}\n\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, buf + written,\n\t\t\tmin_t(size_t, PAGE_CACHE_SIZE, node_size - written));\n\t\tkunmap_atomic(kaddr);\n\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\n\thfsplus_mark_inode_dirty(attr_file, HFSPLUS_I_ATTR_DIRTY);\n\n\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\tif (!sbi->attr_tree)\n\t\tpr_err(\"failed to load attributes file\\n\");\n\nfailed_header_node_init:\n\tkfree(buf);\n\nend_attr_file_creation:\n\tiput(attr_file);\n\n\tif (!err)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\telse if (err == -ENOSPC)\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\telse\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_FAILED_ATTR_TREE);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_init_header_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "58-124",
    "snippet": "static void hfsplus_init_header_node(struct inode *attr_file,\n\t\t\t\t\tu32 clump_size,\n\t\t\t\t\tchar *buf, u16 node_size)\n{\n\tstruct hfs_bnode_desc *desc;\n\tstruct hfs_btree_header_rec *head;\n\tu16 offset;\n\t__be16 *rec_offsets;\n\tu32 hdr_node_map_rec_bits;\n\tchar *bmp;\n\tu32 used_nodes;\n\tu32 used_bmp_bytes;\n\tu64 tmp;\n\n\thfs_dbg(ATTR_MOD, \"init_hdr_attr_file: clump %u, node_size %u\\n\",\n\t\tclump_size, node_size);\n\n\t/* The end of the node contains list of record offsets */\n\trec_offsets = (__be16 *)(buf + node_size);\n\n\tdesc = (struct hfs_bnode_desc *)buf;\n\tdesc->type = HFS_NODE_HEADER;\n\tdesc->num_recs = cpu_to_be16(HFSPLUS_BTREE_HDR_NODE_RECS_COUNT);\n\toffset = sizeof(struct hfs_bnode_desc);\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thead = (struct hfs_btree_header_rec *)(buf + offset);\n\thead->node_size = cpu_to_be16(node_size);\n\ttmp = i_size_read(attr_file);\n\tdo_div(tmp, node_size);\n\thead->node_count = cpu_to_be32(tmp);\n\thead->free_nodes = cpu_to_be32(be32_to_cpu(head->node_count) - 1);\n\thead->clump_size = cpu_to_be32(clump_size);\n\thead->attributes |= cpu_to_be32(HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS);\n\thead->max_key_len = cpu_to_be16(HFSPLUS_ATTR_KEYLEN - sizeof(u16));\n\toffset += sizeof(struct hfs_btree_header_rec);\n\t*--rec_offsets = cpu_to_be16(offset);\n\toffset += HFSPLUS_BTREE_HDR_USER_BYTES;\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thdr_node_map_rec_bits = 8 * (node_size - offset - (4 * sizeof(u16)));\n\tif (be32_to_cpu(head->node_count) > hdr_node_map_rec_bits) {\n\t\tu32 map_node_bits;\n\t\tu32 map_nodes;\n\n\t\tdesc->next = cpu_to_be32(be32_to_cpu(head->leaf_tail) + 1);\n\t\tmap_node_bits = 8 * (node_size - sizeof(struct hfs_bnode_desc) -\n\t\t\t\t\t(2 * sizeof(u16)) - 2);\n\t\tmap_nodes = (be32_to_cpu(head->node_count) -\n\t\t\t\thdr_node_map_rec_bits +\n\t\t\t\t(map_node_bits - 1)) / map_node_bits;\n\t\tbe32_add_cpu(&head->free_nodes, 0 - map_nodes);\n\t}\n\n\tbmp = buf + offset;\n\tused_nodes =\n\t\tbe32_to_cpu(head->node_count) - be32_to_cpu(head->free_nodes);\n\tused_bmp_bytes = used_nodes / 8;\n\tif (used_bmp_bytes) {\n\t\tmemset(bmp, 0xFF, used_bmp_bytes);\n\t\tbmp += used_bmp_bytes;\n\t\tused_nodes %= 8;\n\t}\n\t*bmp = ~(0xFF >> used_nodes);\n\toffset += hdr_node_map_rec_bits / 8;\n\t*--rec_offsets = cpu_to_be16(offset);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offset"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bmp",
            "0xFF",
            "used_bmp_bytes"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->free_nodes"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->node_count"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&head->free_nodes",
            "0 - map_nodes"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->node_count"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "be32_to_cpu(head->leaf_tail) + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->leaf_tail"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->node_count"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offset"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offset"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_ATTR_KEYLEN - sizeof(u16)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "clump_size"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "be32_to_cpu(head->node_count) - 1"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->node_count"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "node_size"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "attr_file"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "node_size"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offset"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_BTREE_HDR_NODE_RECS_COUNT"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ATTR_MOD",
            "\"init_hdr_attr_file: clump %u, node_size %u\\n\"",
            "clump_size",
            "node_size"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_init_header_node(struct inode *attr_file,\n\t\t\t\t\tu32 clump_size,\n\t\t\t\t\tchar *buf, u16 node_size)\n{\n\tstruct hfs_bnode_desc *desc;\n\tstruct hfs_btree_header_rec *head;\n\tu16 offset;\n\t__be16 *rec_offsets;\n\tu32 hdr_node_map_rec_bits;\n\tchar *bmp;\n\tu32 used_nodes;\n\tu32 used_bmp_bytes;\n\tu64 tmp;\n\n\thfs_dbg(ATTR_MOD, \"init_hdr_attr_file: clump %u, node_size %u\\n\",\n\t\tclump_size, node_size);\n\n\t/* The end of the node contains list of record offsets */\n\trec_offsets = (__be16 *)(buf + node_size);\n\n\tdesc = (struct hfs_bnode_desc *)buf;\n\tdesc->type = HFS_NODE_HEADER;\n\tdesc->num_recs = cpu_to_be16(HFSPLUS_BTREE_HDR_NODE_RECS_COUNT);\n\toffset = sizeof(struct hfs_bnode_desc);\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thead = (struct hfs_btree_header_rec *)(buf + offset);\n\thead->node_size = cpu_to_be16(node_size);\n\ttmp = i_size_read(attr_file);\n\tdo_div(tmp, node_size);\n\thead->node_count = cpu_to_be32(tmp);\n\thead->free_nodes = cpu_to_be32(be32_to_cpu(head->node_count) - 1);\n\thead->clump_size = cpu_to_be32(clump_size);\n\thead->attributes |= cpu_to_be32(HFS_TREE_BIGKEYS | HFS_TREE_VARIDXKEYS);\n\thead->max_key_len = cpu_to_be16(HFSPLUS_ATTR_KEYLEN - sizeof(u16));\n\toffset += sizeof(struct hfs_btree_header_rec);\n\t*--rec_offsets = cpu_to_be16(offset);\n\toffset += HFSPLUS_BTREE_HDR_USER_BYTES;\n\t*--rec_offsets = cpu_to_be16(offset);\n\n\thdr_node_map_rec_bits = 8 * (node_size - offset - (4 * sizeof(u16)));\n\tif (be32_to_cpu(head->node_count) > hdr_node_map_rec_bits) {\n\t\tu32 map_node_bits;\n\t\tu32 map_nodes;\n\n\t\tdesc->next = cpu_to_be32(be32_to_cpu(head->leaf_tail) + 1);\n\t\tmap_node_bits = 8 * (node_size - sizeof(struct hfs_bnode_desc) -\n\t\t\t\t\t(2 * sizeof(u16)) - 2);\n\t\tmap_nodes = (be32_to_cpu(head->node_count) -\n\t\t\t\thdr_node_map_rec_bits +\n\t\t\t\t(map_node_bits - 1)) / map_node_bits;\n\t\tbe32_add_cpu(&head->free_nodes, 0 - map_nodes);\n\t}\n\n\tbmp = buf + offset;\n\tused_nodes =\n\t\tbe32_to_cpu(head->node_count) - be32_to_cpu(head->free_nodes);\n\tused_bmp_bytes = used_nodes / 8;\n\tif (used_bmp_bytes) {\n\t\tmemset(bmp, 0xFF, used_bmp_bytes);\n\t\tbmp += used_bmp_bytes;\n\t\tused_nodes %= 8;\n\t}\n\t*bmp = ~(0xFF >> used_nodes);\n\toffset += hdr_node_map_rec_bits / 8;\n\t*--rec_offsets = cpu_to_be16(offset);\n}"
  },
  {
    "function_name": "is_known_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "47-56",
    "snippet": "static inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic inline int is_known_namespace(const char *name)\n{\n\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "strcmp_xattr_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "38-45",
    "snippet": "static int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "HFSPLUS_XATTR_ACL_NAME",
            "sizeof(HFSPLUS_XATTR_ACL_NAME)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_acl(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_ACL_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_ACL_NAME));\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "strcmp_xattr_finder_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
    "lines": "29-36",
    "snippet": "static int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/nls.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfsplus_removexattr(struct inode *inode, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "HFSPLUS_XATTR_FINDER_INFO_NAME",
            "sizeof(HFSPLUS_XATTR_FINDER_INFO_NAME)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nstatic int strcmp_xattr_finder_info(const char *name)\n{\n\tif (name) {\n\t\treturn strncmp(name, HFSPLUS_XATTR_FINDER_INFO_NAME,\n\t\t\t\tsizeof(HFSPLUS_XATTR_FINDER_INFO_NAME));\n\t}\n\treturn -1;\n}"
  }
]