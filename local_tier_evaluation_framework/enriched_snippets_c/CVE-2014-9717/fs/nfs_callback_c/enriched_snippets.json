[
  {
    "function_name": "nfs_callback_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "466-479",
    "snippet": "static int nfs_callback_authenticate(struct svc_rqst *rqstp)\n{\n\tswitch (rqstp->rq_authop->flavour) {\n\tcase RPC_AUTH_NULL:\n\t\tif (rqstp->rq_proc != CB_NULL)\n\t\t\treturn SVC_DROP;\n\t\tbreak;\n\tcase RPC_AUTH_GSS:\n\t\t/* No RPC_AUTH_GSS support yet in NFSv4.1 */\n\t\t if (svc_is_backchannel(rqstp))\n\t\t\treturn SVC_DROP;\n\t}\n\treturn SVC_OK;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_is_backchannel",
          "args": [
            "rqstp"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs_callback_authenticate(struct svc_rqst *rqstp)\n{\n\tswitch (rqstp->rq_authop->flavour) {\n\tcase RPC_AUTH_NULL:\n\t\tif (rqstp->rq_proc != CB_NULL)\n\t\t\treturn SVC_DROP;\n\t\tbreak;\n\tcase RPC_AUTH_GSS:\n\t\t/* No RPC_AUTH_GSS support yet in NFSv4.1 */\n\t\t if (svc_is_backchannel(rqstp))\n\t\t\treturn SVC_DROP;\n\t}\n\treturn SVC_OK;\n}"
  },
  {
    "function_name": "check_gss_callback_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "417-455",
    "snippet": "int\ncheck_gss_callback_principal(struct nfs_client *clp, struct svc_rqst *rqstp)\n{\n\tchar *p = rqstp->rq_cred.cr_principal;\n\n\tif (rqstp->rq_authop->flavour != RPC_AUTH_GSS)\n\t\treturn 1;\n\n\t/* No RPC_AUTH_GSS on NFSv4.1 back channel yet */\n\tif (clp->cl_minorversion != 0)\n\t\treturn 0;\n\t/*\n\t * It might just be a normal user principal, in which case\n\t * userspace won't bother to tell us the name at all.\n\t */\n\tif (p == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Did we get the acceptor from userland during the SETCLIENID\n\t * negotiation?\n\t */\n\tif (clp->cl_acceptor)\n\t\treturn !strcmp(p, clp->cl_acceptor);\n\n\t/*\n\t * Otherwise try to verify it using the cl_hostname. Note that this\n\t * doesn't work if a non-canonical hostname was used in the devname.\n\t */\n\n\t/* Expect a GSS_C_NT_HOSTBASED_NAME like \"nfs@serverhostname\" */\n\n\tif (memcmp(p, \"nfs@\", 4) != 0)\n\t\treturn 0;\n\tp += 4;\n\tif (strcmp(p, clp->cl_hostname) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "clp->cl_hostname"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p",
            "\"nfs@\"",
            "4"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nint\ncheck_gss_callback_principal(struct nfs_client *clp, struct svc_rqst *rqstp)\n{\n\tchar *p = rqstp->rq_cred.cr_principal;\n\n\tif (rqstp->rq_authop->flavour != RPC_AUTH_GSS)\n\t\treturn 1;\n\n\t/* No RPC_AUTH_GSS on NFSv4.1 back channel yet */\n\tif (clp->cl_minorversion != 0)\n\t\treturn 0;\n\t/*\n\t * It might just be a normal user principal, in which case\n\t * userspace won't bother to tell us the name at all.\n\t */\n\tif (p == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Did we get the acceptor from userland during the SETCLIENID\n\t * negotiation?\n\t */\n\tif (clp->cl_acceptor)\n\t\treturn !strcmp(p, clp->cl_acceptor);\n\n\t/*\n\t * Otherwise try to verify it using the cl_hostname. Note that this\n\t * doesn't work if a non-canonical hostname was used in the devname.\n\t */\n\n\t/* Expect a GSS_C_NT_HOSTBASED_NAME like \"nfs@serverhostname\" */\n\n\tif (memcmp(p, \"nfs@\", 4) != 0)\n\t\treturn 0;\n\tp += 4;\n\tif (strcmp(p, clp->cl_hostname) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs_callback_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "397-414",
    "snippet": "void nfs_callback_down(int minorversion, struct net *net)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\n\tmutex_lock(&nfs_callback_mutex);\n\tnfs_callback_down_net(minorversion, cb_info->serv, net);\n\tcb_info->users--;\n\tif (cb_info->users == 0 && cb_info->task != NULL) {\n\t\tkthread_stop(cb_info->task);\n\t\tdprintk(\"nfs_callback_down: service stopped\\n\");\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tdprintk(\"nfs_callback_down: service destroyed\\n\");\n\t\tcb_info->serv = NULL;\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t}\n\tmutex_unlock(&nfs_callback_mutex);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];",
      "static DEFINE_MUTEX(nfs_callback_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfs_callback_mutex"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_callback_down: service destroyed\\n\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_exit_thread",
          "args": [
            "cb_info->rqst"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_callback_down: service stopped\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "cb_info->task"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_callback_down_net",
          "args": [
            "minorversion",
            "cb_info->serv",
            "net"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_down_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "255-264",
          "snippet": "static void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfs_callback_mutex"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\nstatic DEFINE_MUTEX(nfs_callback_mutex);\n\nvoid nfs_callback_down(int minorversion, struct net *net)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\n\tmutex_lock(&nfs_callback_mutex);\n\tnfs_callback_down_net(minorversion, cb_info->serv, net);\n\tcb_info->users--;\n\tif (cb_info->users == 0 && cb_info->task != NULL) {\n\t\tkthread_stop(cb_info->task);\n\t\tdprintk(\"nfs_callback_down: service stopped\\n\");\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tdprintk(\"nfs_callback_down: service destroyed\\n\");\n\t\tcb_info->serv = NULL;\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t}\n\tmutex_unlock(&nfs_callback_mutex);\n}"
  },
  {
    "function_name": "nfs_callback_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "352-392",
    "snippet": "int nfs_callback_up(u32 minorversion, struct rpc_xprt *xprt)\n{\n\tstruct svc_serv *serv;\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\tstruct net *net = xprt->xprt_net;\n\n\tmutex_lock(&nfs_callback_mutex);\n\n\tserv = nfs_callback_create_svc(minorversion);\n\tif (IS_ERR(serv)) {\n\t\tret = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\tret = nfs_callback_up_net(minorversion, serv, net);\n\tif (ret < 0)\n\t\tgoto err_net;\n\n\tret = nfs_callback_start_svc(minorversion, xprt, serv);\n\tif (ret < 0)\n\t\tgoto err_start;\n\n\tcb_info->users++;\n\t/*\n\t * svc_create creates the svc_serv with sv_nrthreads == 1, and then\n\t * svc_prepare_thread increments that. So we need to call svc_destroy\n\t * on both success and failure so that the refcount is 1 when the\n\t * thread exits.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nfs_callback_mutex);\n\treturn ret;\n\nerr_start:\n\tnfs_callback_down_net(minorversion, serv, net);\n\tdprintk(\"NFS: Couldn't create server thread; err = %d\\n\", ret);\n\tgoto err_net;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];",
      "static DEFINE_MUTEX(nfs_callback_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: Couldn't create server thread; err = %d\\n\"",
            "ret"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_callback_down_net",
          "args": [
            "minorversion",
            "serv",
            "net"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_down_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "255-264",
          "snippet": "static void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfs_callback_mutex"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_destroy",
          "args": [
            "serv"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_callback_start_svc",
          "args": [
            "minorversion",
            "xprt",
            "serv"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_start_svc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "209-253",
          "snippet": "static int nfs_callback_start_svc(int minorversion, struct rpc_xprt *xprt,\n\t\t\t\t  struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\tint (*callback_svc)(void *vrqstp);\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\n\tnfs_callback_bc_serv(minorversion, xprt, serv);\n\n\tif (cb_info->task)\n\t\treturn 0;\n\n\tswitch (minorversion) {\n\tcase 0:\n\t\t/* v4.0 callback setup */\n\t\trqstp = nfs4_callback_up(serv);\n\t\tcallback_svc = nfs4_callback_svc;\n\t\tbreak;\n\tdefault:\n\t\tnfs_minorversion_callback_svc_setup(serv,\n\t\t\t\t&rqstp, &callback_svc);\n\t}\n\n\tif (IS_ERR(rqstp))\n\t\treturn PTR_ERR(rqstp);\n\n\tsvc_sock_update_bufs(serv);\n\n\tcb_info->serv = serv;\n\tcb_info->rqst = rqstp;\n\tcb_info->task = kthread_create(callback_svc, cb_info->rqst,\n\t\t\t\t    \"nfsv4.%u-svc\", minorversion);\n\tif (IS_ERR(cb_info->task)) {\n\t\tret = PTR_ERR(cb_info->task);\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t\treturn ret;\n\t}\n\trqstp->rq_task = cb_info->task;\n\twake_up_process(cb_info->task);\n\tdprintk(\"nfs_callback_up: service started\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\n\nstatic int nfs_callback_start_svc(int minorversion, struct rpc_xprt *xprt,\n\t\t\t\t  struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\tint (*callback_svc)(void *vrqstp);\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\n\tnfs_callback_bc_serv(minorversion, xprt, serv);\n\n\tif (cb_info->task)\n\t\treturn 0;\n\n\tswitch (minorversion) {\n\tcase 0:\n\t\t/* v4.0 callback setup */\n\t\trqstp = nfs4_callback_up(serv);\n\t\tcallback_svc = nfs4_callback_svc;\n\t\tbreak;\n\tdefault:\n\t\tnfs_minorversion_callback_svc_setup(serv,\n\t\t\t\t&rqstp, &callback_svc);\n\t}\n\n\tif (IS_ERR(rqstp))\n\t\treturn PTR_ERR(rqstp);\n\n\tsvc_sock_update_bufs(serv);\n\n\tcb_info->serv = serv;\n\tcb_info->rqst = rqstp;\n\tcb_info->task = kthread_create(callback_svc, cb_info->rqst,\n\t\t\t\t    \"nfsv4.%u-svc\", minorversion);\n\tif (IS_ERR(cb_info->task)) {\n\t\tret = PTR_ERR(cb_info->task);\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t\treturn ret;\n\t}\n\trqstp->rq_task = cb_info->task;\n\twake_up_process(cb_info->task);\n\tdprintk(\"nfs_callback_up: service started\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_callback_up_net",
          "args": [
            "minorversion",
            "serv",
            "net"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_up_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "266-309",
          "snippet": "static int nfs_callback_up_net(int minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tint ret;\n\n\tif (nn->cb_users[minorversion]++)\n\t\treturn 0;\n\n\tdprintk(\"NFS: create per-net callback data; net=%p\\n\", net);\n\n\tret = svc_bind(serv, net);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"NFS: bind callback service failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tret = nfs4_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tret = nfs41_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: unknown callback version: %d\\n\",\n\t\t\t\t\tminorversion);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"NFS: callback service start failed\\n\");\n\t\tgoto err_socks;\n\t}\n\treturn 0;\n\nerr_socks:\n\tsvc_rpcb_cleanup(serv, net);\nerr_bind:\n\tdprintk(\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %p\\n\", ret, net);\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs_callback_up_net(int minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tint ret;\n\n\tif (nn->cb_users[minorversion]++)\n\t\treturn 0;\n\n\tdprintk(\"NFS: create per-net callback data; net=%p\\n\", net);\n\n\tret = svc_bind(serv, net);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"NFS: bind callback service failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tret = nfs4_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tret = nfs41_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: unknown callback version: %d\\n\",\n\t\t\t\t\tminorversion);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"NFS: callback service start failed\\n\");\n\t\tgoto err_socks;\n\t}\n\treturn 0;\n\nerr_socks:\n\tsvc_rpcb_cleanup(serv, net);\nerr_bind:\n\tdprintk(\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %p\\n\", ret, net);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "serv"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "serv"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_callback_create_svc",
          "args": [
            "minorversion"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_create_svc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "311-347",
          "snippet": "static struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\n\t/*\n\t * Check whether we're already up and running.\n\t */\n\tif (cb_info->task) {\n\t\t/*\n\t\t * Note: increase service usage, because later in case of error\n\t\t * svc_destroy() will be called.\n\t\t */\n\t\tsvc_get(cb_info->serv);\n\t\treturn cb_info->serv;\n\t}\n\n\t/*\n\t * Sanity check: if there's no task,\n\t * we should be the first user ...\n\t */\n\tif (cb_info->users)\n\t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n\t\t\tcb_info->users);\n\n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, NULL);\n\tif (!serv) {\n\t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* As there is only one thread we need to over-ride the\n\t * default maximum of 80 connections\n\t */\n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];",
            "static struct svc_program nfs4_callback_program;",
            "static struct svc_program nfs4_callback_program = {\n\t.pg_prog = NFS4_CALLBACK,\t\t\t/* RPC service number */\n\t.pg_nvers = ARRAY_SIZE(nfs4_callback_version),\t/* Number of entries */\n\t.pg_vers = nfs4_callback_version,\t\t/* version table */\n\t.pg_name = \"NFSv4 callback\",\t\t\t/* service name */\n\t.pg_class = \"nfs\",\t\t\t\t/* authentication class */\n\t.pg_stats = &nfs4_callback_stats,\n\t.pg_authenticate = nfs_callback_authenticate,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\nstatic struct svc_program nfs4_callback_program;\nstatic struct svc_program nfs4_callback_program = {\n\t.pg_prog = NFS4_CALLBACK,\t\t\t/* RPC service number */\n\t.pg_nvers = ARRAY_SIZE(nfs4_callback_version),\t/* Number of entries */\n\t.pg_vers = nfs4_callback_version,\t\t/* version table */\n\t.pg_name = \"NFSv4 callback\",\t\t\t/* service name */\n\t.pg_class = \"nfs\",\t\t\t\t/* authentication class */\n\t.pg_stats = &nfs4_callback_stats,\n\t.pg_authenticate = nfs_callback_authenticate,\n};\n\nstatic struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\n\t/*\n\t * Check whether we're already up and running.\n\t */\n\tif (cb_info->task) {\n\t\t/*\n\t\t * Note: increase service usage, because later in case of error\n\t\t * svc_destroy() will be called.\n\t\t */\n\t\tsvc_get(cb_info->serv);\n\t\treturn cb_info->serv;\n\t}\n\n\t/*\n\t * Sanity check: if there's no task,\n\t * we should be the first user ...\n\t */\n\tif (cb_info->users)\n\t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n\t\t\tcb_info->users);\n\n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, NULL);\n\tif (!serv) {\n\t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* As there is only one thread we need to over-ride the\n\t * default maximum of 80 connections\n\t */\n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfs_callback_mutex"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\nstatic DEFINE_MUTEX(nfs_callback_mutex);\n\nint nfs_callback_up(u32 minorversion, struct rpc_xprt *xprt)\n{\n\tstruct svc_serv *serv;\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\tstruct net *net = xprt->xprt_net;\n\n\tmutex_lock(&nfs_callback_mutex);\n\n\tserv = nfs_callback_create_svc(minorversion);\n\tif (IS_ERR(serv)) {\n\t\tret = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\tret = nfs_callback_up_net(minorversion, serv, net);\n\tif (ret < 0)\n\t\tgoto err_net;\n\n\tret = nfs_callback_start_svc(minorversion, xprt, serv);\n\tif (ret < 0)\n\t\tgoto err_start;\n\n\tcb_info->users++;\n\t/*\n\t * svc_create creates the svc_serv with sv_nrthreads == 1, and then\n\t * svc_prepare_thread increments that. So we need to call svc_destroy\n\t * on both success and failure so that the refcount is 1 when the\n\t * thread exits.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nfs_callback_mutex);\n\treturn ret;\n\nerr_start:\n\tnfs_callback_down_net(minorversion, serv, net);\n\tdprintk(\"NFS: Couldn't create server thread; err = %d\\n\", ret);\n\tgoto err_net;\n}"
  },
  {
    "function_name": "nfs_callback_create_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "311-347",
    "snippet": "static struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\n\t/*\n\t * Check whether we're already up and running.\n\t */\n\tif (cb_info->task) {\n\t\t/*\n\t\t * Note: increase service usage, because later in case of error\n\t\t * svc_destroy() will be called.\n\t\t */\n\t\tsvc_get(cb_info->serv);\n\t\treturn cb_info->serv;\n\t}\n\n\t/*\n\t * Sanity check: if there's no task,\n\t * we should be the first user ...\n\t */\n\tif (cb_info->users)\n\t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n\t\t\tcb_info->users);\n\n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, NULL);\n\tif (!serv) {\n\t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* As there is only one thread we need to over-ride the\n\t * default maximum of 80 connections\n\t */\n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];",
      "static struct svc_program nfs4_callback_program;",
      "static struct svc_program nfs4_callback_program = {\n\t.pg_prog = NFS4_CALLBACK,\t\t\t/* RPC service number */\n\t.pg_nvers = ARRAY_SIZE(nfs4_callback_version),\t/* Number of entries */\n\t.pg_vers = nfs4_callback_version,\t\t/* version table */\n\t.pg_name = \"NFSv4 callback\",\t\t\t/* service name */\n\t.pg_class = \"nfs\",\t\t\t\t/* authentication class */\n\t.pg_stats = &nfs4_callback_stats,\n\t.pg_authenticate = nfs_callback_authenticate,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_callback_create_svc: service created\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nfs_callback_create_svc: create service failed\\n\""
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_create",
          "args": [
            "&nfs4_callback_program",
            "NFS4_CALLBACK_BUFSIZE",
            "NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "cb_info->serv"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\nstatic struct svc_program nfs4_callback_program;\nstatic struct svc_program nfs4_callback_program = {\n\t.pg_prog = NFS4_CALLBACK,\t\t\t/* RPC service number */\n\t.pg_nvers = ARRAY_SIZE(nfs4_callback_version),\t/* Number of entries */\n\t.pg_vers = nfs4_callback_version,\t\t/* version table */\n\t.pg_name = \"NFSv4 callback\",\t\t\t/* service name */\n\t.pg_class = \"nfs\",\t\t\t\t/* authentication class */\n\t.pg_stats = &nfs4_callback_stats,\n\t.pg_authenticate = nfs_callback_authenticate,\n};\n\nstatic struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\n\t/*\n\t * Check whether we're already up and running.\n\t */\n\tif (cb_info->task) {\n\t\t/*\n\t\t * Note: increase service usage, because later in case of error\n\t\t * svc_destroy() will be called.\n\t\t */\n\t\tsvc_get(cb_info->serv);\n\t\treturn cb_info->serv;\n\t}\n\n\t/*\n\t * Sanity check: if there's no task,\n\t * we should be the first user ...\n\t */\n\tif (cb_info->users)\n\t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n\t\t\tcb_info->users);\n\n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, NULL);\n\tif (!serv) {\n\t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* As there is only one thread we need to over-ride the\n\t * default maximum of 80 connections\n\t */\n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}"
  },
  {
    "function_name": "nfs_callback_up_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "266-309",
    "snippet": "static int nfs_callback_up_net(int minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tint ret;\n\n\tif (nn->cb_users[minorversion]++)\n\t\treturn 0;\n\n\tdprintk(\"NFS: create per-net callback data; net=%p\\n\", net);\n\n\tret = svc_bind(serv, net);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"NFS: bind callback service failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tret = nfs4_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tret = nfs41_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: unknown callback version: %d\\n\",\n\t\t\t\t\tminorversion);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"NFS: callback service start failed\\n\");\n\t\tgoto err_socks;\n\t}\n\treturn 0;\n\nerr_socks:\n\tsvc_rpcb_cleanup(serv, net);\nerr_bind:\n\tdprintk(\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %p\\n\", ret, net);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %p\\n\"",
            "ret",
            "net"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_rpcb_cleanup",
          "args": [
            "serv",
            "net"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: callback service start failed\\n\""
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_callback_up_net",
          "args": [
            "serv",
            "net"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_callback_up_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "191-194",
          "snippet": "static int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_callback_up_net",
          "args": [
            "serv",
            "net"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_callback_up_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "42-67",
          "snippet": "static int nfs4_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\tint ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\tnn->nfs_callback_tcpport = ret;\n\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\tnn->nfs_callback_tcpport, PF_INET, net);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET6,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret > 0) {\n\t\tnn->nfs_callback_tcpport6 = ret;\n\t\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\t\tnn->nfs_callback_tcpport6, PF_INET6, net);\n\t} else if (ret != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\treturn (ret) ? ret : -ENOMEM;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs4_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\tint ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\tnn->nfs_callback_tcpport = ret;\n\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\tnn->nfs_callback_tcpport, PF_INET, net);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET6,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret > 0) {\n\t\tnn->nfs_callback_tcpport6 = ret;\n\t\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\t\tnn->nfs_callback_tcpport6, PF_INET6, net);\n\t} else if (ret != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\treturn (ret) ? ret : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_bind",
          "args": [
            "serv",
            "net"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: create per-net callback data; net=%p\\n\"",
            "net"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs_callback_up_net(int minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tint ret;\n\n\tif (nn->cb_users[minorversion]++)\n\t\treturn 0;\n\n\tdprintk(\"NFS: create per-net callback data; net=%p\\n\", net);\n\n\tret = svc_bind(serv, net);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"NFS: bind callback service failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tret = nfs4_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tret = nfs41_callback_up_net(serv, net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: unknown callback version: %d\\n\",\n\t\t\t\t\tminorversion);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"NFS: callback service start failed\\n\");\n\t\tgoto err_socks;\n\t}\n\treturn 0;\n\nerr_socks:\n\tsvc_rpcb_cleanup(serv, net);\nerr_bind:\n\tdprintk(\"NFS: Couldn't create callback socket: err = %d; \"\n\t\t\t\"net = %p\\n\", ret, net);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_callback_down_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "255-264",
    "snippet": "static void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_shutdown_net",
          "args": [
            "serv",
            "net"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: destroy per-net callback data; net=%p\\n\"",
            "net"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_callback_down_net(u32 minorversion, struct svc_serv *serv, struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tif (--nn->cb_users[minorversion])\n\t\treturn;\n\n\tdprintk(\"NFS: destroy per-net callback data; net=%p\\n\", net);\n\tsvc_shutdown_net(serv, net);\n}"
  },
  {
    "function_name": "nfs_callback_start_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "209-253",
    "snippet": "static int nfs_callback_start_svc(int minorversion, struct rpc_xprt *xprt,\n\t\t\t\t  struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\tint (*callback_svc)(void *vrqstp);\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\n\tnfs_callback_bc_serv(minorversion, xprt, serv);\n\n\tif (cb_info->task)\n\t\treturn 0;\n\n\tswitch (minorversion) {\n\tcase 0:\n\t\t/* v4.0 callback setup */\n\t\trqstp = nfs4_callback_up(serv);\n\t\tcallback_svc = nfs4_callback_svc;\n\t\tbreak;\n\tdefault:\n\t\tnfs_minorversion_callback_svc_setup(serv,\n\t\t\t\t&rqstp, &callback_svc);\n\t}\n\n\tif (IS_ERR(rqstp))\n\t\treturn PTR_ERR(rqstp);\n\n\tsvc_sock_update_bufs(serv);\n\n\tcb_info->serv = serv;\n\tcb_info->rqst = rqstp;\n\tcb_info->task = kthread_create(callback_svc, cb_info->rqst,\n\t\t\t\t    \"nfsv4.%u-svc\", minorversion);\n\tif (IS_ERR(cb_info->task)) {\n\t\tret = PTR_ERR(cb_info->task);\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t\treturn ret;\n\t}\n\trqstp->rq_task = cb_info->task;\n\twake_up_process(cb_info->task);\n\tdprintk(\"nfs_callback_up: service started\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_callback_up: service started\\n\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "cb_info->task"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_exit_thread",
          "args": [
            "cb_info->rqst"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cb_info->task"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cb_info->task"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "callback_svc",
            "cb_info->rqst",
            "\"nfsv4.%u-svc\"",
            "minorversion"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_sock_update_bufs",
          "args": [
            "serv"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rqstp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rqstp"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_minorversion_callback_svc_setup",
          "args": [
            "serv",
            "&rqstp",
            "&callback_svc"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_minorversion_callback_svc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "196-201",
          "snippet": "static void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = ERR_PTR(-ENOTSUPP);\n\t*callback_svc = ERR_PTR(-ENOTSUPP);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = ERR_PTR(-ENOTSUPP);\n\t*callback_svc = ERR_PTR(-ENOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_callback_up",
          "args": [
            "serv"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_callback_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "95-99",
          "snippet": "static struct svc_rqst *\nnfs4_callback_up(struct svc_serv *serv)\n{\n\treturn svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct svc_rqst *\nnfs4_callback_up(struct svc_serv *serv)\n{\n\treturn svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_callback_bc_serv",
          "args": [
            "minorversion",
            "xprt",
            "serv"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_callback_bc_serv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "203-206",
          "snippet": "static inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct nfs_callback_data nfs_callback_info[NFS4_MAX_MINOR_VERSION + 1];\n\nstatic int nfs_callback_start_svc(int minorversion, struct rpc_xprt *xprt,\n\t\t\t\t  struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\tint (*callback_svc)(void *vrqstp);\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tint ret;\n\n\tnfs_callback_bc_serv(minorversion, xprt, serv);\n\n\tif (cb_info->task)\n\t\treturn 0;\n\n\tswitch (minorversion) {\n\tcase 0:\n\t\t/* v4.0 callback setup */\n\t\trqstp = nfs4_callback_up(serv);\n\t\tcallback_svc = nfs4_callback_svc;\n\t\tbreak;\n\tdefault:\n\t\tnfs_minorversion_callback_svc_setup(serv,\n\t\t\t\t&rqstp, &callback_svc);\n\t}\n\n\tif (IS_ERR(rqstp))\n\t\treturn PTR_ERR(rqstp);\n\n\tsvc_sock_update_bufs(serv);\n\n\tcb_info->serv = serv;\n\tcb_info->rqst = rqstp;\n\tcb_info->task = kthread_create(callback_svc, cb_info->rqst,\n\t\t\t\t    \"nfsv4.%u-svc\", minorversion);\n\tif (IS_ERR(cb_info->task)) {\n\t\tret = PTR_ERR(cb_info->task);\n\t\tsvc_exit_thread(cb_info->rqst);\n\t\tcb_info->rqst = NULL;\n\t\tcb_info->task = NULL;\n\t\treturn ret;\n\t}\n\trqstp->rq_task = cb_info->task;\n\twake_up_process(cb_info->task);\n\tdprintk(\"nfs_callback_up: service started\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_callback_bc_serv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "203-206",
    "snippet": "static inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n}"
  },
  {
    "function_name": "nfs_minorversion_callback_svc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "196-201",
    "snippet": "static void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = ERR_PTR(-ENOTSUPP);\n\t*callback_svc = ERR_PTR(-ENOTSUPP);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTSUPP"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTSUPP"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = ERR_PTR(-ENOTSUPP);\n\t*callback_svc = ERR_PTR(-ENOTSUPP);\n}"
  },
  {
    "function_name": "nfs41_callback_up_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "191-194",
    "snippet": "static int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_callback_bc_serv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "180-189",
    "snippet": "static inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n\tif (minorversion)\n\t\t/*\n\t\t * Save the svc_serv in the transport so that it can\n\t\t * be referenced when the session backchannel is initialized\n\t\t */\n\t\txprt->bc_serv = serv;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic inline void nfs_callback_bc_serv(u32 minorversion, struct rpc_xprt *xprt,\n\t\tstruct svc_serv *serv)\n{\n\tif (minorversion)\n\t\t/*\n\t\t * Save the svc_serv in the transport so that it can\n\t\t * be referenced when the session backchannel is initialized\n\t\t */\n\t\txprt->bc_serv = serv;\n}"
  },
  {
    "function_name": "nfs_minorversion_callback_svc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "173-178",
    "snippet": "static void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = nfs41_callback_up(serv);\n\t*callback_svc = nfs41_callback_svc;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_callback_up",
          "args": [
            "serv"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_callback_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "156-171",
          "snippet": "static struct svc_rqst *\nnfs41_callback_up(struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\n\tINIT_LIST_HEAD(&serv->sv_cb_list);\n\tspin_lock_init(&serv->sv_cb_lock);\n\tinit_waitqueue_head(&serv->sv_cb_waitq);\n\trqstp = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n\tif (IS_ERR(rqstp)) {\n\t\tsvc_xprt_put(serv->sv_bc_xprt);\n\t\tserv->sv_bc_xprt = NULL;\n\t}\n\tdprintk(\"--> %s return %d\\n\", __func__, PTR_ERR_OR_ZERO(rqstp));\n\treturn rqstp;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct svc_rqst *\nnfs41_callback_up(struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\n\tINIT_LIST_HEAD(&serv->sv_cb_list);\n\tspin_lock_init(&serv->sv_cb_lock);\n\tinit_waitqueue_head(&serv->sv_cb_waitq);\n\trqstp = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n\tif (IS_ERR(rqstp)) {\n\t\tsvc_xprt_put(serv->sv_bc_xprt);\n\t\tserv->sv_bc_xprt = NULL;\n\t}\n\tdprintk(\"--> %s return %d\\n\", __func__, PTR_ERR_OR_ZERO(rqstp));\n\treturn rqstp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic void nfs_minorversion_callback_svc_setup(struct svc_serv *serv,\n\t\tstruct svc_rqst **rqstpp, int (**callback_svc)(void *vrqstp))\n{\n\t*rqstpp = nfs41_callback_up(serv);\n\t*callback_svc = nfs41_callback_svc;\n}"
  },
  {
    "function_name": "nfs41_callback_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "156-171",
    "snippet": "static struct svc_rqst *\nnfs41_callback_up(struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\n\tINIT_LIST_HEAD(&serv->sv_cb_list);\n\tspin_lock_init(&serv->sv_cb_lock);\n\tinit_waitqueue_head(&serv->sv_cb_waitq);\n\trqstp = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n\tif (IS_ERR(rqstp)) {\n\t\tsvc_xprt_put(serv->sv_bc_xprt);\n\t\tserv->sv_bc_xprt = NULL;\n\t}\n\tdprintk(\"--> %s return %d\\n\", __func__, PTR_ERR_OR_ZERO(rqstp));\n\treturn rqstp;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s return %d\\n\"",
            "__func__",
            "PTR_ERR_OR_ZERO(rqstp)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "rqstp"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "serv->sv_bc_xprt"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rqstp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_prepare_thread",
          "args": [
            "serv",
            "&serv->sv_pools[0]",
            "NUMA_NO_NODE"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&serv->sv_cb_waitq"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&serv->sv_cb_lock"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&serv->sv_cb_list"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct svc_rqst *\nnfs41_callback_up(struct svc_serv *serv)\n{\n\tstruct svc_rqst *rqstp;\n\n\tINIT_LIST_HEAD(&serv->sv_cb_list);\n\tspin_lock_init(&serv->sv_cb_lock);\n\tinit_waitqueue_head(&serv->sv_cb_waitq);\n\trqstp = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n\tif (IS_ERR(rqstp)) {\n\t\tsvc_xprt_put(serv->sv_bc_xprt);\n\t\tserv->sv_bc_xprt = NULL;\n\t}\n\tdprintk(\"--> %s return %d\\n\", __func__, PTR_ERR_OR_ZERO(rqstp));\n\treturn rqstp;\n}"
  },
  {
    "function_name": "nfs41_callback_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "116-151",
    "snippet": "static int\nnfs41_callback_svc(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = vrqstp;\n\tstruct svc_serv *serv = rqstp->rq_server;\n\tstruct rpc_rqst *req;\n\tint error;\n\tDEFINE_WAIT(wq);\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tprepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_UNINTERRUPTIBLE);\n\t\tspin_lock_bh(&serv->sv_cb_lock);\n\t\tif (!list_empty(&serv->sv_cb_list)) {\n\t\t\treq = list_first_entry(&serv->sv_cb_list,\n\t\t\t\t\tstruct rpc_rqst, rq_bc_list);\n\t\t\tlist_del(&req->rq_bc_list);\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t\tdprintk(\"Invoking bc_svc_process()\\n\");\n\t\t\terror = bc_svc_process(serv, req, rqstp);\n\t\t\tdprintk(\"bc_svc_process() returned w/ error code= %d\\n\",\n\t\t\t\terror);\n\t\t} else {\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\t/* schedule_timeout to game the hung task watchdog */\n\t\t\tschedule_timeout(60 * HZ);\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&serv->sv_cb_waitq",
            "&wq"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "60 * HZ"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&serv->sv_cb_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"bc_svc_process() returned w/ error code= %d\\n\"",
            "error"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bc_svc_process",
          "args": [
            "serv",
            "req",
            "rqstp"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Invoking bc_svc_process()\\n\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&serv->sv_cb_waitq",
            "&wq"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&serv->sv_cb_lock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->rq_bc_list"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&serv->sv_cb_list",
            "structrpc_rqst",
            "rq_bc_list"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&serv->sv_cb_list"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&serv->sv_cb_lock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&serv->sv_cb_waitq",
            "&wq",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wq"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int\nnfs41_callback_svc(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = vrqstp;\n\tstruct svc_serv *serv = rqstp->rq_server;\n\tstruct rpc_rqst *req;\n\tint error;\n\tDEFINE_WAIT(wq);\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tprepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_UNINTERRUPTIBLE);\n\t\tspin_lock_bh(&serv->sv_cb_lock);\n\t\tif (!list_empty(&serv->sv_cb_list)) {\n\t\t\treq = list_first_entry(&serv->sv_cb_list,\n\t\t\t\t\tstruct rpc_rqst, rq_bc_list);\n\t\t\tlist_del(&req->rq_bc_list);\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t\tdprintk(\"Invoking bc_svc_process()\\n\");\n\t\t\terror = bc_svc_process(serv, req, rqstp);\n\t\t\tdprintk(\"bc_svc_process() returned w/ error code= %d\\n\",\n\t\t\t\terror);\n\t\t} else {\n\t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n\t\t\t/* schedule_timeout to game the hung task watchdog */\n\t\t\tschedule_timeout(60 * HZ);\n\t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs41_callback_up_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "102-111",
    "snippet": "static int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\t/*\n\t * Create an svc_sock for the back channel service that shares the\n\t * fore channel connection.\n\t * Returns the input port (0) and sets the svc_serv bc_xprt on success\n\t */\n\treturn svc_create_xprt(serv, \"tcp-bc\", net, PF_INET, 0,\n\t\t\t      SVC_SOCK_ANONYMOUS);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "serv",
            "\"tcp-bc\"",
            "net",
            "PF_INET",
            "0",
            "SVC_SOCK_ANONYMOUS"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs41_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\t/*\n\t * Create an svc_sock for the back channel service that shares the\n\t * fore channel connection.\n\t * Returns the input port (0) and sets the svc_serv bc_xprt on success\n\t */\n\treturn svc_create_xprt(serv, \"tcp-bc\", net, PF_INET, 0,\n\t\t\t      SVC_SOCK_ANONYMOUS);\n}"
  },
  {
    "function_name": "nfs4_callback_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "95-99",
    "snippet": "static struct svc_rqst *\nnfs4_callback_up(struct svc_serv *serv)\n{\n\treturn svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_prepare_thread",
          "args": [
            "serv",
            "&serv->sv_pools[0]",
            "NUMA_NO_NODE"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic struct svc_rqst *\nnfs4_callback_up(struct svc_serv *serv)\n{\n\treturn svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);\n}"
  },
  {
    "function_name": "nfs4_callback_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "72-90",
    "snippet": "static int\nnfs4_callback_svc(void *vrqstp)\n{\n\tint err;\n\tstruct svc_rqst *rqstp = vrqstp;\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\t/*\n\t\t * Listen for a request on the socket\n\t\t */\n\t\terr = svc_recv(rqstp, MAX_SCHEDULE_TIMEOUT);\n\t\tif (err == -EAGAIN || err == -EINTR)\n\t\t\tcontinue;\n\t\tsvc_process(rqstp);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_process",
          "args": [
            "rqstp"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_recv",
          "args": [
            "rqstp",
            "MAX_SCHEDULE_TIMEOUT"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int\nnfs4_callback_svc(void *vrqstp)\n{\n\tint err;\n\tstruct svc_rqst *rqstp = vrqstp;\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\t/*\n\t\t * Listen for a request on the socket\n\t\t */\n\t\terr = svc_recv(rqstp, MAX_SCHEDULE_TIMEOUT);\n\t\tif (err == -EAGAIN || err == -EINTR)\n\t\t\tcontinue;\n\t\tsvc_process(rqstp);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_callback_up_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
    "lines": "42-67",
    "snippet": "static int nfs4_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\tint ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\tnn->nfs_callback_tcpport = ret;\n\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\tnn->nfs_callback_tcpport, PF_INET, net);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET6,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret > 0) {\n\t\tnn->nfs_callback_tcpport6 = ret;\n\t\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\t\tnn->nfs_callback_tcpport6, PF_INET6, net);\n\t} else if (ret != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\treturn (ret) ? ret : -ENOMEM;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <net/inet_sock.h>",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mutex.h>",
      "#include <linux/errno.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/module.h>",
      "#include <linux/ip.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: Callback listener port = %u (af %u, net %p)\\n\"",
            "nn->nfs_callback_tcpport6",
            "PF_INET6",
            "net"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "serv",
            "\"tcp\"",
            "net",
            "PF_INET6",
            "nfs_callback_set_tcpport",
            "SVC_SOCK_ANONYMOUS"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: Callback listener port = %u (af %u, net %p)\\n\"",
            "nn->nfs_callback_tcpport",
            "PF_INET",
            "net"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "serv",
            "\"tcp\"",
            "net",
            "PF_INET",
            "nfs_callback_set_tcpport",
            "SVC_SOCK_ANONYMOUS"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nstatic int nfs4_callback_up_net(struct svc_serv *serv, struct net *net)\n{\n\tint ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\tnn->nfs_callback_tcpport = ret;\n\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\tnn->nfs_callback_tcpport, PF_INET, net);\n\n\tret = svc_create_xprt(serv, \"tcp\", net, PF_INET6,\n\t\t\t\tnfs_callback_set_tcpport, SVC_SOCK_ANONYMOUS);\n\tif (ret > 0) {\n\t\tnn->nfs_callback_tcpport6 = ret;\n\t\tdprintk(\"NFS: Callback listener port = %u (af %u, net %p)\\n\",\n\t\t\t\tnn->nfs_callback_tcpport6, PF_INET6, net);\n\t} else if (ret != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\treturn (ret) ? ret : -ENOMEM;\n}"
  }
]