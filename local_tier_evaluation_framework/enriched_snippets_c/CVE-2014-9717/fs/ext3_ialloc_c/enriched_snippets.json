[
  {
    "function_name": "ext3_count_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "693-705",
    "snippet": "unsigned long ext3_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_used_dirs_count"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext3_count_free_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "646-690",
    "snippet": "unsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_inodes_count"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\"",
            "le32_to_cpu(es->s_free_inodes_count)",
            "desc_count",
            "bitmap_count"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_free_inodes_count"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_count_free",
          "args": [
            "bitmap_bh",
            "EXT3_INODES_PER_GROUP(sb) / 8"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/bitmap.c",
          "lines": "14-17",
          "snippet": "unsigned long ext3_count_free (struct buffer_head * map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nunsigned long ext3_count_free (struct buffer_head * map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "i"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "43-61",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_count_free_inodes (struct super_block * sb)\n{\n\tunsigned long desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_inodes: stored = %u, computed = %lu, %lu\\n\",\n\t\tle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\n\t\tgdp = ext3_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}"
  },
  {
    "function_name": "ext3_orphan_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "570-644",
    "snippet": "struct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);\n\tunsigned long block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext3_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext3_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text3_warning(sb, __func__,\n\t\t     \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_NOTICE \"ext3_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext3_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_NOTICE \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_NOTICE \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_NOTICE \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_NOTICE \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_NOTICE \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"i_nlink=%u\\n\"",
            "inode->i_nlink"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "bit",
            "bitmap_bh->b_data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"bad orphan inode %lu!  e2fsck was run?\"",
            "ino"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_can_truncate",
          "args": [
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2454-2463",
          "snippet": "int ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext3_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "bit",
            "bitmap_bh->b_data"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "43-61",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);\n\tunsigned long block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext3_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext3_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text3_warning(sb, __func__,\n\t\t     \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_NOTICE \"ext3_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext3_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_NOTICE \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_NOTICE \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_NOTICE \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_NOTICE \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_NOTICE \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ext3_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "346-567",
    "snippet": "struct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_allocate_inode",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"allocating inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3443-3454",
          "snippet": "int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext3_iloc iloc;\n\tint err;\n\n\tmight_sleep();\n\ttrace_ext3_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\tif (!err)\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_init_security",
          "args": [
            "handle",
            "inode",
            "dir",
            "qstr"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr_security.c",
          "lines": "65-71",
          "snippet": "int\next3_init_security(handle_t *handle, struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext3_initxattrs, handle);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/security.h>\n\nint\next3_init_security(handle_t *handle, struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext3_initxattrs, handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_init_acl",
          "args": [
            "handle",
            "inode",
            "dir"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/acl.c",
          "lines": "259-281",
          "snippet": "int\next3_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext3_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext3_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n\nint\next3_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext3_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext3_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_NEW"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2812-2827",
          "snippet": "void ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mask_flags",
          "args": [
            "mode",
            "EXT3_I(dir)->i_flags & EXT3_FL_INHERITED"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "173-181",
          "snippet": "static inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)",
            "#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))"
          ],
          "globals_used": [
            "extern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)\n#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))\n\nextern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);\n\nstatic inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dir"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ei->i_data",
            "0",
            "sizeof(ei->i_data)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh2",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "group"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_used_dirs_count",
            "1"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_inodes_count",
            "-1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh2",
            "\"get_write_access\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"ext3_new_inode\"",
            "\"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\"",
            "group",
            "ino"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_release_buffer",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "journal_release_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1212-1216",
          "snippet": "void\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, group)",
            "ino",
            "bitmap_bh->b_data"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"get_write_access\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_next_zero_bit",
          "args": [
            "(unsigned long *)\n\t\t\t\tbitmap_bh->b_data",
            "EXT3_INODES_PER_GROUP(sb)",
            "ino"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "43-61",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group",
            "&bh2"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_group_other",
          "args": [
            "sb",
            "dir"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "find_group_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "279-334",
          "snippet": "static int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tint ngroups = EXT3_SB(sb)->s_groups_count;\n\tstruct ext3_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext3_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\treturn group;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some free\n\t * blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\treturn group;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\treturn group;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tint ngroups = EXT3_SB(sb)->s_groups_count;\n\tstruct ext3_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext3_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\treturn group;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some free\n\t * blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\treturn group;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\treturn group;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_group_orlov",
          "args": [
            "sb",
            "dir"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "find_group_orlov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "193-277",
          "snippet": "static int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT3_INODES_PER_GROUP(sb);\n\tunsigned int freei, avefreei;\n\text3_fsblk_t freeb, avefreeb;\n\tunsigned int ndirs;\n\tint max_dirs, min_inodes;\n\text3_grpblk_t min_blocks;\n\tint group = -1, i;\n\tstruct ext3_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfreeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = freeb / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t}\n\t\tif (best_group >= 0)\n\t\t\treturn best_group;\n\t\tgoto fallback;\n\t}\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT3_BLOCKS_PER_GROUP(sb) / 4;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\treturn group;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\treturn group;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT3_INODES_PER_GROUP(sb);\n\tunsigned int freei, avefreei;\n\text3_fsblk_t freeb, avefreeb;\n\tunsigned int ndirs;\n\tint max_dirs, min_inodes;\n\text3_grpblk_t min_blocks;\n\tint group = -1, i;\n\tstruct ext3_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfreeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = freeb / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t}\n\t\tif (best_group >= 0)\n\t\t\treturn best_group;\n\t\tgoto fallback;\n\t}\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT3_BLOCKS_PER_GROUP(sb) / 4;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\treturn group;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\treturn group;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_request_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\n\t\t\t     const struct qstr *qstr, umode_t mode)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group;\n\tunsigned long ino = 0;\n\tstruct inode * inode;\n\tstruct ext3_group_desc * gdp = NULL;\n\tstruct ext3_super_block * es;\n\tstruct ext3_inode_info *ei;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0;\n\tstruct inode *ret;\n\tint i;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\ttrace_ext3_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT3_I(inode);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode))\n\t\tgroup = find_group_orlov(sb, dir);\n\telse\n\t\tgroup = find_group_other(sb, dir);\n\n\terr = -ENOSPC;\n\tif (group == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\terr = -EIO;\n\n\t\tgdp = ext3_get_group_desc(sb, group, &bh2);\n\t\tif (!gdp)\n\t\t\tgoto fail;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh)\n\t\t\tgoto fail;\n\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext3_find_next_zero_bit((unsigned long *)\n\t\t\t\tbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\n\t\tif (ino < EXT3_INODES_PER_GROUP(sb)) {\n\n\t\t\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, bitmap_bh);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t\t/* we won it */\n\t\t\t\tBUFFER_TRACE(bitmap_bh,\n\t\t\t\t\t\"call ext3_journal_dirty_metadata\");\n\t\t\t\terr = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto got;\n\t\t\t}\n\t\t\t/* we lost it */\n\t\t\tjournal_release_buffer(handle, bitmap_bh);\n\n\t\t\tif (++ino < EXT3_INODES_PER_GROUP(sb))\n\t\t\t\tgoto repeat_in_this_group;\n\t\t}\n\n\t\t/*\n\t\t * This case is possible in concurrent environment.  It is very\n\t\t * rare.  We cannot repeat the find_group_xxx() call because\n\t\t * that will simply return the same blockgroup, because the\n\t\t * group descriptor metadata has not yet been updated.\n\t\t * So we just go onto the next blockgroup.\n\t\t */\n\t\tif (++group == sbi->s_groups_count)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tino += group * EXT3_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d, inode=%lu\", group, ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tBUFFER_TRACE(bh2, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, bh2);\n\tif (err) goto fail;\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bh2);\n\tif (err) goto fail;\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\tei->i_flags =\n\t\text3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n#endif\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\n\text3_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\thandle->h_sync = 1;\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\tei->i_state_flags = 0;\n\text3_set_inode_state(inode, EXT3_STATE_NEW);\n\n\t/* See comment in ext3_iget for explanation */\n\tif (ino >= EXT3_FIRST_INO(sb) + 1 &&\n\t    EXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize =\n\t\t\tsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\n\t} else {\n\t\tei->i_extra_isize = 0;\n\t}\n\n\tret = inode;\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext3_init_acl(handle, inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_init_security(handle, inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text3_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text3_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext3_allocate_inode(inode, dir, mode);\n\tgoto really_out;\nfail:\n\text3_std_error(sb, err);\nout:\n\tiput(inode);\n\tret = ERR_PTR(err);\nreally_out:\n\tbrelse(bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "find_group_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "279-334",
    "snippet": "static int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tint ngroups = EXT3_SB(sb)->s_groups_count;\n\tstruct ext3_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext3_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\treturn group;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some free\n\t * blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\treturn group;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\treturn group;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_inodes_count"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "parent"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tint ngroups = EXT3_SB(sb)->s_groups_count;\n\tstruct ext3_group_desc *desc;\n\tint group, i;\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\tgroup = parent_group;\n\tdesc = ext3_get_group_desc (sb, group, NULL);\n\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\treturn group;\n\n\t/*\n\t * We're going to place this inode in a different blockgroup from its\n\t * parent.  We want to cause files in a common directory to all land in\n\t * the same blockgroup.  But we want files which are in a different\n\t * directory which shares a blockgroup with our parent to land in a\n\t * different blockgroup.\n\t *\n\t * So add our directory's i_ino into the starting point for the hash.\n\t */\n\tgroup = (group + parent->i_ino) % ngroups;\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode and some free\n\t * blocks.\n\t */\n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\tgroup += i;\n\t\tif (group >= ngroups)\n\t\t\tgroup -= ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\n\t\t\t\tle16_to_cpu(desc->bg_free_blocks_count))\n\t\t\treturn group;\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode, even if that group\n\t * has no free blocks.\n\t */\n\tgroup = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (desc && le16_to_cpu(desc->bg_free_inodes_count))\n\t\t\treturn group;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "find_group_orlov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "193-277",
    "snippet": "static int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT3_INODES_PER_GROUP(sb);\n\tunsigned int freei, avefreei;\n\text3_fsblk_t freeb, avefreeb;\n\tunsigned int ndirs;\n\tint max_dirs, min_inodes;\n\text3_grpblk_t min_blocks;\n\tint group = -1, i;\n\tstruct ext3_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfreeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = freeb / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t}\n\t\tif (best_group >= 0)\n\t\t\treturn best_group;\n\t\tgoto fallback;\n\t}\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT3_BLOCKS_PER_GROUP(sb) / 4;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\treturn group;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\treturn group;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_inodes_count"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "parent"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\n{\n\tint parent_group = EXT3_I(parent)->i_block_group;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint ngroups = sbi->s_groups_count;\n\tint inodes_per_group = EXT3_INODES_PER_GROUP(sb);\n\tunsigned int freei, avefreei;\n\text3_fsblk_t freeb, avefreeb;\n\tunsigned int ndirs;\n\tint max_dirs, min_inodes;\n\text3_grpblk_t min_blocks;\n\tint group = -1, i;\n\tstruct ext3_group_desc *desc;\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfreeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\tavefreeb = freeb / ngroups;\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif ((parent == sb->s_root->d_inode) ||\n\t    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint best_group = -1;\n\n\t\tgroup = prandom_u32();\n\t\tparent_group = (unsigned)group % ngroups;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgroup = (parent_group + i) % ngroups;\n\t\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\n\t\t\t\tcontinue;\n\t\t\tbest_group = group;\n\t\t\tbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\n\t\t}\n\t\tif (best_group >= 0)\n\t\t\treturn best_group;\n\t\tgoto fallback;\n\t}\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group / 16;\n\tmin_inodes = avefreei - inodes_per_group / 4;\n\tmin_blocks = avefreeb - EXT3_BLOCKS_PER_GROUP(sb) / 4;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\n\t\t\tcontinue;\n\t\treturn group;\n\t}\n\nfallback:\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgroup = (parent_group + i) % ngroups;\n\t\tdesc = ext3_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\n\t\t\treturn group;\n\t}\n\n\tif (avefreei) {\n\t\t/*\n\t\t * The free-inodes counter is approximate, and for really small\n\t\t * filesystems the above test can fail to find any blockgroups\n\t\t */\n\t\tavefreei = 0;\n\t\tgoto fallback;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "ext3_free_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "79-167",
    "snippet": "void ext3_free_inode (handle_t *handle, struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext3_group_desc * gdp;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint fatal = 0, err;\n\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\tprintk (\"ext3_free_inode: inode has count=%d\\n\",\n\t\t\t\t\tatomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\tprintk (\"ext3_free_inode: inode has nlink=%d\\n\",\n\t\t\tinode->i_nlink);\n\t\treturn;\n\t}\n\tif (!sb) {\n\t\tprintk(\"ext3_free_inode: inode on nonexistent device\\n\");\n\t\treturn;\n\t}\n\tsbi = EXT3_SB(sb);\n\n\tino = inode->i_ino;\n\text3_debug (\"freeing inode %lu\\n\", ino);\n\ttrace_ext3_free_inode(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tes = EXT3_SB(sb)->s_es;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\tbit, bitmap_bh->b_data))\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse {\n\t\tgdp = ext3_get_group_desc (sb, block_group, &bh2);\n\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext3_journal_get_write_access(handle, bh2);\n\t\tif (fatal) goto error_return;\n\n\t\tif (gdp) {\n\t\t\tspin_lock(sb_bgl_lock(sbi, block_group));\n\t\t\tle16_add_cpu(&gdp->bg_free_inodes_count, 1);\n\t\t\tif (is_directory)\n\t\t\t\tle16_add_cpu(&gdp->bg_used_dirs_count, -1);\n\t\t\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\t\t\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\t\t\tif (is_directory)\n\t\t\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\n\t\t}\n\t\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\tif (!fatal) fatal = err;\n\t}\n\tBUFFER_TRACE(bitmap_bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!fatal)\n\t\tfatal = err;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, fatal);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "sb",
            "fatal"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh2",
            "\"call ext3_journal_dirty_metadata\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(sbi, block_group)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "block_group"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_used_dirs_count",
            "-1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_inodes_count",
            "1"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(sbi, block_group)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh2"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh2",
            "\"get_write_access\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "&bh2"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"ext3_free_inode\"",
            "\"bit already cleared for inode %lu\"",
            "ino"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_clear_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, block_group)",
            "bit",
            "bitmap_bh->b_data"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"get_write_access\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inode_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "read_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
          "lines": "43-61",
          "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/random.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_free_inode",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"freeing inode %lu\\n\"",
            "ino"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext3_free_inode: inode on nonexistent device\\n\""
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_inode (handle_t *handle, struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext3_group_desc * gdp;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint fatal = 0, err;\n\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\tprintk (\"ext3_free_inode: inode has count=%d\\n\",\n\t\t\t\t\tatomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\tprintk (\"ext3_free_inode: inode has nlink=%d\\n\",\n\t\t\tinode->i_nlink);\n\t\treturn;\n\t}\n\tif (!sb) {\n\t\tprintk(\"ext3_free_inode: inode on nonexistent device\\n\");\n\t\treturn;\n\t}\n\tsbi = EXT3_SB(sb);\n\n\tino = inode->i_ino;\n\text3_debug (\"freeing inode %lu\\n\", ino);\n\ttrace_ext3_free_inode(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tes = EXT3_SB(sb)->s_es;\n\tif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\tbit, bitmap_bh->b_data))\n\t\text3_error (sb, \"ext3_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse {\n\t\tgdp = ext3_get_group_desc (sb, block_group, &bh2);\n\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext3_journal_get_write_access(handle, bh2);\n\t\tif (fatal) goto error_return;\n\n\t\tif (gdp) {\n\t\t\tspin_lock(sb_bgl_lock(sbi, block_group));\n\t\t\tle16_add_cpu(&gdp->bg_free_inodes_count, 1);\n\t\t\tif (is_directory)\n\t\t\t\tle16_add_cpu(&gdp->bg_used_dirs_count, -1);\n\t\t\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\t\t\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\t\t\tif (is_directory)\n\t\t\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\n\t\t}\n\t\tBUFFER_TRACE(bh2, \"call ext3_journal_dirty_metadata\");\n\t\terr = ext3_journal_dirty_metadata(handle, bh2);\n\t\tif (!fatal) fatal = err;\n\t}\n\tBUFFER_TRACE(bitmap_bh, \"call ext3_journal_dirty_metadata\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!fatal)\n\t\tfatal = err;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, fatal);\n}"
  },
  {
    "function_name": "read_inode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ialloc.c",
    "lines": "43-61",
    "snippet": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext3.h\"",
      "#include <linux/random.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"read_inode_bitmap\"",
            "\"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\"",
            "block_group",
            "le32_to_cpu(desc->bg_inode_bitmap)"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_bitmap"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(desc->bg_inode_bitmap)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/random.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\n{\n\tstruct ext3_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text3_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}"
  }
]