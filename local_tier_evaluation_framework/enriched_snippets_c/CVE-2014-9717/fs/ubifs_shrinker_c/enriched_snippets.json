[
  {
    "function_name": "scan(struct shrin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
    "lines": "291-331",
    "snippet": "ubifs_shrink_scan(struct shrinker *shrink,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long nr = sc->nr_to_scan;\n\tint contention = 0;\n\tunsigned long freed;\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\tif (!clean_zn_cnt) {\n\t\t/*\n\t\t * No clean znodes, nothing to reap. All we can do in this case\n\t\t * is to kick background threads to start commit, which will\n\t\t * probably make clean znodes which, in turn, will be freeable.\n\t\t * And we return -1 which means will make VM call us again\n\t\t * later.\n\t\t */\n\t\tdbg_tnc(\"no clean znodes, kick a thread\");\n\t\treturn kick_a_thread();\n\t}\n\n\tfreed = shrink_tnc_trees(nr, OLD_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough old znodes, try to free young ones\");\n\tfreed += shrink_tnc_trees(nr - freed, YOUNG_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough young znodes, free all\");\n\tfreed += shrink_tnc_trees(nr - freed, 0, &contention);\n\n\tif (!freed && contention) {\n\t\tdbg_tnc(\"freed nothing, but contention\");\n\t\treturn SHRINK_STOP;\n\t}\n\nout:\n\tdbg_tnc(\"%lu znodes were freed, requested %lu\", freed, nr);\n\treturn freed;\n}",
    "includes": [
      "fs.h\"\n\n/* List of a"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "znodes",
          "args": [
            "ere freed, requested %lu\", freed, nr);",
            "retur",
            "fr"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d nothi",
          "args": [
            "g, but contention\");\n\t\treturn S"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ees(nr - freed,",
          "args": [
            ", &content",
            "n",
            "if (!fre"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enough",
          "args": [
            "oung znodes, free all\");\n\tfreed +="
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "has_enough_invalid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "89-102",
          "snippet": "static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t invalid_user_blocks = sbi->user_block_count -\n\t\t\t\t\twritten_block_count(sbi);\n\t/*\n\t * Background GC is triggered with the following conditions.\n\t * 1. There are a number of invalid blocks.\n\t * 2. There is not enough free space.\n\t */\n\tif (invalid_user_blocks > limit_invalid_user_blocks(sbi) &&\n\t\t\tfree_user_blocks(sbi) < limit_free_user_blocks(sbi))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t invalid_user_blocks = sbi->user_block_count -\n\t\t\t\t\twritten_block_count(sbi);\n\t/*\n\t * Background GC is triggered with the following conditions.\n\t * 1. There are a number of invalid blocks.\n\t * 2. There is not enough free space.\n\t */\n\tif (invalid_user_blocks > limit_invalid_user_blocks(sbi) &&\n\t\t\tfree_user_blocks(sbi) < limit_free_user_blocks(sbi))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ees(nr - freed,",
          "args": [
            "OUNG_ZNODE",
            "GE, &contention",
            "if (freed"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ees(nr, OLD_ZNOD",
          "args": [
            "_A",
            ", &contention",
            "if (freed"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "();\n\t}\n\n\tfree",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lean zn",
          "args": [
            "des, kick a thread\");\n\t\treturn k"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&ubifs_clean",
          "args": [
            "zn_cnt);\n\n\tif (!cle"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* List of a\n\nubifs_shrink_scan(struct shrinker *shrink,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long nr = sc->nr_to_scan;\n\tint contention = 0;\n\tunsigned long freed;\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\tif (!clean_zn_cnt) {\n\t\t/*\n\t\t * No clean znodes, nothing to reap. All we can do in this case\n\t\t * is to kick background threads to start commit, which will\n\t\t * probably make clean znodes which, in turn, will be freeable.\n\t\t * And we return -1 which means will make VM call us again\n\t\t * later.\n\t\t */\n\t\tdbg_tnc(\"no clean znodes, kick a thread\");\n\t\treturn kick_a_thread();\n\t}\n\n\tfreed = shrink_tnc_trees(nr, OLD_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough old znodes, try to free young ones\");\n\tfreed += shrink_tnc_trees(nr - freed, YOUNG_ZNODE_AGE, &contention);\n\tif (freed >= nr)\n\t\tgoto out;\n\n\tdbg_tnc(\"not enough young znodes, free all\");\n\tfreed += shrink_tnc_trees(nr - freed, 0, &contention);\n\n\tif (!freed && contention) {\n\t\tdbg_tnc(\"freed nothing, but contention\");\n\t\treturn SHRINK_STOP;\n\t}\n\nout:\n\tdbg_tnc(\"%lu znodes were freed, requested %lu\", freed, nr);\n\treturn freed;\n}"
  },
  {
    "function_name": "count(struct shrin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
    "lines": "279-289",
    "snippet": "ubifs_shrink_count(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\t/*\n\t * Due to the way UBIFS updates the clean znode counter it may\n\t * temporarily be negative.\n\t */\n\treturn clean_zn_cnt >= 0 ? clean_zn_cnt : 1;\n}\n\nunsigned lo",
    "includes": [
      "fs.h\"\n\n/* List of a"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ead(&ubifs_clean",
          "args": [
            "zn_cnt);\n\n\t/*\n\t * D"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* List of a\n\nubifs_shrink_count(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tlong clean_zn_cnt = atomic_long_read(&ubifs_clean_zn_cnt);\n\n\t/*\n\t * Due to the way UBIFS updates the clean znode counter it may\n\t * temporarily be negative.\n\t */\n\treturn clean_zn_cnt >= 0 ? clean_zn_cnt : 1;\n}\n\nunsigned lo"
  },
  {
    "function_name": "(void)\n{\n\tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
    "lines": "225-277",
    "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
    "includes": [
      "fs.h\"\n\n/* List of a"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\n\treturn 0"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\t}\n\t}\n\tsp"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\t\t\treturn"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bg_commit(c);\n\t\t\t\tmute",
          "args": [
            "_"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\n\t\t\t\tubifs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(&c->infos_li",
          "args": [
            "t, &ubifs_info",
            ";\n\t\t\t\tspin_u"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\t\t\treturn"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\t\t\t\tmutex_"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\t\t\tcontin"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt);\n\n\t\t\tif (!d"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\t\t\t\treturn"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&c->umount_m",
          "args": [
            "tex)) {\n\t\t\t\t/*"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(c, &ubifs_in",
          "args": [
            "o",
            "infos_list)",
            "long d"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\tfor (i ="
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
  },
  {
    "function_name": "ees(int nr, int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
    "lines": "156-215",
    "snippet": "rink_tnc_trees(int nr, int age, int *contention)\n{\n\tstruct ubifs_info *c;\n\tstruct list_head *p;\n\tunsigned int run_no;\n\tint freed = 0;\n\n\tspin_lock(&ubifs_infos_lock);\n\tdo {\n\t\trun_no = ++shrinker_run_no;\n\t} while (run_no == 0);\n\t/* Iterate over all mounted UBIFS file-systems and try to shrink them */\n\tp = ubifs_infos.next;\n\twhile (p != &ubifs_infos) {\n\t\tc = list_entry(p, struct ubifs_info, infos_list);\n\t\t/*\n\t\t * We move the ones we do to the end of the list, so we stop\n\t\t * when we see one we have already done.\n\t\t */\n\t\tif (c->shrinker_run_no == run_no)\n\t\t\tbreak;\n\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t/* Some un-mount is in progress, try next FS */\n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We're holding 'c->umount_mutex', so the file-system won't go\n\t\t * away.\n\t\t */\n\t\tif (!mutex_trylock(&c->tnc_mutex)) {\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ubifs_infos_lock);\n\t\t/*\n\t\t * OK, now we have TNC locked, the file-system cannot go away -\n\t\t * it is safe to reap the cache.\n\t\t */\n\t\tc->shrinker_run_no = run_no;\n\t\tfreed += shrink_tnc(c, nr, age, contention);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\tspin_lock(&ubifs_infos_lock);\n\t\t/* Get the next list element before we move this one */\n\t\tp = p->next;\n\t\t/*\n\t\t * Move this one to the end of the list to provide some\n\t\t * fairness.\n\t\t */\n\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\tmutex_unlock(&c->umount_mutex);\n\t\tif (freed >= nr)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\treturn freed;\n}\n\n/**\n * kick",
    "includes": [
      "fs.h\"\n\n/* List of a"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\treturn fr"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\tif (free"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(&c->infos_li",
          "args": [
            "t, &ubifs_info",
            ";\n\t\tmutex_un"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\t\t/* Get t"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\t\tspin_loc"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr, age,",
          "args": [
            "o",
            "en",
            "on)",
            "mutex_un"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\t\t/*\n\t\t *"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\t\t\t*conten"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&c->tnc_mute",
          "args": [
            ")) {\n\t\t\tmutex"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&c->umount_m",
          "args": [
            "tex)) {\n\t\t\t/* So"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct ub",
          "args": [
            "f",
            "info, nfos_list)",
            "/*\n\t\t *"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\tdo {\n\t\tru"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* List of a\n\nrink_tnc_trees(int nr, int age, int *contention)\n{\n\tstruct ubifs_info *c;\n\tstruct list_head *p;\n\tunsigned int run_no;\n\tint freed = 0;\n\n\tspin_lock(&ubifs_infos_lock);\n\tdo {\n\t\trun_no = ++shrinker_run_no;\n\t} while (run_no == 0);\n\t/* Iterate over all mounted UBIFS file-systems and try to shrink them */\n\tp = ubifs_infos.next;\n\twhile (p != &ubifs_infos) {\n\t\tc = list_entry(p, struct ubifs_info, infos_list);\n\t\t/*\n\t\t * We move the ones we do to the end of the list, so we stop\n\t\t * when we see one we have already done.\n\t\t */\n\t\tif (c->shrinker_run_no == run_no)\n\t\t\tbreak;\n\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t/* Some un-mount is in progress, try next FS */\n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We're holding 'c->umount_mutex', so the file-system won't go\n\t\t * away.\n\t\t */\n\t\tif (!mutex_trylock(&c->tnc_mutex)) {\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t*contention = 1;\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ubifs_infos_lock);\n\t\t/*\n\t\t * OK, now we have TNC locked, the file-system cannot go away -\n\t\t * it is safe to reap the cache.\n\t\t */\n\t\tc->shrinker_run_no = run_no;\n\t\tfreed += shrink_tnc(c, nr, age, contention);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\tspin_lock(&ubifs_infos_lock);\n\t\t/* Get the next list element before we move this one */\n\t\tp = p->next;\n\t\t/*\n\t\t * Move this one to the end of the list to provide some\n\t\t * fairness.\n\t\t */\n\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\tmutex_unlock(&c->umount_mutex);\n\t\tif (freed >= nr)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\treturn freed;\n}\n\n/**\n * kick"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
    "lines": "70-144",
    "snippet": "rink_tnc(struct ubifs_info *c, int nr, int age, int *contention)\n{\n\tint total_freed = 0;\n\tstruct ubifs_znode *znode, *zprev;\n\tint time = get_seconds();\n\n\tubifs_assert(mutex_is_locked(&c->umount_mutex));\n\tubifs_assert(mutex_is_locked(&c->tnc_mutex));\n\n\tif (!c->zroot.znode || atomic_long_read(&c->clean_zn_cnt) == 0)\n\t\treturn 0;\n\n\t/*\n\t * Traverse the TNC tree in levelorder manner, so that it is possible\n\t * to destroy large sub-trees. Indeed, if a znode is old, then all its\n\t * children are older or of the same age.\n\t *\n\t * Note, we are holding 'c->tnc_mutex', so we do not have to lock the\n\t * 'c->space_lock' when _reading_ 'c->clean_zn_cnt', because it is\n\t * changed only when the 'c->tnc_mutex' is held.\n\t */\n\tzprev = NULL;\n\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, NULL);\n\twhile (znode && total_freed < nr &&\n\t       atomic_long_read(&c->clean_zn_cnt) > 0) {\n\t\tint freed;\n\n\t\t/*\n\t\t * If the znode is clean, but it is in the 'c->cnext' list, this\n\t\t * means that this znode has just been written to flash as a\n\t\t * part of commit and was marked clean. They will be removed\n\t\t * from the list at end commit. We cannot change the list,\n\t\t * because it is not protected by any mutex (design decision to\n\t\t * make commit really independent and parallel to main I/O). So\n\t\t * we just skip these znodes.\n\t\t *\n\t\t * Note, the 'clean_zn_cnt' counters are not updated until\n\t\t * after the commit, so the UBIFS shrinker does not report\n\t\t * the znodes which are in the 'c->cnext' list as freeable.\n\t\t *\n\t\t * Also note, if the root of a sub-tree is not in 'c->cnext',\n\t\t * then the whole sub-tree is not in 'c->cnext' as well, so it\n\t\t * is safe to dump whole sub-tree.\n\t\t */\n\n\t\tif (znode->cnext) {\n\t\t\t/*\n\t\t\t * Very soon these znodes will be removed from the list\n\t\t\t * and become freeable.\n\t\t\t */\n\t\t\t*contention = 1;\n\t\t} else if (!ubifs_zn_dirty(znode) &&\n\t\t\t   abs(time - znode->time) >= age) {\n\t\t\tif (znode->parent)\n\t\t\t\tznode->parent->zbranch[znode->iip].znode = NULL;\n\t\t\telse\n\t\t\t\tc->zroot.znode = NULL;\n\n\t\t\tfreed = ubifs_destroy_tnc_subtree(znode);\n\t\t\tatomic_long_sub(freed, &ubifs_clean_zn_cnt);\n\t\t\tatomic_long_sub(freed, &c->clean_zn_cnt);\n\t\t\ttotal_freed += freed;\n\t\t\tznode = zprev;\n\t\t}\n\n\t\tif (unlikely(!c->zroot.znode))\n\t\t\tbreak;\n\n\t\tzprev = znode;\n\t\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, znode);\n\t\tcond_resched();\n\t}\n\n\treturn total_freed;\n}\n\n/**\n * shri",
    "includes": [
      "fs.h\"\n\n/* List of a"
    ],
    "macros_used": [],
    "globals_used": [
      "ubifs_clean_zn_cnt;\n\n/**\n * shri"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\t}\n\n\tretu",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elorder_next(c->zroot.zno",
          "args": [
            "e, znode);\n\t\tc",
            "d_res"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zroot.zn",
          "args": [
            "de))\n\t\t\tbreak;"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ub(freed, &c->c",
          "args": [
            "ean_z",
            "cnt);\n\t\t\ttotal_f"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ub(freed, &ubif",
          "args": [
            "_clea",
            "zn_cnt);\n\t\t\tatomic_"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_tnc_subtree(znode);\n\t\t\ta",
          "args": [
            "omic_"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode",
          "args": [
            ">time) >= age) {"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "cvrd_mst_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "386-400",
          "snippet": "te_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nte_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l"
        }
      },
      {
        "call_info": {
          "callee": "y(znode) &&",
          "args": [
            "ab"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt) > 0) {\n\t\tin"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elorder_next(c->zroot.zno",
          "args": [
            "e, NULL);\n\twhi",
            "(zn"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt) == 0)\n\t\tret"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->tnc_mutex));\n\n\tif (!c->"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->tnc_mute",
          "args": [
            "));\n\n\tif (!c-"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->umount_mutex));\n\tubifs_ass"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->umount_m",
          "args": [
            "tex));\n\tubifs_as"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tubifs_a",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* List of a\n\nubifs_clean_zn_cnt;\n\n/**\n * shri;\n\nrink_tnc(struct ubifs_info *c, int nr, int age, int *contention)\n{\n\tint total_freed = 0;\n\tstruct ubifs_znode *znode, *zprev;\n\tint time = get_seconds();\n\n\tubifs_assert(mutex_is_locked(&c->umount_mutex));\n\tubifs_assert(mutex_is_locked(&c->tnc_mutex));\n\n\tif (!c->zroot.znode || atomic_long_read(&c->clean_zn_cnt) == 0)\n\t\treturn 0;\n\n\t/*\n\t * Traverse the TNC tree in levelorder manner, so that it is possible\n\t * to destroy large sub-trees. Indeed, if a znode is old, then all its\n\t * children are older or of the same age.\n\t *\n\t * Note, we are holding 'c->tnc_mutex', so we do not have to lock the\n\t * 'c->space_lock' when _reading_ 'c->clean_zn_cnt', because it is\n\t * changed only when the 'c->tnc_mutex' is held.\n\t */\n\tzprev = NULL;\n\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, NULL);\n\twhile (znode && total_freed < nr &&\n\t       atomic_long_read(&c->clean_zn_cnt) > 0) {\n\t\tint freed;\n\n\t\t/*\n\t\t * If the znode is clean, but it is in the 'c->cnext' list, this\n\t\t * means that this znode has just been written to flash as a\n\t\t * part of commit and was marked clean. They will be removed\n\t\t * from the list at end commit. We cannot change the list,\n\t\t * because it is not protected by any mutex (design decision to\n\t\t * make commit really independent and parallel to main I/O). So\n\t\t * we just skip these znodes.\n\t\t *\n\t\t * Note, the 'clean_zn_cnt' counters are not updated until\n\t\t * after the commit, so the UBIFS shrinker does not report\n\t\t * the znodes which are in the 'c->cnext' list as freeable.\n\t\t *\n\t\t * Also note, if the root of a sub-tree is not in 'c->cnext',\n\t\t * then the whole sub-tree is not in 'c->cnext' as well, so it\n\t\t * is safe to dump whole sub-tree.\n\t\t */\n\n\t\tif (znode->cnext) {\n\t\t\t/*\n\t\t\t * Very soon these znodes will be removed from the list\n\t\t\t * and become freeable.\n\t\t\t */\n\t\t\t*contention = 1;\n\t\t} else if (!ubifs_zn_dirty(znode) &&\n\t\t\t   abs(time - znode->time) >= age) {\n\t\t\tif (znode->parent)\n\t\t\t\tznode->parent->zbranch[znode->iip].znode = NULL;\n\t\t\telse\n\t\t\t\tc->zroot.znode = NULL;\n\n\t\t\tfreed = ubifs_destroy_tnc_subtree(znode);\n\t\t\tatomic_long_sub(freed, &ubifs_clean_zn_cnt);\n\t\t\tatomic_long_sub(freed, &c->clean_zn_cnt);\n\t\t\ttotal_freed += freed;\n\t\t\tznode = zprev;\n\t\t}\n\n\t\tif (unlikely(!c->zroot.znode))\n\t\t\tbreak;\n\n\t\tzprev = znode;\n\t\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, znode);\n\t\tcond_resched();\n\t}\n\n\treturn total_freed;\n}\n\n/**\n * shri"
  }
]