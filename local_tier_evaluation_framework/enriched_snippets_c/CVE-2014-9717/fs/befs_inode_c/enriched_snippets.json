[
  {
    "function_name": "befs_check_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/inode.c",
    "lines": "17-54",
    "snippet": "int\nbefs_check_inode(struct super_block *sb, befs_inode * raw_inode,\n\t\t befs_blocknr_t inode)\n{\n\tu32 magic1 = fs32_to_cpu(sb, raw_inode->magic1);\n\tbefs_inode_addr ino_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tu32 flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\t/* check magic header. */\n\tif (magic1 != BEFS_INODE_MAGIC1) {\n\t\tbefs_error(sb,\n\t\t\t   \"Inode has a bad magic header - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * Sanity check2: inodes store their own block address. Check it.\n\t */\n\tif (inode != iaddr2blockno(sb, &ino_num)) {\n\t\tbefs_error(sb, \"inode blocknr field disagrees with vfs \"\n\t\t\t   \"VFS: %lu, Inode %lu\", (unsigned long)\n\t\t\t   inode, (unsigned long)iaddr2blockno(sb, &ino_num));\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * check flag\n\t */\n\n\tif (!(flags & BEFS_INODE_IN_USE)) {\n\t\tbefs_error(sb, \"inode is not used - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\treturn BEFS_OK;\n}",
    "includes": [
      "#include \"inode.h\"",
      "#include \"befs.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"inode is not used - inode = %lu\"",
            "(unsigned long)inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iaddr2blockno",
          "args": [
            "sb",
            "&ino_num"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "iaddr2blockno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "120-125",
          "snippet": "static inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "raw_inode->flags"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "32-39",
          "snippet": "static inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsrun_to_cpu",
          "args": [
            "sb",
            "raw_inode->inode_num"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "fsrun_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "70-85",
          "snippet": "static inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode.h\"\n#include \"befs.h\"\n#include <linux/fs.h>\n\nint\nbefs_check_inode(struct super_block *sb, befs_inode * raw_inode,\n\t\t befs_blocknr_t inode)\n{\n\tu32 magic1 = fs32_to_cpu(sb, raw_inode->magic1);\n\tbefs_inode_addr ino_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tu32 flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\t/* check magic header. */\n\tif (magic1 != BEFS_INODE_MAGIC1) {\n\t\tbefs_error(sb,\n\t\t\t   \"Inode has a bad magic header - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * Sanity check2: inodes store their own block address. Check it.\n\t */\n\tif (inode != iaddr2blockno(sb, &ino_num)) {\n\t\tbefs_error(sb, \"inode blocknr field disagrees with vfs \"\n\t\t\t   \"VFS: %lu, Inode %lu\", (unsigned long)\n\t\t\t   inode, (unsigned long)iaddr2blockno(sb, &ino_num));\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * check flag\n\t */\n\n\tif (!(flags & BEFS_INODE_IN_USE)) {\n\t\tbefs_error(sb, \"inode is not used - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\treturn BEFS_OK;\n}"
  }
]