[
  {
    "function_name": "ffs2_release_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1326-1341",
    "snippet": "oid jffs2_release_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tstruct jffs2_xattr_ref *tmp, **ptmp;\n\n\tif (ref->node != (void *)ref)\n\t\treturn;\n\n\tfor (tmp=c->xref_dead_list, ptmp=&c->xref_dead_list; tmp; ptmp=&tmp->next, tmp=tmp->next) {\n\t\tif (ref == tmp) {\n\t\t\t*ptmp = tmp->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tjffs2_free_xattr_ref(ref);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_xattr_ref(",
          "args": [
            "ef)"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_release_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tstruct jffs2_xattr_ref *tmp, **ptmp;\n\n\tif (ref->node != (void *)ref)\n\t\treturn;\n\n\tfor (tmp=c->xref_dead_list, ptmp=&c->xref_dead_list; tmp; ptmp=&tmp->next, tmp=tmp->next) {\n\t\tif (ref == tmp) {\n\t\t\t*ptmp = tmp->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tjffs2_free_xattr_ref(ref);\n}"
  },
  {
    "function_name": "ffs2_release_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1316-1324",
    "snippet": "oid jffs2_release_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tif (atomic_read(&xd->refcnt) || xd->node != (void *)xd)\n\t\treturn;\n\n\tlist_del(&xd->xindex);\n\tjffs2_free_xattr_datum(xd);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_xattr_datum(",
          "args": [
            "d)"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "300-304",
          "snippet": "oid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "xd->xindex)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_read(",
          "args": [
            "xd->refcnt)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_release_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tif (atomic_read(&xd->refcnt) || xd->node != (void *)xd)\n\t\treturn;\n\n\tlist_del(&xd->xindex);\n\tjffs2_free_xattr_datum(xd);\n}"
  },
  {
    "function_name": "ffs2_verify_xattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1283-1314",
    "snippet": "nt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->xattr_unchecked)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattr_dead_list)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "ef_totlen(c, jeb, raw))"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "aw)"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "aw)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "xd->xindex)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_verify_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "o_verify_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "132-202",
          "snippet": "tatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattr_unchecked,",
            "index)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_verify_xattr(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t totlen;\n\tint rc;\n\n\tdown_write(&c->xattr_sem);\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\trc = do_verify_xattr_datum(c, xd);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tlist_del_init(&xd->xindex);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\t\tif (ref_flags(raw) != REF_UNCHECKED)\n\t\t\t\tcontinue;\n\t\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t\traw->flash_offset = ref_offset(raw)\n\t\t\t\t| ((xd->node == (void *)raw) ? REF_PRISTINE : REF_NORMAL);\n\t\t}\n\t\tif (xd->flags & JFFS2_XFLAGS_DEAD)\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tup_write(&c->xattr_sem);\n\treturn list_empty(&c->xattr_unchecked) ? 1 : 0;\n}"
  },
  {
    "function_name": "ffs2_garbage_collect_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1248-1281",
    "snippet": "nt jffs2_garbage_collect_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref,\n\t\t\t\t    struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tBUG_ON(!ref->node);\n\n\tif (ref->node != raw)\n\t\tgoto out;\n\tif (is_xattr_ref_dead(ref) && (raw->next_in_ino == (void *)ref))\n\t\tgoto out;\n\n\told_ofs = ref_offset(ref->node);\n\ttotlen = ref_totlen(c, c->gcblock, ref->node);\n\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XREF_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"%s: jffs2_reserve_space_gc() = %d, request = %u\\n\",\n\t\t\t      __func__, rc, totlen);\n\t\trc = rc ? rc : -EBADFD;\n\t\tgoto out;\n\t}\n\trc = save_xattr_ref(c, ref);\n\tif (!rc)\n\t\tdbg_xattr(\"xref (ino=%u, xid=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  ref->ic->ino, ref->xd->xid, old_ofs, ref_offset(ref->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "aw)"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xref (ino=%u, xid=%u) GC'ed from %#08x to %08x\\n\",",
            "ef->ic->ino,",
            "ef->xd->xid,",
            "ld_ofs,",
            "ef_offset(ref->node))"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef->node)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ave_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "506-548",
          "snippet": "tatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "%s: jffs2_reserve_space_gc() = %d, request = %u\\n\",",
            "_func__,",
            "c,",
            "otlen)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space_gc(",
          "args": [
            ",",
            "otlen,",
            "length,",
            "FFS2_SUMMARY_XREF_SIZE)"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space_gc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "212-238",
          "snippet": "nt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "->gcblock,",
            "ef->node)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef->node)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_xattr_ref_dead(",
          "args": [
            "ef)"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "s_xattr_ref_dead(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.h",
          "lines": "66-69",
          "snippet": "tatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}",
          "includes": [
            "include <linux/list.h>",
            "include <linux/xattr.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/list.h>\ninclude <linux/xattr.h>\n#\n\ntatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ref->node)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_garbage_collect_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref,\n\t\t\t\t    struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tBUG_ON(!ref->node);\n\n\tif (ref->node != raw)\n\t\tgoto out;\n\tif (is_xattr_ref_dead(ref) && (raw->next_in_ino == (void *)ref))\n\t\tgoto out;\n\n\told_ofs = ref_offset(ref->node);\n\ttotlen = ref_totlen(c, c->gcblock, ref->node);\n\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XREF_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"%s: jffs2_reserve_space_gc() = %d, request = %u\\n\",\n\t\t\t      __func__, rc, totlen);\n\t\trc = rc ? rc : -EBADFD;\n\t\tgoto out;\n\t}\n\trc = save_xattr_ref(c, ref);\n\tif (!rc)\n\t\tdbg_xattr(\"xref (ino=%u, xid=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  ref->ic->ino, ref->xd->xid, old_ofs, ref_offset(ref->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "ffs2_garbage_collect_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1212-1246",
    "snippet": "nt jffs2_garbage_collect_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd,\n\t\t\t\t      struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tif (xd->node != raw)\n\t\tgoto out;\n\tif (xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID))\n\t\tgoto out;\n\n\trc = load_xattr_datum(c, xd);\n\tif (unlikely(rc)) {\n\t\trc = (rc > 0) ? 0 : rc;\n\t\tgoto out;\n\t}\n\told_ofs = ref_offset(xd->node);\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ xd->name_len + 1 + xd->value_len);\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space_gc()=%d, request=%u\\n\", rc, totlen);\n\t\tgoto out;\n\t}\n\trc = save_xattr_datum(c, xd);\n\tif (!rc)\n\t\tdbg_xattr(\"xdatum (xid=%u, version=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  xd->xid, xd->version, old_ofs, ref_offset(xd->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "aw)"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xdatum (xid=%u, version=%u) GC'ed from %#08x to %08x\\n\",",
            "d->xid,",
            "d->version,",
            "ld_ofs,",
            "ef_offset(xd->node))"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "ave_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "284-334",
          "snippet": "tatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_reserve_space_gc()=%d, request=%u\\n\",",
            "c,",
            "otlen)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space_gc(",
          "args": [
            ",",
            "otlen,",
            "length,",
            "FFS2_SUMMARY_XATTR_SIZE)"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space_gc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "212-238",
          "snippet": "nt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xattr)\n\t\t\t+ xd->name_len + 1 + xd->value_len)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "oad_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "263-282",
          "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_garbage_collect_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd,\n\t\t\t\t      struct jffs2_raw_node_ref *raw)\n{\n\tuint32_t totlen, length, old_ofs;\n\tint rc = 0;\n\n\tdown_write(&c->xattr_sem);\n\tif (xd->node != raw)\n\t\tgoto out;\n\tif (xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID))\n\t\tgoto out;\n\n\trc = load_xattr_datum(c, xd);\n\tif (unlikely(rc)) {\n\t\trc = (rc > 0) ? 0 : rc;\n\t\tgoto out;\n\t}\n\told_ofs = ref_offset(xd->node);\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ xd->name_len + 1 + xd->value_len);\n\trc = jffs2_reserve_space_gc(c, totlen, &length, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space_gc()=%d, request=%u\\n\", rc, totlen);\n\t\tgoto out;\n\t}\n\trc = save_xattr_datum(c, xd);\n\tif (!rc)\n\t\tdbg_xattr(\"xdatum (xid=%u, version=%u) GC'ed from %#08x to %08x\\n\",\n\t\t\t  xd->xid, xd->version, old_ofs, ref_offset(xd->node));\n out:\n\tif (!rc)\n\t\tjffs2_mark_node_obsolete(c, raw);\n\tup_write(&c->xattr_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "o_jffs2_setxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1086-1198",
    "snippet": "nt do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      const char *buffer, size_t size, int flags)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *newref, **pref;\n\tuint32_t length, request;\n\tint rc;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trequest = PAD(sizeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size);\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\treturn rc;\n\t}\n\n\t/* Find existing xattr */\n\tdown_write(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\trc = load_xattr_datum(c, xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!strcmp(xd->xname, xname)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\trc = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tref->ino = ic->ino;\n\t\t\t\tref->xid = xd->xid;\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\trc = save_xattr_ref(c, ref);\n\t\t\t\tif (!rc) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\t\tunrefer_xattr_datum(c, xd);\n\t\t\t\t} else {\n\t\t\t\t\tref->ic = ic;\n\t\t\t\t\tref->xd = xd;\n\t\t\t\t\tref->xseqno &= ~XREF_DELETE_MARKER;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\t/* not found */\n\tif (flags & XATTR_REPLACE) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n\tif (!buffer) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n found:\n\txd = create_xattr_datum(c, xprefix, xname, buffer, size);\n\tif (IS_ERR(xd)) {\n\t\trc = PTR_ERR(xd);\n\t\tgoto out;\n\t}\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\n\t/* create xattr_ref */\n\trequest = PAD(sizeof(struct jffs2_raw_xref));\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XREF_SIZE);\n\tdown_write(&c->xattr_sem);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\tunrefer_xattr_datum(c, xd);\n\t\tup_write(&c->xattr_sem);\n\t\treturn rc;\n\t}\n\tif (ref)\n\t\t*pref = ref->next;\n\tnewref = create_xattr_ref(c, ic, xd);\n\tif (IS_ERR(newref)) {\n\t\tif (ref) {\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t\trc = PTR_ERR(newref);\n\t\tunrefer_xattr_datum(c, xd);\n\t} else if (ref) {\n\t\tdelete_xattr_ref(c, ref);\n\t}\n out:\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elete_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "elete_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "576-594",
          "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nrefer_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "nrefer_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "404-421",
          "snippet": "tatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "ewref)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "ewref)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reate_xattr_ref(",
          "args": [
            ",",
            "c,",
            "d)"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "reate_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "550-574",
          "snippet": "tatic struct jffs2_xattr_ref *create_xattr_ref(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic,\n\t\t\t\t\t\tstruct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_ref *ref;\n\tint ret;\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tref->ic = ic;\n\tref->xd = xd;\n\n\tret = save_xattr_ref(c, ref);\n\tif (ret) {\n\t\tjffs2_free_xattr_ref(ref);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* Chain to inode */\n\tref->next = ic->xref;\n\tic->xref = ref;\n\n\treturn ref; /* success */\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_ref *create_xattr_ref(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic,\n\t\t\t\t\t\tstruct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_ref *ref;\n\tint ret;\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tref->ic = ic;\n\tref->xd = xd;\n\n\tret = save_xattr_ref(c, ref);\n\tif (ret) {\n\t\tjffs2_free_xattr_ref(ref);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* Chain to inode */\n\tref->next = ic->xref;\n\tic->xref = ref;\n\n\treturn ref; /* success */\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_reserve_space()=%d, request=%u\\n\",",
            "c,",
            "equest)"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "equest,",
            "length,",
            "LLOC_NORMAL,",
            "FFS2_SUMMARY_XREF_SIZE)"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xref))"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "d)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reate_xattr_datum(",
          "args": [
            ",",
            "prefix,",
            "name,",
            "uffer,",
            "ize)"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "reate_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "336-402",
          "snippet": "tatic struct jffs2_xattr_datum *create_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    int xprefix, const char *xname,\n\t\t\t\t\t\t    const char *xvalue, int xsize)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t hashkey, name_len;\n\tchar *data;\n\tint i, rc;\n\n\t/* Search xattr_datum has same xname/xvalue by index */\n\thashkey = xattr_datum_hashkey(xprefix, xname, xvalue, xsize);\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->hashkey==hashkey\n\t\t    && xd->xprefix==xprefix\n\t\t    && xd->value_len==xsize\n\t\t    && !strcmp(xd->xname, xname)\n\t\t    && !memcmp(xd->xvalue, xvalue, xsize)) {\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\treturn xd;\n\t\t}\n\t}\n\n\t/* Not found, Create NEW XATTR-Cache */\n\tname_len = strlen(xname);\n\n\txd = jffs2_alloc_xattr_datum();\n\tif (!xd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kmalloc(name_len + 1 + xsize, GFP_KERNEL);\n\tif (!data) {\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstrcpy(data, xname);\n\tmemcpy(data + name_len + 1, xvalue, xsize);\n\n\tatomic_set(&xd->refcnt, 1);\n\txd->xid = ++c->highest_xid;\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xprefix = xprefix;\n\n\txd->hashkey = hashkey;\n\txd->xname = data;\n\txd->xvalue = data + name_len + 1;\n\txd->name_len = name_len;\n\txd->value_len = xsize;\n\txd->data_crc = crc32(0, data, xd->name_len + 1 + xd->value_len);\n\n\trc = save_xattr_datum(c, xd);\n\tif (rc) {\n\t\tkfree(xd->xname);\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* Insert Hash Index */\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\n\tc->xdatum_mem_usage += (xd->name_len + 1 + xd->value_len);\n\treclaim_xattr_datum(c);\n\n\treturn xd;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_datum *create_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    int xprefix, const char *xname,\n\t\t\t\t\t\t    const char *xvalue, int xsize)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t hashkey, name_len;\n\tchar *data;\n\tint i, rc;\n\n\t/* Search xattr_datum has same xname/xvalue by index */\n\thashkey = xattr_datum_hashkey(xprefix, xname, xvalue, xsize);\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->hashkey==hashkey\n\t\t    && xd->xprefix==xprefix\n\t\t    && xd->value_len==xsize\n\t\t    && !strcmp(xd->xname, xname)\n\t\t    && !memcmp(xd->xvalue, xvalue, xsize)) {\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\treturn xd;\n\t\t}\n\t}\n\n\t/* Not found, Create NEW XATTR-Cache */\n\tname_len = strlen(xname);\n\n\txd = jffs2_alloc_xattr_datum();\n\tif (!xd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kmalloc(name_len + 1 + xsize, GFP_KERNEL);\n\tif (!data) {\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstrcpy(data, xname);\n\tmemcpy(data + name_len + 1, xvalue, xsize);\n\n\tatomic_set(&xd->refcnt, 1);\n\txd->xid = ++c->highest_xid;\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xprefix = xprefix;\n\n\txd->hashkey = hashkey;\n\txd->xname = data;\n\txd->xvalue = data + name_len + 1;\n\txd->name_len = name_len;\n\txd->value_len = xsize;\n\txd->data_crc = crc32(0, data, xd->name_len + 1 + xd->value_len);\n\n\trc = save_xattr_datum(c, xd);\n\tif (rc) {\n\t\tkfree(xd->xname);\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* Insert Hash Index */\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\n\tc->xdatum_mem_usage += (xd->name_len + 1 + xd->value_len);\n\treclaim_xattr_datum(c);\n\n\treturn xd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ave_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "506-548",
          "snippet": "tatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "d->xname,",
            "name)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c < 0)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c > 0)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "oad_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "263-282",
          "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_reserve_space()=%d, request=%u\\n\",",
            "c,",
            "equest)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "name)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_xattr_ref_inode(",
          "args": [
            ",",
            "c)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "heck_xattr_ref_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "634-688",
          "snippet": "tatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SB_INFO(",
          "args": [
            "node->i_sb)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_INODE_INFO(",
          "args": [
            "node)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      const char *buffer, size_t size, int flags)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *newref, **pref;\n\tuint32_t length, request;\n\tint rc;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trequest = PAD(sizeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size);\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\treturn rc;\n\t}\n\n\t/* Find existing xattr */\n\tdown_write(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\trc = load_xattr_datum(c, xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!strcmp(xd->xname, xname)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\trc = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tref->ino = ic->ino;\n\t\t\t\tref->xid = xd->xid;\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\trc = save_xattr_ref(c, ref);\n\t\t\t\tif (!rc) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\t\tunrefer_xattr_datum(c, xd);\n\t\t\t\t} else {\n\t\t\t\t\tref->ic = ic;\n\t\t\t\t\tref->xd = xd;\n\t\t\t\t\tref->xseqno &= ~XREF_DELETE_MARKER;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\t/* not found */\n\tif (flags & XATTR_REPLACE) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n\tif (!buffer) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n found:\n\txd = create_xattr_datum(c, xprefix, xname, buffer, size);\n\tif (IS_ERR(xd)) {\n\t\trc = PTR_ERR(xd);\n\t\tgoto out;\n\t}\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\n\t/* create xattr_ref */\n\trequest = PAD(sizeof(struct jffs2_raw_xref));\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XREF_SIZE);\n\tdown_write(&c->xattr_sem);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\tunrefer_xattr_datum(c, xd);\n\t\tup_write(&c->xattr_sem);\n\t\treturn rc;\n\t}\n\tif (ref)\n\t\t*pref = ref->next;\n\tnewref = create_xattr_ref(c, ic, xd);\n\tif (IS_ERR(newref)) {\n\t\tif (ref) {\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t\trc = PTR_ERR(newref);\n\t\tunrefer_xattr_datum(c, xd);\n\t} else if (ref) {\n\t\tdelete_xattr_ref(c, ref);\n\t}\n out:\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\treturn rc;\n}"
  },
  {
    "function_name": "o_jffs2_getxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "1024-1084",
    "snippet": "nt do_jffs2_getxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      char *buffer, size_t size)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tint rc, retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic!=ic);\n\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(xname, xd->xname)) {\n\t\t\trc = xd->value_len;\n\t\t\tif (buffer) {\n\t\t\t\tif (size < rc) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buffer, xd->xvalue, rc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENODATA;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "uffer,",
            "d->xvalue,",
            "c)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "name,",
            "d->xname)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c < 0)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elete_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "elete_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "576-594",
          "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c > 0)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "oad_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "263-282",
          "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef->ic!=ic)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_xattr_ref_inode(",
          "args": [
            ",",
            "c)"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "heck_xattr_ref_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "634-688",
          "snippet": "tatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SB_INFO(",
          "args": [
            "node->i_sb)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_INODE_INFO(",
          "args": [
            "node)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt do_jffs2_getxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      char *buffer, size_t size)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tint rc, retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic!=ic);\n\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(xname, xd->xname)) {\n\t\t\trc = xd->value_len;\n\t\t\tif (buffer) {\n\t\t\t\tif (size < rc) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buffer, xd->xvalue, rc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENODATA;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ffs2_listxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "961-1022",
    "snippet": "size_t jffs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tstruct jffs2_xattr_datum *xd;\n\tconst struct xattr_handler *xhandle;\n\tssize_t len, rc;\n\tint retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tlen = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic != ic);\n\t\txd = ref->xd;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\txhandle = xprefix_to_handler(xd->xprefix);\n\t\tif (!xhandle)\n\t\t\tcontinue;\n\t\tif (buffer) {\n\t\t\trc = xhandle->list(dentry, buffer+len, size-len,\n\t\t\t\t\t   xd->xname, xd->name_len, xd->flags);\n\t\t} else {\n\t\t\trc = xhandle->list(dentry, NULL, 0, xd->xname,\n\t\t\t\t\t   xd->name_len, xd->flags);\n\t\t}\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tlen += rc;\n\t}\n\trc = len;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle->list",
          "args": [
            "entry,",
            "ULL,",
            ",",
            "d->xname,",
            "d->name_len,",
            "d->flags)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle->list",
          "args": [
            "entry,",
            "uffer+len,",
            "ize-len,",
            "d->xname,",
            "d->name_len,",
            "d->flags)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefix_to_handler(",
          "args": [
            "d->xprefix)"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_to_handler(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "931-959",
          "snippet": "tatic const struct xattr_handler *xprefix_to_handler(int xprefix) {\n\tconst struct xattr_handler *ret;\n\n\tswitch (xprefix) {\n\tcase JFFS2_XPREFIX_USER:\n\t\tret = &jffs2_user_xattr_handler;\n\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\tcase JFFS2_XPREFIX_SECURITY:\n\t\tret = &jffs2_security_xattr_handler;\n\t\tbreak;\n#endif\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tcase JFFS2_XPREFIX_ACL_ACCESS:\n\t\tret = &posix_acl_access_xattr_handler;\n\t\tbreak;\n\tcase JFFS2_XPREFIX_ACL_DEFAULT:\n\t\tret = &posix_acl_default_xattr_handler;\n\t\tbreak;\n#endif\n\tcase JFFS2_XPREFIX_TRUSTED:\n\t\tret = &jffs2_trusted_xattr_handler;\n\t\tbreak;\n\tdefault:\n\t\tret = NULL;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic const struct xattr_handler *xprefix_to_handler(int xprefix) {\n\tconst struct xattr_handler *ret;\n\n\tswitch (xprefix) {\n\tcase JFFS2_XPREFIX_USER:\n\t\tret = &jffs2_user_xattr_handler;\n\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\tcase JFFS2_XPREFIX_SECURITY:\n\t\tret = &jffs2_security_xattr_handler;\n\t\tbreak;\n#endif\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tcase JFFS2_XPREFIX_ACL_ACCESS:\n\t\tret = &posix_acl_access_xattr_handler;\n\t\tbreak;\n\tcase JFFS2_XPREFIX_ACL_DEFAULT:\n\t\tret = &posix_acl_default_xattr_handler;\n\t\tbreak;\n#endif\n\tcase JFFS2_XPREFIX_TRUSTED:\n\t\tret = &jffs2_trusted_xattr_handler;\n\t\tbreak;\n\tdefault:\n\t\tret = NULL;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c < 0)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elete_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "elete_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "576-594",
          "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c > 0)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "oad_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "263-282",
          "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef->ic != ic)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_xattr_ref_inode(",
          "args": [
            ",",
            "c)"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "heck_xattr_ref_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "634-688",
          "snippet": "tatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SB_INFO(",
          "args": [
            "node->i_sb)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_INODE_INFO(",
          "args": [
            "node)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nsize_t jffs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tstruct jffs2_xattr_datum *xd;\n\tconst struct xattr_handler *xhandle;\n\tssize_t len, rc;\n\tint retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tlen = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic != ic);\n\t\txd = ref->xd;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\txhandle = xprefix_to_handler(xd->xprefix);\n\t\tif (!xhandle)\n\t\t\tcontinue;\n\t\tif (buffer) {\n\t\t\trc = xhandle->list(dentry, buffer+len, size-len,\n\t\t\t\t\t   xd->xname, xd->name_len, xd->flags);\n\t\t} else {\n\t\t\trc = xhandle->list(dentry, NULL, 0, xd->xname,\n\t\t\t\t\t   xd->name_len, xd->flags);\n\t\t}\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tlen += rc;\n\t}\n\trc = len;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "prefix_to_handler(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "931-959",
    "snippet": "tatic const struct xattr_handler *xprefix_to_handler(int xprefix) {\n\tconst struct xattr_handler *ret;\n\n\tswitch (xprefix) {\n\tcase JFFS2_XPREFIX_USER:\n\t\tret = &jffs2_user_xattr_handler;\n\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\tcase JFFS2_XPREFIX_SECURITY:\n\t\tret = &jffs2_security_xattr_handler;\n\t\tbreak;\n#endif\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tcase JFFS2_XPREFIX_ACL_ACCESS:\n\t\tret = &posix_acl_access_xattr_handler;\n\t\tbreak;\n\tcase JFFS2_XPREFIX_ACL_DEFAULT:\n\t\tret = &posix_acl_default_xattr_handler;\n\t\tbreak;\n#endif\n\tcase JFFS2_XPREFIX_TRUSTED:\n\t\tret = &jffs2_trusted_xattr_handler;\n\t\tbreak;\n\tdefault:\n\t\tret = NULL;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic const struct xattr_handler *xprefix_to_handler(int xprefix) {\n\tconst struct xattr_handler *ret;\n\n\tswitch (xprefix) {\n\tcase JFFS2_XPREFIX_USER:\n\t\tret = &jffs2_user_xattr_handler;\n\t\tbreak;\n#ifdef CONFIG_JFFS2_FS_SECURITY\n\tcase JFFS2_XPREFIX_SECURITY:\n\t\tret = &jffs2_security_xattr_handler;\n\t\tbreak;\n#endif\n#ifdef CONFIG_JFFS2_FS_POSIX_ACL\n\tcase JFFS2_XPREFIX_ACL_ACCESS:\n\t\tret = &posix_acl_access_xattr_handler;\n\t\tbreak;\n\tcase JFFS2_XPREFIX_ACL_DEFAULT:\n\t\tret = &posix_acl_default_xattr_handler;\n\t\tbreak;\n#endif\n\tcase JFFS2_XPREFIX_TRUSTED:\n\t\tret = &jffs2_trusted_xattr_handler;\n\t\tbreak;\n\tdefault:\n\t\tret = NULL;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_setup_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "889-906",
    "snippet": "truct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t  uint32_t xid, uint32_t version)\n{\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = jffs2_find_xattr_datum(c, xid);\n\tif (!xd) {\n\t\txd = jffs2_alloc_xattr_datum();\n\t\tif (!xd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\txd->xid = xid;\n\t\txd->version = version;\n\t\tif (xd->xid > c->highest_xid)\n\t\t\tc->highest_xid = xd->xid;\n\t\tlist_add_tail(&xd->xindex, &c->xattrindex[xid % XATTRINDEX_HASHSIZE]);\n\t}\n\treturn xd;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "xd->xindex,",
            "c->xattrindex[xid % XATTRINDEX_HASHSIZE])"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_xattr_datum(",
          "args": [],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_find_xattr_datum(",
          "args": [
            ",",
            "id)"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_find_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "725-738",
          "snippet": "tatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t  uint32_t xid, uint32_t version)\n{\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = jffs2_find_xattr_datum(c, xid);\n\tif (!xd) {\n\t\txd = jffs2_alloc_xattr_datum();\n\t\tif (!xd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\txd->xid = xid;\n\t\txd->version = version;\n\t\tif (xd->xid > c->highest_xid)\n\t\t\tc->highest_xid = xd->xid;\n\t\tlist_add_tail(&xd->xindex, &c->xattrindex[xid % XATTRINDEX_HASHSIZE]);\n\t}\n\treturn xd;\n}"
  },
  {
    "function_name": "ffs2_build_xattr_subsystem(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "775-887",
    "snippet": "oid jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tstruct jffs2_xattr_ref *xref_tmphash[XREF_TMPHASH_SIZE];\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_raw_node_ref *raw;\n\tint i, xdatum_count = 0, xdatum_unchecked_count = 0, xref_count = 0;\n\tint xdatum_orphan_count = 0, xref_orphan_count = 0, xref_dead_count = 0;\n\n\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_BUILDING));\n\n\t/* Phase.1 : Merge same xref */\n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++)\n\t\txref_tmphash[i] = NULL;\n\tfor (ref=c->xref_temp; ref; ref=_ref) {\n\t\tstruct jffs2_xattr_ref *tmp;\n\n\t\t_ref = ref->next;\n\t\tif (ref_flags(ref->node) != REF_PRISTINE) {\n\t\t\tif (verify_xattr_ref(c, ref)) {\n\t\t\t\tBUG_ON(ref->node->next_in_ino != (void *)ref);\n\t\t\t\tref->node->next_in_ino = NULL;\n\t\t\t\tjffs2_mark_node_obsolete(c, ref->node);\n\t\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ti = (ref->ino ^ ref->xid) % XREF_TMPHASH_SIZE;\n\t\tfor (tmp=xref_tmphash[i]; tmp; tmp=tmp->next) {\n\t\t\tif (tmp->ino == ref->ino && tmp->xid == ref->xid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tmp) {\n\t\t\traw = ref->node;\n\t\t\tif (ref->xseqno > tmp->xseqno) {\n\t\t\t\ttmp->xseqno = ref->xseqno;\n\t\t\t\traw->next_in_ino = tmp->node;\n\t\t\t\ttmp->node = raw;\n\t\t\t} else {\n\t\t\t\traw->next_in_ino = tmp->node->next_in_ino;\n\t\t\t\ttmp->node->next_in_ino = raw;\n\t\t\t}\n\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tref->next = xref_tmphash[i];\n\t\t\txref_tmphash[i] = ref;\n\t\t}\n\t}\n\tc->xref_temp = NULL;\n\n\t/* Phase.2 : Bind xref with inode_cache and xattr_datum */\n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++) {\n\t\tfor (ref=xref_tmphash[i]; ref; ref=_ref) {\n\t\t\txref_count++;\n\t\t\t_ref = ref->next;\n\t\t\tif (is_xattr_ref_dead(ref)) {\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_dead_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* At this point, ref->xid and ref->ino contain XID and inode number.\n\t\t\t   ref->xd and ref->ic are not valid yet. */\n\t\t\txd = jffs2_find_xattr_datum(c, ref->xid);\n\t\t\tic = jffs2_get_ino_cache(c, ref->ino);\n\t\t\tif (!xd || !ic || !ic->pino_nlink) {\n\t\t\t\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) is orphan.\\n\",\n\t\t\t\t\t  ref->ino, ref->xid, ref->xseqno);\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tref->xd = xd;\n\t\t\tref->ic = ic;\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t}\n\n\t/* Phase.3 : Link unchecked xdatum to xattr_unchecked list */\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\txdatum_count++;\n\t\t\tlist_del_init(&xd->xindex);\n\t\t\tif (!atomic_read(&xd->refcnt)) {\n\t\t\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) is orphan.\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_xattr_datum_unchecked(c, xd)) {\n\t\t\t\tdbg_xattr(\"unchecked xdatum(xid=%u, version=%u)\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_unchecked_count++;\n\t\t\t}\n\t\t}\n\t}\n\t/* build complete */\n\tJFFS2_NOTICE(\"complete building xattr subsystem, %u of xdatum\"\n\t\t     \" (%u unchecked, %u orphan) and \"\n\t\t     \"%u of xref (%u dead, %u orphan) found.\\n\",\n\t\t     xdatum_count, xdatum_unchecked_count, xdatum_orphan_count,\n\t\t     xref_count, xref_dead_count, xref_orphan_count);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FFS2_NOTICE(",
          "args": [
            "complete building xattr subsystem, %u of xdatum\"\n\t\t     \" (%u unchecked, %u orphan) and \"\n\t\t     \"%u of xref (%u dead, %u orphan) found.\\n\",",
            "datum_count,",
            "datum_unchecked_count,",
            "datum_orphan_count,",
            "ref_count,",
            "ref_dead_count,",
            "ref_orphan_count)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattr_unchecked)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "unchecked xdatum(xid=%u, version=%u)\\n\",",
            "d->xid,",
            "d->version)"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_xattr_datum_unchecked(",
          "args": [
            ",",
            "d)"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "s_xattr_datum_unchecked(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "71-85",
          "snippet": "tatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattr_unchecked)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xdatum(xid=%u, version=%u) is orphan.\\n\",",
            "d->xid,",
            "d->version)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_read(",
          "args": [
            "xd->refcnt)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "xd->xindex)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattrindex[i],",
            "index)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_inc(",
          "args": [
            "xd->refcnt)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xref(ino=%u, xid=%u, xseqno=%u) is orphan.\\n\",",
            "ef->ino,",
            "ef->xid,",
            "ef->xseqno)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_get_ino_cache(",
          "args": [
            ",",
            "ef->ino)"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_get_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "421-434",
          "snippet": "truct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_find_xattr_datum(",
          "args": [
            ",",
            "ef->xid)"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_find_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "725-738",
          "snippet": "tatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s_xattr_ref_dead(",
          "args": [
            "ef)"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "s_xattr_ref_dead(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.h",
          "lines": "66-69",
          "snippet": "tatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}",
          "includes": [
            "include <linux/list.h>",
            "include <linux/xattr.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/list.h>\ninclude <linux/xattr.h>\n#\n\ntatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_ref(",
          "args": [
            "ef)"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "ef->node)"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef->node->next_in_ino != (void *)ref)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erify_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "erify_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "444-504",
          "snippet": "tatic int verify_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t/* obsolete node */\n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR(\"inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=ref->node; raw != (void *)ref; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((ref->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",\n\t\t  ref->ino, ref->xid, ref_offset(ref->node));\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int verify_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t/* obsolete node */\n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR(\"inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=ref->node; raw != (void *)ref; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((ref->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",\n\t\t  ref->ino, ref->xid, ref_offset(ref->node));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "ef->node)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "(c->flags & JFFS2_SB_FLAG_BUILDING))"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tstruct jffs2_xattr_ref *xref_tmphash[XREF_TMPHASH_SIZE];\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_raw_node_ref *raw;\n\tint i, xdatum_count = 0, xdatum_unchecked_count = 0, xref_count = 0;\n\tint xdatum_orphan_count = 0, xref_orphan_count = 0, xref_dead_count = 0;\n\n\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_BUILDING));\n\n\t/* Phase.1 : Merge same xref */\n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++)\n\t\txref_tmphash[i] = NULL;\n\tfor (ref=c->xref_temp; ref; ref=_ref) {\n\t\tstruct jffs2_xattr_ref *tmp;\n\n\t\t_ref = ref->next;\n\t\tif (ref_flags(ref->node) != REF_PRISTINE) {\n\t\t\tif (verify_xattr_ref(c, ref)) {\n\t\t\t\tBUG_ON(ref->node->next_in_ino != (void *)ref);\n\t\t\t\tref->node->next_in_ino = NULL;\n\t\t\t\tjffs2_mark_node_obsolete(c, ref->node);\n\t\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ti = (ref->ino ^ ref->xid) % XREF_TMPHASH_SIZE;\n\t\tfor (tmp=xref_tmphash[i]; tmp; tmp=tmp->next) {\n\t\t\tif (tmp->ino == ref->ino && tmp->xid == ref->xid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tmp) {\n\t\t\traw = ref->node;\n\t\t\tif (ref->xseqno > tmp->xseqno) {\n\t\t\t\ttmp->xseqno = ref->xseqno;\n\t\t\t\traw->next_in_ino = tmp->node;\n\t\t\t\ttmp->node = raw;\n\t\t\t} else {\n\t\t\t\traw->next_in_ino = tmp->node->next_in_ino;\n\t\t\t\ttmp->node->next_in_ino = raw;\n\t\t\t}\n\t\t\tjffs2_free_xattr_ref(ref);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tref->next = xref_tmphash[i];\n\t\t\txref_tmphash[i] = ref;\n\t\t}\n\t}\n\tc->xref_temp = NULL;\n\n\t/* Phase.2 : Bind xref with inode_cache and xattr_datum */\n\tfor (i=0; i < XREF_TMPHASH_SIZE; i++) {\n\t\tfor (ref=xref_tmphash[i]; ref; ref=_ref) {\n\t\t\txref_count++;\n\t\t\t_ref = ref->next;\n\t\t\tif (is_xattr_ref_dead(ref)) {\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_dead_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* At this point, ref->xid and ref->ino contain XID and inode number.\n\t\t\t   ref->xd and ref->ic are not valid yet. */\n\t\t\txd = jffs2_find_xattr_datum(c, ref->xid);\n\t\t\tic = jffs2_get_ino_cache(c, ref->ino);\n\t\t\tif (!xd || !ic || !ic->pino_nlink) {\n\t\t\t\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) is orphan.\\n\",\n\t\t\t\t\t  ref->ino, ref->xid, ref->xseqno);\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\txref_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tref->xd = xd;\n\t\t\tref->ic = ic;\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t}\n\n\t/* Phase.3 : Link unchecked xdatum to xattr_unchecked list */\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\txdatum_count++;\n\t\t\tlist_del_init(&xd->xindex);\n\t\t\tif (!atomic_read(&xd->refcnt)) {\n\t\t\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) is orphan.\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_orphan_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_xattr_datum_unchecked(c, xd)) {\n\t\t\t\tdbg_xattr(\"unchecked xdatum(xid=%u, version=%u)\\n\",\n\t\t\t\t\t  xd->xid, xd->version);\n\t\t\t\tlist_add(&xd->xindex, &c->xattr_unchecked);\n\t\t\t\txdatum_unchecked_count++;\n\t\t\t}\n\t\t}\n\t}\n\t/* build complete */\n\tJFFS2_NOTICE(\"complete building xattr subsystem, %u of xdatum\"\n\t\t     \" (%u unchecked, %u orphan) and \"\n\t\t     \"%u of xref (%u dead, %u orphan) found.\\n\",\n\t\t     xdatum_count, xdatum_unchecked_count, xdatum_orphan_count,\n\t\t     xref_count, xref_dead_count, xref_orphan_count);\n}"
  },
  {
    "function_name": "ffs2_clear_xattr_subsystem(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "740-772",
    "snippet": "oid jffs2_clear_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tint i;\n\n\tfor (ref=c->xref_temp; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (ref=c->xref_dead_list; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\tlist_del(&xd->xindex);\n\t\t\tkfree(xd->xname);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_dead_list, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_xattr_datum(",
          "args": [
            "d)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "300-304",
          "snippet": "oid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "xd->xindex)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattr_unchecked,",
            "index)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "xd->xindex)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattr_dead_list,",
            "index)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "d->xname)"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "xd->xindex)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattrindex[i],",
            "index)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_ref(",
          "args": [
            "ef)"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_clear_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\tint i;\n\n\tfor (ref=c->xref_temp; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (ref=c->xref_dead_list; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[i], xindex) {\n\t\t\tlist_del(&xd->xindex);\n\t\t\tkfree(xd->xname);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_dead_list, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n\tlist_for_each_entry_safe(xd, _xd, &c->xattr_unchecked, xindex) {\n\t\tlist_del(&xd->xindex);\n\t\tjffs2_free_xattr_datum(xd);\n\t}\n}"
  },
  {
    "function_name": "ffs2_find_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "725-738",
    "snippet": "tatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "d,",
            "c->xattrindex[i],",
            "index)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)))"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_datum *jffs2_find_xattr_datum(struct jffs2_sb_info *c, uint32_t xid)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tint i = xid % XATTRINDEX_HASHSIZE;\n\n\t/* It's only used in scanning/building process. */\n\tBUG_ON(!(c->flags & (JFFS2_SB_FLAG_SCANNING|JFFS2_SB_FLAG_BUILDING)));\n\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->xid==xid)\n\t\t\treturn xd;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ffs2_init_xattr_subsystem(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "707-723",
    "snippet": "oid jffs2_init_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tint i;\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++)\n\t\tINIT_LIST_HEAD(&c->xattrindex[i]);\n\tINIT_LIST_HEAD(&c->xattr_unchecked);\n\tINIT_LIST_HEAD(&c->xattr_dead_list);\n\tc->xref_dead_list = NULL;\n\tc->xref_temp = NULL;\n\n\tinit_rwsem(&c->xattr_sem);\n\tc->highest_xid = 0;\n\tc->highest_xseqno = 0;\n\tc->xdatum_mem_usage = 0;\n\tc->xdatum_mem_threshold = 32 * 1024;\t/* Default 32KB */\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nit_rwsem(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_LIST_HEAD(",
          "args": [
            "c->xattr_dead_list)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_LIST_HEAD(",
          "args": [
            "c->xattr_unchecked)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_LIST_HEAD(",
          "args": [
            "c->xattrindex[i])"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_init_xattr_subsystem(struct jffs2_sb_info *c)\n{\n\tint i;\n\n\tfor (i=0; i < XATTRINDEX_HASHSIZE; i++)\n\t\tINIT_LIST_HEAD(&c->xattrindex[i]);\n\tINIT_LIST_HEAD(&c->xattr_unchecked);\n\tINIT_LIST_HEAD(&c->xattr_dead_list);\n\tc->xref_dead_list = NULL;\n\tc->xref_temp = NULL;\n\n\tinit_rwsem(&c->xattr_sem);\n\tc->highest_xid = 0;\n\tc->highest_xseqno = 0;\n\tc->xdatum_mem_usage = 0;\n\tc->xdatum_mem_threshold = 32 * 1024;\t/* Default 32KB */\n}"
  },
  {
    "function_name": "ffs2_xattr_do_crccheck_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "690-693",
    "snippet": "oid jffs2_xattr_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tcheck_xattr_ref_inode(c, ic);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heck_xattr_ref_inode(",
          "args": [
            ",",
            "c)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "heck_xattr_ref_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "634-688",
          "snippet": "tatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_xattr_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tcheck_xattr_ref_inode(c, ic);\n}"
  },
  {
    "function_name": "heck_xattr_ref_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "634-688",
    "snippet": "tatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elete_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "elete_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "576-594",
          "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "ef->xd->xname,",
            "mp->xd->xname)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c < 0)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c > 0)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_xattr_datum(",
          "args": [
            ",",
            "mp->xd)"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "oad_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "263-282",
          "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c < 0)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "c > 0)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(",
          "args": [
            "c->flags & INO_FLAGS_XATTR_CHECKED)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_xattr_ref_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* success of check_xattr_ref_inode() means that inode (ic) dose not have\n\t * duplicate name/value pairs. If duplicate name/value pair would be found,\n\t * one will be removed.\n\t */\n\tstruct jffs2_xattr_ref *ref, *cmp, **pref, **pcmp;\n\tint rc = 0;\n\n\tif (likely(ic->flags & INO_FLAGS_XATTR_CHECKED))\n\t\treturn 0;\n\tdown_write(&c->xattr_sem);\n retry:\n\trc = 0;\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tif (!ref->xd->xname) {\n\t\t\trc = load_xattr_datum(c, ref->xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfor (cmp=ref->next, pcmp=&ref->next; cmp; pcmp=&cmp->next, cmp=cmp->next) {\n\t\t\tif (!cmp->xd->xname) {\n\t\t\t\tref->xd->flags |= JFFS2_XFLAGS_BIND;\n\t\t\t\trc = load_xattr_datum(c, cmp->xd);\n\t\t\t\tref->xd->flags &= ~JFFS2_XFLAGS_BIND;\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ref->xd->xprefix == cmp->xd->xprefix\n\t\t\t    && !strcmp(ref->xd->xname, cmp->xd->xname)) {\n\t\t\t\tif (ref->xseqno > cmp->xseqno) {\n\t\t\t\t\t*pcmp = cmp->next;\n\t\t\t\t\tdelete_xattr_ref(c, cmp);\n\t\t\t\t} else {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t}\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t}\n\tic->flags |= INO_FLAGS_XATTR_CHECKED;\n out:\n\tup_write(&c->xattr_sem);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ffs2_xattr_free_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "614-632",
    "snippet": "oid jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_free_ino_caches() until unmounting FS. */\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\txd = ref->xd;\n\t\tif (atomic_dec_and_test(&xd->refcnt)) {\n\t\t\tunload_xattr_datum(c, xd);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_ref(",
          "args": [
            "ef)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_datum(",
          "args": [
            "d)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "300-304",
          "snippet": "oid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nload_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "nload_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "87-100",
          "snippet": "tatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomic_dec_and_test(",
          "args": [
            "xd->refcnt)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_free_ino_caches() until unmounting FS. */\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\txd = ref->xd;\n\t\tif (atomic_dec_and_test(&xd->refcnt)) {\n\t\t\tunload_xattr_datum(c, xd);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}"
  },
  {
    "function_name": "ffs2_xattr_delete_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "596-612",
    "snippet": "oid jffs2_xattr_delete_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_evict_inode() on inode removing.\n\t   When an inode with XATTR is removed, those XATTRs must be removed. */\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tif (!ic || ic->pino_nlink > 0)\n\t\treturn;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tdelete_xattr_ref(c, ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elete_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "elete_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "576-594",
          "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "c->xattr_sem)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_xattr_delete_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_evict_inode() on inode removing.\n\t   When an inode with XATTR is removed, those XATTRs must be removed. */\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tif (!ic || ic->pino_nlink > 0)\n\t\treturn;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\tdelete_xattr_ref(c, ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}"
  },
  {
    "function_name": "elete_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "576-594",
    "snippet": "tatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nrefer_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "nrefer_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "404-421",
          "snippet": "tatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",",
            "ef->ino,",
            "ef->xid,",
            "ef->xseqno)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void delete_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = ref->xd;\n\tref->xseqno |= XREF_DELETE_MARKER;\n\tref->ino = ref->ic->ino;\n\tref->xid = ref->xd->xid;\n\tspin_lock(&c->erase_completion_lock);\n\tref->next = c->xref_dead_list;\n\tc->xref_dead_list = ref;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"xref(ino=%u, xid=%u, xseqno=%u) was removed.\\n\",\n\t\t  ref->ino, ref->xid, ref->xseqno);\n\n\tunrefer_xattr_datum(c, xd);\n}"
  },
  {
    "function_name": "reate_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "550-574",
    "snippet": "tatic struct jffs2_xattr_ref *create_xattr_ref(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic,\n\t\t\t\t\t\tstruct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_ref *ref;\n\tint ret;\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tref->ic = ic;\n\tref->xd = xd;\n\n\tret = save_xattr_ref(c, ref);\n\tif (ret) {\n\t\tjffs2_free_xattr_ref(ref);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* Chain to inode */\n\tref->next = ic->xref;\n\tic->xref = ref;\n\n\treturn ref; /* success */\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "et)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_ref(",
          "args": [
            "ef)"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ave_xattr_ref(",
          "args": [
            ",",
            "ef)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ave_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "506-548",
          "snippet": "tatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_xattr_ref(",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_ref *create_xattr_ref(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic,\n\t\t\t\t\t\tstruct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_ref *ref;\n\tint ret;\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tref->ic = ic;\n\tref->xd = xd;\n\n\tret = save_xattr_ref(c, ref);\n\tif (ret) {\n\t\tjffs2_free_xattr_ref(ref);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* Chain to inode */\n\tref->next = ic->xref;\n\tic->xref = ref;\n\n\treturn ref; /* success */\n}"
  },
  {
    "function_name": "ave_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "506-548",
    "snippet": "tatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "success on saving xref (ino=%u, xid=%u)\\n\",",
            "ef->ic->ino,",
            "ef->xd->xid)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_physical_node_ref(",
          "args": [
            ",",
            "hys_ofs | REF_PRISTINE,",
            "AD(sizeof(rr)),",
            "void *)ref)"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_physical_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "500-553",
          "snippet": "truct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rr))"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rr))"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",",
            "et,",
            "izeof(rr),",
            "ength,",
            "hys_ofs)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_write(",
          "args": [
            ",",
            "hys_ofs,",
            "izeof(rr),",
            "length,",
            "char *)&rr)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, &rr, sizeof(rr) - 4))"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rr,",
            "izeof(rr) - 4)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "seqno)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ef->xd->xid)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ef->ic->ino)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ef->xid)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ef->ino)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_xattr_ref_dead(",
          "args": [
            "ef)"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "s_xattr_ref_dead(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.h",
          "lines": "66-69",
          "snippet": "tatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}",
          "includes": [
            "include <linux/list.h>",
            "include <linux/xattr.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/list.h>\ninclude <linux/xattr.h>\n#\n\ntatic inline int is_xattr_ref_dead(struct jffs2_xattr_ref *ref)\n{\n\treturn ((ref->xseqno & XREF_DELETE_MARKER) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4))"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rr,",
            "izeof(struct jffs2_unknown_node) - 4)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "AD(sizeof(rr)))"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rr))"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_XREF)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xref rr;\n\tsize_t length;\n\tuint32_t xseqno, phys_ofs = write_ofs(c);\n\tint ret;\n\n\trr.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trr.nodetype = cpu_to_je16(JFFS2_NODETYPE_XREF);\n\trr.totlen = cpu_to_je32(PAD(sizeof(rr)));\n\trr.hdr_crc = cpu_to_je32(crc32(0, &rr, sizeof(struct jffs2_unknown_node) - 4));\n\n\txseqno = (c->highest_xseqno += 2);\n\tif (is_xattr_ref_dead(ref)) {\n\t\txseqno |= XREF_DELETE_MARKER;\n\t\trr.ino = cpu_to_je32(ref->ino);\n\t\trr.xid = cpu_to_je32(ref->xid);\n\t} else {\n\t\trr.ino = cpu_to_je32(ref->ic->ino);\n\t\trr.xid = cpu_to_je32(ref->xd->xid);\n\t}\n\trr.xseqno = cpu_to_je32(xseqno);\n\trr.node_crc = cpu_to_je32(crc32(0, &rr, sizeof(rr) - 4));\n\n\tret = jffs2_flash_write(c, phys_ofs, sizeof(rr), &length, (char *)&rr);\n\tif (ret || sizeof(rr) != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_write() returned %d, request=%zu, retlen=%zu, at %#08x\\n\",\n\t\t\t      ret, sizeof(rr), length, phys_ofs);\n\t\tret = ret ? ret : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(sizeof(rr)), NULL);\n\n\t\treturn ret;\n\t}\n\t/* success */\n\tref->xseqno = xseqno;\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(sizeof(rr)), (void *)ref);\n\n\tdbg_xattr(\"success on saving xref (ino=%u, xid=%u)\\n\", ref->ic->ino, ref->xd->xid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "erify_xattr_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "444-504",
    "snippet": "tatic int verify_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t/* obsolete node */\n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR(\"inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=ref->node; raw != (void *)ref; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((ref->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",\n\t\t  ref->ino, ref->xid, ref_offset(ref->node));\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",",
            "ef->ino,",
            "ef->xid,",
            "ef_offset(ref->node))"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef->node)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "aw)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "ef_totlen(c, jeb, raw))"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "aw)"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.xseqno)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.xid)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.ino)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",",
            "ffset,",
            "e16_to_cpu(rr.magic),",
            "FFS2_MAGIC_BITMASK,",
            "e16_to_cpu(rr.nodetype),",
            "FFS2_NODETYPE_XREF,",
            "e32_to_cpu(rr.totlen),",
            "AD(sizeof(rr)))"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rr))"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.totlen)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "r.nodetype)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "r.magic)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rr))"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.totlen)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "r.nodetype)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "r.magic)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",",
            "ffset,",
            "e32_to_cpu(rr.node_crc),",
            "rc)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.node_crc)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r.node_crc)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rr,",
            "izeof(rr) - 4)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",",
            "c,",
            "izeof(rr),",
            "eadlen,",
            "ffset)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "ffset,",
            "izeof(rr),",
            "readlen,",
            "char *)&rr)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef->node)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "ef->node)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int verify_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xref rr;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (ref_flags(ref->node) != REF_UNCHECKED)\n\t\tgoto complete;\n\toffset = ref_offset(ref->node);\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rr), &readlen, (char *)&rr);\n\tif (rc || sizeof(rr) != readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu, at %#08x\\n\",\n\t\t\t      rc, sizeof(rr), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\t/* obsolete node */\n\tcrc = crc32(0, &rr, sizeof(rr) - 4);\n\tif (crc != je32_to_cpu(rr.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rr.node_crc), crc);\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tif (je16_to_cpu(rr.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rr.nodetype) != JFFS2_NODETYPE_XREF\n\t    || je32_to_cpu(rr.totlen) != PAD(sizeof(rr))) {\n\t\tJFFS2_ERROR(\"inconsistent xref at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%zu\\n\",\n\t\t\t    offset, je16_to_cpu(rr.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rr.nodetype), JFFS2_NODETYPE_XREF,\n\t\t\t    je32_to_cpu(rr.totlen), PAD(sizeof(rr)));\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\tref->ino = je32_to_cpu(rr.ino);\n\tref->xid = je32_to_cpu(rr.xid);\n\tref->xseqno = je32_to_cpu(rr.xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=ref->node; raw != (void *)ref; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((ref->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\tdbg_xattr(\"success on verifying xref (ino=%u, xid=%u) at %#08x\\n\",\n\t\t  ref->ino, ref->xid, ref_offset(ref->node));\n\treturn 0;\n}"
  },
  {
    "function_name": "nrefer_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "404-421",
    "snippet": "tatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "xdatum(xid=%u, version=%u) was removed.\\n\",",
            "d->xid,",
            "d->version)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattr_dead_list)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_datum(",
          "args": [
            "d)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "300-304",
          "snippet": "oid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "(xd->flags & JFFS2_XFLAGS_INVALID))"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nload_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "nload_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "87-100",
          "snippet": "tatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomic_dec_and_lock(",
          "args": [
            "xd->refcnt,",
            "c->erase_completion_lock)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unrefer_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tif (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {\n\t\tunload_xattr_datum(c, xd);\n\t\txd->flags |= JFFS2_XFLAGS_DEAD;\n\t\tif (xd->node == (void *)xd) {\n\t\t\tBUG_ON(!(xd->flags & JFFS2_XFLAGS_INVALID));\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t} else {\n\t\t\tlist_add(&xd->xindex, &c->xattr_dead_list);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tdbg_xattr(\"xdatum(xid=%u, version=%u) was removed.\\n\",\n\t\t\t  xd->xid, xd->version);\n\t}\n}"
  },
  {
    "function_name": "reate_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "336-402",
    "snippet": "tatic struct jffs2_xattr_datum *create_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    int xprefix, const char *xname,\n\t\t\t\t\t\t    const char *xvalue, int xsize)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t hashkey, name_len;\n\tchar *data;\n\tint i, rc;\n\n\t/* Search xattr_datum has same xname/xvalue by index */\n\thashkey = xattr_datum_hashkey(xprefix, xname, xvalue, xsize);\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->hashkey==hashkey\n\t\t    && xd->xprefix==xprefix\n\t\t    && xd->value_len==xsize\n\t\t    && !strcmp(xd->xname, xname)\n\t\t    && !memcmp(xd->xvalue, xvalue, xsize)) {\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\treturn xd;\n\t\t}\n\t}\n\n\t/* Not found, Create NEW XATTR-Cache */\n\tname_len = strlen(xname);\n\n\txd = jffs2_alloc_xattr_datum();\n\tif (!xd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kmalloc(name_len + 1 + xsize, GFP_KERNEL);\n\tif (!data) {\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstrcpy(data, xname);\n\tmemcpy(data + name_len + 1, xvalue, xsize);\n\n\tatomic_set(&xd->refcnt, 1);\n\txd->xid = ++c->highest_xid;\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xprefix = xprefix;\n\n\txd->hashkey = hashkey;\n\txd->xname = data;\n\txd->xvalue = data + name_len + 1;\n\txd->name_len = name_len;\n\txd->value_len = xsize;\n\txd->data_crc = crc32(0, data, xd->name_len + 1 + xd->value_len);\n\n\trc = save_xattr_datum(c, xd);\n\tif (rc) {\n\t\tkfree(xd->xname);\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* Insert Hash Index */\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\n\tc->xdatum_mem_usage += (xd->name_len + 1 + xd->value_len);\n\treclaim_xattr_datum(c);\n\n\treturn xd;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eclaim_xattr_datum(",
          "args": [
            ")"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "eclaim_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "102-130",
          "snippet": "tatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattrindex[i])"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "c)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_xattr_datum(",
          "args": [
            "d)"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "300-304",
          "snippet": "oid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_datum(struct jffs2_xattr_datum *xd)\n{\n\tdbg_memalloc(\"%p\\n\", xd);\n\tkmem_cache_free(xattr_datum_cache, xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "d->xname)"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ave_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ave_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "284-334",
          "snippet": "tatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "ata,",
            "d->name_len + 1 + xd->value_len)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_set(",
          "args": [
            "xd->refcnt,",
            ")"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "ata + name_len + 1,",
            "value,",
            "size)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcpy(",
          "args": [
            "ata,",
            "name)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "ame_len + 1 + xsize,",
            "FP_KERNEL)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_xattr_datum(",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "name)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_inc(",
          "args": [
            "xd->refcnt)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcmp(",
          "args": [
            "d->xvalue,",
            "value,",
            "size)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "d->xname,",
            "name)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "d,",
            "c->xattrindex[i],",
            "index)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr_datum_hashkey(",
          "args": [
            "prefix,",
            "name,",
            "value,",
            "size)"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "attr_datum_hashkey(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "64-69",
          "snippet": "tatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_xattr_datum *create_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t    int xprefix, const char *xname,\n\t\t\t\t\t\t    const char *xvalue, int xsize)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t hashkey, name_len;\n\tchar *data;\n\tint i, rc;\n\n\t/* Search xattr_datum has same xname/xvalue by index */\n\thashkey = xattr_datum_hashkey(xprefix, xname, xvalue, xsize);\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_for_each_entry(xd, &c->xattrindex[i], xindex) {\n\t\tif (xd->hashkey==hashkey\n\t\t    && xd->xprefix==xprefix\n\t\t    && xd->value_len==xsize\n\t\t    && !strcmp(xd->xname, xname)\n\t\t    && !memcmp(xd->xvalue, xvalue, xsize)) {\n\t\t\tatomic_inc(&xd->refcnt);\n\t\t\treturn xd;\n\t\t}\n\t}\n\n\t/* Not found, Create NEW XATTR-Cache */\n\tname_len = strlen(xname);\n\n\txd = jffs2_alloc_xattr_datum();\n\tif (!xd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kmalloc(name_len + 1 + xsize, GFP_KERNEL);\n\tif (!data) {\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstrcpy(data, xname);\n\tmemcpy(data + name_len + 1, xvalue, xsize);\n\n\tatomic_set(&xd->refcnt, 1);\n\txd->xid = ++c->highest_xid;\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xprefix = xprefix;\n\n\txd->hashkey = hashkey;\n\txd->xname = data;\n\txd->xvalue = data + name_len + 1;\n\txd->name_len = name_len;\n\txd->value_len = xsize;\n\txd->data_crc = crc32(0, data, xd->name_len + 1 + xd->value_len);\n\n\trc = save_xattr_datum(c, xd);\n\tif (rc) {\n\t\tkfree(xd->xname);\n\t\tjffs2_free_xattr_datum(xd);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* Insert Hash Index */\n\ti = hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\n\tc->xdatum_mem_usage += (xd->name_len + 1 + xd->value_len);\n\treclaim_xattr_datum(c);\n\n\treturn xd;\n}"
  },
  {
    "function_name": "ave_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "284-334",
    "snippet": "tatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",",
            "d->xid,",
            "d->version,",
            "d->xprefix,",
            "d->xname)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_physical_node_ref(",
          "args": [
            ",",
            "hys_ofs | REF_PRISTINE,",
            "AD(totlen),",
            "void *)xd)"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_physical_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "500-553",
          "snippet": "truct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "otlen)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "otlen)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",",
            "c,",
            "otlen,",
            "ength,",
            "hys_ofs)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_writev(",
          "args": [
            ",",
            "ecs,",
            ",",
            "hys_ofs,",
            "length,",
            ")"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4))"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rx,",
            "izeof(struct jffs2_raw_xattr) - 4)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, vecs[1].iov_base, vecs[1].iov_len))"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "ecs[1].iov_base,",
            "ecs[1].iov_len)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "d->value_len)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+xd->version)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "d->xid)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4))"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rx,",
            "izeof(struct jffs2_unknown_node) - 4)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "AD(totlen))"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "otlen)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_XATTR)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rx,",
            ",",
            "izeof(rx))"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "d->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "xd->xname)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int save_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_raw_xattr rx;\n\tstruct kvec vecs[2];\n\tsize_t length;\n\tint rc, totlen;\n\tuint32_t phys_ofs = write_ofs(c);\n\n\tBUG_ON(!xd->xname);\n\tBUG_ON(xd->flags & (JFFS2_XFLAGS_DEAD|JFFS2_XFLAGS_INVALID));\n\n\tvecs[0].iov_base = &rx;\n\tvecs[0].iov_len = sizeof(rx);\n\tvecs[1].iov_base = xd->xname;\n\tvecs[1].iov_len = xd->name_len + 1 + xd->value_len;\n\ttotlen = vecs[0].iov_len + vecs[1].iov_len;\n\n\t/* Setup raw-xattr */\n\tmemset(&rx, 0, sizeof(rx));\n\trx.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trx.nodetype = cpu_to_je16(JFFS2_NODETYPE_XATTR);\n\trx.totlen = cpu_to_je32(PAD(totlen));\n\trx.hdr_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_unknown_node) - 4));\n\n\trx.xid = cpu_to_je32(xd->xid);\n\trx.version = cpu_to_je32(++xd->version);\n\trx.xprefix = xd->xprefix;\n\trx.name_len = xd->name_len;\n\trx.value_len = cpu_to_je16(xd->value_len);\n\trx.data_crc = cpu_to_je32(crc32(0, vecs[1].iov_base, vecs[1].iov_len));\n\trx.node_crc = cpu_to_je32(crc32(0, &rx, sizeof(struct jffs2_raw_xattr) - 4));\n\n\trc = jffs2_flash_writev(c, vecs, 2, phys_ofs, &length, 0);\n\tif (rc || totlen != length) {\n\t\tJFFS2_WARNING(\"jffs2_flash_writev()=%d, req=%u, wrote=%zu, at %#08x\\n\",\n\t\t\t      rc, totlen, length, phys_ofs);\n\t\trc = rc ? rc : -EIO;\n\t\tif (length)\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, PAD(totlen), NULL);\n\n\t\treturn rc;\n\t}\n\t/* success */\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, PAD(totlen), (void *)xd);\n\n\tdbg_xattr(\"success on saving xdatum (xid=%u, version=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->version, xd->xprefix, xd->xname);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "oad_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "263-282",
    "snippet": "tatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o_load_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "o_load_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "204-261",
          "snippet": "tatic int do_load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tchar *data;\n\tsize_t readlen;\n\tuint32_t crc, length;\n\tint i, ret, retry = 0;\n\n\tBUG_ON(ref_flags(xd->node) != REF_PRISTINE);\n\tBUG_ON(!list_empty(&xd->xindex));\n retry:\n\tlength = xd->name_len + 1 + xd->value_len;\n\tdata = kmalloc(length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(xd->node)+sizeof(struct jffs2_raw_xattr),\n\t\t\t       length, &readlen, data);\n\n\tif (ret || length!=readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",\n\t\t\t      ret, length, readlen, ref_offset(xd->node));\n\t\tkfree(data);\n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tdata[xd->name_len] = '\\0';\n\tcrc = crc32(0, data, length);\n\tif (crc != xd->data_crc) {\n\t\tJFFS2_WARNING(\"node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",\n\t\t\t      ref_offset(xd->node), xd->data_crc, crc);\n\t\tkfree(data);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xname = data;\n\txd->xvalue = data + xd->name_len+1;\n\n\tc->xdatum_mem_usage += length;\n\n\txd->hashkey = xattr_datum_hashkey(xd->xprefix, xd->xname, xd->xvalue, xd->value_len);\n\ti = xd->hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\tif (!retry) {\n\t\tretry = 1;\n\t\treclaim_xattr_datum(c);\n\t\tif (!xd->xname)\n\t\t\tgoto retry;\n\t}\n\n\tdbg_xattr(\"success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->xprefix, xd->xname);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int do_load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tchar *data;\n\tsize_t readlen;\n\tuint32_t crc, length;\n\tint i, ret, retry = 0;\n\n\tBUG_ON(ref_flags(xd->node) != REF_PRISTINE);\n\tBUG_ON(!list_empty(&xd->xindex));\n retry:\n\tlength = xd->name_len + 1 + xd->value_len;\n\tdata = kmalloc(length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(xd->node)+sizeof(struct jffs2_raw_xattr),\n\t\t\t       length, &readlen, data);\n\n\tif (ret || length!=readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",\n\t\t\t      ret, length, readlen, ref_offset(xd->node));\n\t\tkfree(data);\n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tdata[xd->name_len] = '\\0';\n\tcrc = crc32(0, data, length);\n\tif (crc != xd->data_crc) {\n\t\tJFFS2_WARNING(\"node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",\n\t\t\t      ref_offset(xd->node), xd->data_crc, crc);\n\t\tkfree(data);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xname = data;\n\txd->xvalue = data + xd->name_len+1;\n\n\tc->xdatum_mem_usage += length;\n\n\txd->hashkey = xattr_datum_hashkey(xd->xprefix, xd->xname, xd->xvalue, xd->value_len);\n\ti = xd->hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\tif (!retry) {\n\t\tretry = 1;\n\t\treclaim_xattr_datum(c);\n\t\tif (!xd->xname)\n\t\t\tgoto retry;\n\t}\n\n\tdbg_xattr(\"success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->xprefix, xd->xname);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o_verify_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "o_verify_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "132-202",
          "snippet": "tatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "s_xattr_datum_unchecked(c, xd))"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_xattr_datum_unchecked(",
          "args": [
            ",",
            "d)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "s_xattr_datum_unchecked(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "71-85",
          "snippet": "tatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "d->flags & JFFS2_XFLAGS_DEAD)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem);\n\t * rc < 0 : recoverable error, try again\n\t * rc = 0 : success\n\t * rc > 0 : Unrecoverable error, this node should be deleted.\n\t */\n\tint rc = 0;\n\n\tBUG_ON(xd->flags & JFFS2_XFLAGS_DEAD);\n\tif (xd->xname)\n\t\treturn 0;\n\tif (xd->flags & JFFS2_XFLAGS_INVALID)\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\tif (unlikely(is_xattr_datum_unchecked(c, xd)))\n\t\trc = do_verify_xattr_datum(c, xd);\n\tif (!rc)\n\t\trc = do_load_xattr_datum(c, xd);\n\treturn rc;\n}"
  },
  {
    "function_name": "o_load_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "204-261",
    "snippet": "tatic int do_load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tchar *data;\n\tsize_t readlen;\n\tuint32_t crc, length;\n\tint i, ret, retry = 0;\n\n\tBUG_ON(ref_flags(xd->node) != REF_PRISTINE);\n\tBUG_ON(!list_empty(&xd->xindex));\n retry:\n\tlength = xd->name_len + 1 + xd->value_len;\n\tdata = kmalloc(length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(xd->node)+sizeof(struct jffs2_raw_xattr),\n\t\t\t       length, &readlen, data);\n\n\tif (ret || length!=readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",\n\t\t\t      ret, length, readlen, ref_offset(xd->node));\n\t\tkfree(data);\n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tdata[xd->name_len] = '\\0';\n\tcrc = crc32(0, data, length);\n\tif (crc != xd->data_crc) {\n\t\tJFFS2_WARNING(\"node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",\n\t\t\t      ref_offset(xd->node), xd->data_crc, crc);\n\t\tkfree(data);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xname = data;\n\txd->xvalue = data + xd->name_len+1;\n\n\tc->xdatum_mem_usage += length;\n\n\txd->hashkey = xattr_datum_hashkey(xd->xprefix, xd->xname, xd->xvalue, xd->value_len);\n\ti = xd->hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\tif (!retry) {\n\t\tretry = 1;\n\t\treclaim_xattr_datum(c);\n\t\tif (!xd->xname)\n\t\t\tgoto retry;\n\t}\n\n\tdbg_xattr(\"success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->xprefix, xd->xname);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",",
            "d->xid,",
            "d->xprefix,",
            "d->xname)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eclaim_xattr_datum(",
          "args": [
            ")"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "eclaim_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "102-130",
          "snippet": "tatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "xd->xindex,",
            "c->xattrindex[i])"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr_datum_hashkey(",
          "args": [
            "d->xprefix,",
            "d->xname,",
            "d->xvalue,",
            "d->value_len)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "attr_datum_hashkey(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "64-69",
          "snippet": "tatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "ata)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",",
            "ef_offset(xd->node),",
            "d->data_crc,",
            "rc)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "ata,",
            "ength)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",",
            "et,",
            "ength,",
            "eadlen,",
            "ef_offset(xd->node))"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "ef_offset(xd->node)+sizeof(struct jffs2_raw_xattr),",
            "ength,",
            "readlen,",
            "ata)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "ength,",
            "FP_KERNEL)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "list_empty(&xd->xindex))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "xd->xindex)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef_flags(xd->node) != REF_PRISTINE)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "d->node)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int do_load_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tchar *data;\n\tsize_t readlen;\n\tuint32_t crc, length;\n\tint i, ret, retry = 0;\n\n\tBUG_ON(ref_flags(xd->node) != REF_PRISTINE);\n\tBUG_ON(!list_empty(&xd->xindex));\n retry:\n\tlength = xd->name_len + 1 + xd->value_len;\n\tdata = kmalloc(length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(xd->node)+sizeof(struct jffs2_raw_xattr),\n\t\t\t       length, &readlen, data);\n\n\tif (ret || length!=readlen) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read() returned %d, request=%d, readlen=%zu, at %#08x\\n\",\n\t\t\t      ret, length, readlen, ref_offset(xd->node));\n\t\tkfree(data);\n\t\treturn ret ? ret : -EIO;\n\t}\n\n\tdata[xd->name_len] = '\\0';\n\tcrc = crc32(0, data, length);\n\tif (crc != xd->data_crc) {\n\t\tJFFS2_WARNING(\"node CRC failed (JFFS2_NODETYPE_XATTR)\"\n\t\t\t      \" at %#08x, read: 0x%08x calculated: 0x%08x\\n\",\n\t\t\t      ref_offset(xd->node), xd->data_crc, crc);\n\t\tkfree(data);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\n\txd->flags |= JFFS2_XFLAGS_HOT;\n\txd->xname = data;\n\txd->xvalue = data + xd->name_len+1;\n\n\tc->xdatum_mem_usage += length;\n\n\txd->hashkey = xattr_datum_hashkey(xd->xprefix, xd->xname, xd->xvalue, xd->value_len);\n\ti = xd->hashkey % XATTRINDEX_HASHSIZE;\n\tlist_add(&xd->xindex, &c->xattrindex[i]);\n\tif (!retry) {\n\t\tretry = 1;\n\t\treclaim_xattr_datum(c);\n\t\tif (!xd->xname)\n\t\t\tgoto retry;\n\t}\n\n\tdbg_xattr(\"success on loading xdatum (xid=%u, xprefix=%u, xname='%s')\\n\",\n\t\t  xd->xid, xd->xprefix, xd->xname);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "o_verify_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "132-202",
    "snippet": "tatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "success on verfying xdatum (xid=%u, version=%u)\\n\",",
            "d->xid,",
            "d->version)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "xd->xindex)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "aw)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "ef_totlen(c, jeb, raw))"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "aw)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "aw)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.data_crc)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.value_len)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",",
            "ffset,",
            "e16_to_cpu(rx.magic),",
            "FFS2_MAGIC_BITMASK,",
            "e16_to_cpu(rx.nodetype),",
            "FFS2_NODETYPE_XATTR,",
            "e32_to_cpu(rx.totlen),",
            "otlen,",
            "e32_to_cpu(rx.xid),",
            "d->xid,",
            "e32_to_cpu(rx.version),",
            "d->version)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.version)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.xid)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.totlen)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.nodetype)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.magic)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.version)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.xid)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.totlen)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.nodetype)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.magic)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len))"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x.value_len)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",",
            "ffset,",
            "e32_to_cpu(rx.hdr_crc),",
            "rc)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.hdr_crc)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x.node_crc)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "rx,",
            "izeof(rx) - 4)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",",
            "c,",
            "izeof(rx),",
            "eadlen,",
            "ffset)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "ffset,",
            "izeof(rx),",
            "readlen,",
            "char *)&rx)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "d->node)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->node)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_raw_xattr rx;\n\tsize_t readlen;\n\tuint32_t crc, offset, totlen;\n\tint rc;\n\n\tspin_lock(&c->erase_completion_lock);\n\toffset = ref_offset(xd->node);\n\tif (ref_flags(xd->node) == REF_PRISTINE)\n\t\tgoto complete;\n\tspin_unlock(&c->erase_completion_lock);\n\n\trc = jffs2_flash_read(c, offset, sizeof(rx), &readlen, (char *)&rx);\n\tif (rc || readlen != sizeof(rx)) {\n\t\tJFFS2_WARNING(\"jffs2_flash_read()=%d, req=%zu, read=%zu at %#08x\\n\",\n\t\t\t      rc, sizeof(rx), readlen, offset);\n\t\treturn rc ? rc : -EIO;\n\t}\n\tcrc = crc32(0, &rx, sizeof(rx) - 4);\n\tif (crc != je32_to_cpu(rx.node_crc)) {\n\t\tJFFS2_ERROR(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t    offset, je32_to_cpu(rx.hdr_crc), crc);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\ttotlen = PAD(sizeof(rx) + rx.name_len + 1 + je16_to_cpu(rx.value_len));\n\tif (je16_to_cpu(rx.magic) != JFFS2_MAGIC_BITMASK\n\t    || je16_to_cpu(rx.nodetype) != JFFS2_NODETYPE_XATTR\n\t    || je32_to_cpu(rx.totlen) != totlen\n\t    || je32_to_cpu(rx.xid) != xd->xid\n\t    || je32_to_cpu(rx.version) != xd->version) {\n\t\tJFFS2_ERROR(\"inconsistent xdatum at %#08x, magic=%#04x/%#04x, \"\n\t\t\t    \"nodetype=%#04x/%#04x, totlen=%u/%u, xid=%u/%u, version=%u/%u\\n\",\n\t\t\t    offset, je16_to_cpu(rx.magic), JFFS2_MAGIC_BITMASK,\n\t\t\t    je16_to_cpu(rx.nodetype), JFFS2_NODETYPE_XATTR,\n\t\t\t    je32_to_cpu(rx.totlen), totlen,\n\t\t\t    je32_to_cpu(rx.xid), xd->xid,\n\t\t\t    je32_to_cpu(rx.version), xd->version);\n\t\txd->flags |= JFFS2_XFLAGS_INVALID;\n\t\treturn JFFS2_XATTR_IS_CORRUPTED;\n\t}\n\txd->xprefix = rx.xprefix;\n\txd->name_len = rx.name_len;\n\txd->value_len = je16_to_cpu(rx.value_len);\n\txd->data_crc = je32_to_cpu(rx.data_crc);\n\n\tspin_lock(&c->erase_completion_lock);\n complete:\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tjeb = &c->blocks[ref_offset(raw) / c->sector_size];\n\t\ttotlen = PAD(ref_totlen(c, jeb, raw));\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\tc->unchecked_size -= totlen; c->used_size += totlen;\n\t\t\tjeb->unchecked_size -= totlen; jeb->used_size += totlen;\n\t\t}\n\t\traw->flash_offset = ref_offset(raw) | ((xd->node==raw) ? REF_PRISTINE : REF_NORMAL);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* unchecked xdatum is chained with c->xattr_unchecked */\n\tlist_del_init(&xd->xindex);\n\n\tdbg_xattr(\"success on verfying xdatum (xid=%u, version=%u)\\n\",\n\t\t  xd->xid, xd->version);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eclaim_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "102-130",
    "snippet": "tatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FFS2_NOTICE(",
          "args": [
            "xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",",
            "efore,",
            "->xdatum_mem_usage,",
            "efore - c->xdatum_mem_usage)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nload_xattr_datum(",
          "args": [
            ",",
            "d)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "nload_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "87-100",
          "snippet": "tatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry_safe(",
          "args": [
            "d,",
            "xd,",
            "c->xattrindex[index],",
            "index)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void reclaim_xattr_datum(struct jffs2_sb_info *c)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tstruct jffs2_xattr_datum *xd, *_xd;\n\tuint32_t target, before;\n\tstatic int index = 0;\n\tint count;\n\n\tif (c->xdatum_mem_threshold > c->xdatum_mem_usage)\n\t\treturn;\n\n\tbefore = c->xdatum_mem_usage;\n\ttarget = c->xdatum_mem_usage * 4 / 5; /* 20% reduction */\n\tfor (count = 0; count < XATTRINDEX_HASHSIZE; count++) {\n\t\tlist_for_each_entry_safe(xd, _xd, &c->xattrindex[index], xindex) {\n\t\t\tif (xd->flags & JFFS2_XFLAGS_HOT) {\n\t\t\t\txd->flags &= ~JFFS2_XFLAGS_HOT;\n\t\t\t} else if (!(xd->flags & JFFS2_XFLAGS_BIND)) {\n\t\t\t\tunload_xattr_datum(c, xd);\n\t\t\t}\n\t\t\tif (c->xdatum_mem_usage <= target)\n\t\t\t\tgoto out;\n\t\t}\n\t\tindex = (index+1) % XATTRINDEX_HASHSIZE;\n\t}\n out:\n\tJFFS2_NOTICE(\"xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\\n\",\n\t\t     before, c->xdatum_mem_usage, before - c->xdatum_mem_usage);\n}"
  },
  {
    "function_name": "nload_xattr_datum(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "87-100",
    "snippet": "tatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "xd->xindex)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "d->xname)"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "bg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version))"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "%s: xid=%u, version=%u\\n\",",
            "_func__,",
            "d->xid,",
            "d->version)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void unload_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under down_write(xattr_sem) */\n\tD1(dbg_xattr(\"%s: xid=%u, version=%u\\n\", __func__, xd->xid, xd->version));\n\tif (xd->xname) {\n\t\tc->xdatum_mem_usage -= (xd->name_len + 1 + xd->value_len);\n\t\tkfree(xd->xname);\n\t}\n\n\tlist_del_init(&xd->xindex);\n\txd->hashkey = 0;\n\txd->xname = NULL;\n\txd->xvalue = NULL;\n}"
  },
  {
    "function_name": "s_xattr_datum_unchecked(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "71-85",
    "snippet": "tatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "aw)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int is_xattr_datum_unchecked(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tint rc = 0;\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw=xd->node; raw != (void *)xd; raw=raw->next_in_ino) {\n\t\tif (ref_flags(raw) == REF_UNCHECKED) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "attr_datum_hashkey(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
    "lines": "64-69",
    "snippet": "tatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}",
    "includes": [
      "include \"nodelist.h\"\n/",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/posix_acl_xattr.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/highmem.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/time.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            "prefix,",
            "value,",
            "size)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            "prefix,",
            "name,",
            "ame_len)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "name)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t xattr_datum_hashkey(int xprefix, const char *xname, const char *xvalue, int xsize)\n{\n\tint name_len = strlen(xname);\n\n\treturn crc32(xprefix, xname, name_len) ^ crc32(xprefix, xvalue, xsize);\n}"
  }
]