[
  {
    "function_name": "xfs_allocbt_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "492-503",
    "snippet": "int\nxfs_allocbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_ALLOC_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_alloc_rec_t);\n\treturn blocklen / (sizeof(xfs_alloc_key_t) + sizeof(xfs_alloc_ptr_t));\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ALLOC_BLOCK_LEN",
          "args": [
            "mp"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_allocbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_ALLOC_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_alloc_rec_t);\n\treturn blocklen / (sizeof(xfs_alloc_key_t) + sizeof(xfs_alloc_ptr_t));\n}"
  },
  {
    "function_name": "xfs_allocbt_init_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "452-487",
    "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_BNO]"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_CNT]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_btree_cur_zone",
            "KM_SLEEP"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
  },
  {
    "function_name": "xfs_allocbt_recs_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "406-423",
    "snippet": "STATIC int\nxfs_allocbt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn be32_to_cpu(r1->alloc.ar_startblock) +\n\t\t\tbe32_to_cpu(r1->alloc.ar_blockcount) <=\n\t\t\tbe32_to_cpu(r2->alloc.ar_startblock);\n\t} else {\n\t\treturn be32_to_cpu(r1->alloc.ar_blockcount) <\n\t\t\tbe32_to_cpu(r2->alloc.ar_blockcount) ||\n\t\t\t(r1->alloc.ar_blockcount == r2->alloc.ar_blockcount &&\n\t\t\t be32_to_cpu(r1->alloc.ar_startblock) <\n\t\t\t be32_to_cpu(r2->alloc.ar_startblock));\n\t}\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r2->alloc.ar_startblock"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r1->alloc.ar_startblock"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r2->alloc.ar_blockcount"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r1->alloc.ar_blockcount"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r2->alloc.ar_startblock"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r1->alloc.ar_blockcount"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r1->alloc.ar_startblock"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn be32_to_cpu(r1->alloc.ar_startblock) +\n\t\t\tbe32_to_cpu(r1->alloc.ar_blockcount) <=\n\t\t\tbe32_to_cpu(r2->alloc.ar_startblock);\n\t} else {\n\t\treturn be32_to_cpu(r1->alloc.ar_blockcount) <\n\t\t\tbe32_to_cpu(r2->alloc.ar_blockcount) ||\n\t\t\t(r1->alloc.ar_blockcount == r2->alloc.ar_blockcount &&\n\t\t\t be32_to_cpu(r1->alloc.ar_startblock) <\n\t\t\t be32_to_cpu(r2->alloc.ar_startblock));\n\t}\n}"
  },
  {
    "function_name": "xfs_allocbt_keys_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "388-404",
    "snippet": "STATIC int\nxfs_allocbt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn be32_to_cpu(k1->alloc.ar_startblock) <\n\t\t       be32_to_cpu(k2->alloc.ar_startblock);\n\t} else {\n\t\treturn be32_to_cpu(k1->alloc.ar_blockcount) <\n\t\t\tbe32_to_cpu(k2->alloc.ar_blockcount) ||\n\t\t\t(k1->alloc.ar_blockcount == k2->alloc.ar_blockcount &&\n\t\t\t be32_to_cpu(k1->alloc.ar_startblock) <\n\t\t\t be32_to_cpu(k2->alloc.ar_startblock));\n\t}\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2->alloc.ar_startblock"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1->alloc.ar_startblock"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2->alloc.ar_blockcount"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1->alloc.ar_blockcount"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2->alloc.ar_startblock"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1->alloc.ar_startblock"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn be32_to_cpu(k1->alloc.ar_startblock) <\n\t\t       be32_to_cpu(k2->alloc.ar_startblock);\n\t} else {\n\t\treturn be32_to_cpu(k1->alloc.ar_blockcount) <\n\t\t\tbe32_to_cpu(k2->alloc.ar_blockcount) ||\n\t\t\t(k1->alloc.ar_blockcount == k2->alloc.ar_blockcount &&\n\t\t\t be32_to_cpu(k1->alloc.ar_startblock) <\n\t\t\t be32_to_cpu(k2->alloc.ar_startblock));\n\t}\n}"
  },
  {
    "function_name": "xfs_allocbt_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "367-379",
    "snippet": "static void\nxfs_allocbt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_allocbt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_sblock_calc_crc(bp);\n\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_sblock_calc_crc",
          "args": [
            "bp"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_sblock_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "258-270",
          "snippet": "void\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_verify",
          "args": [
            "bp"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "272-350",
          "snippet": "static bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_allocbt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_allocbt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_sblock_calc_crc(bp);\n\n}"
  },
  {
    "function_name": "xfs_allocbt_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "352-365",
    "snippet": "static void\nxfs_allocbt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_sblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_allocbt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_verify",
          "args": [
            "bp"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "272-350",
          "snippet": "static bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_sblock_verify_crc",
          "args": [
            "bp"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_sblock_verify_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "272-280",
          "snippet": "bool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_allocbt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_sblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_allocbt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}"
  },
  {
    "function_name": "xfs_allocbt_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "272-350",
    "snippet": "static bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_rightsib"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_leftsib"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ABTC_MAGIC"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_owner"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&block->bb_u.s.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ABTC_CRC_MAGIC"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ABTB_MAGIC"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_owner"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ABTB_CRC_MAGIC"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_allocbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * magic number and level verification\n\t *\n\t * During growfs operations, we can't verify the exact level or owner as\n\t * the perag is not fully initialised and hence not attached to the\n\t * buffer.  In this case, check against the maximum tree depth.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agf information will not yet have been initialised\n\t * from the on disk AGF. Again, we can only check against maximum limits\n\t * in this case.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_ABTB_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTB_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_BNOi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tcase cpu_to_be32(XFS_ABTC_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_ABTC_MAGIC):\n\t\tif (pag && pag->pagf_init) {\n\t\t\tif (level >= pag->pagf_levels[XFS_BTNUM_CNTi])\n\t\t\t\treturn false;\n\t\t} else if (level >= mp->m_ag_maxlevels)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* numrecs verification */\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_alloc_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_allocbt_key_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "251-270",
    "snippet": "STATIC __int64_t\nxfs_allocbt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\txfs_alloc_rec_incore_t\t*rec = &cur->bc_rec.a;\n\txfs_alloc_key_t\t\t*kp = &key->alloc;\n\t__int64_t\t\tdiff;\n\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn (__int64_t)be32_to_cpu(kp->ar_startblock) -\n\t\t\t\trec->ar_startblock;\n\t}\n\n\tdiff = (__int64_t)be32_to_cpu(kp->ar_blockcount) - rec->ar_blockcount;\n\tif (diff)\n\t\treturn diff;\n\n\treturn (__int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "kp->ar_startblock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "kp->ar_blockcount"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "kp->ar_startblock"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC __int64_t\nxfs_allocbt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\txfs_alloc_rec_incore_t\t*rec = &cur->bc_rec.a;\n\txfs_alloc_key_t\t\t*kp = &key->alloc;\n\t__int64_t\t\tdiff;\n\n\tif (cur->bc_btnum == XFS_BTNUM_BNO) {\n\t\treturn (__int64_t)be32_to_cpu(kp->ar_startblock) -\n\t\t\t\trec->ar_startblock;\n\t}\n\n\tdiff = (__int64_t)be32_to_cpu(kp->ar_blockcount) - rec->ar_blockcount;\n\tif (diff)\n\t\treturn diff;\n\n\treturn (__int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;\n}"
  },
  {
    "function_name": "xfs_allocbt_init_ptr_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "238-249",
    "snippet": "STATIC void\nxfs_allocbt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agf->agf_seqno));\n\tASSERT(agf->agf_roots[cur->bc_btnum] != 0);\n\n\tptr->s = agf->agf_roots[cur->bc_btnum];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agf->agf_roots[cur->bc_btnum] != 0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_private.a.agno == be32_to_cpu(agf->agf_seqno)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "cur->bc_private.a.agbp"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_allocbt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agf->agf_seqno));\n\tASSERT(agf->agf_roots[cur->bc_btnum] != 0);\n\n\tptr->s = agf->agf_roots[cur->bc_btnum];\n}"
  },
  {
    "function_name": "xfs_allocbt_init_rec_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "227-236",
    "snippet": "STATIC void\nxfs_allocbt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(cur->bc_rec.a.ar_startblock != 0);\n\n\trec->alloc.ar_startblock = cpu_to_be32(cur->bc_rec.a.ar_startblock);\n\trec->alloc.ar_blockcount = cpu_to_be32(cur->bc_rec.a.ar_blockcount);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cur->bc_rec.a.ar_blockcount"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cur->bc_rec.a.ar_startblock"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_rec.a.ar_startblock != 0"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_allocbt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(cur->bc_rec.a.ar_startblock != 0);\n\n\trec->alloc.ar_startblock = cpu_to_be32(cur->bc_rec.a.ar_startblock);\n\trec->alloc.ar_blockcount = cpu_to_be32(cur->bc_rec.a.ar_blockcount);\n}"
  },
  {
    "function_name": "xfs_allocbt_init_rec_from_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "216-225",
    "snippet": "STATIC void\nxfs_allocbt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(key->alloc.ar_startblock != 0);\n\n\trec->alloc.ar_startblock = key->alloc.ar_startblock;\n\trec->alloc.ar_blockcount = key->alloc.ar_blockcount;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key->alloc.ar_startblock != 0"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_allocbt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(key->alloc.ar_startblock != 0);\n\n\trec->alloc.ar_startblock = key->alloc.ar_startblock;\n\trec->alloc.ar_blockcount = key->alloc.ar_blockcount;\n}"
  },
  {
    "function_name": "xfs_allocbt_init_key_from_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "205-214",
    "snippet": "STATIC void\nxfs_allocbt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(rec->alloc.ar_startblock != 0);\n\n\tkey->alloc.ar_startblock = rec->alloc.ar_startblock;\n\tkey->alloc.ar_blockcount = rec->alloc.ar_blockcount;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rec->alloc.ar_startblock != 0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_allocbt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(rec->alloc.ar_startblock != 0);\n\n\tkey->alloc.ar_startblock = rec->alloc.ar_startblock;\n\tkey->alloc.ar_blockcount = rec->alloc.ar_blockcount;\n}"
  },
  {
    "function_name": "xfs_allocbt_get_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "197-203",
    "snippet": "STATIC int\nxfs_allocbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mxr[level != 0];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mxr[level != 0];\n}"
  },
  {
    "function_name": "xfs_allocbt_get_minrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "189-195",
    "snippet": "STATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}"
  },
  {
    "function_name": "xfs_allocbt_update_lastrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "129-187",
    "snippet": "STATIC void\nxfs_allocbt_update_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tptr,\n\tint\t\t\treason)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(cur->bc_private.a.agbp);\n\txfs_agnumber_t\t\tseqno = be32_to_cpu(agf->agf_seqno);\n\tstruct xfs_perag\t*pag;\n\t__be32\t\t\tlen;\n\tint\t\t\tnumrecs;\n\n\tASSERT(cur->bc_btnum == XFS_BTNUM_CNT);\n\n\tswitch (reason) {\n\tcase LASTREC_UPDATE:\n\t\t/*\n\t\t * If this is the last leaf block and it's the last record,\n\t\t * then update the size of the longest extent in the AG.\n\t\t */\n\t\tif (ptr != xfs_btree_get_numrecs(block))\n\t\t\treturn;\n\t\tlen = rec->alloc.ar_blockcount;\n\t\tbreak;\n\tcase LASTREC_INSREC:\n\t\tif (be32_to_cpu(rec->alloc.ar_blockcount) <=\n\t\t    be32_to_cpu(agf->agf_longest))\n\t\t\treturn;\n\t\tlen = rec->alloc.ar_blockcount;\n\t\tbreak;\n\tcase LASTREC_DELREC:\n\t\tnumrecs = xfs_btree_get_numrecs(block);\n\t\tif (ptr <= numrecs)\n\t\t\treturn;\n\t\tASSERT(ptr == numrecs + 1);\n\n\t\tif (numrecs) {\n\t\t\txfs_alloc_rec_t *rrp;\n\n\t\t\trrp = XFS_ALLOC_REC_ADDR(cur->bc_mp, block, numrecs);\n\t\t\tlen = rrp->ar_blockcount;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tagf->agf_longest = len;\n\tpag = xfs_perag_get(cur->bc_mp, seqno);\n\tpag->pagf_longest = be32_to_cpu(len);\n\txfs_perag_put(pag);\n\txfs_alloc_log_agf(cur->bc_tp, cur->bc_private.a.agbp, XFS_AGF_LONGEST);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "cur->bc_tp",
            "cur->bc_private.a.agbp",
            "XFS_AGF_LONGEST"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "len"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "cur->bc_mp",
            "seqno"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_REC_ADDR",
          "args": [
            "cur->bc_mp",
            "block",
            "numrecs"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ptr == numrecs + 1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_longest"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->alloc.ar_blockcount"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_btnum == XFS_BTNUM_CNT"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "cur->bc_private.a.agbp"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_allocbt_update_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tptr,\n\tint\t\t\treason)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(cur->bc_private.a.agbp);\n\txfs_agnumber_t\t\tseqno = be32_to_cpu(agf->agf_seqno);\n\tstruct xfs_perag\t*pag;\n\t__be32\t\t\tlen;\n\tint\t\t\tnumrecs;\n\n\tASSERT(cur->bc_btnum == XFS_BTNUM_CNT);\n\n\tswitch (reason) {\n\tcase LASTREC_UPDATE:\n\t\t/*\n\t\t * If this is the last leaf block and it's the last record,\n\t\t * then update the size of the longest extent in the AG.\n\t\t */\n\t\tif (ptr != xfs_btree_get_numrecs(block))\n\t\t\treturn;\n\t\tlen = rec->alloc.ar_blockcount;\n\t\tbreak;\n\tcase LASTREC_INSREC:\n\t\tif (be32_to_cpu(rec->alloc.ar_blockcount) <=\n\t\t    be32_to_cpu(agf->agf_longest))\n\t\t\treturn;\n\t\tlen = rec->alloc.ar_blockcount;\n\t\tbreak;\n\tcase LASTREC_DELREC:\n\t\tnumrecs = xfs_btree_get_numrecs(block);\n\t\tif (ptr <= numrecs)\n\t\t\treturn;\n\t\tASSERT(ptr == numrecs + 1);\n\n\t\tif (numrecs) {\n\t\t\txfs_alloc_rec_t *rrp;\n\n\t\t\trrp = XFS_ALLOC_REC_ADDR(cur->bc_mp, block, numrecs);\n\t\t\tlen = rrp->ar_blockcount;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tagf->agf_longest = len;\n\tpag = xfs_perag_get(cur->bc_mp, seqno);\n\tpag->pagf_longest = be32_to_cpu(len);\n\txfs_perag_put(pag);\n\txfs_alloc_log_agf(cur->bc_tp, cur->bc_private.a.agbp, XFS_AGF_LONGEST);\n}"
  },
  {
    "function_name": "xfs_allocbt_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "103-124",
    "snippet": "STATIC int\nxfs_allocbt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\txfs_agblock_t\t\tbno;\n\tint\t\t\terror;\n\n\tbno = xfs_daddr_to_agbno(cur->bc_mp, XFS_BUF_ADDR(bp));\n\terror = xfs_alloc_put_freelist(cur->bc_tp, agbp, NULL, bno, 1);\n\tif (error)\n\t\treturn error;\n\n\txfs_extent_busy_insert(cur->bc_tp, be32_to_cpu(agf->agf_seqno), bno, 1,\n\t\t\t      XFS_EXTENT_BUSY_SKIP_DISCARD);\n\txfs_trans_agbtree_delta(cur->bc_tp, -1);\n\n\txfs_trans_binval(cur->bc_tp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "cur->bc_tp",
            "bp"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_agbtree_delta",
          "args": [
            "cur->bc_tp",
            "-1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_insert",
          "args": [
            "cur->bc_tp",
            "be32_to_cpu(agf->agf_seqno)",
            "bno",
            "1",
            "XFS_EXTENT_BUSY_SKIP_DISCARD"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "34-93",
          "snippet": "void\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_put_freelist",
          "args": [
            "cur->bc_tp",
            "agbp",
            "NULL",
            "bno",
            "1"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_put_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2135-2190",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_daddr_to_agbno",
          "args": [
            "cur->bc_mp",
            "XFS_BUF_ADDR(bp)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_daddr_to_agbno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.h",
          "lines": "296-301",
          "snippet": "static inline xfs_agblock_t\nxfs_daddr_to_agbno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\treturn (xfs_agblock_t) do_div(ld, mp->m_sb.sb_agblocks);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_agblock_t\nxfs_daddr_to_agbno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\treturn (xfs_agblock_t) do_div(ld, mp->m_sb.sb_agblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\txfs_agblock_t\t\tbno;\n\tint\t\t\terror;\n\n\tbno = xfs_daddr_to_agbno(cur->bc_mp, XFS_BUF_ADDR(bp));\n\terror = xfs_alloc_put_freelist(cur->bc_tp, agbp, NULL, bno, 1);\n\tif (error)\n\t\treturn error;\n\n\txfs_extent_busy_insert(cur->bc_tp, be32_to_cpu(agf->agf_seqno), bno, 1,\n\t\t\t      XFS_EXTENT_BUSY_SKIP_DISCARD);\n\txfs_trans_agbtree_delta(cur->bc_tp, -1);\n\n\txfs_trans_binval(cur->bc_tp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_allocbt_alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "67-101",
    "snippet": "STATIC int\nxfs_allocbt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\txfs_agblock_t\t\tbno;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/* Allocate the new block from the freelist. If we can't, give up.  */\n\terror = xfs_alloc_get_freelist(cur->bc_tp, cur->bc_private.a.agbp,\n\t\t\t\t       &bno, 1);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tif (bno == NULLAGBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\txfs_extent_busy_reuse(cur->bc_mp, cur->bc_private.a.agno, bno, 1, false);\n\n\txfs_trans_agbtree_delta(cur->bc_tp, 1);\n\tnew->s = cpu_to_be32(bno);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bno"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_agbtree_delta",
          "args": [
            "cur->bc_tp",
            "1"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_reuse",
          "args": [
            "cur->bc_mp",
            "cur->bc_private.a.agno",
            "bno",
            "1",
            "false"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "304-341",
          "snippet": "void\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_freelist",
          "args": [
            "cur->bc_tp",
            "cur->bc_private.a.agbp",
            "&bno",
            "1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2014-2074",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\txfs_agblock_t\t\tbno;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/* Allocate the new block from the freelist. If we can't, give up.  */\n\terror = xfs_alloc_get_freelist(cur->bc_tp, cur->bc_private.a.agbp,\n\t\t\t\t       &bno, 1);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tif (bno == NULLAGBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\txfs_extent_busy_reuse(cur->bc_mp, cur->bc_private.a.agno, bno, 1, false);\n\n\txfs_trans_agbtree_delta(cur->bc_tp, 1);\n\tnew->s = cpu_to_be32(bno);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_allocbt_set_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "45-65",
    "snippet": "STATIC void\nxfs_allocbt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tinc)\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\txfs_agnumber_t\t\tseqno = be32_to_cpu(agf->agf_seqno);\n\tint\t\t\tbtnum = cur->bc_btnum;\n\tstruct xfs_perag\t*pag = xfs_perag_get(cur->bc_mp, seqno);\n\n\tASSERT(ptr->s != 0);\n\n\tagf->agf_roots[btnum] = ptr->s;\n\tbe32_add_cpu(&agf->agf_levels[btnum], inc);\n\tpag->pagf_levels[btnum] += inc;\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(cur->bc_tp, agbp, XFS_AGF_ROOTS | XFS_AGF_LEVELS);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "cur->bc_tp",
            "agbp",
            "XFS_AGF_ROOTS | XFS_AGF_LEVELS"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_levels[btnum]",
            "inc"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ptr->s != 0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "cur->bc_mp",
            "seqno"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_allocbt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tinc)\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\txfs_agnumber_t\t\tseqno = be32_to_cpu(agf->agf_seqno);\n\tint\t\t\tbtnum = cur->bc_btnum;\n\tstruct xfs_perag\t*pag = xfs_perag_get(cur->bc_mp, seqno);\n\n\tASSERT(ptr->s != 0);\n\n\tagf->agf_roots[btnum] = ptr->s;\n\tbe32_add_cpu(&agf->agf_levels[btnum], inc);\n\tpag->pagf_levels[btnum] += inc;\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(cur->bc_tp, agbp, XFS_AGF_ROOTS | XFS_AGF_LEVELS);\n}"
  },
  {
    "function_name": "xfs_allocbt_dup_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
    "lines": "36-43",
    "snippet": "xfs_btree_cur *\nxfs_allocbt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_allocbt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.a.agbp, cur->bc_private.a.agno,\n\t\t\tcur->bc_btnum);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "cur->bc_mp",
            "cur->bc_tp",
            "cur->bc_private.a.agbp",
            "cur->bc_private.a.agno",
            "cur->bc_btnum"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_btree_cur *\nxfs_allocbt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_allocbt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.a.agbp, cur->bc_private.a.agno,\n\t\t\tcur->bc_btnum);\n}"
  }
]