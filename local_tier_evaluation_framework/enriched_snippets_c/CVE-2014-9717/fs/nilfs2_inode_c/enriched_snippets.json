[
  {
    "function_name": "nilfs_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "1007-1136",
    "snippet": "int nilfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t __u64 start, __u64 len)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 logical = 0, phys = 0, size = 0;\n\t__u32 flags = 0;\n\tloff_t isize;\n\tsector_t blkoff, end_blkoff;\n\tsector_t delalloc_blkoff;\n\tunsigned long delalloc_blklen;\n\tunsigned int blkbits = inode->i_blkbits;\n\tint ret, n;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\n\tblkoff = start >> blkbits;\n\tend_blkoff = (start + len - 1) >> blkbits;\n\n\tdelalloc_blklen = nilfs_find_uncommitted_extent(inode, blkoff,\n\t\t\t\t\t\t\t&delalloc_blkoff);\n\n\tdo {\n\t\t__u64 blkphy;\n\t\tunsigned int maxblocks;\n\n\t\tif (delalloc_blklen && blkoff == delalloc_blkoff) {\n\t\t\tif (size) {\n\t\t\t\t/* End of the current extent */\n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff)\n\t\t\t\tbreak;\n\n\t\t\tflags = FIEMAP_EXTENT_MERGED | FIEMAP_EXTENT_DELALLOC;\n\t\t\tlogical = blkoff << blkbits;\n\t\t\tphys = 0;\n\t\t\tsize = delalloc_blklen << blkbits;\n\n\t\t\tblkoff = delalloc_blkoff + delalloc_blklen;\n\t\t\tdelalloc_blklen = nilfs_find_uncommitted_extent(\n\t\t\t\tinode, blkoff, &delalloc_blkoff);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Limit the number of blocks that we look up so as\n\t\t * not to get into the next delayed allocation extent.\n\t\t */\n\t\tmaxblocks = INT_MAX;\n\t\tif (delalloc_blklen)\n\t\t\tmaxblocks = min_t(sector_t, delalloc_blkoff - blkoff,\n\t\t\t\t\t  maxblocks);\n\t\tblkphy = 0;\n\n\t\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t\tn = nilfs_bmap_lookup_contig(\n\t\t\tNILFS_I(inode)->i_bmap, blkoff, &blkphy, maxblocks);\n\t\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\n\t\tif (n < 0) {\n\t\t\tint past_eof;\n\n\t\t\tif (unlikely(n != -ENOENT))\n\t\t\t\tbreak; /* error */\n\n\t\t\t/* HOLE */\n\t\t\tblkoff++;\n\t\t\tpast_eof = ((blkoff << blkbits) >= isize);\n\n\t\t\tif (size) {\n\t\t\t\t/* End of the current extent */\n\n\t\t\t\tif (past_eof)\n\t\t\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff || past_eof)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (size) {\n\t\t\t\tif (phys && blkphy << blkbits == phys + size) {\n\t\t\t\t\t/* The current extent goes on */\n\t\t\t\t\tsize += n << blkbits;\n\t\t\t\t} else {\n\t\t\t\t\t/* Terminate the current extent */\n\t\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\t\tfieinfo, logical, phys, size,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tif (ret || blkoff > end_blkoff)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* Start another extent */\n\t\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\t\tsize = n << blkbits;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Start a new extent */\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\tsize = n << blkbits;\n\t\t\t}\n\t\t\tblkoff += n;\n\t\t}\n\t\tcond_resched();\n\t} while (true);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "logical",
            "phys",
            "size",
            "flags"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "n != -ENOENT"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup_contig",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "blkoff",
            "&blkphy",
            "maxblocks"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "99-109",
          "snippet": "int nilfs_bmap_lookup_contig(struct nilfs_bmap *bmap, __u64 key, __u64 *ptrp,\n\t\t\t     unsigned maxblocks)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup_contig(bmap, key, ptrp, maxblocks);\n\tup_read(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_lookup_contig(struct nilfs_bmap *bmap, __u64 key, __u64 *ptrp,\n\t\t\t     unsigned maxblocks)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup_contig(bmap, key, ptrp, maxblocks);\n\tup_read(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "sector_t",
            "delalloc_blkoff - blkoff",
            "maxblocks"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_find_uncommitted_extent",
          "args": [
            "inode",
            "blkoff",
            "&delalloc_blkoff"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_find_uncommitted_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "515-585",
          "snippet": "unsigned long nilfs_find_uncommitted_extent(struct inode *inode,\n\t\t\t\t\t    sector_t start_blk,\n\t\t\t\t\t    sector_t *blkoff)\n{\n\tunsigned int i;\n\tpgoff_t index;\n\tunsigned int nblocks_in_page;\n\tunsigned long length = 0;\n\tsector_t b;\n\tstruct pagevec pvec;\n\tstruct page *page;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn 0;\n\n\tindex = start_blk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tnblocks_in_page = 1U << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\nrepeat:\n\tpvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,\n\t\t\t\t\tpvec.pages);\n\tif (pvec.nr == 0)\n\t\treturn length;\n\n\tif (length > 0 && pvec.pages[0]->index > index)\n\t\tgoto out;\n\n\tb = pvec.pages[0]->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\ti = 0;\n\tdo {\n\t\tpage = pvec.pages[i];\n\n\t\tlock_page(page);\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (b < start_blk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tif (length == 0)\n\t\t\t\t\t\t*blkoff = b;\n\t\t\t\t\tlength++;\n\t\t\t\t} else if (length > 0) {\n\t\t\t\t\tgoto out_locked;\n\t\t\t\t}\n\t\t\t} while (++b, bh = bh->b_this_page, bh != head);\n\t\t} else {\n\t\t\tif (length > 0)\n\t\t\t\tgoto out_locked;\n\n\t\t\tb += nblocks_in_page;\n\t\t}\n\t\tunlock_page(page);\n\n\t} while (++i < pagevec_count(&pvec));\n\n\tindex = page->index + 1;\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n\nout_locked:\n\tunlock_page(page);\nout:\n\tpagevec_release(&pvec);\n\treturn length;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nunsigned long nilfs_find_uncommitted_extent(struct inode *inode,\n\t\t\t\t\t    sector_t start_blk,\n\t\t\t\t\t    sector_t *blkoff)\n{\n\tunsigned int i;\n\tpgoff_t index;\n\tunsigned int nblocks_in_page;\n\tunsigned long length = 0;\n\tsector_t b;\n\tstruct pagevec pvec;\n\tstruct page *page;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn 0;\n\n\tindex = start_blk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tnblocks_in_page = 1U << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\nrepeat:\n\tpvec.nr = find_get_pages_contig(inode->i_mapping, index, PAGEVEC_SIZE,\n\t\t\t\t\tpvec.pages);\n\tif (pvec.nr == 0)\n\t\treturn length;\n\n\tif (length > 0 && pvec.pages[0]->index > index)\n\t\tgoto out;\n\n\tb = pvec.pages[0]->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\ti = 0;\n\tdo {\n\t\tpage = pvec.pages[i];\n\n\t\tlock_page(page);\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (b < start_blk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tif (length == 0)\n\t\t\t\t\t\t*blkoff = b;\n\t\t\t\t\tlength++;\n\t\t\t\t} else if (length > 0) {\n\t\t\t\t\tgoto out_locked;\n\t\t\t\t}\n\t\t\t} while (++b, bh = bh->b_this_page, bh != head);\n\t\t} else {\n\t\t\tif (length > 0)\n\t\t\t\tgoto out_locked;\n\n\t\t\tb += nblocks_in_page;\n\t\t}\n\t\tunlock_page(page);\n\n\t} while (++i < pagevec_count(&pvec));\n\n\tindex = page->index + 1;\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n\nout_locked:\n\tunlock_page(page);\nout:\n\tpagevec_release(&pvec);\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fieinfo",
            "FIEMAP_FLAG_SYNC"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "138-148",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t __u64 start, __u64 len)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 logical = 0, phys = 0, size = 0;\n\t__u32 flags = 0;\n\tloff_t isize;\n\tsector_t blkoff, end_blkoff;\n\tsector_t delalloc_blkoff;\n\tunsigned long delalloc_blklen;\n\tunsigned int blkbits = inode->i_blkbits;\n\tint ret, n;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\n\tblkoff = start >> blkbits;\n\tend_blkoff = (start + len - 1) >> blkbits;\n\n\tdelalloc_blklen = nilfs_find_uncommitted_extent(inode, blkoff,\n\t\t\t\t\t\t\t&delalloc_blkoff);\n\n\tdo {\n\t\t__u64 blkphy;\n\t\tunsigned int maxblocks;\n\n\t\tif (delalloc_blklen && blkoff == delalloc_blkoff) {\n\t\t\tif (size) {\n\t\t\t\t/* End of the current extent */\n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff)\n\t\t\t\tbreak;\n\n\t\t\tflags = FIEMAP_EXTENT_MERGED | FIEMAP_EXTENT_DELALLOC;\n\t\t\tlogical = blkoff << blkbits;\n\t\t\tphys = 0;\n\t\t\tsize = delalloc_blklen << blkbits;\n\n\t\t\tblkoff = delalloc_blkoff + delalloc_blklen;\n\t\t\tdelalloc_blklen = nilfs_find_uncommitted_extent(\n\t\t\t\tinode, blkoff, &delalloc_blkoff);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Limit the number of blocks that we look up so as\n\t\t * not to get into the next delayed allocation extent.\n\t\t */\n\t\tmaxblocks = INT_MAX;\n\t\tif (delalloc_blklen)\n\t\t\tmaxblocks = min_t(sector_t, delalloc_blkoff - blkoff,\n\t\t\t\t\t  maxblocks);\n\t\tblkphy = 0;\n\n\t\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t\tn = nilfs_bmap_lookup_contig(\n\t\t\tNILFS_I(inode)->i_bmap, blkoff, &blkphy, maxblocks);\n\t\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\n\t\tif (n < 0) {\n\t\t\tint past_eof;\n\n\t\t\tif (unlikely(n != -ENOENT))\n\t\t\t\tbreak; /* error */\n\n\t\t\t/* HOLE */\n\t\t\tblkoff++;\n\t\t\tpast_eof = ((blkoff << blkbits) >= isize);\n\n\t\t\tif (size) {\n\t\t\t\t/* End of the current extent */\n\n\t\t\t\tif (past_eof)\n\t\t\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff || past_eof)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (size) {\n\t\t\t\tif (phys && blkphy << blkbits == phys + size) {\n\t\t\t\t\t/* The current extent goes on */\n\t\t\t\t\tsize += n << blkbits;\n\t\t\t\t} else {\n\t\t\t\t\t/* Terminate the current extent */\n\t\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\t\tfieinfo, logical, phys, size,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tif (ret || blkoff > end_blkoff)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* Start another extent */\n\t\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\t\tsize = n << blkbits;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Start a new extent */\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\tsize = n << blkbits;\n\t\t\t}\n\t\t\tblkoff += n;\n\t\t}\n\t\tcond_resched();\n\t} while (true);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "987-1005",
    "snippet": "void nilfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\tif (is_bad_inode(inode)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"tried to mark bad_inode dirty. ignored.\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tif (mdi) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\t__nilfs_mark_inode_dirty(inode, flags);\n\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nilfs_mark_inode_dirty",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "959-975",
          "snippet": "int __nilfs_mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct buffer_head *ibh;\n\tint err;\n\n\terr = nilfs_load_inode_block(inode, &ibh);\n\tif (unlikely(err)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"failed to reget inode block.\\n\");\n\t\treturn err;\n\t}\n\tnilfs_update_inode(inode, ibh, flags);\n\tmark_buffer_dirty(ibh);\n\tnilfs_mdt_mark_dirty(NILFS_I(inode)->i_root->ifile);\n\tbrelse(ibh);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint __nilfs_mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct buffer_head *ibh;\n\tint err;\n\n\terr = nilfs_load_inode_block(inode, &ibh);\n\tif (unlikely(err)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"failed to reget inode block.\\n\");\n\t\treturn err;\n\t}\n\tnilfs_update_inode(inode, ibh, flags);\n\tmark_buffer_dirty(ibh);\n\tnilfs_mdt_mark_dirty(NILFS_I(inode)->i_root->ifile);\n\tbrelse(ibh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "0"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "inode"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"tried to mark bad_inode dirty. ignored.\\n\""
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\tif (is_bad_inode(inode)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"tried to mark bad_inode dirty. ignored.\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tif (mdi) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\t__nilfs_mark_inode_dirty(inode, flags);\n\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n}"
  },
  {
    "function_name": "__nilfs_mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "959-975",
    "snippet": "int __nilfs_mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct buffer_head *ibh;\n\tint err;\n\n\terr = nilfs_load_inode_block(inode, &ibh);\n\tif (unlikely(err)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"failed to reget inode block.\\n\");\n\t\treturn err;\n\t}\n\tnilfs_update_inode(inode, ibh, flags);\n\tmark_buffer_dirty(ibh);\n\tnilfs_mdt_mark_dirty(NILFS_I(inode)->i_root->ifile);\n\tbrelse(ibh);\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ibh"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "NILFS_I(inode)->i_root->ifile"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "ibh"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_update_inode",
          "args": [
            "inode",
            "ibh",
            "flags"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "691-710",
          "snippet": "void nilfs_update_inode(struct inode *inode, struct buffer_head *ibh, int flags)\n{\n\tino_t ino = inode->i_ino;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *ifile = ii->i_root->ifile;\n\tstruct nilfs_inode *raw_inode;\n\n\traw_inode = nilfs_ifile_map_inode(ifile, ino, ibh);\n\n\tif (test_and_clear_bit(NILFS_I_NEW, &ii->i_state))\n\t\tmemset(raw_inode, 0, NILFS_MDT(ifile)->mi_entry_size);\n\tif (flags & I_DIRTY_DATASYNC)\n\t\tset_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\n\tnilfs_write_inode_common(inode, raw_inode, 0);\n\t\t/* XXX: call with has_bmap = 0 is a workaround to avoid\n\t\t   deadlock of bmap. This delays update of i_bmap to just\n\t\t   before writing */\n\tnilfs_ifile_unmap_inode(ifile, ino, ibh);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_update_inode(struct inode *inode, struct buffer_head *ibh, int flags)\n{\n\tino_t ino = inode->i_ino;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *ifile = ii->i_root->ifile;\n\tstruct nilfs_inode *raw_inode;\n\n\traw_inode = nilfs_ifile_map_inode(ifile, ino, ibh);\n\n\tif (test_and_clear_bit(NILFS_I_NEW, &ii->i_state))\n\t\tmemset(raw_inode, 0, NILFS_MDT(ifile)->mi_entry_size);\n\tif (flags & I_DIRTY_DATASYNC)\n\t\tset_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\n\tnilfs_write_inode_common(inode, raw_inode, 0);\n\t\t/* XXX: call with has_bmap = 0 is a workaround to avoid\n\t\t   deadlock of bmap. This delays update of i_bmap to just\n\t\t   before writing */\n\tnilfs_ifile_unmap_inode(ifile, ino, ibh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"failed to reget inode block.\\n\""
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_load_inode_block",
          "args": [
            "inode",
            "&ibh"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_load_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "884-910",
          "snippet": "int nilfs_load_inode_block(struct inode *inode, struct buffer_head **pbh)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (ii->i_bh == NULL) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\terr = nilfs_ifile_get_inode_block(ii->i_root->ifile,\n\t\t\t\t\t\t  inode->i_ino, pbh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tif (ii->i_bh == NULL)\n\t\t\tii->i_bh = *pbh;\n\t\telse {\n\t\t\tbrelse(*pbh);\n\t\t\t*pbh = ii->i_bh;\n\t\t}\n\t} else\n\t\t*pbh = ii->i_bh;\n\n\tget_bh(*pbh);\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_load_inode_block(struct inode *inode, struct buffer_head **pbh)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (ii->i_bh == NULL) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\terr = nilfs_ifile_get_inode_block(ii->i_root->ifile,\n\t\t\t\t\t\t  inode->i_ino, pbh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tif (ii->i_bh == NULL)\n\t\t\tii->i_bh = *pbh;\n\t\telse {\n\t\t\tbrelse(*pbh);\n\t\t\t*pbh = ii->i_bh;\n\t\t}\n\t} else\n\t\t*pbh = ii->i_bh;\n\n\tget_bh(*pbh);\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint __nilfs_mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct buffer_head *ibh;\n\tint err;\n\n\terr = nilfs_load_inode_block(inode, &ibh);\n\tif (unlikely(err)) {\n\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t      \"failed to reget inode block.\\n\");\n\t\treturn err;\n\t}\n\tnilfs_update_inode(inode, ibh, flags);\n\tmark_buffer_dirty(ibh);\n\tnilfs_mdt_mark_dirty(NILFS_I(inode)->i_root->ifile);\n\tbrelse(ibh);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_set_file_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "927-957",
    "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_QUEUED",
            "&ii->i_state"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ii->i_dirty",
            "&nilfs->ns_dirty_files"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"cannot get inode (ino=%lu)\\n\"",
            "inode->i_ino"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nr_dirty",
            "&nilfs->ns_ndirtyblks"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "912-925",
    "snippet": "int nilfs_inode_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tint ret = 0;\n\n\tif (!list_empty(&ii->i_dirty)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tret = test_bit(NILFS_I_DIRTY, &ii->i_state) ||\n\t\t\ttest_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_inode_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tint ret = 0;\n\n\tif (!list_empty(&ii->i_dirty)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tret = test_bit(NILFS_I_DIRTY, &ii->i_state) ||\n\t\t\ttest_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_load_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "884-910",
    "snippet": "int nilfs_load_inode_block(struct inode *inode, struct buffer_head **pbh)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (ii->i_bh == NULL) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\terr = nilfs_ifile_get_inode_block(ii->i_root->ifile,\n\t\t\t\t\t\t  inode->i_ino, pbh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tif (ii->i_bh == NULL)\n\t\t\tii->i_bh = *pbh;\n\t\telse {\n\t\t\tbrelse(*pbh);\n\t\t\t*pbh = ii->i_bh;\n\t\t}\n\t} else\n\t\t*pbh = ii->i_bh;\n\n\tget_bh(*pbh);\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*pbh"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*pbh"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_get_inode_block",
          "args": [
            "ii->i_root->ifile",
            "inode->i_ino",
            "pbh"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_get_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "143-160",
          "snippet": "int nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_load_inode_block(struct inode *inode, struct buffer_head **pbh)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (ii->i_bh == NULL) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\terr = nilfs_ifile_get_inode_block(ii->i_root->ifile,\n\t\t\t\t\t\t  inode->i_ino, pbh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tif (ii->i_bh == NULL)\n\t\t\tii->i_bh = *pbh;\n\t\telse {\n\t\t\tbrelse(*pbh);\n\t\t\t*pbh = ii->i_bh;\n\t\t}\n\t} else\n\t\t*pbh = ii->i_bh;\n\n\tget_bh(*pbh);\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "874-882",
    "snippet": "int nilfs_permission(struct inode *inode, int mask)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\tif ((mask & MAY_WRITE) && root &&\n\t    root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\treturn -EROFS; /* snapshot is not writable */\n\n\treturn generic_permission(inode, mask);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_permission(struct inode *inode, int mask)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\tif ((mask & MAY_WRITE) && root &&\n\t    root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\treturn -EROFS; /* snapshot is not writable */\n\n\treturn generic_permission(inode, mask);\n}"
  },
  {
    "function_name": "nilfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "836-872",
    "snippet": "int nilfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint err;\n\n\terr = inode_change_ok(inode, iattr);\n\tif (err)\n\t\treturn err;\n\n\terr = nilfs_transaction_begin(sb, &ti, 0);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tnilfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\terr = nilfs_acl_chmod(inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t}\n\n\treturn nilfs_transaction_commit(sb);\n\nout_err:\n\tnilfs_transaction_abort(sb);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "sb"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "sb"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_acl_chmod",
          "args": [
            "inode"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "205-208",
          "snippet": "static inline int nilfs_acl_chmod(struct inode *inode)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_acl_chmod(struct inode *inode)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_truncate",
          "args": [
            "inode"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "745-775",
          "snippet": "void nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "iattr->ia_size"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "sb",
            "&ti",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint err;\n\n\terr = inode_change_ok(inode, iattr);\n\tif (err)\n\t\treturn err;\n\n\terr = nilfs_transaction_begin(sb, &ti, 0);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tnilfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\terr = nilfs_acl_chmod(inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t}\n\n\treturn nilfs_transaction_commit(sb);\n\nout_err:\n\tnilfs_transaction_abort(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "801-834",
    "snippet": "void nilfs_evict_inode(struct inode *inode)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint ret;\n\n\tif (inode->i_nlink || !ii->i_root || unlikely(is_bad_inode(inode))) {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t\tnilfs_clear_inode(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/* TODO: some of the following operations may fail.  */\n\tnilfs_truncate_bmap(ii, 0);\n\tnilfs_mark_inode_dirty(inode);\n\tclear_inode(inode);\n\n\tret = nilfs_ifile_delete_inode(ii->i_root->ifile, inode->i_ino);\n\tif (!ret)\n\t\tatomic64_dec(&ii->i_root->inodes_count);\n\n\tnilfs_clear_inode(inode);\n\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But delete_inode has no return value. */\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "sb"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_transaction_flag",
          "args": [
            "NILFS_TI_SYNC"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_transaction_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "171-176",
          "snippet": "static inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_clear_inode",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "777-799",
          "snippet": "static void nilfs_clear_inode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\t/*\n\t * Free resources allocated in nilfs_read_inode(), here.\n\t */\n\tBUG_ON(!list_empty(&ii->i_dirty));\n\tbrelse(ii->i_bh);\n\tii->i_bh = NULL;\n\n\tif (mdi && mdi->mi_palloc_cache)\n\t\tnilfs_palloc_destroy_cache(inode);\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\tnilfs_bmap_clear(ii->i_bmap);\n\n\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\n\tif (ii->i_root && inode->i_ino == NILFS_ROOT_INO)\n\t\tnilfs_put_root(ii->i_root);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_clear_inode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\t/*\n\t * Free resources allocated in nilfs_read_inode(), here.\n\t */\n\tBUG_ON(!list_empty(&ii->i_dirty));\n\tbrelse(ii->i_bh);\n\tii->i_bh = NULL;\n\n\tif (mdi && mdi->mi_palloc_cache)\n\t\tnilfs_palloc_destroy_cache(inode);\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\tnilfs_bmap_clear(ii->i_bmap);\n\n\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\n\tif (ii->i_root && inode->i_ino == NILFS_ROOT_INO)\n\t\tnilfs_put_root(ii->i_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&ii->i_root->inodes_count"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_delete_inode",
          "args": [
            "ii->i_root->ifile",
            "inode->i_ino"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "108-141",
          "snippet": "int nilfs_ifile_delete_inode(struct inode *ifile, ino_t ino)\n{\n\tstruct nilfs_palloc_req req = {\n\t\t.pr_entry_nr = ino, .pr_entry_bh = NULL\n\t};\n\tstruct nilfs_inode *raw_inode;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_prepare_free_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 0,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_free_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req.pr_entry_bh->b_page);\n\traw_inode = nilfs_palloc_block_get_entry(ifile, req.pr_entry_nr,\n\t\t\t\t\t\t req.pr_entry_bh, kaddr);\n\traw_inode->i_flags = 0;\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tbrelse(req.pr_entry_bh);\n\n\tnilfs_palloc_commit_free_entry(ifile, &req);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_delete_inode(struct inode *ifile, ino_t ino)\n{\n\tstruct nilfs_palloc_req req = {\n\t\t.pr_entry_nr = ino, .pr_entry_bh = NULL\n\t};\n\tstruct nilfs_inode *raw_inode;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_prepare_free_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 0,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_free_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req.pr_entry_bh->b_page);\n\traw_inode = nilfs_palloc_block_get_entry(ifile, req.pr_entry_nr,\n\t\t\t\t\t\t req.pr_entry_bh, kaddr);\n\traw_inode->i_flags = 0;\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tbrelse(req.pr_entry_bh);\n\n\tnilfs_palloc_commit_free_entry(ifile, &req);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_truncate_bmap",
          "args": [
            "ii",
            "0"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_truncate_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "714-743",
          "snippet": "static void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */\n\nstatic void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "sb",
            "&ti",
            "0"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_bad_inode(inode)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_evict_inode(struct inode *inode)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint ret;\n\n\tif (inode->i_nlink || !ii->i_root || unlikely(is_bad_inode(inode))) {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t\tnilfs_clear_inode(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/* TODO: some of the following operations may fail.  */\n\tnilfs_truncate_bmap(ii, 0);\n\tnilfs_mark_inode_dirty(inode);\n\tclear_inode(inode);\n\n\tret = nilfs_ifile_delete_inode(ii->i_root->ifile, inode->i_ino);\n\tif (!ret)\n\t\tatomic64_dec(&ii->i_root->inodes_count);\n\n\tnilfs_clear_inode(inode);\n\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But delete_inode has no return value. */\n}"
  },
  {
    "function_name": "nilfs_clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "777-799",
    "snippet": "static void nilfs_clear_inode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\t/*\n\t * Free resources allocated in nilfs_read_inode(), here.\n\t */\n\tBUG_ON(!list_empty(&ii->i_dirty));\n\tbrelse(ii->i_bh);\n\tii->i_bh = NULL;\n\n\tif (mdi && mdi->mi_palloc_cache)\n\t\tnilfs_palloc_destroy_cache(inode);\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\tnilfs_bmap_clear(ii->i_bmap);\n\n\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\n\tif (ii->i_root && inode->i_ino == NILFS_ROOT_INO)\n\t\tnilfs_put_root(ii->i_root);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "ii->i_root"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_btnode_cache_clear",
          "args": [
            "&ii->i_btnode_cache"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_cache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "37-41",
          "snippet": "void nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_clear",
          "args": [
            "ii->i_bmap"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_clear_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.h",
          "lines": "264-267",
          "snippet": "static inline void nilfs_bmap_clear_dirty(struct nilfs_bmap *bmap)\n{\n\tbmap->b_state &= ~NILFS_BMAP_DIRTY;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NILFS_BMAP_DIRTY\t0x00000001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define NILFS_BMAP_DIRTY\t0x00000001\n\nstatic inline void nilfs_bmap_clear_dirty(struct nilfs_bmap *bmap)\n{\n\tbmap->b_state &= ~NILFS_BMAP_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_destroy_cache",
          "args": [
            "inode"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_destroy_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "780-784",
          "snippet": "void nilfs_palloc_destroy_cache(struct inode *inode)\n{\n\tnilfs_palloc_clear_cache(inode);\n\tNILFS_MDT(inode)->mi_palloc_cache = NULL;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_destroy_cache(struct inode *inode)\n{\n\tnilfs_palloc_clear_cache(inode);\n\tNILFS_MDT(inode)->mi_palloc_cache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ii->i_bh"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&ii->i_dirty)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_clear_inode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\t/*\n\t * Free resources allocated in nilfs_read_inode(), here.\n\t */\n\tBUG_ON(!list_empty(&ii->i_dirty));\n\tbrelse(ii->i_bh);\n\tii->i_bh = NULL;\n\n\tif (mdi && mdi->mi_palloc_cache)\n\t\tnilfs_palloc_destroy_cache(inode);\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\tnilfs_bmap_clear(ii->i_bmap);\n\n\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\n\tif (ii->i_root && inode->i_ino == NILFS_ROOT_INO)\n\t\tnilfs_put_root(ii->i_root);\n}"
  },
  {
    "function_name": "nilfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "745-775",
    "snippet": "void nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "sb"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_file_dirty",
          "args": [
            "inode",
            "0"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_file_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "927-957",
          "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_transaction_flag",
          "args": [
            "NILFS_TI_SYNC"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_transaction_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "171-176",
          "snippet": "static inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_truncate_bmap",
          "args": [
            "ii",
            "blkoff"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_truncate_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "714-743",
          "snippet": "static void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */\n\nstatic void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "inode->i_size",
            "nilfs_get_block"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3323-3335",
          "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "sb",
            "&ti",
            "0"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}"
  },
  {
    "function_name": "nilfs_truncate_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "714-743",
    "snippet": "static void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [
      "#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "ii->vfs_inode.i_sb",
            "__func__",
            "\"failed to truncate bmap (ino=%lu, err=%d)\"",
            "ii->vfs_inode.i_ino",
            "ret"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_truncate",
          "args": [
            "ii->i_bmap",
            "b"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "279-288",
          "snippet": "int nilfs_bmap_truncate(struct nilfs_bmap *bmap, unsigned long key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_truncate(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_truncate(struct nilfs_bmap *bmap, unsigned long key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_truncate(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_relax_pressure_in_lock",
          "args": [
            "ii->vfs_inode.i_sb"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_relax_pressure_in_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "272-293",
          "snippet": "void nilfs_relax_pressure_in_lock(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || !sci->sc_flush_request)\n\t\treturn;\n\n\tset_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (sci->sc_flush_request &&\n\t    test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags)) {\n\t\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\t\tti->ti_flags |= NILFS_TI_WRITER;\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\t\tti->ti_flags &= ~NILFS_TI_WRITER;\n\t}\n\tdowngrade_write(&nilfs->ns_segctor_sem);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nvoid nilfs_relax_pressure_in_lock(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || !sci->sc_flush_request)\n\t\treturn;\n\n\tset_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (sci->sc_flush_request &&\n\t    test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags)) {\n\t\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\t\tti->ti_flags |= NILFS_TI_WRITER;\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\t\tti->ti_flags &= ~NILFS_TI_WRITER;\n\t}\n\tdowngrade_write(&nilfs->ns_segctor_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "NILFS_MAX_TRUNCATE_BLOCKS",
            "b - from"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_last_key",
          "args": [
            "ii->i_bmap",
            "&b"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_last_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "194-208",
          "snippet": "int nilfs_bmap_last_key(struct nilfs_bmap *bmap, unsigned long *key)\n{\n\t__u64 lastkey;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_last_key(bmap, &lastkey);\n\tup_read(&bmap->b_sem);\n\n\tif (ret < 0)\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\telse\n\t\t*key = lastkey;\n\treturn ret;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_last_key(struct nilfs_bmap *bmap, unsigned long *key)\n{\n\t__u64 lastkey;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_last_key(bmap, &lastkey);\n\tup_read(&bmap->b_sem);\n\n\tif (ret < 0)\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\telse\n\t\t*key = lastkey;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MAX_TRUNCATE_BLOCKS\t16384  /* 64MB for 4KB block */\n\nstatic void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\tunsigned long b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(unsigned long, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warning(ii->vfs_inode.i_sb, __func__,\n\t\t      \"failed to truncate bmap (ino=%lu, err=%d)\",\n\t\t      ii->vfs_inode.i_ino, ret);\n}"
  },
  {
    "function_name": "nilfs_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "691-710",
    "snippet": "void nilfs_update_inode(struct inode *inode, struct buffer_head *ibh, int flags)\n{\n\tino_t ino = inode->i_ino;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *ifile = ii->i_root->ifile;\n\tstruct nilfs_inode *raw_inode;\n\n\traw_inode = nilfs_ifile_map_inode(ifile, ino, ibh);\n\n\tif (test_and_clear_bit(NILFS_I_NEW, &ii->i_state))\n\t\tmemset(raw_inode, 0, NILFS_MDT(ifile)->mi_entry_size);\n\tif (flags & I_DIRTY_DATASYNC)\n\t\tset_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\n\tnilfs_write_inode_common(inode, raw_inode, 0);\n\t\t/* XXX: call with has_bmap = 0 is a workaround to avoid\n\t\t   deadlock of bmap. This delays update of i_bmap to just\n\t\t   before writing */\n\tnilfs_ifile_unmap_inode(ifile, ino, ibh);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_ifile_unmap_inode",
          "args": [
            "ifile",
            "ino",
            "ibh"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_unmap_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "42-46",
          "snippet": "static inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_write_inode_common",
          "args": [
            "inode",
            "raw_inode",
            "0"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "653-689",
          "snippet": "void nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_INODE_SYNC",
            "&ii->i_state"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "NILFS_MDT(ifile)->mi_entry_size"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "ifile"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NILFS_I_NEW",
            "&ii->i_state"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_map_inode",
          "args": [
            "ifile",
            "ino",
            "ibh"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_map_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "35-40",
          "snippet": "static inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_update_inode(struct inode *inode, struct buffer_head *ibh, int flags)\n{\n\tino_t ino = inode->i_ino;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *ifile = ii->i_root->ifile;\n\tstruct nilfs_inode *raw_inode;\n\n\traw_inode = nilfs_ifile_map_inode(ifile, ino, ibh);\n\n\tif (test_and_clear_bit(NILFS_I_NEW, &ii->i_state))\n\t\tmemset(raw_inode, 0, NILFS_MDT(ifile)->mi_entry_size);\n\tif (flags & I_DIRTY_DATASYNC)\n\t\tset_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\n\tnilfs_write_inode_common(inode, raw_inode, 0);\n\t\t/* XXX: call with has_bmap = 0 is a workaround to avoid\n\t\t   deadlock of bmap. This delays update of i_bmap to just\n\t\t   before writing */\n\tnilfs_ifile_unmap_inode(ifile, ino, ibh);\n}"
  },
  {
    "function_name": "nilfs_write_inode_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "653-689",
    "snippet": "void nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "huge_encode_dev(inode->i_rdev)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_write",
          "args": [
            "ii->i_bmap",
            "raw_inode"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "528-537",
          "snippet": "void nilfs_bmap_write(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tdown_write(&bmap->b_sem);\n\tmemcpy(raw_inode->i_bmap, bmap->b_u.u_data,\n\t       NILFS_INODE_BMAP_SIZE * sizeof(__le64));\n\tif (bmap->b_inode->i_ino == NILFS_DAT_INO)\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\n\tup_write(&bmap->b_sem);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_write(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tdown_write(&bmap->b_sem);\n\tmemcpy(raw_inode->i_bmap, bmap->b_u.u_data,\n\t       NILFS_INODE_BMAP_SIZE * sizeof(__le64));\n\tif (bmap->b_inode->i_ino == NILFS_DAT_INO)\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\n\tup_write(&bmap->b_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)raw_inode + sizeof(*raw_inode)",
            "0",
            "nilfs->ns_inode_size - sizeof(*raw_inode)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_ROOT_METADATA_FILE",
          "args": [
            "inode->i_ino"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ii->i_flags"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_blocks"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_nsec"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_size"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}"
  },
  {
    "function_name": "nilfs_iget_for_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "629-651",
    "snippet": "struct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_init_gcinode",
          "args": [
            "inode"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_init_gcinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
          "lines": "168-180",
          "snippet": "int nilfs_init_gcinode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_mapping->a_ops = &empty_aops;\n\n\tii->i_flags = 0;\n\tnilfs_bmap_init_gc(ii->i_bmap);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_init_gcinode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_mapping->a_ops = &empty_aops;\n\n\tii->i_flags = 0;\n\tnilfs_bmap_init_gc(ii->i_bmap);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "ino",
            "nilfs_iget_test",
            "nilfs_iget_set",
            "&args"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "nilfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "608-627",
    "snippet": "struct inode *nilfs_iget(struct super_block *sb, struct nilfs_root *root,\n\t\t\t unsigned long ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = nilfs_iget_locked(sb, root, ino);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = __nilfs_read_inode(sb, root, ino, inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nilfs_read_inode",
          "args": [
            "sb",
            "root",
            "ino",
            "inode"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "504-554",
          "snippet": "static int __nilfs_read_inode(struct super_block *sb,\n\t\t\t      struct nilfs_root *root, unsigned long ino,\n\t\t\t      struct inode *inode)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\tstruct nilfs_inode *raw_inode;\n\tint err;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\terr = nilfs_ifile_get_inode_block(root->ifile, ino, &bh);\n\tif (unlikely(err))\n\t\tgoto bad_inode;\n\n\traw_inode = nilfs_ifile_map_inode(root->ifile, ino, bh);\n\n\terr = nilfs_read_inode_common(inode, raw_inode);\n\tif (err)\n\t\tgoto failed_unmap;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_dir_inode_operations;\n\t\tinode->i_fop = &nilfs_dir_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else {\n\t\tinode->i_op = &nilfs_special_inode_operations;\n\t\tinit_special_inode(\n\t\t\tinode, inode->i_mode,\n\t\t\thuge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));\n\t}\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tnilfs_set_inode_flags(inode);\n\treturn 0;\n\n failed_unmap:\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\n bad_inode:\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations nilfs_aops = {\n\t.writepage\t\t= nilfs_writepage,\n\t.readpage\t\t= nilfs_readpage,\n\t.writepages\t\t= nilfs_writepages,\n\t.set_page_dirty\t\t= nilfs_set_page_dirty,\n\t.readpages\t\t= nilfs_readpages,\n\t.write_begin\t\t= nilfs_write_begin,\n\t.write_end\t\t= nilfs_write_end,\n\t/* .releasepage\t\t= nilfs_releasepage, */\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.direct_IO\t\t= nilfs_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nconst struct address_space_operations nilfs_aops = {\n\t.writepage\t\t= nilfs_writepage,\n\t.readpage\t\t= nilfs_readpage,\n\t.writepages\t\t= nilfs_writepages,\n\t.set_page_dirty\t\t= nilfs_set_page_dirty,\n\t.readpages\t\t= nilfs_readpages,\n\t.write_begin\t\t= nilfs_write_begin,\n\t.write_end\t\t= nilfs_write_end,\n\t/* .releasepage\t\t= nilfs_releasepage, */\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.direct_IO\t\t= nilfs_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n};\n\nstatic int __nilfs_read_inode(struct super_block *sb,\n\t\t\t      struct nilfs_root *root, unsigned long ino,\n\t\t\t      struct inode *inode)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\tstruct nilfs_inode *raw_inode;\n\tint err;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\terr = nilfs_ifile_get_inode_block(root->ifile, ino, &bh);\n\tif (unlikely(err))\n\t\tgoto bad_inode;\n\n\traw_inode = nilfs_ifile_map_inode(root->ifile, ino, bh);\n\n\terr = nilfs_read_inode_common(inode, raw_inode);\n\tif (err)\n\t\tgoto failed_unmap;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_dir_inode_operations;\n\t\tinode->i_fop = &nilfs_dir_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else {\n\t\tinode->i_op = &nilfs_special_inode_operations;\n\t\tinit_special_inode(\n\t\t\tinode, inode->i_mode,\n\t\t\thuge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));\n\t}\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tnilfs_set_inode_flags(inode);\n\treturn 0;\n\n failed_unmap:\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\n bad_inode:\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget_locked",
          "args": [
            "sb",
            "root",
            "ino"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "598-606",
          "snippet": "struct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget(struct super_block *sb, struct nilfs_root *root,\n\t\t\t unsigned long ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = nilfs_iget_locked(sb, root, ino);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = __nilfs_read_inode(sb, root, ino, inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "nilfs_iget_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "598-606",
    "snippet": "struct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "ino",
            "nilfs_iget_test",
            "nilfs_iget_set",
            "&args"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}"
  },
  {
    "function_name": "nilfs_ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "588-596",
    "snippet": "struct inode *nilfs_ilookup(struct super_block *sb, struct nilfs_root *root,\n\t\t\t    unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn ilookup5(sb, ino, nilfs_iget_test, &args);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "ino",
            "nilfs_iget_test",
            "&args"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_ilookup(struct super_block *sb, struct nilfs_root *root,\n\t\t\t    unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn ilookup5(sb, ino, nilfs_iget_test, &args);\n}"
  },
  {
    "function_name": "nilfs_iget_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "571-586",
    "snippet": "static int nilfs_iget_set(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\n\tinode->i_ino = args->ino;\n\tif (args->for_gc) {\n\t\tNILFS_I(inode)->i_state = 1 << NILFS_I_GCINODE;\n\t\tNILFS_I(inode)->i_cno = args->cno;\n\t\tNILFS_I(inode)->i_root = NULL;\n\t} else {\n\t\tif (args->root && args->ino == NILFS_ROOT_INO)\n\t\t\tnilfs_get_root(args->root);\n\t\tNILFS_I(inode)->i_root = args->root;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_iget_test(struct inode *inode, void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_root",
          "args": [
            "args->root"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "304-307",
          "snippet": "static inline void nilfs_get_root(struct nilfs_root *root)\n{\n\tatomic_inc(&root->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void nilfs_get_root(struct nilfs_root *root)\n{\n\tatomic_inc(&root->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_iget_test(struct inode *inode, void *opaque);\n\nstatic int nilfs_iget_set(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\n\tinode->i_ino = args->ino;\n\tif (args->for_gc) {\n\t\tNILFS_I(inode)->i_state = 1 << NILFS_I_GCINODE;\n\t\tNILFS_I(inode)->i_cno = args->cno;\n\t\tNILFS_I(inode)->i_root = NULL;\n\t} else {\n\t\tif (args->root && args->ino == NILFS_ROOT_INO)\n\t\t\tnilfs_get_root(args->root);\n\t\tNILFS_I(inode)->i_root = args->root;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_iget_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "556-569",
    "snippet": "static int nilfs_iget_test(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\tstruct nilfs_inode_info *ii;\n\n\tif (args->ino != inode->i_ino || args->root != NILFS_I(inode)->i_root)\n\t\treturn 0;\n\n\tii = NILFS_I(inode);\n\tif (!test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\treturn !args->for_gc;\n\n\treturn args->for_gc && args->cno == ii->i_cno;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_iget_test(struct inode *inode, void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_GCINODE",
            "&ii->i_state"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_iget_test(struct inode *inode, void *opaque);\n\nstatic int nilfs_iget_test(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\tstruct nilfs_inode_info *ii;\n\n\tif (args->ino != inode->i_ino || args->root != NILFS_I(inode)->i_root)\n\t\treturn 0;\n\n\tii = NILFS_I(inode);\n\tif (!test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\treturn !args->for_gc;\n\n\treturn args->for_gc && args->cno == ii->i_cno;\n}"
  },
  {
    "function_name": "__nilfs_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "504-554",
    "snippet": "static int __nilfs_read_inode(struct super_block *sb,\n\t\t\t      struct nilfs_root *root, unsigned long ino,\n\t\t\t      struct inode *inode)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\tstruct nilfs_inode *raw_inode;\n\tint err;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\terr = nilfs_ifile_get_inode_block(root->ifile, ino, &bh);\n\tif (unlikely(err))\n\t\tgoto bad_inode;\n\n\traw_inode = nilfs_ifile_map_inode(root->ifile, ino, bh);\n\n\terr = nilfs_read_inode_common(inode, raw_inode);\n\tif (err)\n\t\tgoto failed_unmap;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_dir_inode_operations;\n\t\tinode->i_fop = &nilfs_dir_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else {\n\t\tinode->i_op = &nilfs_special_inode_operations;\n\t\tinit_special_inode(\n\t\t\tinode, inode->i_mode,\n\t\t\thuge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));\n\t}\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tnilfs_set_inode_flags(inode);\n\treturn 0;\n\n failed_unmap:\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\n bad_inode:\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations nilfs_aops = {\n\t.writepage\t\t= nilfs_writepage,\n\t.readpage\t\t= nilfs_readpage,\n\t.writepages\t\t= nilfs_writepages,\n\t.set_page_dirty\t\t= nilfs_set_page_dirty,\n\t.readpages\t\t= nilfs_readpages,\n\t.write_begin\t\t= nilfs_write_begin,\n\t.write_end\t\t= nilfs_write_end,\n\t/* .releasepage\t\t= nilfs_releasepage, */\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.direct_IO\t\t= nilfs_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_unmap_inode",
          "args": [
            "root->ifile",
            "ino",
            "bh"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_unmap_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "42-46",
          "snippet": "static inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "443-461",
          "snippet": "void nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "huge_decode_dev(le64_to_cpu(raw_inode->i_device_code))"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_decode_dev",
          "args": [
            "le64_to_cpu(raw_inode->i_device_code)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "raw_inode->i_device_code"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_read_inode_common",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "463-502",
          "snippet": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_map_inode",
          "args": [
            "root->ifile",
            "ino",
            "bh"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_map_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "35-40",
          "snippet": "static inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_get_inode_block",
          "args": [
            "root->ifile",
            "ino",
            "&bh"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_get_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "143-160",
          "snippet": "int nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nconst struct address_space_operations nilfs_aops = {\n\t.writepage\t\t= nilfs_writepage,\n\t.readpage\t\t= nilfs_readpage,\n\t.writepages\t\t= nilfs_writepages,\n\t.set_page_dirty\t\t= nilfs_set_page_dirty,\n\t.readpages\t\t= nilfs_readpages,\n\t.write_begin\t\t= nilfs_write_begin,\n\t.write_end\t\t= nilfs_write_end,\n\t/* .releasepage\t\t= nilfs_releasepage, */\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.direct_IO\t\t= nilfs_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n};\n\nstatic int __nilfs_read_inode(struct super_block *sb,\n\t\t\t      struct nilfs_root *root, unsigned long ino,\n\t\t\t      struct inode *inode)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\tstruct nilfs_inode *raw_inode;\n\tint err;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\terr = nilfs_ifile_get_inode_block(root->ifile, ino, &bh);\n\tif (unlikely(err))\n\t\tgoto bad_inode;\n\n\traw_inode = nilfs_ifile_map_inode(root->ifile, ino, bh);\n\n\terr = nilfs_read_inode_common(inode, raw_inode);\n\tif (err)\n\t\tgoto failed_unmap;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_dir_inode_operations;\n\t\tinode->i_fop = &nilfs_dir_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else {\n\t\tinode->i_op = &nilfs_special_inode_operations;\n\t\tinit_special_inode(\n\t\t\tinode, inode->i_mode,\n\t\t\thuge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));\n\t}\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tnilfs_set_inode_flags(inode);\n\treturn 0;\n\n failed_unmap:\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\n bad_inode:\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_read_inode_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "463-502",
    "snippet": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_read",
          "args": [
            "ii->i_bmap",
            "raw_inode"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "483-519",
          "snippet": "int nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tif (raw_inode == NULL)\n\t\tmemset(bmap->b_u.u_data, 0, NILFS_BMAP_SIZE);\n\telse\n\t\tmemcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);\n\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_state = 0;\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tswitch (bmap->b_inode->i_ino) {\n\tcase NILFS_DAT_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_P;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_dat_lock_key);\n\t\tbreak;\n\tcase NILFS_CPFILE_INO:\n\tcase NILFS_SUFILE_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VS;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tbreak;\n\tcase NILFS_IFILE_INO:\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\t/* Fall through */\n\tdefault:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VM;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tbreak;\n\t}\n\n\treturn (bmap->b_u.u_flags & NILFS_BMAP_LARGE) ?\n\t\tnilfs_btree_init(bmap) : nilfs_direct_init(bmap);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key nilfs_bmap_dat_lock_key;",
            "static struct lock_class_key nilfs_bmap_mdt_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstatic struct lock_class_key nilfs_bmap_dat_lock_key;\nstatic struct lock_class_key nilfs_bmap_mdt_lock_key;\n\nint nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tif (raw_inode == NULL)\n\t\tmemset(bmap->b_u.u_data, 0, NILFS_BMAP_SIZE);\n\telse\n\t\tmemcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);\n\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_state = 0;\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tswitch (bmap->b_inode->i_ino) {\n\tcase NILFS_DAT_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_P;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_dat_lock_key);\n\t\tbreak;\n\tcase NILFS_CPFILE_INO:\n\tcase NILFS_SUFILE_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VS;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tbreak;\n\tcase NILFS_IFILE_INO:\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\t/* Fall through */\n\tdefault:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VM;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tbreak;\n\t}\n\n\treturn (bmap->b_u.u_flags & NILFS_BMAP_LARGE) ?\n\t\tnilfs_btree_init(bmap) : nilfs_direct_init(bmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_generation"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "raw_inode->i_blocks"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(raw_inode->i_links_count)"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_links_count"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(raw_inode->i_gid)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(raw_inode->i_uid)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "443-461",
    "snippet": "void nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}"
  },
  {
    "function_name": "nilfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "364-441",
    "snippet": "struct inode *nilfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_root *root;\n\tint err = -ENOMEM;\n\tino_t ino;\n\n\tinode = new_inode(sb);\n\tif (unlikely(!inode))\n\t\tgoto failed;\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\troot = NILFS_I(dir)->i_root;\n\tii = NILFS_I(inode);\n\tii->i_state = 1 << NILFS_I_NEW;\n\tii->i_root = root;\n\n\terr = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);\n\tif (unlikely(err))\n\t\tgoto failed_ifile_create_inode;\n\t/* reference count of i_bh inherits from nilfs_mdt_read_block() */\n\n\tatomic64_inc(&root->inodes_count);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = ino;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, NULL);\n\t\tif (err < 0)\n\t\t\tgoto failed_after_creation;\n\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\n\tii->i_flags = nilfs_mask_flags(\n\t\tmode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);\n\n\t/* ii->i_file_acl = 0; */\n\t/* ii->i_dir_acl = 0; */\n\tii->i_dir_start_lookup = 0;\n\tnilfs_set_inode_flags(inode);\n\tspin_lock(&nilfs->ns_next_gen_lock);\n\tinode->i_generation = nilfs->ns_next_generation++;\n\tspin_unlock(&nilfs->ns_next_gen_lock);\n\tif (nilfs_insert_inode_locked(inode, root, ino) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed_after_creation;\n\t}\n\n\terr = nilfs_init_acl(inode, dir);\n\tif (unlikely(err))\n\t\tgoto failed_after_creation; /* never occur. When supporting\n\t\t\t\t    nilfs_init_acl(), proper cancellation of\n\t\t\t\t    above jobs should be considered */\n\n\treturn inode;\n\n failed_after_creation:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);  /* raw_inode will be deleted through\n\t\t\t nilfs_evict_inode() */\n\tgoto failed;\n\n failed_ifile_create_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);  /* if i_nlink == 1, generic_forget_inode() will be\n\t\t\t called */\n failed:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_init_acl",
          "args": [
            "inode",
            "dir"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "210-214",
          "snippet": "static inline int nilfs_init_acl(struct inode *inode, struct inode *dir)\n{\n\tinode->i_mode &= ~current_umask();\n\treturn 0;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_init_acl(struct inode *inode, struct inode *dir)\n{\n\tinode->i_mode &= ~current_umask();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_insert_inode_locked",
          "args": [
            "inode",
            "root",
            "ino"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "353-362",
          "snippet": "static int nilfs_insert_inode_locked(struct inode *inode,\n\t\t\t\t     struct nilfs_root *root,\n\t\t\t\t     unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn insert_inode_locked4(inode, ino, nilfs_iget_test, &args);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_insert_inode_locked(struct inode *inode,\n\t\t\t\t     struct nilfs_root *root,\n\t\t\t\t     unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn insert_inode_locked4(inode, ino, nilfs_iget_test, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_next_gen_lock"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_next_gen_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "443-461",
          "snippet": "void nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mask_flags",
          "args": [
            "mode",
            "NILFS_I(dir)->i_flags & NILFS_FL_INHERITED"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "226-234",
          "snippet": "static inline __u32 nilfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~(FS_DIRSYNC_FL | FS_TOPDIR_FL);\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline __u32 nilfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~(FS_DIRSYNC_FL | FS_TOPDIR_FL);\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "dir"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_read",
          "args": [
            "ii->i_bmap",
            "NULL"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "483-519",
          "snippet": "int nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tif (raw_inode == NULL)\n\t\tmemset(bmap->b_u.u_data, 0, NILFS_BMAP_SIZE);\n\telse\n\t\tmemcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);\n\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_state = 0;\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tswitch (bmap->b_inode->i_ino) {\n\tcase NILFS_DAT_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_P;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_dat_lock_key);\n\t\tbreak;\n\tcase NILFS_CPFILE_INO:\n\tcase NILFS_SUFILE_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VS;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tbreak;\n\tcase NILFS_IFILE_INO:\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\t/* Fall through */\n\tdefault:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VM;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tbreak;\n\t}\n\n\treturn (bmap->b_u.u_flags & NILFS_BMAP_LARGE) ?\n\t\tnilfs_btree_init(bmap) : nilfs_direct_init(bmap);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key nilfs_bmap_dat_lock_key;",
            "static struct lock_class_key nilfs_bmap_mdt_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstatic struct lock_class_key nilfs_bmap_dat_lock_key;\nstatic struct lock_class_key nilfs_bmap_mdt_lock_key;\n\nint nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tif (raw_inode == NULL)\n\t\tmemset(bmap->b_u.u_data, 0, NILFS_BMAP_SIZE);\n\telse\n\t\tmemcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);\n\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_state = 0;\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tswitch (bmap->b_inode->i_ino) {\n\tcase NILFS_DAT_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_P;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_dat_lock_key);\n\t\tbreak;\n\tcase NILFS_CPFILE_INO:\n\tcase NILFS_SUFILE_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VS;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tbreak;\n\tcase NILFS_IFILE_INO:\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\t/* Fall through */\n\tdefault:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VM;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tbreak;\n\t}\n\n\treturn (bmap->b_u.u_flags & NILFS_BMAP_LARGE) ?\n\t\tnilfs_btree_init(bmap) : nilfs_direct_init(bmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&root->inodes_count"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_create_inode",
          "args": [
            "root->ifile",
            "&ino",
            "&ii->i_bh"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "65-92",
          "snippet": "int nilfs_ifile_create_inode(struct inode *ifile, ino_t *out_ino,\n\t\t\t     struct buffer_head **out_bh)\n{\n\tstruct nilfs_palloc_req req;\n\tint ret;\n\n\treq.pr_entry_nr = 0;  /* 0 says find free inode from beginning of\n\t\t\t\t a group. dull code!! */\n\treq.pr_entry_bh = NULL;\n\n\tret = nilfs_palloc_prepare_alloc_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 1,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_alloc_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\tnilfs_palloc_commit_alloc_entry(ifile, &req);\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tnilfs_mdt_mark_dirty(ifile);\n\t*out_ino = (ino_t)req.pr_entry_nr;\n\t*out_bh = req.pr_entry_bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_create_inode(struct inode *ifile, ino_t *out_ino,\n\t\t\t     struct buffer_head **out_bh)\n{\n\tstruct nilfs_palloc_req req;\n\tint ret;\n\n\treq.pr_entry_nr = 0;  /* 0 says find free inode from beginning of\n\t\t\t\t a group. dull code!! */\n\treq.pr_entry_bh = NULL;\n\n\tret = nilfs_palloc_prepare_alloc_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 1,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_alloc_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\tnilfs_palloc_commit_alloc_entry(ifile, &req);\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tnilfs_mdt_mark_dirty(ifile);\n\t*out_ino = (ino_t)req.pr_entry_nr;\n\t*out_bh = req.pr_entry_bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_root *root;\n\tint err = -ENOMEM;\n\tino_t ino;\n\n\tinode = new_inode(sb);\n\tif (unlikely(!inode))\n\t\tgoto failed;\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n\n\troot = NILFS_I(dir)->i_root;\n\tii = NILFS_I(inode);\n\tii->i_state = 1 << NILFS_I_NEW;\n\tii->i_root = root;\n\n\terr = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);\n\tif (unlikely(err))\n\t\tgoto failed_ifile_create_inode;\n\t/* reference count of i_bh inherits from nilfs_mdt_read_block() */\n\n\tatomic64_inc(&root->inodes_count);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = ino;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, NULL);\n\t\tif (err < 0)\n\t\t\tgoto failed_after_creation;\n\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\n\tii->i_flags = nilfs_mask_flags(\n\t\tmode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);\n\n\t/* ii->i_file_acl = 0; */\n\t/* ii->i_dir_acl = 0; */\n\tii->i_dir_start_lookup = 0;\n\tnilfs_set_inode_flags(inode);\n\tspin_lock(&nilfs->ns_next_gen_lock);\n\tinode->i_generation = nilfs->ns_next_generation++;\n\tspin_unlock(&nilfs->ns_next_gen_lock);\n\tif (nilfs_insert_inode_locked(inode, root, ino) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed_after_creation;\n\t}\n\n\terr = nilfs_init_acl(inode, dir);\n\tif (unlikely(err))\n\t\tgoto failed_after_creation; /* never occur. When supporting\n\t\t\t\t    nilfs_init_acl(), proper cancellation of\n\t\t\t\t    above jobs should be considered */\n\n\treturn inode;\n\n failed_after_creation:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);  /* raw_inode will be deleted through\n\t\t\t nilfs_evict_inode() */\n\tgoto failed;\n\n failed_ifile_create_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);  /* if i_nlink == 1, generic_forget_inode() will be\n\t\t\t called */\n failed:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "nilfs_insert_inode_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "353-362",
    "snippet": "static int nilfs_insert_inode_locked(struct inode *inode,\n\t\t\t\t     struct nilfs_root *root,\n\t\t\t\t     unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn insert_inode_locked4(inode, ino, nilfs_iget_test, &args);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_inode_locked4",
          "args": [
            "inode",
            "ino",
            "nilfs_iget_test",
            "&args"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1365-1405",
          "snippet": "int insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_insert_inode_locked(struct inode *inode,\n\t\t\t\t     struct nilfs_root *root,\n\t\t\t\t     unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn insert_inode_locked4(inode, ino, nilfs_iget_test, &args);\n}"
  },
  {
    "function_name": "nilfs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "307-337",
    "snippet": "static ssize_t\nnilfs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t size;\n\n\tif (rw == WRITE)\n\t\treturn 0;\n\n\t/* Needs synchronization with the cleaner */\n\tsize = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t  nilfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && size < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\tnilfs_write_failed(mapping, end);\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_write_failed",
          "args": [
            "mapping",
            "end"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "259-267",
          "snippet": "void nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && size < 0"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "nilfs_get_block"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic ssize_t\nnilfs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t size;\n\n\tif (rw == WRITE)\n\t\treturn 0;\n\n\t/* Needs synchronization with the cleaner */\n\tsize = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t  nilfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && size < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\tnilfs_write_failed(mapping, end);\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "nilfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "289-305",
    "snippet": "static int nilfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned nr_dirty;\n\tint err;\n\n\tnr_dirty = nilfs_page_count_clean_buffers(page, start,\n\t\t\t\t\t\t  start + copied);\n\tcopied = generic_write_end(file, mapping, pos, len, copied, page,\n\t\t\t\t   fsdata);\n\tnilfs_set_file_dirty(inode, nr_dirty);\n\terr = nilfs_transaction_commit(inode->i_sb);\n\treturn err ? : copied;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_file_dirty",
          "args": [
            "inode",
            "nr_dirty"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_file_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "927-957",
          "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_count_clean_buffers",
          "args": [
            "page",
            "start",
            "start + copied"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_count_clean_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "447-462",
          "snippet": "unsigned nilfs_page_count_clean_buffers(struct page *page,\n\t\t\t\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tstruct buffer_head *bh, *head;\n\tunsigned nc = 0;\n\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (block_end > from && block_start < to && !buffer_dirty(bh))\n\t\t\tnc++;\n\t}\n\treturn nc;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nunsigned nilfs_page_count_clean_buffers(struct page *page,\n\t\t\t\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tstruct buffer_head *bh, *head;\n\tunsigned nc = 0;\n\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (block_end > from && block_start < to && !buffer_dirty(bh))\n\t\t\tnc++;\n\t}\n\treturn nc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned nr_dirty;\n\tint err;\n\n\tnr_dirty = nilfs_page_count_clean_buffers(page, start,\n\t\t\t\t\t\t  start + copied);\n\tcopied = generic_write_end(file, mapping, pos, len, copied, page,\n\t\t\t\t   fsdata);\n\tnilfs_set_file_dirty(inode, nr_dirty);\n\terr = nilfs_transaction_commit(inode->i_sb);\n\treturn err ? : copied;\n}"
  },
  {
    "function_name": "nilfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "269-287",
    "snippet": "static int nilfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n\n{\n\tstruct inode *inode = mapping->host;\n\tint err = nilfs_transaction_begin(inode->i_sb, NULL, 1);\n\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tnilfs_get_block);\n\tif (unlikely(err)) {\n\t\tnilfs_write_failed(mapping, pos + len);\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "259-267",
          "snippet": "void nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "nilfs_get_block"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "NULL",
            "1"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n\n{\n\tstruct inode *inode = mapping->host;\n\tint err = nilfs_transaction_begin(inode->i_sb, NULL, 1);\n\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tnilfs_get_block);\n\tif (unlikely(err)) {\n\t\tnilfs_write_failed(mapping, pos + len);\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "259-267",
    "snippet": "void nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_truncate",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "745-775",
          "snippet": "void nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0); /* never fails */\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t/* May construct a logical segment and may fail in sync mode.\n\t   But truncate has no return value. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "nilfs_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "223-257",
    "snippet": "static int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_set_file_dirty",
          "args": [
            "inode",
            "nr_dirty"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_file_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "927-957",
          "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "193-221",
    "snippet": "static int nilfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\t/*\n\t\t * It means that filesystem was remounted in read-only\n\t\t * mode because of error or metadata corruption. But we\n\t\t * have dirty pages that try to be flushed in background.\n\t\t * So, here we simply discard this dirty page.\n\t\t */\n\t\tnilfs_clear_dirty_page(page, false);\n\t\tunlock_page(page);\n\t\treturn -EROFS;\n\t}\n\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\terr = nilfs_construct_segment(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t} else if (wbc->for_reclaim)\n\t\tnilfs_flush_segment(inode->i_sb, inode->i_ino);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_flush_segment",
          "args": [
            "inode->i_sb",
            "inode->i_ino"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_flush_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2078-2087",
          "snippet": "void nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nvoid nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "inode->i_sb"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_clear_dirty_page",
          "args": [
            "page",
            "false"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "406-445",
          "snippet": "void nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\t/*\n\t\t * It means that filesystem was remounted in read-only\n\t\t * mode because of error or metadata corruption. But we\n\t\t * have dirty pages that try to be flushed in background.\n\t\t * So, here we simply discard this dirty page.\n\t\t */\n\t\tnilfs_clear_dirty_page(page, false);\n\t\tunlock_page(page);\n\t\treturn -EROFS;\n\t}\n\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\terr = nilfs_construct_segment(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t} else if (wbc->for_reclaim)\n\t\tnilfs_flush_segment(inode->i_sb, inode->i_ino);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "175-191",
    "snippet": "static int nilfs_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tint err = 0;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\tnilfs_clear_dirty_pages(mapping, false);\n\t\treturn -EROFS;\n\t}\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t    wbc->range_start,\n\t\t\t\t\t\t    wbc->range_end);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_construct_dsync_segment",
          "args": [
            "inode->i_sb",
            "inode",
            "wbc->range_start",
            "wbc->range_end"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_dsync_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2205-2247",
          "snippet": "int nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_dirty_pages",
          "args": [
            "mapping",
            "false"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "379-399",
          "snippet": "void nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tint err = 0;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\tnilfs_clear_dirty_pages(mapping, false);\n\t\treturn -EROFS;\n\t}\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t    wbc->range_start,\n\t\t\t\t\t\t    wbc->range_end);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "169-173",
    "snippet": "static int nilfs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, nilfs_get_block);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "nilfs_get_block"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, nilfs_get_block);\n}"
  },
  {
    "function_name": "nilfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "156-159",
    "snippet": "static int nilfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, nilfs_get_block);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "nilfs_get_block"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, nilfs_get_block);\n}"
  },
  {
    "function_name": "nilfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "83-148",
    "snippet": "int nilfs_get_block(struct inode *inode, sector_t blkoff,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 blknum = 0;\n\tint err = 0, ret;\n\tunsigned maxblocks = bh_result->b_size >> inode->i_blkbits;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tret = nilfs_bmap_lookup_contig(ii->i_bmap, blkoff, &blknum, maxblocks);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tif (ret >= 0) {\t/* found */\n\t\tmap_bh(bh_result, inode->i_sb, blknum);\n\t\tif (ret > 0)\n\t\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tgoto out;\n\t}\n\t/* data block was not found */\n\tif (ret == -ENOENT && create) {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tbh_result->b_blocknr = 0;\n\t\terr = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\terr = nilfs_bmap_insert(ii->i_bmap, (unsigned long)blkoff,\n\t\t\t\t\t(unsigned long)bh_result);\n\t\tif (unlikely(err != 0)) {\n\t\t\tif (err == -EEXIST) {\n\t\t\t\t/*\n\t\t\t\t * The get_block() function could be called\n\t\t\t\t * from multiple callers for an inode.\n\t\t\t\t * However, the page having this block must\n\t\t\t\t * be locked in this case.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"nilfs_get_block: a race condition \"\n\t\t\t\t       \"while inserting a data block. \"\n\t\t\t\t       \"(inode number=%lu, file block \"\n\t\t\t\t       \"offset=%llu)\\n\",\n\t\t\t\t       inode->i_ino,\n\t\t\t\t       (unsigned long long)blkoff);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tnilfs_transaction_abort(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\t\tnilfs_mark_inode_dirty_sync(inode);\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\t\t/* Error handling should be detailed */\n\t\tset_buffer_new(bh_result);\n\t\tset_buffer_delay(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, 0); /* dbn must be changed\n\t\t\t\t\t\t      to proper value */\n\t} else if (ret == -ENOENT) {\n\t\t/* not found is not error (e.g. hole); must return without\n\t\t   the mapped state flag. */\n\t\t;\n\t} else {\n\t\terr = ret;\n\t}\n\n out:\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_delay",
          "args": [
            "bh_result"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t       \"nilfs_get_block: a race condition \"\n\t\t\t\t       \"while inserting a data block. \"\n\t\t\t\t       \"(inode number=%lu, file block \"\n\t\t\t\t       \"offset=%llu)\\n\"",
            "inode->i_ino",
            "(unsigned long long)blkoff"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != 0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_insert",
          "args": [
            "ii->i_bmap",
            "(unsigned long)blkoff",
            "(unsigned long)bh_result"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "155-166",
          "snippet": "int nilfs_bmap_insert(struct nilfs_bmap *bmap,\n\t\t      unsigned long key,\n\t\t      unsigned long rec)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_insert(bmap, key, rec);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_insert(struct nilfs_bmap *bmap,\n\t\t      unsigned long key,\n\t\t      unsigned long rec)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_insert(bmap, key, rec);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "1"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "blknum"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup_contig",
          "args": [
            "ii->i_bmap",
            "blkoff",
            "&blknum",
            "maxblocks"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "99-109",
          "snippet": "int nilfs_bmap_lookup_contig(struct nilfs_bmap *bmap, __u64 key, __u64 *ptrp,\n\t\t\t     unsigned maxblocks)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup_contig(bmap, key, ptrp, maxblocks);\n\tup_read(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_lookup_contig(struct nilfs_bmap *bmap, __u64 key, __u64 *ptrp,\n\t\t\t     unsigned maxblocks)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup_contig(bmap, key, ptrp, maxblocks);\n\tup_read(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_get_block(struct inode *inode, sector_t blkoff,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 blknum = 0;\n\tint err = 0, ret;\n\tunsigned maxblocks = bh_result->b_size >> inode->i_blkbits;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tret = nilfs_bmap_lookup_contig(ii->i_bmap, blkoff, &blknum, maxblocks);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tif (ret >= 0) {\t/* found */\n\t\tmap_bh(bh_result, inode->i_sb, blknum);\n\t\tif (ret > 0)\n\t\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tgoto out;\n\t}\n\t/* data block was not found */\n\tif (ret == -ENOENT && create) {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tbh_result->b_blocknr = 0;\n\t\terr = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\terr = nilfs_bmap_insert(ii->i_bmap, (unsigned long)blkoff,\n\t\t\t\t\t(unsigned long)bh_result);\n\t\tif (unlikely(err != 0)) {\n\t\t\tif (err == -EEXIST) {\n\t\t\t\t/*\n\t\t\t\t * The get_block() function could be called\n\t\t\t\t * from multiple callers for an inode.\n\t\t\t\t * However, the page having this block must\n\t\t\t\t * be locked in this case.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"nilfs_get_block: a race condition \"\n\t\t\t\t       \"while inserting a data block. \"\n\t\t\t\t       \"(inode number=%lu, file block \"\n\t\t\t\t       \"offset=%llu)\\n\",\n\t\t\t\t       inode->i_ino,\n\t\t\t\t       (unsigned long long)blkoff);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tnilfs_transaction_abort(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\t\tnilfs_mark_inode_dirty_sync(inode);\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\t\t/* Error handling should be detailed */\n\t\tset_buffer_new(bh_result);\n\t\tset_buffer_delay(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, 0); /* dbn must be changed\n\t\t\t\t\t\t      to proper value */\n\t} else if (ret == -ENOENT) {\n\t\t/* not found is not error (e.g. hole); must return without\n\t\t   the mapped state flag. */\n\t\t;\n\t} else {\n\t\terr = ret;\n\t}\n\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_inode_sub_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "63-70",
    "snippet": "void nilfs_inode_sub_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_sub_bytes(inode, (1 << inode->i_blkbits) * n);\n\tif (root)\n\t\tatomic64_sub(n, &root->blocks_count);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_sub",
          "args": [
            "n",
            "&root->blocks_count"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_sub_bytes",
          "args": [
            "inode",
            "(1 << inode->i_blkbits) * n"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sub_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "482-487",
          "snippet": "void inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_inode_sub_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_sub_bytes(inode, (1 << inode->i_blkbits) * n);\n\tif (root)\n\t\tatomic64_sub(n, &root->blocks_count);\n}"
  },
  {
    "function_name": "nilfs_inode_add_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
    "lines": "54-61",
    "snippet": "void nilfs_inode_add_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_add_bytes(inode, (1 << inode->i_blkbits) * n);\n\tif (root)\n\t\tatomic64_add(n, &root->blocks_count);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "n",
            "&root->blocks_count"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "(1 << inode->i_blkbits) * n"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_inode_add_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_add_bytes(inode, (1 << inode->i_blkbits) * n);\n\tif (root)\n\t\tatomic64_add(n, &root->blocks_count);\n}"
  }
]