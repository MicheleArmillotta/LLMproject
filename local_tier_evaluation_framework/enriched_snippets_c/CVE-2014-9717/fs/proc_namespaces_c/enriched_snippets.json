[
  {
    "function_name": "proc_ns_dir_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
    "lines": "138-166",
    "snippet": "static struct dentry *proc_ns_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct proc_ns_operations **entry, **last;\n\tunsigned int len = dentry->d_name.len;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries)];\n\tfor (entry = ns_entries; entry < last; entry++) {\n\t\tif (strlen((*entry)->name) != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, (*entry)->name, len))\n\t\t\tbreak;\n\t}\n\tif (entry == last)\n\t\tgoto out;\n\n\terror = proc_ns_instantiate(dir, dentry, task, *entry);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct proc_ns_operations *ns_entries[] = {\n#ifdef CONFIG_NET_NS\n\t&netns_operations,\n#endif\n#ifdef CONFIG_UTS_NS\n\t&utsns_operations,\n#endif\n#ifdef CONFIG_IPC_NS\n\t&ipcns_operations,\n#endif\n#ifdef CONFIG_PID_NS\n\t&pidns_operations,\n#endif\n#ifdef CONFIG_USER_NS\n\t&userns_operations,\n#endif\n\t&mntns_operations,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_ns_instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "*entry"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "proc_ns_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
          "lines": "81-104",
          "snippet": "static int proc_ns_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct proc_ns_operations *ns_ops = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = S_IFLNK|S_IRWXUGO;\n\tinode->i_op = &proc_ns_link_inode_operations;\n\tei->ns_ops = ns_ops;\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_ns_link_inode_operations = {\n\t.readlink\t= proc_ns_readlink,\n\t.follow_link\t= proc_ns_follow_link,\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic const struct inode_operations proc_ns_link_inode_operations = {\n\t.readlink\t= proc_ns_readlink,\n\t.follow_link\t= proc_ns_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_ns_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct proc_ns_operations *ns_ops = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = S_IFLNK|S_IRWXUGO;\n\tinode->i_op = &proc_ns_link_inode_operations;\n\tei->ns_ops = ns_ops;\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dentry->d_name.name",
            "(*entry)->name",
            "len"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(*entry)->name"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ns_entries"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dir"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic const struct proc_ns_operations *ns_entries[] = {\n#ifdef CONFIG_NET_NS\n\t&netns_operations,\n#endif\n#ifdef CONFIG_UTS_NS\n\t&utsns_operations,\n#endif\n#ifdef CONFIG_IPC_NS\n\t&ipcns_operations,\n#endif\n#ifdef CONFIG_PID_NS\n\t&pidns_operations,\n#endif\n#ifdef CONFIG_USER_NS\n\t&userns_operations,\n#endif\n\t&mntns_operations,\n};\n\nstatic struct dentry *proc_ns_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct proc_ns_operations **entry, **last;\n\tunsigned int len = dentry->d_name.len;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries)];\n\tfor (entry = ns_entries; entry < last; entry++) {\n\t\tif (strlen((*entry)->name) != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, (*entry)->name, len))\n\t\t\tbreak;\n\t}\n\tif (entry == last)\n\t\tgoto out;\n\n\terror = proc_ns_instantiate(dir, dentry, task, *entry);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "proc_ns_dir_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
    "lines": "106-131",
    "snippet": "static int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct proc_ns_operations **entry, **last;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tif (ctx->pos >= 2 + ARRAY_SIZE(ns_entries))\n\t\tgoto out;\n\tentry = ns_entries + (ctx->pos - 2);\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\n\twhile (entry <= last) {\n\t\tconst struct proc_ns_operations *ops = *entry;\n\t\tif (!proc_fill_cache(file, ctx, ops->name, strlen(ops->name),\n\t\t\t\t     proc_ns_instantiate, task, ops))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t\tentry++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct proc_ns_operations *ns_entries[] = {\n#ifdef CONFIG_NET_NS\n\t&netns_operations,\n#endif\n#ifdef CONFIG_UTS_NS\n\t&utsns_operations,\n#endif\n#ifdef CONFIG_IPC_NS\n\t&ipcns_operations,\n#endif\n#ifdef CONFIG_PID_NS\n\t&pidns_operations,\n#endif\n#ifdef CONFIG_USER_NS\n\t&userns_operations,\n#endif\n\t&mntns_operations,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "ops->name",
            "strlen(ops->name)",
            "proc_ns_instantiate",
            "task",
            "ops"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ops->name"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ns_entries"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ns_entries"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic const struct proc_ns_operations *ns_entries[] = {\n#ifdef CONFIG_NET_NS\n\t&netns_operations,\n#endif\n#ifdef CONFIG_UTS_NS\n\t&utsns_operations,\n#endif\n#ifdef CONFIG_IPC_NS\n\t&ipcns_operations,\n#endif\n#ifdef CONFIG_PID_NS\n\t&pidns_operations,\n#endif\n#ifdef CONFIG_USER_NS\n\t&userns_operations,\n#endif\n\t&mntns_operations,\n};\n\nstatic int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct proc_ns_operations **entry, **last;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tif (ctx->pos >= 2 + ARRAY_SIZE(ns_entries))\n\t\tgoto out;\n\tentry = ns_entries + (ctx->pos - 2);\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\n\twhile (entry <= last) {\n\t\tconst struct proc_ns_operations *ops = *entry;\n\t\tif (!proc_fill_cache(file, ctx, ops->name, strlen(ops->name),\n\t\t\t\t     proc_ns_instantiate, task, ops))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t\tentry++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_ns_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
    "lines": "81-104",
    "snippet": "static int proc_ns_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct proc_ns_operations *ns_ops = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = S_IFLNK|S_IRWXUGO;\n\tinode->i_op = &proc_ns_link_inode_operations;\n\tei->ns_ops = ns_ops;\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations proc_ns_link_inode_operations = {\n\t.readlink\t= proc_ns_readlink,\n\t.follow_link\t= proc_ns_follow_link,\n\t.setattr\t= proc_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "pid_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1539-1569",
          "snippet": "int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&pid_dentry_operations"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic const struct inode_operations proc_ns_link_inode_operations = {\n\t.readlink\t= proc_ns_readlink,\n\t.follow_link\t= proc_ns_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_ns_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct proc_ns_operations *ns_ops = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = S_IFLNK|S_IRWXUGO;\n\tinode->i_op = &proc_ns_link_inode_operations;\n\tei->ns_ops = ns_ops;\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_ns_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
    "lines": "54-73",
    "snippet": "static int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tchar name[50];\n\tint res = -EACCES;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn res;\n\n\tif (ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tres = ns_get_name(name, sizeof(name), task, ns_ops);\n\t\tif (res >= 0)\n\t\t\tres = readlink_copy(buffer, buflen, name);\n\t}\n\tput_task_struct(task);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink_copy",
          "args": [
            "buffer",
            "buflen",
            "name"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "readlink_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4409-4422",
          "snippet": "int readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_get_name",
          "args": [
            "name",
            "sizeof(name)",
            "task",
            "ns_ops"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ns_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nsfs.c",
          "lines": "108-119",
          "snippet": "int ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tres = snprintf(buf, size, \"%s:[%u]\", ns_ops->name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tres = snprintf(buf, size, \"%s:[%u]\", ns_ops->name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tchar name[50];\n\tint res = -EACCES;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn res;\n\n\tif (ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tres = ns_get_name(name, sizeof(name), task, ns_ops);\n\t\tif (res >= 0)\n\t\t\tres = readlink_copy(buffer, buflen, name);\n\t}\n\tput_task_struct(task);\n\treturn res;\n}"
  },
  {
    "function_name": "proc_ns_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/namespaces.c",
    "lines": "33-52",
    "snippet": "static void *proc_ns_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tstruct path ns_path;\n\tvoid *error = ERR_PTR(-EACCES);\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn error;\n\n\tif (ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\terror = ns_get_path(&ns_path, task, ns_ops);\n\t\tif (!error)\n\t\t\tnd_jump_link(nd, &ns_path);\n\t}\n\tput_task_struct(task);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_jump_link",
          "args": [
            "nd",
            "&ns_path"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "nd_jump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "708-715",
          "snippet": "void nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_get_path",
          "args": [
            "&ns_path",
            "task",
            "ns_ops"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ns_get_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nsfs.c",
          "lines": "46-106",
          "snippet": "void *ns_get_path(struct path *path, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct vfsmount *mnt = mntget(nsfs_mnt);\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct ns_common *ns;\n\tunsigned long d;\n\nagain:\n\tns = ns_ops->get(task);\n\tif (!ns) {\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns_ops->put(ns);\ngot_it:\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns_ops->put(ns);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns_ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\tgoto got_it;\n}",
          "includes": [
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *nsfs_mnt;",
            "static const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct vfsmount *nsfs_mnt;\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n};\n\nvoid *ns_get_path(struct path *path, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct vfsmount *mnt = mntget(nsfs_mnt);\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct ns_common *ns;\n\tunsigned long d;\n\nagain:\n\tns = ns_ops->get(task);\n\tif (!ns) {\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns_ops->put(ns);\ngot_it:\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns_ops->put(ns);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns_ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\tgoto got_it;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/utsname.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_fs.h>\n\nstatic void *proc_ns_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tstruct path ns_path;\n\tvoid *error = ERR_PTR(-EACCES);\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn error;\n\n\tif (ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\terror = ns_get_path(&ns_path, task, ns_ops);\n\t\tif (!error)\n\t\t\tnd_jump_link(nd, &ns_path);\n\t}\n\tput_task_struct(task);\n\treturn error;\n}"
  }
]