[
  {
    "function_name": "nfs4_fl_prepare_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "261-290",
    "snippet": "struct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
      "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filelayout_test_devid_unavailable",
          "args": [
            "devid"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "filelayout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.c",
          "lines": "266-271",
          "snippet": "bool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs4trace.h\"",
            "#include \"filelayout.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs4trace.h\"\n#include \"filelayout.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn filelayout_test_devid_invalid(node) ||\n\t\tnfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_connect",
          "args": [
            "s",
            "ds",
            "devid",
            "dataserver_timeo",
            "dataserver_retrans",
            "4",
            "s->nfs_client->cl_minorversion",
            "s->nfs_client->cl_rpcclient->cl_auth->au_flavor"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "664-691",
          "snippet": "void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nvoid nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_mark_devid_invalid",
          "args": [
            "devid"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_mark_devid_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "419-423",
          "snippet": "static inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: No data server for offset index %d\\n\"",
            "__func__",
            "ds_idx"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lseg->pls_layout->plh_inode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_DEVID_NODE",
          "args": [
            "lseg"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "88-92",
          "snippet": "static inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFILELAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg)\n{\n\treturn &FILELAYOUT_LSEG(lseg)->dsaddr->id_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\tstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\n\tstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\n\tstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\n\tstruct nfs4_pnfs_ds *ret = ds;\n\tstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\n\n\tif (ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\tgoto out;\n\t}\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out_test_devid;\n\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans, 4,\n\t\t\t     s->nfs_client->cl_minorversion,\n\t\t\t     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);\n\nout_test_devid:\n\tif (filelayout_test_devid_unavailable(devid))\n\t\tret = NULL;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_fl_select_ds_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "241-258",
    "snippet": "struct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_fl_calc_ds_index",
          "args": [
            "lseg",
            "j"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_calc_ds_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "235-239",
          "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu32 i;\n\n\tif (flseg->stripe_type == STRIPE_SPARSE) {\n\t\tif (flseg->num_fh == 1)\n\t\t\ti = 0;\n\t\telse if (flseg->num_fh == 0)\n\t\t\t/* Use the MDS OPEN fh set in nfs_read_rpcsetup */\n\t\t\treturn NULL;\n\t\telse\n\t\t\ti = nfs4_fl_calc_ds_index(lseg, j);\n\t} else\n\t\ti = j;\n\treturn flseg->fh_array[i];\n}"
  },
  {
    "function_name": "nfs4_fl_calc_ds_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "235-239",
    "snippet": "u32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\n{\n\treturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\n}"
  },
  {
    "function_name": "nfs4_fl_calc_j_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "223-233",
    "snippet": "u32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "flseg->dsaddr->stripe_count"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "flseg->stripe_unit"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILELAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "FILELAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayout.h",
          "lines": "80-86",
          "snippet": "static inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_filelayout_segment *\nFILELAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_filelayout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nu32\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\n{\n\tstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\n\tu64 tmp;\n\n\ttmp = offset - flseg->pattern_offset;\n\tdo_div(tmp, flseg->stripe_unit);\n\ttmp += flseg->first_stripe_index;\n\treturn do_div(tmp, flseg->dsaddr->stripe_count);\n}"
  },
  {
    "function_name": "nfs4_fl_put_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "213-217",
    "snippet": "void\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "&dsaddr->id_node"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tnfs4_put_deviceid_node(&dsaddr->id_node);\n}"
  },
  {
    "function_name": "nfs4_fl_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "62-211",
    "snippet": "struct nfs4_file_layout_dsaddr *\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_flags)\n{\n\tint i;\n\tu32 cnt, num;\n\tu8 *indexp;\n\t__be32 *p;\n\tu8 *stripe_indices;\n\tu8 max_stripe_index;\n\tstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* Get the stripe count (number of stripe index) */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_scratch;\n\n\tcnt = be32_to_cpup(p);\n\tdprintk(\"%s stripe count  %d\\n\", __func__, cnt);\n\tif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe count %d greater than \"\n\t\t       \"supported maximum %d\\n\", __func__,\n\t\t\tcnt, NFS4_PNFS_MAX_STRIPE_CNT);\n\t\tgoto out_err_free_scratch;\n\t}\n\n\t/* read stripe indices */\n\tstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\n\tif (!stripe_indices)\n\t\tgoto out_err_free_scratch;\n\n\tp = xdr_inline_decode(&stream, cnt << 2);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tindexp = &stripe_indices[0];\n\tmax_stripe_index = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\t*indexp = be32_to_cpup(p++);\n\t\tmax_stripe_index = max(max_stripe_index, *indexp);\n\t\tindexp++;\n\t}\n\n\t/* Check the multipath list count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tnum = be32_to_cpup(p);\n\tdprintk(\"%s ds_num %u\\n\", __func__, num);\n\tif (num > NFS4_PNFS_MAX_MULTI_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: multipath count %d greater than \"\n\t\t\t\"supported maximum %d\\n\", __func__,\n\t\t\tnum, NFS4_PNFS_MAX_MULTI_CNT);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\t/* validate stripe indices are all < num */\n\tif (max_stripe_index >= num) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\",\n\t\t\t__func__, max_stripe_index, num);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\tdsaddr = kzalloc(sizeof(*dsaddr) +\n\t\t\t(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\n\t\t\tgfp_flags);\n\tif (!dsaddr)\n\t\tgoto out_err_free_stripe_indices;\n\n\tdsaddr->stripe_count = cnt;\n\tdsaddr->stripe_indices = stripe_indices;\n\tstripe_indices = NULL;\n\tdsaddr->ds_num = num;\n\tnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\n\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tint j;\n\t\tu32 mp_count;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free_deviceid;\n\n\t\tmp_count = be32_to_cpup(p); /* multipath count */\n\t\tfor (j = 0; j < mp_count; j++) {\n\t\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t\t    &stream, gfp_flags);\n\t\t\tif (da)\n\t\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t\t}\n\t\tif (list_empty(&dsaddrs)) {\n\t\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out_err_free_deviceid;\n\t\t}\n\n\t\tdsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\t\tif (!dsaddr->ds_list[i])\n\t\t\tgoto out_err_drain_dsaddrs;\n\n\t\t/* If DS was already in cache, free ds addrs */\n\t\twhile (!list_empty(&dsaddrs)) {\n\t\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t\t      da_node);\n\t\t\tlist_del_init(&da->da_node);\n\t\t\tkfree(da->da_remotestr);\n\t\t\tkfree(da);\n\t\t}\n\t}\n\n\t__free_page(scratch);\n\treturn dsaddr;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\nout_err_free_deviceid:\n\tnfs4_fl_free_deviceid(dsaddr);\n\t/* stripe_indicies was part of dsaddr */\n\tgoto out_err_free_scratch;\nout_err_free_stripe_indices:\n\tkfree(stripe_indices);\nout_err_free_scratch:\n\t__free_page(scratch);\nout_err:\n\tdprintk(\"%s ERROR: returning NULL\\n\", __func__);\n\treturn NULL;\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ERROR: returning NULL\\n\"",
            "__func__"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stripe_indices"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_fl_free_deviceid",
          "args": [
            "dsaddr"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_fl_free_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
          "lines": "44-59",
          "snippet": "void\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\n\tnfs4_print_deviceid(&dsaddr->id_node.deviceid);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tds = dsaddr->ds_list[i];\n\t\tif (ds != NULL)\n\t\t\tnfs4_pnfs_ds_put(ds);\n\t}\n\tkfree(dsaddr->stripe_indices);\n\tkfree(dsaddr);\n}",
          "includes": [
            "#include \"filelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\n\tnfs4_print_deviceid(&dsaddr->id_node.deviceid);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tds = dsaddr->ds_list[i];\n\t\tif (ds != NULL)\n\t\t\tnfs4_pnfs_ds_put(ds);\n\t}\n\tkfree(dsaddr->stripe_indices);\n\tkfree(dsaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da->da_remotestr"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&da->da_node"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dsaddrs",
            "structnfs4_pnfs_ds_addr",
            "da_node"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dsaddrs"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da->da_remotestr"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&da->da_node"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dsaddrs",
            "structnfs4_pnfs_ds_addr",
            "da_node"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_add",
          "args": [
            "&dsaddrs",
            "gfp_flags"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "485-527",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);",
            "static LIST_HEAD(nfs4_data_server_cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\nstatic LIST_HEAD(nfs4_data_server_cache);\n\nstruct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: no suitable DS addresses found\\n\"",
            "__func__"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&da->da_node",
            "&dsaddrs"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_decode_mp_ds_addr",
          "args": [
            "server->nfs_client->cl_net",
            "&stream",
            "gfp_flags"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_decode_mp_ds_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "697-839",
          "snippet": "struct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dsaddrs"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_deviceid_node",
          "args": [
            "&dsaddr->id_node",
            "server",
            "&pdev->dev_id"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "247-258",
          "snippet": "void\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dsaddr) +\n\t\t\t(sizeof(struct nfs4_pnfs_ds *) * (num - 1))",
            "gfp_flags"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\"",
            "__func__",
            "max_stripe_index",
            "num"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ds_num %u\\n\"",
            "__func__",
            "num"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_stripe_index",
            "*indexp"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "cnt << 2"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cnt",
            "sizeof(u8)",
            "gfp_flags"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s stripe count  %d\\n\"",
            "__func__",
            "cnt"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&stream",
            "&buf",
            "pdev->pages",
            "pdev->pglen"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_file_layout_dsaddr *\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_flags)\n{\n\tint i;\n\tu32 cnt, num;\n\tu8 *indexp;\n\t__be32 *p;\n\tu8 *stripe_indices;\n\tu8 max_stripe_index;\n\tstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* Get the stripe count (number of stripe index) */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_scratch;\n\n\tcnt = be32_to_cpup(p);\n\tdprintk(\"%s stripe count  %d\\n\", __func__, cnt);\n\tif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe count %d greater than \"\n\t\t       \"supported maximum %d\\n\", __func__,\n\t\t\tcnt, NFS4_PNFS_MAX_STRIPE_CNT);\n\t\tgoto out_err_free_scratch;\n\t}\n\n\t/* read stripe indices */\n\tstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\n\tif (!stripe_indices)\n\t\tgoto out_err_free_scratch;\n\n\tp = xdr_inline_decode(&stream, cnt << 2);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tindexp = &stripe_indices[0];\n\tmax_stripe_index = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\t*indexp = be32_to_cpup(p++);\n\t\tmax_stripe_index = max(max_stripe_index, *indexp);\n\t\tindexp++;\n\t}\n\n\t/* Check the multipath list count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_free_stripe_indices;\n\n\tnum = be32_to_cpup(p);\n\tdprintk(\"%s ds_num %u\\n\", __func__, num);\n\tif (num > NFS4_PNFS_MAX_MULTI_CNT) {\n\t\tprintk(KERN_WARNING \"NFS: %s: multipath count %d greater than \"\n\t\t\t\"supported maximum %d\\n\", __func__,\n\t\t\tnum, NFS4_PNFS_MAX_MULTI_CNT);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\t/* validate stripe indices are all < num */\n\tif (max_stripe_index >= num) {\n\t\tprintk(KERN_WARNING \"NFS: %s: stripe index %u >= num ds %u\\n\",\n\t\t\t__func__, max_stripe_index, num);\n\t\tgoto out_err_free_stripe_indices;\n\t}\n\n\tdsaddr = kzalloc(sizeof(*dsaddr) +\n\t\t\t(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\n\t\t\tgfp_flags);\n\tif (!dsaddr)\n\t\tgoto out_err_free_stripe_indices;\n\n\tdsaddr->stripe_count = cnt;\n\tdsaddr->stripe_indices = stripe_indices;\n\tstripe_indices = NULL;\n\tdsaddr->ds_num = num;\n\tnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\n\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tint j;\n\t\tu32 mp_count;\n\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_free_deviceid;\n\n\t\tmp_count = be32_to_cpup(p); /* multipath count */\n\t\tfor (j = 0; j < mp_count; j++) {\n\t\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t\t    &stream, gfp_flags);\n\t\t\tif (da)\n\t\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t\t}\n\t\tif (list_empty(&dsaddrs)) {\n\t\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out_err_free_deviceid;\n\t\t}\n\n\t\tdsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\t\tif (!dsaddr->ds_list[i])\n\t\t\tgoto out_err_drain_dsaddrs;\n\n\t\t/* If DS was already in cache, free ds addrs */\n\t\twhile (!list_empty(&dsaddrs)) {\n\t\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t\t      da_node);\n\t\t\tlist_del_init(&da->da_node);\n\t\t\tkfree(da->da_remotestr);\n\t\t\tkfree(da);\n\t\t}\n\t}\n\n\t__free_page(scratch);\n\treturn dsaddr;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\nout_err_free_deviceid:\n\tnfs4_fl_free_deviceid(dsaddr);\n\t/* stripe_indicies was part of dsaddr */\n\tgoto out_err_free_scratch;\nout_err_free_stripe_indices:\n\tkfree(stripe_indices);\nout_err_free_scratch:\n\t__free_page(scratch);\nout_err:\n\tdprintk(\"%s ERROR: returning NULL\\n\", __func__);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_fl_free_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/filelayout/filelayoutdev.c",
    "lines": "44-59",
    "snippet": "void\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\n\tnfs4_print_deviceid(&dsaddr->id_node.deviceid);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tds = dsaddr->ds_list[i];\n\t\tif (ds != NULL)\n\t\t\tnfs4_pnfs_ds_put(ds);\n\t}\n\tkfree(dsaddr->stripe_indices);\n\tkfree(dsaddr);\n}",
    "includes": [
      "#include \"filelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dsaddr"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dsaddr->stripe_indices"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_put",
          "args": [
            "ds"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "421-429",
          "snippet": "void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\n\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_print_deviceid",
          "args": [
            "&dsaddr->id_node.deviceid"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_print_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "520-522",
          "snippet": "static inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\n\tnfs4_print_deviceid(&dsaddr->id_node.deviceid);\n\n\tfor (i = 0; i < dsaddr->ds_num; i++) {\n\t\tds = dsaddr->ds_list[i];\n\t\tif (ds != NULL)\n\t\t\tnfs4_pnfs_ds_put(ds);\n\t}\n\tkfree(dsaddr->stripe_indices);\n\tkfree(dsaddr);\n}"
  }
]