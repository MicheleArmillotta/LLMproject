[
  {
    "function_name": "cifs_get_spnego_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_spnego.c",
    "lines": "95-179",
    "snippet": "struct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifs_spnego.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [
      "#define PID_KEY_LEN\t\t7",
      "#define USER_KEY_LEN\t\t6",
      "#define CREDUID_KEY_LEN\t\t11",
      "#define UID_KEY_LEN\t\t7",
      "#define IP_KEY_LEN\t\t5",
      "#define HOST_KEY_LEN\t\t5",
      "#define MAX_MECH_STR_LEN\t13",
      "#define MAX_VER_STR_LEN\t\t8"
    ],
    "globals_used": [
      "struct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "description"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dump_mem",
          "args": [
            "\"SPNEGO reply blob:\"",
            "msg->data",
            "min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dump_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "34-40",
          "snippet": "void\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dump_mem(char *label, void *data, int length)\n{\n\tpr_debug(\"%s: dump of %d bytes of data at 0x%p\\n\", label, length, data);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       data, length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "1024U",
            "msg->secblob_len + msg->sesskey_len"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "spnego_key"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&cifs_spnego_key_type",
            "description",
            "\"\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"key description = %s\\n\"",
            "description"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\";pid=0x%x\"",
            "current->pid"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "description"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\";user=%s\"",
            "sesInfo->user_name"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\";creduid=0x%x\"",
            "from_kuid_munged(&init_user_ns, sesInfo->cred_uid)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "sesInfo->cred_uid"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\";uid=0x%x\"",
            "from_kuid_munged(&init_user_ns, sesInfo->linux_uid)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "sesInfo->linux_uid"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\";sec=mskrb5\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sprintf_disk_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "154-158",
          "snippet": "static void sprintf_disk_child(char *buf, struct disk_child *dc)\n{\n\tsprintf(buf, \"[dc_number=%d, dc_size=%u]\", dc_block_number(dc),\n\t\tdc_size(dc));\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void sprintf_disk_child(char *buf, struct disk_child *dc)\n{\n\tsprintf(buf, \"[dc_number=%d, dc_size=%u]\", dc_block_number(dc),\n\t\tdc_size(dc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"ip6=%pI6\"",
            "&sa6->sin6_addr"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"ip4=%pI4\"",
            "&sa->sin_addr"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"ver=0x%x;host=%s;\"",
            "CIFS_SPNEGO_UPCALL_VERSION",
            "hostname"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "desc_len",
            "GFP_KERNEL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifs_spnego.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#define PID_KEY_LEN\t\t7\n#define USER_KEY_LEN\t\t6\n#define CREDUID_KEY_LEN\t\t11\n#define UID_KEY_LEN\t\t7\n#define IP_KEY_LEN\t\t5\n#define HOST_KEY_LEN\t\t5\n#define MAX_MECH_STR_LEN\t13\n#define MAX_VER_STR_LEN\t\t8\n\nstruct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};\n\nstruct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}"
  },
  {
    "function_name": "cifs_spnego_key_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_spnego.c",
    "lines": "52-56",
    "snippet": "static void\ncifs_spnego_key_destroy(struct key *key)\n{\n\tkfree(key->payload.data);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifs_spnego.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key->payload.data"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifs_spnego.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\nstatic void\ncifs_spnego_key_destroy(struct key *key)\n{\n\tkfree(key->payload.data);\n}"
  },
  {
    "function_name": "cifs_spnego_key_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_spnego.c",
    "lines": "33-50",
    "snippet": "static int\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\tgoto error;\n\n\t/* attach the data */\n\tkey->payload.data = payload;\n\tret = 0;\n\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifs_spnego.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "prep->data",
            "prep->datalen",
            "GFP_KERNEL"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifs_spnego.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\nstatic int\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\tgoto error;\n\n\t/* attach the data */\n\tkey->payload.data = payload;\n\tret = 0;\n\nerror:\n\treturn ret;\n}"
  }
]