[
  {
    "function_name": "nfsd4_block_decode_layoutupdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
    "lines": "91-157",
    "snippet": "int\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * NFS4_BLOCK_EXTENT_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset %lld\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"blocklayoutxdr.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfs4.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iomaps"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: incorrect extent state %d\\n\"",
            "__func__",
            "bex.es"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unaligned disk offset %lld\\n\"",
            "__func__",
            "bex.soff"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&bex.soff"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unaligned length %lld\\n\"",
            "__func__",
            "bex.foff"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&bex.len"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unaligned offset %lld\\n\"",
            "__func__",
            "bex.foff"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&bex.foff"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "sizeof(struct nfsd4_deviceid)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bex.vol_id",
            "p",
            "sizeof(struct nfsd4_deviceid)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: failed to allocate extent array\\n\"",
            "__func__"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_iomaps",
            "sizeof(*iomaps)",
            "GFP_KERNEL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: extent array size mismatch: %u/%u\\n\"",
            "__func__",
            "len",
            "expected"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: extent array too small: %u\\n\"",
            "__func__",
            "len"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nint\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * NFS4_BLOCK_EXTENT_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset %lld\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "nfsd4_block_encode_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
    "lines": "63-89",
    "snippet": "__be32\nnfsd4_block_encode_getdeviceinfo(struct xdr_stream *xdr,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev = gdp->gd_device;\n\tint len = sizeof(__be32), ret, i;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + sizeof(__be32));\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tfor (i = 0; i < dev->nr_volumes; i++) {\n\t\tret = nfsd4_block_encode_volume(xdr, &dev->volumes[i]);\n\t\tif (ret < 0)\n\t\t\treturn nfserrno(ret);\n\t\tlen += ret;\n\t}\n\n\t/*\n\t * Fill in the overall length and number of volumes at the beginning\n\t * of the layout.\n\t */\n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(dev->nr_volumes);\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayoutxdr.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfs4.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dev->nr_volumes"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "ret"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_block_encode_volume",
          "args": [
            "xdr",
            "&dev->volumes[i]"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_encode_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
          "lines": "38-61",
          "snippet": "static int\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint len;\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tlen = 4 + 4 + 8 + 4 + b->simple.sig_len;\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(1);\t/* single signature */\n\t\tp = xdr_encode_hyper(p, b->simple.offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"blocklayoutxdr.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfs4.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint len;\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tlen = 4 + 4 + 8 + 4 + b->simple.sig_len;\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(1);\t/* single signature */\n\t\tp = xdr_encode_hyper(p, b->simple.offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + sizeof(__be32)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\n__be32\nnfsd4_block_encode_getdeviceinfo(struct xdr_stream *xdr,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev = gdp->gd_device;\n\tint len = sizeof(__be32), ret, i;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + sizeof(__be32));\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tfor (i = 0; i < dev->nr_volumes; i++) {\n\t\tret = nfsd4_block_encode_volume(xdr, &dev->volumes[i]);\n\t\tif (ret < 0)\n\t\t\treturn nfserrno(ret);\n\t\tlen += ret;\n\t}\n\n\t/*\n\t * Fill in the overall length and number of volumes at the beginning\n\t * of the layout.\n\t */\n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(dev->nr_volumes);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_block_encode_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
    "lines": "38-61",
    "snippet": "static int\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint len;\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tlen = 4 + 4 + 8 + 4 + b->simple.sig_len;\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(1);\t/* single signature */\n\t\tp = xdr_encode_hyper(p, b->simple.offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"blocklayoutxdr.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfs4.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "b->simple.sig",
            "b->simple.sig_len"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "b->simple.offset"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "b->type"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint len;\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tlen = 4 + 4 + 8 + 4 + b->simple.sig_len;\n\t\tp = xdr_reserve_space(xdr, len);\n\t\tif (!p)\n\t\t\treturn -ETOOSMALL;\n\n\t\t*p++ = cpu_to_be32(b->type);\n\t\t*p++ = cpu_to_be32(1);\t/* single signature */\n\t\tp = xdr_encode_hyper(p, b->simple.offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "nfsd4_block_encode_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
    "lines": "14-36",
    "snippet": "__be32\nnfsd4_block_encode_layoutget(struct xdr_stream *xdr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct pnfs_block_extent *b = lgp->lg_content;\n\tint len = sizeof(__be32) + 5 * sizeof(__be64) + sizeof(__be32);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(__be32) + len);\n\tif (!p)\n\t\treturn nfserr_toosmall;\n\n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(1);\t\t/* we always return a single extent */\n\n\tp = xdr_encode_opaque_fixed(p, &b->vol_id,\n\t\t\tsizeof(struct nfsd4_deviceid));\n\tp = xdr_encode_hyper(p, b->foff);\n\tp = xdr_encode_hyper(p, b->len);\n\tp = xdr_encode_hyper(p, b->soff);\n\t*p++ = cpu_to_be32(b->es);\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayoutxdr.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfs4.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "b->es"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "b->soff"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "b->len"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "b->foff"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&b->vol_id",
            "sizeof(struct nfsd4_deviceid)"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "sizeof(__be32) + len"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\n__be32\nnfsd4_block_encode_layoutget(struct xdr_stream *xdr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct pnfs_block_extent *b = lgp->lg_content;\n\tint len = sizeof(__be32) + 5 * sizeof(__be64) + sizeof(__be32);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(__be32) + len);\n\tif (!p)\n\t\treturn nfserr_toosmall;\n\n\t*p++ = cpu_to_be32(len);\n\t*p++ = cpu_to_be32(1);\t\t/* we always return a single extent */\n\n\tp = xdr_encode_opaque_fixed(p, &b->vol_id,\n\t\t\tsizeof(struct nfsd4_deviceid));\n\tp = xdr_encode_hyper(p, b->foff);\n\tp = xdr_encode_hyper(p, b->len);\n\tp = xdr_encode_hyper(p, b->soff);\n\t*p++ = cpu_to_be32(b->es);\n\treturn 0;\n}"
  }
]