[
  {
    "function_name": "xfs_mru_cache_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "546-552",
    "snippet": "void\nxfs_mru_cache_done(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock)\n{\n\tspin_unlock(&mru->lock);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "mru->lock"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_done(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock)\n{\n\tspin_unlock(&mru->lock);\n}"
  },
  {
    "function_name": "xfs_mru_cache_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "518-539",
    "snippet": "struct xfs_mru_cache_elem *\nxfs_mru_cache_lookup(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_lookup(&mru->store, key);\n\tif (elem) {\n\t\tlist_del(&elem->list_node);\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\t\t__release(mru_lock); /* help sparse not be stupid */\n\t} else\n\t\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "mru_lock"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_list_insert",
          "args": [
            "mru",
            "elem"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "200-227",
          "snippet": "STATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct\t*xfs_mru_reap_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nSTATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&elem->list_node"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&mru->store",
            "key"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mru && mru->lists"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstruct xfs_mru_cache_elem *\nxfs_mru_cache_lookup(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_lookup(&mru->store, key);\n\tif (elem) {\n\t\tlist_del(&elem->list_node);\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\t\t__release(mru_lock); /* help sparse not be stupid */\n\t} else\n\t\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}"
  },
  {
    "function_name": "xfs_mru_cache_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "486-496",
    "snippet": "void\nxfs_mru_cache_delete(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\telem = xfs_mru_cache_remove(mru, key);\n\tif (elem)\n\t\tmru->free_func(elem);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mru->free_func",
          "args": [
            "elem"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_remove",
          "args": [
            "mru",
            "key"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "462-480",
          "snippet": "struct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstruct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_delete(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\telem = xfs_mru_cache_remove(mru, key);\n\tif (elem)\n\t\tmru->free_func(elem);\n}"
  },
  {
    "function_name": "xfs_mru_cache_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "462-480",
    "snippet": "struct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&elem->list_node"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&mru->store",
            "key"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mru && mru->lists"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstruct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}"
  },
  {
    "function_name": "xfs_mru_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "428-454",
    "snippet": "int\nxfs_mru_cache_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tint\t\t\terror;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn -EINVAL;\n\n\tif (radix_tree_preload(GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&elem->list_node);\n\telem->key = key;\n\n\tspin_lock(&mru->lock);\n\terror = radix_tree_insert(&mru->store, key, elem);\n\tradix_tree_preload_end();\n\tif (!error)\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\tspin_unlock(&mru->lock);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_list_insert",
          "args": [
            "mru",
            "elem"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_list_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "200-227",
          "snippet": "STATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct\t*xfs_mru_reap_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nSTATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&mru->store",
            "key",
            "elem"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&elem->list_node"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mru && mru->lists"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nint\nxfs_mru_cache_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tint\t\t\terror;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn -EINVAL;\n\n\tif (radix_tree_preload(GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&elem->list_node);\n\telem->key = key;\n\n\tspin_lock(&mru->lock);\n\terror = radix_tree_insert(&mru->store, key, elem);\n\tradix_tree_preload_end();\n\tif (!error)\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\tspin_unlock(&mru->lock);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_mru_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "410-421",
    "snippet": "void\nxfs_mru_cache_destroy(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\txfs_mru_cache_flush(mru);\n\n\tkmem_free(mru->lists);\n\tkmem_free(mru);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mru"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_flush",
          "args": [
            "mru"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "390-408",
          "snippet": "static void\nxfs_mru_cache_flush(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tif (mru->queued) {\n\t\tspin_unlock(&mru->lock);\n\t\tcancel_delayed_work_sync(&mru->work);\n\t\tspin_lock(&mru->lock);\n\t}\n\n\t_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tspin_unlock(&mru->lock);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_mru_cache_flush(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tif (mru->queued) {\n\t\tspin_unlock(&mru->lock);\n\t\tcancel_delayed_work_sync(&mru->work);\n\t\tspin_lock(&mru->lock);\n\t}\n\n\t_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tspin_unlock(&mru->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_destroy(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\txfs_mru_cache_flush(mru);\n\n\tkmem_free(mru->lists);\n\tkmem_free(mru);\n}"
  },
  {
    "function_name": "xfs_mru_cache_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "390-408",
    "snippet": "static void\nxfs_mru_cache_flush(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tif (mru->queued) {\n\t\tspin_unlock(&mru->lock);\n\t\tcancel_delayed_work_sync(&mru->work);\n\t\tspin_lock(&mru->lock);\n\t}\n\n\t_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tspin_unlock(&mru->lock);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_clear_reap_list",
          "args": [
            "mru"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_clear_reap_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "238-266",
          "snippet": "STATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_migrate",
          "args": [
            "mru",
            "jiffies + mru->grp_count * mru->grp_time"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "136-192",
          "snippet": "STATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mru->work"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_mru_cache_flush(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tif (mru->queued) {\n\t\tspin_unlock(&mru->lock);\n\t\tcancel_delayed_work_sync(&mru->work);\n\t\tspin_lock(&mru->lock);\n\t}\n\n\t_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tspin_unlock(&mru->lock);\n}"
  },
  {
    "function_name": "xfs_mru_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "326-382",
    "snippet": "int\nxfs_mru_cache_create(\n\tstruct xfs_mru_cache\t**mrup,\n\tunsigned int\t\tlifetime_ms,\n\tunsigned int\t\tgrp_count,\n\txfs_mru_cache_free_func_t free_func)\n{\n\tstruct xfs_mru_cache\t*mru = NULL;\n\tint\t\t\terr = 0, grp;\n\tunsigned int\t\tgrp_time;\n\n\tif (mrup)\n\t\t*mrup = NULL;\n\n\tif (!mrup || !grp_count || !lifetime_ms || !free_func)\n\t\treturn -EINVAL;\n\n\tif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\n\t\treturn -EINVAL;\n\n\tif (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))\n\t\treturn -ENOMEM;\n\n\t/* An extra list is needed to avoid reaping up to a grp_time early. */\n\tmru->grp_count = grp_count + 1;\n\tmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);\n\n\tif (!mru->lists) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor (grp = 0; grp < mru->grp_count; grp++)\n\t\tINIT_LIST_HEAD(mru->lists + grp);\n\n\t/*\n\t * We use GFP_KERNEL radix tree preload and do inserts under a\n\t * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.\n\t */\n\tINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&mru->reap_list);\n\tspin_lock_init(&mru->lock);\n\tINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\n\n\tmru->grp_time  = grp_time;\n\tmru->free_func = free_func;\n\n\t*mrup = mru;\n\nexit:\n\tif (err && mru && mru->lists)\n\t\tkmem_free(mru->lists);\n\tif (err && mru)\n\t\tkmem_free(mru);\n\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mru"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&mru->work",
            "_xfs_mru_cache_reap"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mru->lock"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mru->reap_list"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&mru->store",
            "GFP_ATOMIC"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "mru->lists + grp"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "mru->grp_count * sizeof(*mru->lists)",
            "KM_SLEEP"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "lifetime_ms"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nint\nxfs_mru_cache_create(\n\tstruct xfs_mru_cache\t**mrup,\n\tunsigned int\t\tlifetime_ms,\n\tunsigned int\t\tgrp_count,\n\txfs_mru_cache_free_func_t free_func)\n{\n\tstruct xfs_mru_cache\t*mru = NULL;\n\tint\t\t\terr = 0, grp;\n\tunsigned int\t\tgrp_time;\n\n\tif (mrup)\n\t\t*mrup = NULL;\n\n\tif (!mrup || !grp_count || !lifetime_ms || !free_func)\n\t\treturn -EINVAL;\n\n\tif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\n\t\treturn -EINVAL;\n\n\tif (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))\n\t\treturn -ENOMEM;\n\n\t/* An extra list is needed to avoid reaping up to a grp_time early. */\n\tmru->grp_count = grp_count + 1;\n\tmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);\n\n\tif (!mru->lists) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor (grp = 0; grp < mru->grp_count; grp++)\n\t\tINIT_LIST_HEAD(mru->lists + grp);\n\n\t/*\n\t * We use GFP_KERNEL radix tree preload and do inserts under a\n\t * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.\n\t */\n\tINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&mru->reap_list);\n\tspin_lock_init(&mru->lock);\n\tINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\n\n\tmru->grp_time  = grp_time;\n\tmru->free_func = free_func;\n\n\t*mrup = mru;\n\nexit:\n\tif (err && mru && mru->lists)\n\t\tkmem_free(mru->lists);\n\tif (err && mru)\n\t\tkmem_free(mru);\n\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_mru_cache_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "314-318",
    "snippet": "void\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct\t*xfs_mru_reap_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "xfs_mru_reap_wq"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nvoid\nxfs_mru_cache_uninit(void)\n{\n\tdestroy_workqueue(xfs_mru_reap_wq);\n}"
  },
  {
    "function_name": "xfs_mru_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "304-312",
    "snippet": "int\nxfs_mru_cache_init(void)\n{\n\txfs_mru_reap_wq = alloc_workqueue(\"xfs_mru_cache\",\n\t\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1);\n\tif (!xfs_mru_reap_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct\t*xfs_mru_reap_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"xfs_mru_cache\"",
            "WQ_MEM_RECLAIM|WQ_FREEZABLE",
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nint\nxfs_mru_cache_init(void)\n{\n\txfs_mru_reap_wq = alloc_workqueue(\"xfs_mru_cache\",\n\t\t\t\tWQ_MEM_RECLAIM|WQ_FREEZABLE, 1);\n\tif (!xfs_mru_reap_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "_xfs_mru_cache_reap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "275-302",
    "snippet": "STATIC void\n_xfs_mru_cache_reap(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_mru_cache\t*mru =\n\t\tcontainer_of(work, struct xfs_mru_cache, work.work);\n\tunsigned long\t\tnow, next;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tnext = _xfs_mru_cache_migrate(mru, jiffies);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tmru->queued = next;\n\tif ((mru->queued > 0)) {\n\t\tnow = jiffies;\n\t\tif (next <= now)\n\t\t\tnext = 0;\n\t\telse\n\t\t\tnext -= now;\n\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work, next);\n\t}\n\n\tspin_unlock(&mru->lock);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct\t*xfs_mru_reap_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "xfs_mru_reap_wq",
            "&mru->work",
            "next"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_clear_reap_list",
          "args": [
            "mru"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_clear_reap_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "238-266",
          "snippet": "STATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_migrate",
          "args": [
            "mru",
            "jiffies"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "136-192",
          "snippet": "STATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mru && mru->lists"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structxfs_mru_cache",
            "work.work"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nSTATIC void\n_xfs_mru_cache_reap(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_mru_cache\t*mru =\n\t\tcontainer_of(work, struct xfs_mru_cache, work.work);\n\tunsigned long\t\tnow, next;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\tspin_lock(&mru->lock);\n\tnext = _xfs_mru_cache_migrate(mru, jiffies);\n\t_xfs_mru_cache_clear_reap_list(mru);\n\n\tmru->queued = next;\n\tif ((mru->queued > 0)) {\n\t\tnow = jiffies;\n\t\tif (next <= now)\n\t\t\tnext = 0;\n\t\telse\n\t\t\tnext -= now;\n\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work, next);\n\t}\n\n\tspin_unlock(&mru->lock);\n}"
  },
  {
    "function_name": "_xfs_mru_cache_clear_reap_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "238-266",
    "snippet": "STATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mru->lock"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mru->free_func",
          "args": [
            "elem"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&elem->list_node"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "elem",
            "next",
            "&tmp",
            "list_node"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mru->lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&elem->list_node",
            "&tmp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&mru->store",
            "elem->key"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "elem",
            "next",
            "&mru->reap_list",
            "list_node"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "mru->lock"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "mru->lock"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_mru_cache_clear_reap_list(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock) __acquires(mru->lock)\n{\n\tstruct xfs_mru_cache_elem *elem, *next;\n\tstruct list_head\ttmp;\n\n\tINIT_LIST_HEAD(&tmp);\n\tlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\n\n\t\t/* Remove the element from the data store. */\n\t\tradix_tree_delete(&mru->store, elem->key);\n\n\t\t/*\n\t\t * remove to temp list so it can be freed without\n\t\t * needing to hold the lock\n\t\t */\n\t\tlist_move(&elem->list_node, &tmp);\n\t}\n\tspin_unlock(&mru->lock);\n\n\tlist_for_each_entry_safe(elem, next, &tmp, list_node) {\n\t\tlist_del_init(&elem->list_node);\n\t\tmru->free_func(elem);\n\t}\n\n\tspin_lock(&mru->lock);\n}"
  },
  {
    "function_name": "_xfs_mru_cache_list_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "200-227",
    "snippet": "STATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct\t*xfs_mru_reap_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&elem->list_node",
            "mru->lists + grp"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "xfs_mru_reap_wq",
            "&mru->work",
            "mru->grp_count * mru->grp_time"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_mru_cache_migrate",
          "args": [
            "mru",
            "now"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_mru_cache_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "136-192",
          "snippet": "STATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstatic struct workqueue_struct\t*xfs_mru_reap_wq;\n\nSTATIC void\n_xfs_mru_cache_list_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tunsigned int\t\tgrp = 0;\n\tunsigned long\t\tnow = jiffies;\n\n\t/*\n\t * If the data store is empty, initialise time zero, leave grp set to\n\t * zero and start the work queue timer if necessary.  Otherwise, set grp\n\t * to the number of group times that have elapsed since time zero.\n\t */\n\tif (!_xfs_mru_cache_migrate(mru, now)) {\n\t\tmru->time_zero = now;\n\t\tif (!mru->queued) {\n\t\t\tmru->queued = 1;\n\t\t\tqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\n\t\t\t                   mru->grp_count * mru->grp_time);\n\t\t}\n\t} else {\n\t\tgrp = (now - mru->time_zero) / mru->grp_time;\n\t\tgrp = (mru->lru_grp + grp) % mru->grp_count;\n\t}\n\n\t/* Insert the element at the tail of the corresponding list. */\n\tlist_add_tail(&elem->list_node, mru->lists + grp);\n}"
  },
  {
    "function_name": "_xfs_mru_cache_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
    "lines": "136-192",
    "snippet": "STATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "lru_list"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "lru_list",
            "mru->reap_list.prev"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned long\n_xfs_mru_cache_migrate(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tnow)\n{\n\tunsigned int\t\tgrp;\n\tunsigned int\t\tmigrated = 0;\n\tstruct list_head\t*lru_list;\n\n\t/* Nothing to do if the data store is empty. */\n\tif (!mru->time_zero)\n\t\treturn 0;\n\n\t/* While time zero is older than the time spanned by all the lists. */\n\twhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\n\n\t\t/*\n\t\t * If the LRU list isn't empty, migrate its elements to the tail\n\t\t * of the reap list.\n\t\t */\n\t\tlru_list = mru->lists + mru->lru_grp;\n\t\tif (!list_empty(lru_list))\n\t\t\tlist_splice_init(lru_list, mru->reap_list.prev);\n\n\t\t/*\n\t\t * Advance the LRU group number, freeing the old LRU list to\n\t\t * become the new MRU list; advance time zero accordingly.\n\t\t */\n\t\tmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\n\t\tmru->time_zero += mru->grp_time;\n\n\t\t/*\n\t\t * If reaping is so far behind that all the elements on all the\n\t\t * lists have been migrated to the reap list, it's now empty.\n\t\t */\n\t\tif (++migrated == mru->grp_count) {\n\t\t\tmru->lru_grp = 0;\n\t\t\tmru->time_zero = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Find the first non-empty list from the LRU end. */\n\tfor (grp = 0; grp < mru->grp_count; grp++) {\n\n\t\t/* Check the grp'th list from the LRU end. */\n\t\tlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\n\t\tif (!list_empty(lru_list))\n\t\t\treturn mru->time_zero +\n\t\t\t       (mru->grp_count + grp) * mru->grp_time;\n\t}\n\n\t/* All the lists must be empty. */\n\tmru->lru_grp = 0;\n\tmru->time_zero = 0;\n\treturn 0;\n}"
  }
]