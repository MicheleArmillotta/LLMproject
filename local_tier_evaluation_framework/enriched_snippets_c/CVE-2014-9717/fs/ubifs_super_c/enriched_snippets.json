[
  {
    "function_name": "id)\n{\n\tubi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2277-2293",
    "snippet": "_exit ubifs_exit(void)\n{\n\tubifs_assert(list_empty(&ubifs_infos));\n\tubifs_assert(atomic_long_read(&ubifs_clean_zn_cnt) == 0);\n\n\tdbg_debugfs_exit();\n\tubifs_compressors_exit();\n\tunregister_shrinker(&ubifs_shrinker_info);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ubifs_inode_slab);\n\tunregister_filesystem(&ubifs_fs_type);\n}\nmodule_exit(",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "shrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali",
      "file_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lesystem(&ubifs_fs_ty",
          "args": [
            "e);\n}\nmodule_e"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(ubifs_inode_",
          "args": [
            "lab);\n\tunregiste"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tkmem_cac",
          "args": [],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rinker(&ubifs_shrin",
          "args": [
            "er_info);\n\n\t/*\n\t * M"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sors_exit();\n\tunregist",
          "args": [],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit();\n\tubifs_co",
          "args": [],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_",
          "args": [
            "ead(&ubifs_clean_zn_cnt) == 0);\n\n\tdbg_debu"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&ubifs_clean",
          "args": [
            "zn_cnt) == 0);\n\n\tdb"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty(&",
          "args": [
            "bifs_infos));\n\tubifs_ass"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_infos",
          "args": [
            ");\n\tubifs_as"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nshrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali;\nfile_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS;\n\n_exit ubifs_exit(void)\n{\n\tubifs_assert(list_empty(&ubifs_infos));\n\tubifs_assert(atomic_long_read(&ubifs_clean_zn_cnt) == 0);\n\n\tdbg_debugfs_exit();\n\tubifs_compressors_exit();\n\tunregister_shrinker(&ubifs_shrinker_info);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ubifs_inode_slab);\n\tunregister_filesystem(&ubifs_fs_type);\n}\nmodule_exit("
  },
  {
    "function_name": "id)\n{\n\tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2180-2273",
    "snippet": "init ubifs_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct ubifs_ch) != 24);\n\n\t/* Make sure node sizes are 8-byte aligned */\n\tBUILD_BUG_ON(UBIFS_CH_SZ        & 7);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_CS_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_ORPH_NODE_SZ & 7);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_NODE_SZ      & 7);\n\tBUILD_BUG_ON(MIN_WRITE_SZ           & 7);\n\n\t/* Check min. node size */\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ < MIN_WRITE_SZ);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  > UBIFS_MAX_NODE_SZ);\n\n\t/* Defined node sizes */\n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ  != 4096);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ != 512);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ != 160);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ != 64);\n\n\t/*\n\t * We use 2 bit wide bit-fields to store compression type, which should\n\t * be amended if more compressors are added. The bit-fields are:\n\t * @compr_type in 'struct ubifs_inode', @default_compr in\n\t * 'struct ubifs_info' and @compr_type in 'struct ubifs_mount_opts'.\n\t */\n\tBUILD_BUG_ON(UBIFS_COMPR_TYPES_CNT > 4);\n\n\t/*\n\t * We require that PAGE_CACHE_SIZE is greater-than-or-equal-to\n\t * UBIFS_BLOCK_SIZE. It is assumed that both are powers of 2.\n\t */\n\tif (PAGE_CACHE_SIZE < UBIFS_BLOCK_SIZE) {\n\t\tubifs_err(\"VFS page cache size is %u bytes, but UBIFS requires at least 4096 bytes\",\n\t\t\t  (unsigned int)PAGE_CACHE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tubifs_inode_slab = kmem_cache_create(\"ubifs_inode_slab\",\n\t\t\t\tsizeof(struct ubifs_inode), 0,\n\t\t\t\tSLAB_MEM_SPREAD | SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t&inode_slab_ctor);\n\tif (!ubifs_inode_slab)\n\t\treturn -ENOMEM;\n\n\tregister_shrinker(&ubifs_shrinker_info);\n\n\terr = ubifs_compressors_init();\n\tif (err)\n\t\tgoto out_shrinker;\n\n\terr = dbg_debugfs_init();\n\tif (err)\n\t\tgoto out_compr;\n\n\terr = register_filesystem(&ubifs_fs_type);\n\tif (err) {\n\t\tubifs_err(\"cannot register file system, error %d\", err);\n\t\tgoto out_dbg;\n\t}\n\treturn 0;\n\nout_dbg:\n\tdbg_debugfs_exit();\nout_compr:\n\tubifs_compressors_exit();\nout_shrinker:\n\tunregister_shrinker(&ubifs_shrinker_info);\n\tkmem_cache_destroy(ubifs_inode_slab);\n\treturn err;\n}\n/* late_init",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "shrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali",
      "file_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stroy(ubifs_inode_",
          "args": [
            "lab);\n\treturn er"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rinker(&ubifs_shrin",
          "args": [
            "er_info);\n\tkmem_cach"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sors_exit();\nout_shrin",
          "args": [],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit();\nout_compr",
          "args": [],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot regi",
          "args": [
            "ter file system, error %d\", err);\n\t\tgot",
            "out"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system(&ubifs_fs_ty",
          "args": [
            "e);\n\tif (err)"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit();\n\tif (err)",
          "args": [],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sors_init();\n\tif (err)",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nker(&ubifs_shrin",
          "args": [
            "er_info);\n\n\terr = ub"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eate(\"ubifs_inode",
          "args": [
            "slab\",\n\t\t\t\tsizeof(",
            "ubifs_inode), 0,\n\t\t\t\tSLAB",
            "E",
            "AD | SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t&inode_",
            "tor);\n\tif (!ubif"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S page ca",
          "args": [
            "he size is %u bytes, but UBIFS requires at least 4096 bytes\",\n\t\t\t  (unsig",
            ")PAGE_CACHE_SIZE);\n\t\treturn -"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_COMPR_",
          "args": [
            "YPES_CNT > 4);\n\n\t/*\n\t * W"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_REF_NO",
          "args": [
            "E_SZ != 64);\n\n\t/*\n\t * W"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_INO_NO",
          "args": [
            "E_SZ != 160);\n\tBUILD_BUG"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MST_NO",
          "args": [
            "E_SZ != 512);\n\tBUILD_BUG"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_SB_NOD",
          "args": [
            "_SZ  != 4096);\n\tBUILD_BUG"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_IN",
          "args": [
            "_NODE_SZ  > UBIFS_MAX_NODE_SZ);\n\n\t/* Defin"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_DA",
          "args": [
            "A_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_XE",
          "args": [
            "T_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_DE",
          "args": [
            "T_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_TRUN_N",
          "args": [
            "DE_SZ < MIN_WRITE_SZ);\n\n\tBUILD_BU"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_XENT_N",
          "args": [
            "DE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_DENT_N",
          "args": [
            "DE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_INO_NO",
          "args": [
            "E_SZ  < MIN_WRITE_SZ);\n\tBUILD_BUG"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN_WRITE_SZ",
          "args": [
            "& 7);\n\n\t/* Check"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_NO",
          "args": [
            "E_SZ      & 7);\n\tBUILD_BUG"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_IN",
          "args": [
            "_NODE_SZ  & 7);\n\tBUILD_BUG"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_DA",
          "args": [
            "A_NODE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_XE",
          "args": [
            "T_NODE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MAX_DE",
          "args": [
            "T_NODE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_ORPH_N",
          "args": [
            "DE_SZ & 7);\n\n\tBUILD_BU"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_CS_NOD",
          "args": [
            "_SZ   & 7);\n\tBUILD_BUG"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_REF_NO",
          "args": [
            "E_SZ  & 7);\n\tBUILD_BUG"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_MST_NO",
          "args": [
            "E_SZ  & 7);\n\tBUILD_BUG"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_SB_NOD",
          "args": [
            "_SZ   & 7);\n\tBUILD_BUG"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_TRUN_N",
          "args": [
            "DE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_DATA_N",
          "args": [
            "DE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_XENT_N",
          "args": [
            "DE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_DENT_N",
          "args": [
            "DE_SZ & 7);\n\tBUILD_BUG"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_INO_NO",
          "args": [
            "E_SZ  & 7);\n\tBUILD_BUG"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_CH_SZ",
          "args": [
            "& 7);\n\tBUILD_BUG"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof(struc",
          "args": [
            "ubifs_ch) != 24);\n\n\t/* Make"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nshrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali;\nfile_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS;\n\ninit ubifs_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct ubifs_ch) != 24);\n\n\t/* Make sure node sizes are 8-byte aligned */\n\tBUILD_BUG_ON(UBIFS_CH_SZ        & 7);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_CS_NODE_SZ   & 7);\n\tBUILD_BUG_ON(UBIFS_ORPH_NODE_SZ & 7);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  & 7);\n\tBUILD_BUG_ON(UBIFS_MAX_NODE_SZ      & 7);\n\tBUILD_BUG_ON(MIN_WRITE_SZ           & 7);\n\n\t/* Check min. node size */\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ  < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_DENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_XENT_NODE_SZ < MIN_WRITE_SZ);\n\tBUILD_BUG_ON(UBIFS_TRUN_NODE_SZ < MIN_WRITE_SZ);\n\n\tBUILD_BUG_ON(UBIFS_MAX_DENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_XENT_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_DATA_NODE_SZ > UBIFS_MAX_NODE_SZ);\n\tBUILD_BUG_ON(UBIFS_MAX_INO_NODE_SZ  > UBIFS_MAX_NODE_SZ);\n\n\t/* Defined node sizes */\n\tBUILD_BUG_ON(UBIFS_SB_NODE_SZ  != 4096);\n\tBUILD_BUG_ON(UBIFS_MST_NODE_SZ != 512);\n\tBUILD_BUG_ON(UBIFS_INO_NODE_SZ != 160);\n\tBUILD_BUG_ON(UBIFS_REF_NODE_SZ != 64);\n\n\t/*\n\t * We use 2 bit wide bit-fields to store compression type, which should\n\t * be amended if more compressors are added. The bit-fields are:\n\t * @compr_type in 'struct ubifs_inode', @default_compr in\n\t * 'struct ubifs_info' and @compr_type in 'struct ubifs_mount_opts'.\n\t */\n\tBUILD_BUG_ON(UBIFS_COMPR_TYPES_CNT > 4);\n\n\t/*\n\t * We require that PAGE_CACHE_SIZE is greater-than-or-equal-to\n\t * UBIFS_BLOCK_SIZE. It is assumed that both are powers of 2.\n\t */\n\tif (PAGE_CACHE_SIZE < UBIFS_BLOCK_SIZE) {\n\t\tubifs_err(\"VFS page cache size is %u bytes, but UBIFS requires at least 4096 bytes\",\n\t\t\t  (unsigned int)PAGE_CACHE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tubifs_inode_slab = kmem_cache_create(\"ubifs_inode_slab\",\n\t\t\t\tsizeof(struct ubifs_inode), 0,\n\t\t\t\tSLAB_MEM_SPREAD | SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t&inode_slab_ctor);\n\tif (!ubifs_inode_slab)\n\t\treturn -ENOMEM;\n\n\tregister_shrinker(&ubifs_shrinker_info);\n\n\terr = ubifs_compressors_init();\n\tif (err)\n\t\tgoto out_shrinker;\n\n\terr = dbg_debugfs_init();\n\tif (err)\n\t\tgoto out_compr;\n\n\terr = register_filesystem(&ubifs_fs_type);\n\tif (err) {\n\t\tubifs_err(\"cannot register file system, error %d\", err);\n\t\tgoto out_dbg;\n\t}\n\treturn 0;\n\nout_dbg:\n\tdbg_debugfs_exit();\nout_compr:\n\tubifs_compressors_exit();\nout_shrinker:\n\tunregister_shrinker(&ubifs_shrinker_info);\n\tkmem_cache_destroy(ubifs_inode_slab);\n\treturn err;\n}\n/* late_init"
  },
  {
    "function_name": "or(void *obj)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2174-2178",
    "snippet": "node_slab_ctor(void *obj)\n{\n\tstruct ubifs_inode *ui = obj;\n\tinode_init_once(&ui->vfs_inode);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ce(&ui->vfs_ino",
          "args": [
            "e);\n}\n\nstatic"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nnode_slab_ctor(void *obj)\n{\n\tstruct ubifs_inode *ui = obj;\n\tinode_init_once(&ui->vfs_inode);\n}\n\nstatic int"
  },
  {
    "function_name": "per(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2156-2161",
    "snippet": "ill_ubifs_super(struct super_block *s)\n{\n\tstruct ubifs_info *c = s->s_fs_info;\n\tkill_anon_super(s);\n\tkfree(c);\n}\n\nstatic stru",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er(s);\n\tkfree(c",
          "args": [
            ";"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nill_ubifs_super(struct super_block *s)\n{\n\tstruct ubifs_info *c = s->s_fs_info;\n\tkill_anon_super(s);\n\tkfree(c);\n}\n\nstatic stru"
  },
  {
    "function_name": "truct file_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2090-2154",
    "snippet": "dentry *ubifs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *name, void *data)\n{\n\tstruct ubi_volume_desc *ubi;\n\tstruct ubifs_info *c;\n\tstruct super_block *sb;\n\tint err;\n\n\tdbg_gen(\"name %s, flags %#x\", name, flags);\n\n\t/*\n\t * Get UBI device number and volume ID. Mount it read-only so far\n\t * because this might be a new mount point, and UBI allows only one\n\t * read-write user at a time.\n\t */\n\tubi = open_ubi(name, UBI_READONLY);\n\tif (IS_ERR(ubi)) {\n\t\tubifs_err(\"cannot open \\\"%s\\\", error %d\",\n\t\t\t  name, (int)PTR_ERR(ubi));\n\t\treturn ERR_CAST(ubi);\n\t}\n\n\tc = alloc_ubifs_info(ubi);\n\tif (!c) {\n\t\terr = -ENOMEM;\n\t\tgoto out_close;\n\t}\n\n\tdbg_gen(\"opened ubi%d_%d\", c->vi.ubi_num, c->vi.vol_id);\n\n\tsb = sget(fs_type, sb_test, sb_set, flags, c);\n\tif (IS_ERR(sb)) {\n\t\terr = PTR_ERR(sb);\n\t\tkfree(c);\n\t\tgoto out_close;\n\t}\n\n\tif (sb->s_root) {\n\t\tstruct ubifs_info *c1 = sb->s_fs_info;\n\t\tkfree(c);\n\t\t/* A new mount point for already mounted UBIFS */\n\t\tdbg_gen(\"this ubi volume is already mounted\");\n\t\tif (!!(flags & MS_RDONLY) != c1->ro_mount) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_deact;\n\t\t}\n\t} else {\n\t\terr = ubifs_fill_super(sb, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto out_deact;\n\t\t/* We do not support atime */\n\t\tsb->s_flags |= MS_ACTIVE | MS_NOATIME;\n\t}\n\n\t/* 'fill_super()' opens ubi again so we must close it here */\n\tubi_close_volume(ubi);\n\n\treturn dget(sb->s_root);\n\nout_deact:\n\tdeactivate_locked_super(sb);\nout_close:\n\tubi_close_volume(ubi);\n\treturn ERR_PTR(err);\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\nsta",
          "args": [
            "ic"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ume(ubi);\n\tretur",
          "args": [
            "ER"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cked_super(sb);\nout_clo",
          "args": [
            "e:"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ot);",
          "args": [
            "out_deact"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ume(ubi);\n\n\tretu",
          "args": [
            "n d"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per(sb, data, fl",
          "args": [
            "gs",
            "MS_",
            "LENT ? 1 : 0);\n\t\tif (err)"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubi vo",
          "args": [
            "ume is already mounted\");\n\t\tif (!!(f"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "* A n",
          "args": [
            "w"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oto o",
          "args": [
            "t"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c)"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_",
          "args": [
            "est, sb",
            "et, fla",
            ", c);",
            "f (IS",
            "R"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed ubi%",
          "args": [
            "_%d\", c->vi.ubi_n",
            ", c->vi.vol_i",
            ";\n\n\tsb = sge"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfo(ubi);\n\tif (!",
          "args": [
            ") {"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t}\n\n\tc",
          "args": [
            "= a"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot open",
          "args": [
            "\\\"%s\\\", error %d\",\n\t\t\t  name,",
            "R_ER",
            "ubi));\n\t\treturn E"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tret",
          "args": [
            "rn"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\tub",
          "args": [
            "fs_"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", UBI_RE",
          "args": [
            "DONL",
            ";\n\tif (IS_ER"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s, fl",
          "args": [
            "gs %#x\", name, flags",
            "/",
            "* G"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\ndentry *ubifs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *name, void *data)\n{\n\tstruct ubi_volume_desc *ubi;\n\tstruct ubifs_info *c;\n\tstruct super_block *sb;\n\tint err;\n\n\tdbg_gen(\"name %s, flags %#x\", name, flags);\n\n\t/*\n\t * Get UBI device number and volume ID. Mount it read-only so far\n\t * because this might be a new mount point, and UBI allows only one\n\t * read-write user at a time.\n\t */\n\tubi = open_ubi(name, UBI_READONLY);\n\tif (IS_ERR(ubi)) {\n\t\tubifs_err(\"cannot open \\\"%s\\\", error %d\",\n\t\t\t  name, (int)PTR_ERR(ubi));\n\t\treturn ERR_CAST(ubi);\n\t}\n\n\tc = alloc_ubifs_info(ubi);\n\tif (!c) {\n\t\terr = -ENOMEM;\n\t\tgoto out_close;\n\t}\n\n\tdbg_gen(\"opened ubi%d_%d\", c->vi.ubi_num, c->vi.vol_id);\n\n\tsb = sget(fs_type, sb_test, sb_set, flags, c);\n\tif (IS_ERR(sb)) {\n\t\terr = PTR_ERR(sb);\n\t\tkfree(c);\n\t\tgoto out_close;\n\t}\n\n\tif (sb->s_root) {\n\t\tstruct ubifs_info *c1 = sb->s_fs_info;\n\t\tkfree(c);\n\t\t/* A new mount point for already mounted UBIFS */\n\t\tdbg_gen(\"this ubi volume is already mounted\");\n\t\tif (!!(flags & MS_RDONLY) != c1->ro_mount) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_deact;\n\t\t}\n\t} else {\n\t\terr = ubifs_fill_super(sb, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto out_deact;\n\t\t/* We do not support atime */\n\t\tsb->s_flags |= MS_ACTIVE | MS_NOATIME;\n\t}\n\n\t/* 'fill_super()' opens ubi again so we must close it here */\n\tubi_close_volume(ubi);\n\n\treturn dget(sb->s_root);\n\nout_deact:\n\tdeactivate_locked_super(sb);\nout_close:\n\tubi_close_volume(ubi);\n\treturn ERR_PTR(err);\n}\n\nstatic void"
  },
  {
    "function_name": "super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2084-2088",
    "snippet": "_set(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}\n\nstatic stru",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(sb, NULL);\n}",
          "args": [
            "s",
            "tic"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\n_set(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}\n\nstatic stru"
  },
  {
    "function_name": "t super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "2076-2082",
    "snippet": "_test(struct super_block *sb, void *data)\n{\n\tstruct ubifs_info *c1 = data;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\treturn c->vi.cdev == c1->vi.cdev;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\n_test(struct super_block *sb, void *data)\n{\n\tstruct ubifs_info *c1 = data;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\treturn c->vi.cdev == c1->vi.cdev;\n}\n\nstatic int"
  },
  {
    "function_name": "per(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1994-2074",
    "snippet": "ifs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *root;\n\tint err;\n\n\tc->vfs_sb = sb;\n\t/* Re-open the UBI device in read-write mode */\n\tc->ubi = ubi_open_volume(c->vi.ubi_num, c->vi.vol_id, UBI_READWRITE);\n\tif (IS_ERR(c->ubi)) {\n\t\terr = PTR_ERR(c->ubi);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * UBIFS provides 'backing_dev_info' in order to disable read-ahead. For\n\t * UBIFS, I/O is not deferred, it is done immediately in readpage,\n\t * which means the user would have to wait not just for their own I/O\n\t * but the read-ahead I/O as well i.e. completely pointless.\n\t *\n\t * Read-ahead will be disabled because @c->bdi.ra_pages is 0.\n\t */\n\tc->bdi.name = \"ubifs\",\n\tc->bdi.capabilities = 0;\n\terr  = bdi_init(&c->bdi);\n\tif (err)\n\t\tgoto out_close;\n\terr = bdi_register(&c->bdi, NULL, \"ubifs_%d_%d\",\n\t\t\t   c->vi.ubi_num, c->vi.vol_id);\n\tif (err)\n\t\tgoto out_bdi;\n\n\terr = ubifs_parse_options(c, data, 0);\n\tif (err)\n\t\tgoto out_bdi;\n\n\tsb->s_bdi = &c->bdi;\n\tsb->s_fs_info = c;\n\tsb->s_magic = UBIFS_SUPER_MAGIC;\n\tsb->s_blocksize = UBIFS_BLOCK_SIZE;\n\tsb->s_blocksize_bits = UBIFS_BLOCK_SHIFT;\n\tsb->s_maxbytes = c->max_inode_sz = key_max_inode_size(c);\n\tif (c->max_inode_sz > MAX_LFS_FILESIZE)\n\t\tsb->s_maxbytes = c->max_inode_sz = MAX_LFS_FILESIZE;\n\tsb->s_op = &ubifs_super_operations;\n\tsb->s_xattr = ubifs_xattr_handlers;\n\n\tmutex_lock(&c->umount_mutex);\n\terr = mount_ubifs(c);\n\tif (err) {\n\t\tubifs_assert(err < 0);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Read the root inode */\n\troot = ubifs_iget(sb, UBIFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out_umount;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_umount;\n\t}\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn 0;\n\nout_umount:\n\tubifs_umount(c);\nout_unlock:\n\tmutex_unlock(&c->umount_mutex);\nout_bdi:\n\tbdi_destroy(&c->bdi);\nout_close:\n\tubi_close_volume(c->ubi);\nout:\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "super_operations ubifs_super_operations = {\n\t.alloc_inode   = ubifs_alloc_inode,\n\t.destroy_inode = ubifs_destroy_inode,\n\t.put_super     = ubifs_put_super,\n\t.write_inode   = ubifs_write_inode,\n\t.evict_inode   = ubifs_evict_inode,\n\t.statfs        = ubifs_statfs,\n\t.dirty_inode   = ubifs_dirty_inode,\n\t.remount_fs    = ubifs_remount_fs,\n\t.show_options  = ubifs_show_options,\n\t.sync_fs       = ubifs_sync_fs,\n};\n\n/**\n * open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ume(c->ubi);\nout",
          "args": [
            "retu"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bdi);\nou",
          "args": [
            "_close:"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\nout_bdi:"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\nout_unlo",
          "args": [
            "k"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\treturn 0;"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot);\n\tif (",
          "args": [
            "sb->"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\te",
          "args": [
            "r ="
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", UBIFS_RO",
          "args": [
            "T_",
            "O);\n\tif (IS_ER"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err < 0);",
          "args": [
            "oto out"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->umount_m",
          "args": [
            "tex);\n\terr = mou"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_size(c);\n\tif (c->",
          "args": [
            "a"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptions(c, data, 0);",
          "args": [
            "(er"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->bdi, NUL",
          "args": [
            ", \"ubif",
            "%d_%",
            ",\n\t\t\t   c->vi",
            ", c->vi.vol_i",
            ";\n\tif (err)"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi);\n\ti",
          "args": [
            "(err)"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i);\n\t\tg",
          "args": [
            "to out"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me(c->vi.ubi_nu",
          "args": [
            ", c->vi.vol_i",
            "UBI_READWRI",
            ");\n\tif (IS_ER"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nsuper_operations ubifs_super_operations = {\n\t.alloc_inode   = ubifs_alloc_inode,\n\t.destroy_inode = ubifs_destroy_inode,\n\t.put_super     = ubifs_put_super,\n\t.write_inode   = ubifs_write_inode,\n\t.evict_inode   = ubifs_evict_inode,\n\t.statfs        = ubifs_statfs,\n\t.dirty_inode   = ubifs_dirty_inode,\n\t.remount_fs    = ubifs_remount_fs,\n\t.show_options  = ubifs_show_options,\n\t.sync_fs       = ubifs_sync_fs,\n};\n\n/**\n * open;\n\nifs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *root;\n\tint err;\n\n\tc->vfs_sb = sb;\n\t/* Re-open the UBI device in read-write mode */\n\tc->ubi = ubi_open_volume(c->vi.ubi_num, c->vi.vol_id, UBI_READWRITE);\n\tif (IS_ERR(c->ubi)) {\n\t\terr = PTR_ERR(c->ubi);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * UBIFS provides 'backing_dev_info' in order to disable read-ahead. For\n\t * UBIFS, I/O is not deferred, it is done immediately in readpage,\n\t * which means the user would have to wait not just for their own I/O\n\t * but the read-ahead I/O as well i.e. completely pointless.\n\t *\n\t * Read-ahead will be disabled because @c->bdi.ra_pages is 0.\n\t */\n\tc->bdi.name = \"ubifs\",\n\tc->bdi.capabilities = 0;\n\terr  = bdi_init(&c->bdi);\n\tif (err)\n\t\tgoto out_close;\n\terr = bdi_register(&c->bdi, NULL, \"ubifs_%d_%d\",\n\t\t\t   c->vi.ubi_num, c->vi.vol_id);\n\tif (err)\n\t\tgoto out_bdi;\n\n\terr = ubifs_parse_options(c, data, 0);\n\tif (err)\n\t\tgoto out_bdi;\n\n\tsb->s_bdi = &c->bdi;\n\tsb->s_fs_info = c;\n\tsb->s_magic = UBIFS_SUPER_MAGIC;\n\tsb->s_blocksize = UBIFS_BLOCK_SIZE;\n\tsb->s_blocksize_bits = UBIFS_BLOCK_SHIFT;\n\tsb->s_maxbytes = c->max_inode_sz = key_max_inode_size(c);\n\tif (c->max_inode_sz > MAX_LFS_FILESIZE)\n\t\tsb->s_maxbytes = c->max_inode_sz = MAX_LFS_FILESIZE;\n\tsb->s_op = &ubifs_super_operations;\n\tsb->s_xattr = ubifs_xattr_handlers;\n\n\tmutex_lock(&c->umount_mutex);\n\terr = mount_ubifs(c);\n\tif (err) {\n\t\tubifs_assert(err < 0);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Read the root inode */\n\troot = ubifs_iget(sb, UBIFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out_umount;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_umount;\n\t}\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn 0;\n\nout_umount:\n\tubifs_umount(c);\nout_unlock:\n\tmutex_unlock(&c->umount_mutex);\nout_bdi:\n\tbdi_destroy(&c->bdi);\nout_close:\n\tubi_close_volume(c->ubi);\nout:\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "nfo(struct ubi_v",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1948-1992",
    "snippet": "ubifs_info *alloc_ubifs_info(struct ubi_volume_desc *ubi)\n{\n\tstruct ubifs_info *c;\n\n\tc = kzalloc(sizeof(struct ubifs_info), GFP_KERNEL);\n\tif (c) {\n\t\tspin_lock_init(&c->cnt_lock);\n\t\tspin_lock_init(&c->cs_lock);\n\t\tspin_lock_init(&c->buds_lock);\n\t\tspin_lock_init(&c->space_lock);\n\t\tspin_lock_init(&c->orphan_lock);\n\t\tinit_rwsem(&c->commit_sem);\n\t\tmutex_init(&c->lp_mutex);\n\t\tmutex_init(&c->tnc_mutex);\n\t\tmutex_init(&c->log_mutex);\n\t\tmutex_init(&c->umount_mutex);\n\t\tmutex_init(&c->bu_mutex);\n\t\tmutex_init(&c->write_reserve_mutex);\n\t\tinit_waitqueue_head(&c->cmt_wq);\n\t\tc->buds = RB_ROOT;\n\t\tc->old_idx = RB_ROOT;\n\t\tc->size_tree = RB_ROOT;\n\t\tc->orph_tree = RB_ROOT;\n\t\tINIT_LIST_HEAD(&c->infos_list);\n\t\tINIT_LIST_HEAD(&c->idx_gc);\n\t\tINIT_LIST_HEAD(&c->replay_list);\n\t\tINIT_LIST_HEAD(&c->replay_buds);\n\t\tINIT_LIST_HEAD(&c->uncat_list);\n\t\tINIT_LIST_HEAD(&c->empty_list);\n\t\tINIT_LIST_HEAD(&c->freeable_list);\n\t\tINIT_LIST_HEAD(&c->frdi_idx_list);\n\t\tINIT_LIST_HEAD(&c->unclean_leb_list);\n\t\tINIT_LIST_HEAD(&c->old_buds);\n\t\tINIT_LIST_HEAD(&c->orph_list);\n\t\tINIT_LIST_HEAD(&c->orph_new);\n\t\tc->no_chk_data_crc = 1;\n\n\t\tc->highest_inum = UBIFS_FIRST_INO;\n\t\tc->lhead_lnum = c->ltail_lnum = UBIFS_LOG_LNUM;\n\n\t\tubi_get_volume_info(ubi, &c->vi);\n\t\tubi_get_device_info(c->vi.ubi_num, &c->di);\n\t}\n\treturn c;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_info(c->vi.ubi_nu",
          "args": [
            ", &c->di);\n\t}",
            "return"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_info(ubi, &c->vi)",
          "args": [
            "i_get_"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->orph_new",
          "args": [
            ";\n\t\tc->no_ch"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->orph_lis",
          "args": [
            ");\n\t\tINIT_LIS"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->old_buds",
          "args": [
            ";\n\t\tINIT_LIS"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->unclean_",
          "args": [
            "eb_list);\n\t\tINIT_LIS"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->frdi_idx",
          "args": [
            "list);\n\t\tINIT_LIS"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->freeable",
          "args": [
            "list);\n\t\tINIT_LIS"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->empty_li",
          "args": [
            "t);\n\t\tINIT_LIS"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->uncat_li",
          "args": [
            "t);\n\t\tINIT_LIS"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->replay_b",
          "args": [
            "ds);\n\t\tINIT_LIS"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->replay_l",
          "args": [
            "st);\n\t\tINIT_LIS"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->idx_gc);",
          "args": [
            "INIT_LIS"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->infos_li",
          "args": [
            "t);\n\t\tINIT_LIS"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_head(&c->cmt_wq);",
          "args": [
            "c->buds"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->write_re",
          "args": [
            "erve_mutex);\n\t\tinit_wai"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1400-1415",
          "snippet": "static int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "->bu_mutex",
          "args": [
            ";\n\t\tmutex_in"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->umount_m",
          "args": [
            "tex);\n\t\tmutex_in"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "->log_mute",
          "args": [
            ");\n\t\tmutex_in"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\t\tmutex_in"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\t\tmutex_in"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->commit_s",
          "args": [
            "m);\n\t\tmutex_in"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t(&c->orphan_l",
          "args": [
            "ck);\n\t\tinit_rws"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(&c->space_lo",
          "args": [
            "k);\n\t\tspin_loc"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(&c->buds_loc",
          "args": [
            ");\n\t\tspin_loc"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(&c->cs_lock)",
          "args": [
            "spin_loc"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(&c->cnt_lock",
          "args": [
            ";\n\t\tspin_loc"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_info), GFP_KERNEL)",
            "if (c) {"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nubifs_info *alloc_ubifs_info(struct ubi_volume_desc *ubi)\n{\n\tstruct ubifs_info *c;\n\n\tc = kzalloc(sizeof(struct ubifs_info), GFP_KERNEL);\n\tif (c) {\n\t\tspin_lock_init(&c->cnt_lock);\n\t\tspin_lock_init(&c->cs_lock);\n\t\tspin_lock_init(&c->buds_lock);\n\t\tspin_lock_init(&c->space_lock);\n\t\tspin_lock_init(&c->orphan_lock);\n\t\tinit_rwsem(&c->commit_sem);\n\t\tmutex_init(&c->lp_mutex);\n\t\tmutex_init(&c->tnc_mutex);\n\t\tmutex_init(&c->log_mutex);\n\t\tmutex_init(&c->umount_mutex);\n\t\tmutex_init(&c->bu_mutex);\n\t\tmutex_init(&c->write_reserve_mutex);\n\t\tinit_waitqueue_head(&c->cmt_wq);\n\t\tc->buds = RB_ROOT;\n\t\tc->old_idx = RB_ROOT;\n\t\tc->size_tree = RB_ROOT;\n\t\tc->orph_tree = RB_ROOT;\n\t\tINIT_LIST_HEAD(&c->infos_list);\n\t\tINIT_LIST_HEAD(&c->idx_gc);\n\t\tINIT_LIST_HEAD(&c->replay_list);\n\t\tINIT_LIST_HEAD(&c->replay_buds);\n\t\tINIT_LIST_HEAD(&c->uncat_list);\n\t\tINIT_LIST_HEAD(&c->empty_list);\n\t\tINIT_LIST_HEAD(&c->freeable_list);\n\t\tINIT_LIST_HEAD(&c->frdi_idx_list);\n\t\tINIT_LIST_HEAD(&c->unclean_leb_list);\n\t\tINIT_LIST_HEAD(&c->old_buds);\n\t\tINIT_LIST_HEAD(&c->orph_list);\n\t\tINIT_LIST_HEAD(&c->orph_new);\n\t\tc->no_chk_data_crc = 1;\n\n\t\tc->highest_inum = UBIFS_FIRST_INO;\n\t\tc->lhead_lnum = c->ltail_lnum = UBIFS_LOG_LNUM;\n\n\t\tubi_get_volume_info(ubi, &c->vi);\n\t\tubi_get_device_info(c->vi.ubi_num, &c->di);\n\t}\n\treturn c;\n}\n\nstatic int"
  },
  {
    "function_name": "t char *",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1905-1946",
    "snippet": "ubi_volume_desc *open_ubi(const char *name, int mode)\n{\n\tstruct ubi_volume_desc *ubi;\n\tint dev, vol;\n\tchar *endptr;\n\n\t/* First, try to open using the device node path method */\n\tubi = ubi_open_volume_path(name, mode);\n\tif (!IS_ERR(ubi))\n\t\treturn ubi;\n\n\t/* Try the \"nodev\" method */\n\tif (name[0] != 'u' || name[1] != 'b' || name[2] != 'i')\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* ubi:NAME method */\n\tif ((name[3] == ':' || name[3] == '!') && name[4] != '\\0')\n\t\treturn ubi_open_volume_nm(0, name + 4, mode);\n\n\tif (!isdigit(name[3]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = simple_strtoul(name + 3, &endptr, 0);\n\n\t/* ubiY method */\n\tif (*endptr == '\\0')\n\t\treturn ubi_open_volume(0, dev, mode);\n\n\t/* ubiX_Y method */\n\tif (*endptr == '_' && isdigit(endptr[1])) {\n\t\tvol = simple_strtoul(endptr + 1, &endptr, 0);\n\t\tif (*endptr != '\\0')\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn ubi_open_volume(dev, vol, mode);\n\t}\n\n\t/* ubiX:NAME method */\n\tif ((*endptr == ':' || *endptr == '!') && endptr[1] != '\\0')\n\t\treturn ubi_open_volume_nm(dev, ++endptr, mode);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic stru",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AL);\n}",
          "args": [
            "static"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me_nm(dev, ++endpt",
          "args": [
            ", m",
            "e);\n\n\tre",
            "rn E"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me(dev, vol, mo",
          "args": [
            "e);",
            "}",
            "* ub"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "eturn u"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(endptr + 1,",
          "args": [
            "endptr, 0)",
            "if (*",
            "d"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r[1]))",
          "args": [
            "vol ="
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me(0, dev, mode",
          "args": [
            ";",
            "/*",
            "biX_"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(name + 3, &e",
          "args": [
            "dptr, 0)",
            "/* ub"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "ev = si"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "3]))",
          "args": [
            "eturn E"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me_nm(0, name + 4,",
          "args": [
            "m",
            "e);\n\n\tif",
            "!isd"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "* ubi:N"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n u"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "me_path(name, mode);",
          "args": [
            "if",
            "IS_E"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nubi_volume_desc *open_ubi(const char *name, int mode)\n{\n\tstruct ubi_volume_desc *ubi;\n\tint dev, vol;\n\tchar *endptr;\n\n\t/* First, try to open using the device node path method */\n\tubi = ubi_open_volume_path(name, mode);\n\tif (!IS_ERR(ubi))\n\t\treturn ubi;\n\n\t/* Try the \"nodev\" method */\n\tif (name[0] != 'u' || name[1] != 'b' || name[2] != 'i')\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* ubi:NAME method */\n\tif ((name[3] == ':' || name[3] == '!') && name[4] != '\\0')\n\t\treturn ubi_open_volume_nm(0, name + 4, mode);\n\n\tif (!isdigit(name[3]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = simple_strtoul(name + 3, &endptr, 0);\n\n\t/* ubiY method */\n\tif (*endptr == '\\0')\n\t\treturn ubi_open_volume(0, dev, mode);\n\n\t/* ubiX_Y method */\n\tif (*endptr == '_' && isdigit(endptr[1])) {\n\t\tvol = simple_strtoul(endptr + 1, &endptr, 0);\n\t\tif (*endptr != '\\0')\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn ubi_open_volume(dev, vol, mode);\n\t}\n\n\t/* ubiX:NAME method */\n\tif ((*endptr == ':' || *endptr == '!') && endptr[1] != '\\0')\n\t\treturn ubi_open_volume_nm(dev, ++endptr, mode);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic stru"
  },
  {
    "function_name": "_fs(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1827-1871",
    "snippet": "ifs_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\tdbg_gen(\"old flags %#lx, new flags %#x\", sb->s_flags, *flags);\n\n\terr = ubifs_parse_options(c, data, 1);\n\tif (err) {\n\t\tubifs_err(\"invalid or unknown remount parameter\");\n\t\treturn err;\n\t}\n\n\tif (c->ro_mount && !(*flags & MS_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(\"cannot re-mount R/W due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (c->ro_media) {\n\t\t\tubifs_msg(\"cannot re-mount R/W - UBI volume is R/O\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\terr = ubifs_remount_rw(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!c->ro_mount && (*flags & MS_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(\"cannot re-mount R/O due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tubifs_remount_ro(c);\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\telse {\n\t\tdbg_gen(\"disable bulk-read\");\n\t\tkfree(c->bu.buf);\n\t\tc->bu.buf = NULL;\n\t}\n\n\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\treturn 0;\n}\n\nconst struc",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->lst.taken",
          "args": [
            "empty_lebs > 0);\n\treturn 0;"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf);",
          "args": [
            "c->bu.bu"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ble bul",
          "args": [
            "-read\");\n\t\tkfree(c-"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "else {",
          "args": [],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ro(c);\n\t}\n\n\tif",
          "args": [
            "c"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot re-m",
          "args": [
            "unt R/O due to prior errors\");\n\t\t\treturn"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rw(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot re-m",
          "args": [
            "unt R/W - UBI volume is R/O\");\n\t\t\treturn"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot re-m",
          "args": [
            "unt R/W due to prior errors\");\n\t\t\treturn"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid or",
          "args": [
            "nknown remount parameter\");\n\t\treturn e"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptions(c, data, 1);",
          "args": [
            "(er"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags %",
          "args": [
            "lx, new flags %#x\", sb->s_flags",
            "*flags);",
            "r = ub"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em(sb);\n\tdbg_ge",
          "args": [
            "(\""
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\tdbg_gen(\"old flags %#lx, new flags %#x\", sb->s_flags, *flags);\n\n\terr = ubifs_parse_options(c, data, 1);\n\tif (err) {\n\t\tubifs_err(\"invalid or unknown remount parameter\");\n\t\treturn err;\n\t}\n\n\tif (c->ro_mount && !(*flags & MS_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(\"cannot re-mount R/W due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (c->ro_media) {\n\t\t\tubifs_msg(\"cannot re-mount R/W - UBI volume is R/O\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\terr = ubifs_remount_rw(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!c->ro_mount && (*flags & MS_RDONLY)) {\n\t\tif (c->ro_error) {\n\t\t\tubifs_msg(\"cannot re-mount R/O due to prior errors\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\tubifs_remount_ro(c);\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\telse {\n\t\tdbg_gen(\"disable bulk-read\");\n\t\tkfree(c->bu.buf);\n\t\tc->bu.buf = NULL;\n\t}\n\n\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\treturn 0;\n}\n\nconst struc"
  },
  {
    "function_name": "er(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1750-1825",
    "snippet": "bifs_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tubifs_msg(\"un-mount UBI device %d, volume %d\", c->vi.ubi_num,\n\t\t  c->vi.vol_id);\n\n\t/*\n\t * The following asserts are only valid if there has not been a failure\n\t * of the media. For example, there will be dirty inodes if we failed\n\t * to write them back because of I/O errors.\n\t */\n\tif (!c->ro_error) {\n\t\tubifs_assert(c->bi.idx_growth == 0);\n\t\tubifs_assert(c->bi.dd_growth == 0);\n\t\tubifs_assert(c->bi.data_growth == 0);\n\t}\n\n\t/*\n\t * The 'c->umount_lock' prevents races between UBIFS memory shrinker\n\t * and file system un-mount. Namely, it prevents the shrinker from\n\t * picking this superblock for shrinking - it will be just skipped if\n\t * the mutex is locked.\n\t */\n\tmutex_lock(&c->umount_mutex);\n\tif (!c->ro_mount) {\n\t\t/*\n\t\t * First of all kill the background thread to make sure it does\n\t\t * not interfere with un-mounting and freeing resources.\n\t\t */\n\t\tif (c->bgt) {\n\t\t\tkthread_stop(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t}\n\n\t\t/*\n\t\t * On fatal errors c->ro_error is set to 1, in which case we do\n\t\t * not write the master node.\n\t\t */\n\t\tif (!c->ro_error) {\n\t\t\tint err;\n\n\t\t\t/* Synchronize write-buffers */\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\t\t\t/*\n\t\t\t * We are being cleanly unmounted which means the\n\t\t\t * orphans were killed - indicate this in the master\n\t\t\t * node. Also save the reserved GC LEB number.\n\t\t\t */\n\t\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\t\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\t\t\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\t\t\terr = ubifs_write_master(c);\n\t\t\tif (err)\n\t\t\t\t/*\n\t\t\t\t * Recovery will attempt to fix the master area\n\t\t\t\t * next mount, so we just print a message and\n\t\t\t\t * continue to unmount normally.\n\t\t\t\t */\n\t\t\t\tubifs_err(\"failed to write master node, error %d\",\n\t\t\t\t\t  err);\n\t\t} else {\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\t\t/* Make sure write-buffer timers are canceled */\n\t\t\t\thrtimer_cancel(&c->jheads[i].wbuf.timer);\n\t\t}\n\t}\n\n\tubifs_umount(c);\n\tbdi_destroy(&c->bdi);\n\tubi_close_volume(c->ubi);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n}\n\nstatic"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ume(c->ubi);\n\tmu",
          "args": [
            "ex_unl"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bdi);\n\tu",
          "args": [
            "i_close"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\n\tbdi_des",
          "args": [
            "r"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(&c->jheads[i",
          "args": [
            ".wbuf.timer);\n\t\t}\n\t}\n\n\tu"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled to w",
          "args": [
            "ite master node, error %d\",\n\t\t\t\t\t  err)",
            "e {"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aster(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->gc_lnum);",
          "args": [
            "err = u"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_NO",
          "args": [
            "ORPHS);\n\t\t\tc->mst_"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\t\t\tc->mst_"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\n\t\t\t/*"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bgt);",
          "args": [
            "->bgt"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->umount_m",
          "args": [
            "tex);\n\tif (!c->r"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->bi.data_g",
          "args": [
            "owth == 0);\n\t}\n\n\t/*"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.dd_gro",
          "args": [
            "th == 0);\n\t\tubifs_as"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.idx_gr",
          "args": [
            "wth == 0);\n\t\tubifs_as"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "-mount UB",
          "args": [
            "device %d, volume %d\", c->vi.ubi_n",
            ",\n\t\t  c->vi.v",
            ";\n\n\t/*\n\t * T"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\tubifs_msg(\"un-mount UBI device %d, volume %d\", c->vi.ubi_num,\n\t\t  c->vi.vol_id);\n\n\t/*\n\t * The following asserts are only valid if there has not been a failure\n\t * of the media. For example, there will be dirty inodes if we failed\n\t * to write them back because of I/O errors.\n\t */\n\tif (!c->ro_error) {\n\t\tubifs_assert(c->bi.idx_growth == 0);\n\t\tubifs_assert(c->bi.dd_growth == 0);\n\t\tubifs_assert(c->bi.data_growth == 0);\n\t}\n\n\t/*\n\t * The 'c->umount_lock' prevents races between UBIFS memory shrinker\n\t * and file system un-mount. Namely, it prevents the shrinker from\n\t * picking this superblock for shrinking - it will be just skipped if\n\t * the mutex is locked.\n\t */\n\tmutex_lock(&c->umount_mutex);\n\tif (!c->ro_mount) {\n\t\t/*\n\t\t * First of all kill the background thread to make sure it does\n\t\t * not interfere with un-mounting and freeing resources.\n\t\t */\n\t\tif (c->bgt) {\n\t\t\tkthread_stop(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t}\n\n\t\t/*\n\t\t * On fatal errors c->ro_error is set to 1, in which case we do\n\t\t * not write the master node.\n\t\t */\n\t\tif (!c->ro_error) {\n\t\t\tint err;\n\n\t\t\t/* Synchronize write-buffers */\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\t\t\t/*\n\t\t\t * We are being cleanly unmounted which means the\n\t\t\t * orphans were killed - indicate this in the master\n\t\t\t * node. Also save the reserved GC LEB number.\n\t\t\t */\n\t\t\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\t\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\t\t\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\t\t\terr = ubifs_write_master(c);\n\t\t\tif (err)\n\t\t\t\t/*\n\t\t\t\t * Recovery will attempt to fix the master area\n\t\t\t\t * next mount, so we just print a message and\n\t\t\t\t * continue to unmount normally.\n\t\t\t\t */\n\t\t\t\tubifs_err(\"failed to write master node, error %d\",\n\t\t\t\t\t  err);\n\t\t} else {\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\t\t/* Make sure write-buffer timers are canceled */\n\t\t\t\thrtimer_cancel(&c->jheads[i].wbuf.timer);\n\t\t}\n\t}\n\n\tubifs_umount(c);\n\tbdi_destroy(&c->bdi);\n\tubi_close_volume(c->ubi);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic int"
  },
  {
    "function_name": "_ro(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1711-1748",
    "snippet": "bifs_remount_ro(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tubifs_assert(!c->need_recovery);\n\tubifs_assert(!c->ro_mount);\n\n\tmutex_lock(&c->umount_mutex);\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\n\tdbg_save_space_info(c);\n\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\terr = ubifs_write_master(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->ro_mount = 1;\n\terr = dbg_check_space_info(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n}\n\nstatic"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tmu",
          "args": [
            "e",
            "unl"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce_info(c);\n\tif (err",
          "args": [],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, 1);\n\tc->r",
          "args": [
            "_",
            "u"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "c->ileb_b"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_res",
          "args": [
            "rve_buf);\n\tc->write_"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_resv_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3367-3394",
          "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "c->orph_b"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\n\tv",
          "args": [
            "r",
            "(c-"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aster(c);\n\tif (err",
          "args": [],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->gc_lnum);",
          "args": [
            "err = ubi"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_NO",
          "args": [
            "ORPHS);\n\tc->mst_no"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\tc->mst_no"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\n\tc->mst_n"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_info(c);\n\n\tfor (i",
          "args": [
            "="
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bgt);\n\t\tc",
          "args": [
            ">bgt ="
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->umount_m",
          "args": [
            "tex);\n\tif (c->bg"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "!c->ro_mount",
          "args": [
            ";\n\n\tmutex_lo"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->need_rec",
          "args": [
            "very);\n\tubifs_ass"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_remount_ro(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tubifs_assert(!c->need_recovery);\n\tubifs_assert(!c->ro_mount);\n\n\tmutex_lock(&c->umount_mutex);\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\n\tdbg_save_space_info(c);\n\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\terr = ubifs_write_master(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->ro_mount = 1;\n\terr = dbg_check_space_info(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic void"
  },
  {
    "function_name": "_rw(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1541-1702",
    "snippet": "ifs_remount_rw(struct ubifs_info *c)\n{\n\tint err, lnum;\n\n\tif (c->rw_incompat) {\n\t\tubifs_err(\"the file-system is not R/W-compatible\");\n\t\tubifs_msg(\"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION);\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&c->umount_mutex);\n\tdbg_save_space_info(c);\n\tc->remounting_rw = 1;\n\tc->ro_mount = 0;\n\n\tif (c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_free_space(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->old_leb_cnt != c->leb_cnt) {\n\t\tstruct ubifs_sb_node *sup;\n\n\t\tsup = ubifs_read_sb_node(c);\n\t\tif (IS_ERR(sup)) {\n\t\t\terr = PTR_ERR(sup);\n\t\t\tgoto out;\n\t\t}\n\t\tsup->leb_cnt = cpu_to_le32(c->leb_cnt);\n\t\terr = ubifs_write_sb_node(c, sup);\n\t\tkfree(sup);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->need_recovery) {\n\t\tubifs_msg(\"completing deferred recovery\");\n\t\terr = ubifs_write_rcvrd_mst_node(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_recover_size(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_clean_lebs(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* A readonly mount is not allowed to have orphans */\n\t\tubifs_assert(c->tot_orphans == 0);\n\t\terr = ubifs_clear_orphans(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!(c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY))) {\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tc->ileb_buf = vmalloc(c->leb_size);\n\tif (!c->ileb_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ, GFP_KERNEL);\n\tif (!c->write_reserve_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ubifs_lpt_init(c, 0, 1);\n\tif (err)\n\t\tgoto out;\n\n\t/* Create background thread */\n\tc->bgt = kthread_create(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\tif (IS_ERR(c->bgt)) {\n\t\terr = PTR_ERR(c->bgt);\n\t\tc->bgt = NULL;\n\t\tubifs_err(\"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t  c->bgt_name, err);\n\t\tgoto out;\n\t}\n\twake_up_process(c->bgt);\n\n\tc->orph_buf = vmalloc(c->leb_size);\n\tif (!c->orph_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Check for enough log space */\n\tlnum = c->lhead_lnum + 1;\n\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tlnum = UBIFS_LOG_LNUM;\n\tif (lnum == c->ltail_lnum) {\n\t\terr = ubifs_consolidate_log(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->need_recovery)\n\t\terr = ubifs_rcvry_gc_commit(c);\n\telse\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err)\n\t\tgoto out;\n\n\tdbg_gen(\"re-mounted read-write\");\n\tc->remounting_rw = 0;\n\n\tif (c->need_recovery) {\n\t\tc->need_recovery = 0;\n\t\tubifs_msg(\"deferred recovery completed\");\n\t} else {\n\t\t/*\n\t\t * Do not run the debugging space check if the were doing\n\t\t * recovery, because when we saved the information we had the\n\t\t * file-system in a state where the TNC and lprops has been\n\t\t * modified in memory, but all the I/O operations (including a\n\t\t * commit) were deferred. So the file-system was in\n\t\t * \"non-committed\" state. Now the file-system is in committed\n\t\t * state, and of course the amount of free space will change\n\t\t * because, for example, the old index size was imprecise.\n\t\t */\n\t\terr = dbg_check_space_info(c);\n\t}\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n\nout:\n\tc->ro_mount = 1;\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\tfree_wbufs(c);\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->remounting_rw = 0;\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\treturn er"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, 1);\n\tc->r",
          "args": [
            "m",
            "n"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "c->ileb_b"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_res",
          "args": [
            "rve_buf);\n\tc->write_"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_resv_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3367-3394",
          "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\tkfree(c",
          "args": [
            ">"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bgt);\n\t\tc",
          "args": [
            ">bgt ="
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "c->orph_b"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->umount_m",
          "args": [
            "tex);\n\treturn er"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce_info(c);\n\t}\n\n\tmut",
          "args": [
            "x"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferred re",
          "args": [
            "overy completed\");\n\t} else {"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ounted",
          "args": [
            "ead-write\");\n\tc->remoun"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1280-1303",
          "snippet": "int d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\tret = 0;\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\tret = 0;\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ap(c, c->gc_lnu",
          "args": [
            ")",
            "if (err)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_commit(c);\n\telse",
          "args": [
            "r"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date_log(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!c->o"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss(c->bgt);\n\n\tc",
          "args": [
            ">orph_"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot spaw",
          "args": [
            "\\\"%s\\\", error %d\",\n\t\t\t  c->bgt",
            "err);\n\t\tgot",
            "out"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t);\n\t\tc",
          "args": [
            ">bgt ="
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(ubifs_bg_thr",
          "args": [
            "ad, c, \"%s\", c-",
            "g",
            "name",
            "if (IS_ER"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, 0, 1);\n\ti",
          "args": [
            "r"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESSED_D",
          "args": [
            "TA_NODE_BUF_SZ, GFP_KERNEL)",
            "if (!c->w"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!c->i"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aster(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\t\terr = ub"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY))) {\n\t\tc->ms"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rphans(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->tot_orpha",
          "args": [
            "s == 0);\n\t\terr = ub"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_inl_heads(c, c->sbuf);",
          "args": [
            "f (err)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebs(c, c->sbuf);",
          "args": [
            "f (err)"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cvrd_mst_node(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpleting",
          "args": [
            "eferred recovery\");\n\t\terr = ub"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (",
          "args": [
            "rr)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_node(c, sup);\n\t\tk",
          "args": [
            "r",
            "(su"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->leb_cnt);",
          "args": [
            "err = ub"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "got",
          "args": [
            "ou"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "sess_auth_rawntlmssp_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/sess.c",
          "lines": "1143-1237",
          "snippet": "static void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}",
          "includes": [
            "#include \"cifs_spnego.h\"",
            "#include <linux/slab.h>",
            "#include <linux/utsname.h>",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_spnego.h\"\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "{\n\t\t\te",
          "args": [
            "r ="
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c);\n\t\tif (IS",
          "args": [
            "E"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ace(c);\n\tif (err",
          "args": [],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_space(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_info(c);\n\tc->remo",
          "args": [
            "n"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->umount_m",
          "args": [
            "tex);\n\tdbg_save_"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "-flash fo",
          "args": [
            "mat version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t  c->fmt",
            "n, c->ro_compa",
            "version,\n\t\t\t  UBIFS_",
            "VERSION, UBIFS_RO_CO",
            "AT_VERSION);\n\t\treturn -"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e file-sy",
          "args": [
            "tem is not R/W-compatible\");\n\t\tubifs_ms"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_remount_rw(struct ubifs_info *c)\n{\n\tint err, lnum;\n\n\tif (c->rw_incompat) {\n\t\tubifs_err(\"the file-system is not R/W-compatible\");\n\t\tubifs_msg(\"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION);\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&c->umount_mutex);\n\tdbg_save_space_info(c);\n\tc->remounting_rw = 1;\n\tc->ro_mount = 0;\n\n\tif (c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_free_space(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->old_leb_cnt != c->leb_cnt) {\n\t\tstruct ubifs_sb_node *sup;\n\n\t\tsup = ubifs_read_sb_node(c);\n\t\tif (IS_ERR(sup)) {\n\t\t\terr = PTR_ERR(sup);\n\t\t\tgoto out;\n\t\t}\n\t\tsup->leb_cnt = cpu_to_le32(c->leb_cnt);\n\t\terr = ubifs_write_sb_node(c, sup);\n\t\tkfree(sup);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->need_recovery) {\n\t\tubifs_msg(\"completing deferred recovery\");\n\t\terr = ubifs_write_rcvrd_mst_node(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_recover_size(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_clean_lebs(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* A readonly mount is not allowed to have orphans */\n\t\tubifs_assert(c->tot_orphans == 0);\n\t\terr = ubifs_clear_orphans(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!(c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY))) {\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tc->ileb_buf = vmalloc(c->leb_size);\n\tif (!c->ileb_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ, GFP_KERNEL);\n\tif (!c->write_reserve_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ubifs_lpt_init(c, 0, 1);\n\tif (err)\n\t\tgoto out;\n\n\t/* Create background thread */\n\tc->bgt = kthread_create(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\tif (IS_ERR(c->bgt)) {\n\t\terr = PTR_ERR(c->bgt);\n\t\tc->bgt = NULL;\n\t\tubifs_err(\"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t  c->bgt_name, err);\n\t\tgoto out;\n\t}\n\twake_up_process(c->bgt);\n\n\tc->orph_buf = vmalloc(c->leb_size);\n\tif (!c->orph_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Check for enough log space */\n\tlnum = c->lhead_lnum + 1;\n\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tlnum = UBIFS_LOG_LNUM;\n\tif (lnum == c->ltail_lnum) {\n\t\terr = ubifs_consolidate_log(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (c->need_recovery)\n\t\terr = ubifs_rcvry_gc_commit(c);\n\telse\n\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err)\n\t\tgoto out;\n\n\tdbg_gen(\"re-mounted read-write\");\n\tc->remounting_rw = 0;\n\n\tif (c->need_recovery) {\n\t\tc->need_recovery = 0;\n\t\tubifs_msg(\"deferred recovery completed\");\n\t} else {\n\t\t/*\n\t\t * Do not run the debugging space check if the were doing\n\t\t * recovery, because when we saved the information we had the\n\t\t * file-system in a state where the TNC and lprops has been\n\t\t * modified in memory, but all the I/O operations (including a\n\t\t * commit) were deferred. So the file-system was in\n\t\t * \"non-committed\" state. Now the file-system is in committed\n\t\t * state, and of course the amount of free space will change\n\t\t * because, for example, the old index size was imprecise.\n\t\t */\n\t\terr = dbg_check_space_info(c);\n\t}\n\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n\nout:\n\tc->ro_mount = 1;\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\tfree_wbufs(c);\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->remounting_rw = 0;\n\tmutex_unlock(&c->umount_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1504-1531",
    "snippet": "bifs_umount(struct ubifs_info *c)\n{\n\tdbg_gen(\"un-mounting UBI device %d, volume %d\", c->vi.ubi_num,\n\t\tc->vi.vol_id);\n\n\tdbg_debugfs_exit_fs(c);\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\n\n\tdestroy_journal(c);\n\tfree_wbufs(c);\n\tfree_orphans(c);\n\tubifs_lpt_free(c, 0);\n\n\tkfree(c->cbuf);\n\tkfree(c->rcvrd_mst_node);\n\tkfree(c->mst_node);\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tubifs_debugging_exit(c);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ng_exit(c);\n}\n\n/**",
          "args": [],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_up",
          "args": [
            "buf);\n\tubifs_deb"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tk",
          "args": [
            "ree(c->"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "vfree(c->"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf);",
          "args": [
            "vfree(c->"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_res",
          "args": [
            "rve_buf);\n\tkfree(c->"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_resv_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3367-3394",
          "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node)",
          "args": [
            "kfree(c->"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mst",
          "args": [
            "node);\n\tkfree(c->"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "cvrd_mst_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "386-400",
          "snippet": "te_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nte_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l"
        }
      },
      {
        "call_info": {
          "callee": ");\n\tk",
          "args": [
            "ree(c->"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, 0);\n\n\tkfr",
          "args": [
            "e",
            "-"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\n\tubifs_l",
          "args": [
            "t"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tfree_or",
          "args": [
            "h"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al(c);\n\tfree_wb",
          "args": [
            "f"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bgt);\n\n\td",
          "args": [
            "stroy_"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\n\tif (c->b"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "infos_li",
          "args": [
            "t);\n\tspin_unlo"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\tlist_del("
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit_fs(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ounting",
          "args": [
            "UBI device %d, volume %d\", c->vi.ubi_n",
            ",\n\t\tc->vi.vol",
            ";\n\n\tdbg_debu"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "do_io_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2331-2373",
          "snippet": "static int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_umount(struct ubifs_info *c)\n{\n\tdbg_gen(\"un-mounting UBI device %d, volume %d\", c->vi.ubi_num,\n\t\tc->vi.vol_id);\n\n\tdbg_debugfs_exit_fs(c);\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\n\n\tdestroy_journal(c);\n\tfree_wbufs(c);\n\tfree_orphans(c);\n\tubifs_lpt_free(c, 0);\n\n\tkfree(c->cbuf);\n\tkfree(c->rcvrd_mst_node);\n\tkfree(c->mst_node);\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tubifs_debugging_exit(c);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1142-1493",
    "snippet": "unt_ubifs(struct ubifs_info *c)\n{\n\tint err;\n\tlong long x, y;\n\tsize_t sz;\n\n\tc->ro_mount = !!(c->vfs_sb->s_flags & MS_RDONLY);\n\t/* Suppress error messages while probing if MS_SILENT is set */\n\tc->probing = !!(c->vfs_sb->s_flags & MS_SILENT);\n\n\terr = init_constants_early(c);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_debugging_init(c);\n\tif (err)\n\t\treturn err;\n\n\terr = check_volume_empty(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (c->empty && (c->ro_mount || c->ro_media)) {\n\t\t/*\n\t\t * This UBI volume is empty, and read-only, or the file system\n\t\t * is mounted read-only - we cannot format it.\n\t\t */\n\t\tubifs_err(\"can't format empty UBI volume: read-only %s\",\n\t\t\t  c->ro_media ? \"UBI volume\" : \"mount\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\tif (c->ro_media && !c->ro_mount) {\n\t\tubifs_err(\"cannot mount read-write - read-only media\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\t/*\n\t * The requirement for the buffer is that it should fit indexing B-tree\n\t * height amount of integers. We assume the height if the TNC tree will\n\t * never exceed 64.\n\t */\n\terr = -ENOMEM;\n\tc->bottom_up_buf = kmalloc(BOTTOM_UP_HEIGHT * sizeof(int), GFP_KERNEL);\n\tif (!c->bottom_up_buf)\n\t\tgoto out_free;\n\n\tc->sbuf = vmalloc(c->leb_size);\n\tif (!c->sbuf)\n\t\tgoto out_free;\n\n\tif (!c->ro_mount) {\n\t\tc->ileb_buf = vmalloc(c->leb_size);\n\t\tif (!c->ileb_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\n\tif (!c->ro_mount) {\n\t\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!c->write_reserve_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tc->mounting = 1;\n\n\terr = ubifs_read_superblock(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tc->probing = 0;\n\n\t/*\n\t * Make sure the compressor which is set as default in the superblock\n\t * or overridden by mount options is actually compiled in.\n\t */\n\tif (!ubifs_compr_present(c->default_compr)) {\n\t\tubifs_err(\"'compressor \\\"%s\\\" is not compiled in\",\n\t\t\t  ubifs_compr_name(c->default_compr));\n\t\terr = -ENOTSUPP;\n\t\tgoto out_free;\n\t}\n\n\terr = init_constants_sb(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tsz = ALIGN(c->max_idx_node_sz, c->min_io_size);\n\tsz = ALIGN(sz + c->max_idx_node_sz, c->min_io_size);\n\tc->cbuf = kmalloc(sz, GFP_NOFS);\n\tif (!c->cbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = alloc_wbufs(c);\n\tif (err)\n\t\tgoto out_cbuf;\n\n\tsprintf(c->bgt_name, BGT_NAME_PATTERN, c->vi.ubi_num, c->vi.vol_id);\n\tif (!c->ro_mount) {\n\t\t/* Create background thread */\n\t\tc->bgt = kthread_create(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\t\tif (IS_ERR(c->bgt)) {\n\t\t\terr = PTR_ERR(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t\tubifs_err(\"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t\t  c->bgt_name, err);\n\t\t\tgoto out_wbufs;\n\t\t}\n\t\twake_up_process(c->bgt);\n\t}\n\n\terr = ubifs_read_master(c);\n\tif (err)\n\t\tgoto out_master;\n\n\tinit_constants_master(c);\n\n\tif ((c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY)) != 0) {\n\t\tubifs_msg(\"recovery needed\");\n\t\tc->need_recovery = 1;\n\t}\n\n\tif (c->need_recovery && !c->ro_mount) {\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out_master;\n\t}\n\n\terr = ubifs_lpt_init(c, 1, !c->ro_mount);\n\tif (err)\n\t\tgoto out_master;\n\n\tif (!c->ro_mount && c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\tif (!c->ro_mount) {\n\t\t/*\n\t\t * Set the \"dirty\" flag so that if we reboot uncleanly we\n\t\t * will notice this immediately on the next mount.\n\t\t */\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\terr = dbg_check_idx_size(c, c->bi.old_idx_sz);\n\tif (err)\n\t\tgoto out_lpt;\n\n\terr = ubifs_replay_journal(c);\n\tif (err)\n\t\tgoto out_journal;\n\n\t/* Calculate 'min_idx_lebs' after journal replay */\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\terr = ubifs_mount_orphans(c, c->need_recovery, c->ro_mount);\n\tif (err)\n\t\tgoto out_orphans;\n\n\tif (!c->ro_mount) {\n\t\tint lnum;\n\n\t\terr = check_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\n\t\t/* Check for enough log space */\n\t\tlnum = c->lhead_lnum + 1;\n\t\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\t\tlnum = UBIFS_LOG_LNUM;\n\t\tif (lnum == c->ltail_lnum) {\n\t\t\terr = ubifs_consolidate_log(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\tif (c->need_recovery) {\n\t\t\terr = ubifs_recover_size(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t\terr = ubifs_rcvry_gc_commit(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t} else {\n\t\t\terr = take_gc_lnum(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\n\t\t\t/*\n\t\t\t * GC LEB may contain garbage if there was an unclean\n\t\t\t * reboot, and it should be un-mapped.\n\t\t\t */\n\t\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\terr = dbg_check_lprops(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else if (c->need_recovery) {\n\t\terr = ubifs_recover_size(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else {\n\t\t/*\n\t\t * Even if we mount read-only, we have to set space in GC LEB\n\t\t * to proper value because this affects UBIFS free space\n\t\t * reporting. We do not want to have a situation when\n\t\t * re-mounting from R/O to R/W changes amount of free space.\n\t\t */\n\t\terr = take_gc_lnum(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t}\n\n\tspin_lock(&ubifs_infos_lock);\n\tlist_add_tail(&c->infos_list, &ubifs_infos);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->need_recovery) {\n\t\tif (c->ro_mount)\n\t\t\tubifs_msg(\"recovery deferred\");\n\t\telse {\n\t\t\tc->need_recovery = 0;\n\t\t\tubifs_msg(\"recovery completed\");\n\t\t\t/*\n\t\t\t * GC LEB has to be empty and taken at this point. But\n\t\t\t * the journal head LEBs may also be accounted as\n\t\t\t * \"empty taken\" if they are empty.\n\t\t\t */\n\t\t\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\t\t}\n\t} else\n\t\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\n\terr = dbg_check_filesystem(c);\n\tif (err)\n\t\tgoto out_infos;\n\n\terr = dbg_debugfs_init_fs(c);\n\tif (err)\n\t\tgoto out_infos;\n\n\tc->mounting = 0;\n\n\tubifs_msg(\"mounted UBI device %d, volume %d, name \\\"%s\\\"%s\",\n\t\t  c->vi.ubi_num, c->vi.vol_id, c->vi.name,\n\t\t  c->ro_mount ? \", R/O mode\" : \"\");\n\tx = (long long)c->main_lebs * c->leb_size;\n\ty = (long long)c->log_lebs * c->leb_size + c->max_bud_bytes;\n\tubifs_msg(\"LEB size: %d bytes (%d KiB), min./max. I/O unit sizes: %d bytes/%d bytes\",\n\t\t  c->leb_size, c->leb_size >> 10, c->min_io_size,\n\t\t  c->max_write_size);\n\tubifs_msg(\"FS size: %lld bytes (%lld MiB, %d LEBs), journal size %lld bytes (%lld MiB, %d LEBs)\",\n\t\t  x, x >> 20, c->main_lebs,\n\t\t  y, y >> 20, c->log_lebs + c->max_bud_cnt);\n\tubifs_msg(\"reserved for root: %llu bytes (%llu KiB)\",\n\t\t  c->report_rp_size, c->report_rp_size >> 10);\n\tubifs_msg(\"media format: w%d/r%d (latest is w%d/r%d), UUID %pUB%s\",\n\t\t  c->fmt_version, c->ro_compat_version,\n\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION, c->uuid,\n\t\t  c->big_lpt ? \", big LPT model\" : \", small LPT model\");\n\n\tdbg_gen(\"default compressor:  %s\", ubifs_compr_name(c->default_compr));\n\tdbg_gen(\"data journal heads:  %d\",\n\t\tc->jhead_cnt - NONDATA_JHEADS_CNT);\n\tdbg_gen(\"log LEBs:            %d (%d - %d)\",\n\t\tc->log_lebs, UBIFS_LOG_LNUM, c->log_last);\n\tdbg_gen(\"LPT area LEBs:       %d (%d - %d)\",\n\t\tc->lpt_lebs, c->lpt_first, c->lpt_last);\n\tdbg_gen(\"orphan area LEBs:    %d (%d - %d)\",\n\t\tc->orph_lebs, c->orph_first, c->orph_last);\n\tdbg_gen(\"main area LEBs:      %d (%d - %d)\",\n\t\tc->main_lebs, c->main_first, c->leb_cnt - 1);\n\tdbg_gen(\"index LEBs:          %d\", c->lst.idx_lebs);\n\tdbg_gen(\"total index bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->bi.old_idx_sz, c->bi.old_idx_sz >> 10,\n\t\tc->bi.old_idx_sz >> 20);\n\tdbg_gen(\"key hash type:       %d\", c->key_hash_type);\n\tdbg_gen(\"tree fanout:         %d\", c->fanout);\n\tdbg_gen(\"reserved GC LEB:     %d\", c->gc_lnum);\n\tdbg_gen(\"max. znode size      %d\", c->max_znode_sz);\n\tdbg_gen(\"max. index node size %d\", c->max_idx_node_sz);\n\tdbg_gen(\"node sizes:          data %zu, inode %zu, dentry %zu\",\n\t\tUBIFS_DATA_NODE_SZ, UBIFS_INO_NODE_SZ, UBIFS_DENT_NODE_SZ);\n\tdbg_gen(\"node sizes:          trun %zu, sb %zu, master %zu\",\n\t\tUBIFS_TRUN_NODE_SZ, UBIFS_SB_NODE_SZ, UBIFS_MST_NODE_SZ);\n\tdbg_gen(\"node sizes:          ref %zu, cmt. start %zu, orph %zu\",\n\t\tUBIFS_REF_NODE_SZ, UBIFS_CS_NODE_SZ, UBIFS_ORPH_NODE_SZ);\n\tdbg_gen(\"max. node sizes:     data %zu, inode %zu dentry %zu, idx %d\",\n\t\tUBIFS_MAX_DATA_NODE_SZ, UBIFS_MAX_INO_NODE_SZ,\n\t\tUBIFS_MAX_DENT_NODE_SZ, ubifs_idx_node_sz(c, c->fanout));\n\tdbg_gen(\"dead watermark:      %d\", c->dead_wm);\n\tdbg_gen(\"dark watermark:      %d\", c->dark_wm);\n\tdbg_gen(\"LEB overhead:        %d\", c->leb_overhead);\n\tx = (long long)c->main_lebs * c->dark_wm;\n\tdbg_gen(\"max. dark space:     %lld (%lld KiB, %lld MiB)\",\n\t\tx, x >> 10, x >> 20);\n\tdbg_gen(\"maximum bud bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->max_bud_bytes, c->max_bud_bytes >> 10,\n\t\tc->max_bud_bytes >> 20);\n\tdbg_gen(\"BG commit bud bytes: %lld (%lld KiB, %lld MiB)\",\n\t\tc->bg_bud_bytes, c->bg_bud_bytes >> 10,\n\t\tc->bg_bud_bytes >> 20);\n\tdbg_gen(\"current bud bytes    %lld (%lld KiB, %lld MiB)\",\n\t\tc->bud_bytes, c->bud_bytes >> 10, c->bud_bytes >> 20);\n\tdbg_gen(\"max. seq. number:    %llu\", c->max_sqnum);\n\tdbg_gen(\"commit number:       %llu\", c->cmt_no);\n\n\treturn 0;\n\nout_infos:\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\nout_orphans:\n\tfree_orphans(c);\nout_journal:\n\tdestroy_journal(c);\nout_lpt:\n\tubifs_lpt_free(c, 0);\nout_master:\n\tkfree(c->mst_node);\n\tkfree(c->rcvrd_mst_node);\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\nout_wbufs:\n\tfree_wbufs(c);\nout_cbuf:\n\tkfree(c->cbuf);\nout_free:\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tubifs_debugging_exit(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ng_exit(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_up",
          "args": [
            "buf);\n\tubifs_deb"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tk",
          "args": [
            "ree(c->"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "vfree(c->"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf);",
          "args": [
            "vfree(c->"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_res",
          "args": [
            "rve_buf);\n\tkfree(c->"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_resv_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3367-3394",
          "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\nou",
          "args": [
            "_free:"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\nout_cbuf",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bgt);\nout",
          "args": [
            "wbufs:"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mst",
          "args": [
            "node);\n\tif (c->bg"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "cvrd_mst_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "386-400",
          "snippet": "te_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nte_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l"
        }
      },
      {
        "call_info": {
          "callee": "node)",
          "args": [
            "kfree(c->"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, 0);\nout_m",
          "args": [
            "s",
            "r"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al(c);\nout_lpt:",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\nout_jour",
          "args": [
            "a"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\nout_orphan"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "infos_li",
          "args": [
            "t);\n\tspin_unlo"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\tlist_del("
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it numb",
          "args": [
            "r:       %llu\", c->cmt_no);",
            "return 0"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq. n",
          "args": [
            "mber:    %llu\", c->max_sqnu",
            ";\n\tdbg_gen(\""
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent bud",
          "args": [
            "bytes    %lld (%lld KiB, %lld MiB)\",\n\t\tc->bud_by",
            "c->bud_byte",
            ">> 10, c->bud_byte",
            ">> 20);\n\tdbg_gen(\""
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommit b",
          "args": [
            "d bytes: %lld (%lld KiB, %lld MiB)\",\n\t\tc->bg_bud",
            "es, c->bg_bud_b",
            "es >> 10,\n\t\tc->bg_bud",
            "es >> 20);\n\tdbg_gen(\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mum bud",
          "args": [
            "bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->max_bu",
            "tes, c->max_bud_",
            "tes >> 10,\n\t\tc->max_bu",
            "tes >> 20);\n\tdbg_gen(\""
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dark s",
          "args": [
            "ace:     %lld (%lld KiB, %lld MiB)\",\n\t\tx, x >> 1",
            "20);",
            "g_gen(\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overhea",
          "args": [
            ":        %d\", c->leb_over",
            "ad);\n\tx = (long"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_overhead_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "72-80",
          "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waterm",
          "args": [
            "rk:      %d\", c->dark_wm)",
            "dbg_gen(\""
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waterm",
          "args": [
            "rk:      %d\", c->dead_wm)",
            "dbg_gen(\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node s",
          "args": [
            "zes:     data %zu, inode %zu dentry %zu, idx %d\",\n\t\tUBIFS_MAX",
            "A_NODE_SZ, UBIFS_MAX_I",
            "_NODE_SZ,\n\t\tUBIFS_MAX",
            "T_NODE_SZ, ubifs_idx_n",
            "e_sz(c, c->fanout));\n\tdbg_gen(\""
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->fanout",
          "args": [
            ")",
            "dbg_gen("
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizes:",
          "args": [
            "ref %zu, cmt. start %zu, orph %zu\",\n\t\tUBIFS_REF",
            "E_SZ, UBIFS_CS_NO",
            "_SZ, UBIFS_ORPH_",
            "DE_SZ);\n\tdbg_gen(\""
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizes:",
          "args": [
            "trun %zu, sb %zu, master %zu\",\n\t\tUBIFS_TRU",
            "DE_SZ, UBIFS_SB_NO",
            "_SZ, UBIFS_MST_N",
            "E_SZ);\n\tdbg_gen(\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizes:",
          "args": [
            "data %zu, inode %zu, dentry %zu\",\n\t\tUBIFS_DAT",
            "DE_SZ, UBIFS_INO_N",
            "E_SZ, UBIFS_DENT_",
            "DE_SZ);\n\tdbg_gen(\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index",
          "args": [
            "ode size %d\", c->max_idx_",
            "de_sz);\n\tdbg_gen(\""
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "_index(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/commit.c",
          "lines": "565-734",
          "snippet": "_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint lnum, offs, len, err = 0, uninitialized_var(last_level), child_cnt;\n\tint first = 1, iip;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tunion ubifs_key uninitialized_var(lower_key), upper_key, l_key, u_key;\n\tunsigned long long uninitialized_var(last_sqnum);\n\tstruct ubifs_idx_node *idx;\n\tstruct list_head list;\n\tstruct idx_node *i;\n\tsize_t sz;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&list);\n\n\tsz = sizeof(struct idx_node) + ubifs_idx_node_sz(c, c->fanout) -\n\t     UBIFS_IDX_NODE_SZ;\n\n\t/* Start at the old zroot */\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\tiip = 0;\n\n\t/*\n\t * Traverse the index tree preorder depth-first i.e. do a node and then\n\t * its subtrees from left to right.\n\t */\n\twhile (1) {\n\t\tstruct ubifs_branch *br;\n\n\t\t/* Get the next index node */\n\t\ti = kmalloc(sz, GFP_NOFS);\n\t\tif (!i) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\ti->iip = iip;\n\t\t/* Keep the index nodes on our path in a linked list */\n\t\tlist_add_tail(&i->list, &list);\n\t\t/* Read the index node */\n\t\tidx = &i->idx;\n\t\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\t/* Validate index node */\n\t\tchild_cnt = le16_to_cpu(idx->child_cnt);\n\t\tif (child_cnt < 1 || child_cnt > c->fanout) {\n\t\t\terr = 1;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\t/* Check root level and sqnum */\n\t\t\tif (le16_to_cpu(idx->level) != d->old_zroot_level) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (le64_to_cpu(idx->ch.sqnum) != d->old_zroot_sqnum) {\n\t\t\t\terr = 3;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\t/* Set last values as though root had a parent */\n\t\t\tlast_level = le16_to_cpu(idx->level) + 1;\n\t\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum) + 1;\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &lower_key);\n\t\t\thighest_ino_key(c, &upper_key, INUM_WATERMARK);\n\t\t}\n\t\tkey_copy(c, &upper_key, &i->upper_key);\n\t\tif (le16_to_cpu(idx->level) != last_level - 1) {\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/*\n\t\t * The index is always written bottom up hence a child's sqnum\n\t\t * is always less than the parents.\n\t\t */\n\t\tif (le64_to_cpu(idx->ch.sqnum) >= last_sqnum) {\n\t\t\terr = 4;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/* Check key range */\n\t\tkey_read(c, ubifs_idx_key(c, idx), &l_key);\n\t\tbr = ubifs_idx_branch(c, idx, child_cnt - 1);\n\t\tkey_read(c, &br->key, &u_key);\n\t\tif (keys_cmp(c, &lower_key, &l_key) > 0) {\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) < 0) {\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) == 0)\n\t\t\tif (!is_hash_key(c, &u_key)) {\n\t\t\t\terr = 7;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t/* Go to next index node */\n\t\tif (le16_to_cpu(idx->level) == 0) {\n\t\t\t/* At the bottom, so go up until can go right */\n\t\t\twhile (1) {\n\t\t\t\t/* Drop the bottom of the list */\n\t\t\t\tlist_del(&i->list);\n\t\t\t\tkfree(i);\n\t\t\t\t/* No more list means we are done */\n\t\t\t\tif (list_empty(&list))\n\t\t\t\t\tgoto out;\n\t\t\t\t/* Look at the new bottom */\n\t\t\t\ti = list_entry(list.prev, struct idx_node,\n\t\t\t\t\t       list);\n\t\t\t\tidx = &i->idx;\n\t\t\t\t/* Can we go right */\n\t\t\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\t\t\tiip = iip + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t/* Nope, so go up again */\n\t\t\t\t\tiip = i->iip;\n\t\t\t}\n\t\t} else\n\t\t\t/* Go down left */\n\t\t\tiip = 0;\n\t\t/*\n\t\t * We have the parent in 'idx' and now we set up for reading the\n\t\t * child pointed to by slot 'iip'.\n\t\t */\n\t\tlast_level = le16_to_cpu(idx->level);\n\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum);\n\t\tbr = ubifs_idx_branch(c, idx, iip);\n\t\tlnum = le32_to_cpu(br->lnum);\n\t\toffs = le32_to_cpu(br->offs);\n\t\tlen = le32_to_cpu(br->len);\n\t\tkey_read(c, &br->key, &lower_key);\n\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\tbr = ubifs_idx_branch(c, idx, iip + 1);\n\t\t\tkey_read(c, &br->key, &upper_key);\n\t\t} else\n\t\t\tkey_copy(c, &i->upper_key, &upper_key);\n\t}\nout:\n\terr = dbg_old_index_check_init(c, zroot);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"dumping index node (iip=%d)\", i->iip);\n\tubifs_dump_node(c, idx);\n\tlist_del(&i->list);\n\tkfree(i);\n\tif (!list_empty(&list)) {\n\t\ti = list_entry(list.prev, struct idx_node, list);\n\t\tubifs_err(\"dumping parent index node\");\n\t\tubifs_dump_node(c, &i->idx);\n\t}\nout_free:\n\twhile (!list_empty(&list)) {\n\t\ti = list_entry(list.next, struct idx_node, list);\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n\tubifs_err(\"failed, error %d\", err);\n\tif (err > 0)\n\t\terr = -EINVAL;\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/*\n * nothin",
            "ux/slab.h>\n#include \"ubi",
            "ux/kthread.h>\n#include <lin",
            "ux/freezer.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * nothin\nux/slab.h>\n#include \"ubi\nux/kthread.h>\n#include <lin\nux/freezer.h>\n#include <lin\n\n_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint lnum, offs, len, err = 0, uninitialized_var(last_level), child_cnt;\n\tint first = 1, iip;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tunion ubifs_key uninitialized_var(lower_key), upper_key, l_key, u_key;\n\tunsigned long long uninitialized_var(last_sqnum);\n\tstruct ubifs_idx_node *idx;\n\tstruct list_head list;\n\tstruct idx_node *i;\n\tsize_t sz;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&list);\n\n\tsz = sizeof(struct idx_node) + ubifs_idx_node_sz(c, c->fanout) -\n\t     UBIFS_IDX_NODE_SZ;\n\n\t/* Start at the old zroot */\n\tlnum = d->old_zroot.lnum;\n\toffs = d->old_zroot.offs;\n\tlen = d->old_zroot.len;\n\tiip = 0;\n\n\t/*\n\t * Traverse the index tree preorder depth-first i.e. do a node and then\n\t * its subtrees from left to right.\n\t */\n\twhile (1) {\n\t\tstruct ubifs_branch *br;\n\n\t\t/* Get the next index node */\n\t\ti = kmalloc(sz, GFP_NOFS);\n\t\tif (!i) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\ti->iip = iip;\n\t\t/* Keep the index nodes on our path in a linked list */\n\t\tlist_add_tail(&i->list, &list);\n\t\t/* Read the index node */\n\t\tidx = &i->idx;\n\t\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\t/* Validate index node */\n\t\tchild_cnt = le16_to_cpu(idx->child_cnt);\n\t\tif (child_cnt < 1 || child_cnt > c->fanout) {\n\t\t\terr = 1;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\t/* Check root level and sqnum */\n\t\t\tif (le16_to_cpu(idx->level) != d->old_zroot_level) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (le64_to_cpu(idx->ch.sqnum) != d->old_zroot_sqnum) {\n\t\t\t\terr = 3;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\t/* Set last values as though root had a parent */\n\t\t\tlast_level = le16_to_cpu(idx->level) + 1;\n\t\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum) + 1;\n\t\t\tkey_read(c, ubifs_idx_key(c, idx), &lower_key);\n\t\t\thighest_ino_key(c, &upper_key, INUM_WATERMARK);\n\t\t}\n\t\tkey_copy(c, &upper_key, &i->upper_key);\n\t\tif (le16_to_cpu(idx->level) != last_level - 1) {\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/*\n\t\t * The index is always written bottom up hence a child's sqnum\n\t\t * is always less than the parents.\n\t\t */\n\t\tif (le64_to_cpu(idx->ch.sqnum) >= last_sqnum) {\n\t\t\terr = 4;\n\t\t\tgoto out_dump;\n\t\t}\n\t\t/* Check key range */\n\t\tkey_read(c, ubifs_idx_key(c, idx), &l_key);\n\t\tbr = ubifs_idx_branch(c, idx, child_cnt - 1);\n\t\tkey_read(c, &br->key, &u_key);\n\t\tif (keys_cmp(c, &lower_key, &l_key) > 0) {\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) < 0) {\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (keys_cmp(c, &upper_key, &u_key) == 0)\n\t\t\tif (!is_hash_key(c, &u_key)) {\n\t\t\t\terr = 7;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t/* Go to next index node */\n\t\tif (le16_to_cpu(idx->level) == 0) {\n\t\t\t/* At the bottom, so go up until can go right */\n\t\t\twhile (1) {\n\t\t\t\t/* Drop the bottom of the list */\n\t\t\t\tlist_del(&i->list);\n\t\t\t\tkfree(i);\n\t\t\t\t/* No more list means we are done */\n\t\t\t\tif (list_empty(&list))\n\t\t\t\t\tgoto out;\n\t\t\t\t/* Look at the new bottom */\n\t\t\t\ti = list_entry(list.prev, struct idx_node,\n\t\t\t\t\t       list);\n\t\t\t\tidx = &i->idx;\n\t\t\t\t/* Can we go right */\n\t\t\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\t\t\tiip = iip + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t/* Nope, so go up again */\n\t\t\t\t\tiip = i->iip;\n\t\t\t}\n\t\t} else\n\t\t\t/* Go down left */\n\t\t\tiip = 0;\n\t\t/*\n\t\t * We have the parent in 'idx' and now we set up for reading the\n\t\t * child pointed to by slot 'iip'.\n\t\t */\n\t\tlast_level = le16_to_cpu(idx->level);\n\t\tlast_sqnum = le64_to_cpu(idx->ch.sqnum);\n\t\tbr = ubifs_idx_branch(c, idx, iip);\n\t\tlnum = le32_to_cpu(br->lnum);\n\t\toffs = le32_to_cpu(br->offs);\n\t\tlen = le32_to_cpu(br->len);\n\t\tkey_read(c, &br->key, &lower_key);\n\t\tif (iip + 1 < le16_to_cpu(idx->child_cnt)) {\n\t\t\tbr = ubifs_idx_branch(c, idx, iip + 1);\n\t\t\tkey_read(c, &br->key, &upper_key);\n\t\t} else\n\t\t\tkey_copy(c, &i->upper_key, &upper_key);\n\t}\nout:\n\terr = dbg_old_index_check_init(c, zroot);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"dumping index node (iip=%d)\", i->iip);\n\tubifs_dump_node(c, idx);\n\tlist_del(&i->list);\n\tkfree(i);\n\tif (!list_empty(&list)) {\n\t\ti = list_entry(list.prev, struct idx_node, list);\n\t\tubifs_err(\"dumping parent index node\");\n\t\tubifs_dump_node(c, &i->idx);\n\t}\nout_free:\n\twhile (!list_empty(&list)) {\n\t\ti = list_entry(list.next, struct idx_node, list);\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n\tubifs_err(\"failed, error %d\", err);\n\tif (err > 0)\n\t\terr = -EINVAL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "znode",
          "args": [
            "ize      %d\", c->max_znod",
            "sz);\n\tdbg_gen(\""
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "dx_znode(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "140-167",
          "snippet": "s_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ns_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest"
        }
      },
      {
        "call_info": {
          "callee": "rved GC",
          "args": [
            "LEB:     %d\", c->gc_lnum)",
            "dbg_gen(\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanout",
          "args": [
            "%d\", c->fanout);",
            "dbg_gen(\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash ty",
          "args": [
            "e:       %d\", c->key_hash",
            "ype);\n\tdbg_gen(\""
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l index",
          "args": [
            "bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->bi.old",
            "_sz, c->bi.old_i",
            "_sz >> 10,\n\t\tc->bi.old",
            "_sz >> 20);\n\tdbg_gen(\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x LEBs:",
          "args": [
            "%d\", c->lst.idx_",
            "bs);\n\tdbg_gen(\""
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "area L",
          "args": [
            "Bs:      %d (%d - %d)\",\n\t\tc->main_l",
            "c->main_fir",
            ", c->leb_cnt",
            "1);\n\tdbg_gen(\""
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an area",
          "args": [
            "LEBs:    %d (%d - %d)\",\n\t\tc->orph_l",
            "c->orph_fir",
            ", c->orph_las",
            ";\n\tdbg_gen(\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "area LE",
          "args": [
            "s:       %d (%d - %d)\",\n\t\tc->lpt_le",
            "c->lpt_firs",
            "c->lpt_last",
            "dbg_gen(\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEBs:",
          "args": [
            "%d (%d - %d)\",\n\t\tc->log_le",
            "UBIFS_LOG_L",
            "M, c->log_last",
            "dbg_gen(\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journa",
          "args": [
            "heads:  %d\",\n\t\tc->jhead_",
            "- NONDATA_JHEADS_CNT);\n\tdbg_gen(\""
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_journal_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2527-2557",
          "snippet": "static void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);",
            "static void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);",
            "static void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);",
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ult com",
          "args": [
            "ressor:  %s\", ubifs_compr",
            "ame(c->default_compr));\n\tdbg_gen(\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame(c->default_c",
          "args": [
            "mpr));\n\tdbg_gen("
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dia forma",
          "args": [
            ": w%d/r%d (latest is w%d/r%d), UUID %pUB%s\",\n\t\t  c->fmt_",
            "n, c->ro_compa",
            "version,\n\t\t  UBIFS_F",
            "VERSION, UBIFS_RO_CO",
            "AT_VERSION, c->uuid,",
            "c->big_",
            "\", big LPT model\" : \", small LPT model\");\n\n\tdbg_gen("
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "served fo",
          "args": [
            "root: %llu bytes (%llu KiB)\",\n\t\t  c->repo",
            "size, c->report_r",
            "size >> 10);\n\tubifs_msg"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size: %l",
          "args": [
            "d bytes (%lld MiB, %d LEBs), journal size %lld bytes (%lld MiB, %d LEBs)\",\n\t\t  x, x >>",
            "-",
            "ain_leb",
            "y, y >>",
            "-",
            "og_lebs",
            "c->max_bud_cnt);\n\tubifs_msg"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B size: %",
          "args": [
            "bytes (%d KiB), min./max. I/O unit sizes: %d bytes/%d bytes\",\n\t\t  c->leb_",
            "c->leb_size",
            "> 10, c->min_io_s",
            "e,\n\t\t  c->max_",
            "size);\n\tubifs_msg"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unted UBI",
          "args": [
            "device %d, volume %d, name \\\"%s\\\"%s\",\n\t\t  c->vi.u",
            ", c->vi.vol_i",
            "c->vi.name,",
            "c->ro_m",
            "\", R/O mode\" : \"\");\n\tx = (long"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_fs(c);\n\tif (err",
          "args": [],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esystem(c);\n\tif (err",
          "args": [],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst.taken",
          "args": [
            "empty_lebs > 0);\n\n\terr = db"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lst.taken",
          "args": [
            "empty_lebs > 0);\n\t\t}\n\t} els"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery co",
          "args": [
            "pleted\");\n\t\t\t/*"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery de",
          "args": [
            "erred\");\n\t\telse {"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_infos",
          "args": [
            "lock);\n\n\tif (c->n"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&c->infos_li",
          "args": [
            "t, &ubifs_info",
            ";\n\tspin_unlo"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifs_infos",
          "args": [
            "lock);\n\tlist_add_"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, c->gc_lnu",
          "args": [
            ")",
            "if (err"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_commit(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date_log(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ace(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rphans(c, c->need_r",
          "args": [
            "c",
            "ery, c->ro_mount",
            "if (err)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\n\terr =",
          "args": [
            "b"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal(c);\n\tif (err",
          "args": [],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size(c, c->bi.old",
          "args": [
            "i",
            "_sz);\n\tif (err)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aster(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\t\terr = ub"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_space(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, 1, !c->ro",
          "args": [
            "m",
            "n",
            ";\n\tif (err)"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_inl_heads(c, c->sbuf);",
          "args": [
            "f (err)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery ne",
          "args": [
            "ded\");\n\t\tc->need_"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY)) != 0) {"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_master(c);\n\n\tif ((c",
          "args": [
            ">"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ster(c);\n\tif (err",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss(c->bgt);\n\t}",
          "args": [
            "err ="
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot spaw",
          "args": [
            "\\\"%s\\\", error %d\",\n\t\t\t\t  c->bg",
            "err);\n\t\t\tgo",
            "ou"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t);",
          "args": [
            "->bgt"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(ubifs_bg_thr",
          "args": [
            "ad, c, \"%s\", c-",
            "g",
            "name",
            "if (IS_E"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_name,",
          "args": [
            "BGT_NAME_PA",
            "ERN, c->vi.ubi_n",
            ", c->vi.vol_i",
            ";\n\tif (!c->r"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FP_NOFS",
          "args": [
            ";",
            "f (!c->c"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">max_",
          "args": [
            "dx_node_sz, c->min_io_s",
            "e);\n\tc->cbuf ="
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idx_n",
          "args": [
            "de_sz, c->min_io_s",
            "e);\n\tsz = ALIG"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sb(c);\n\tif (err",
          "args": [],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ompressor",
          "args": [
            "\\\"%s\\\" is not compiled in\",\n\t\t\t  ubifs_",
            "ame(c->default_compr));\n\t\terr = -E"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompressor_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "28-59",
          "snippet": "void *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct squashfs_stream __percpu *percpu;\n\tint err, cpu;\n\n\tpercpu = alloc_percpu(struct squashfs_stream);\n\tif (percpu == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tstream->stream = msblk->decompressor->init(msblk, comp_opts);\n\t\tif (IS_ERR(stream->stream)) {\n\t\t\terr = PTR_ERR(stream->stream);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkfree(comp_opts);\n\treturn (__force void *) percpu;\n\nout:\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tif (!IS_ERR_OR_NULL(stream->stream))\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t}\n\tfree_percpu(percpu);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct squashfs_stream __percpu *percpu;\n\tint err, cpu;\n\n\tpercpu = alloc_percpu(struct squashfs_stream);\n\tif (percpu == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tstream->stream = msblk->decompressor->init(msblk, comp_opts);\n\t\tif (IS_ERR(stream->stream)) {\n\t\t\terr = PTR_ERR(stream->stream);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkfree(comp_opts);\n\treturn (__force void *) percpu;\n\nout:\n\tfor_each_possible_cpu(cpu) {\n\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\tif (!IS_ERR_OR_NULL(stream->stream))\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t}\n\tfree_percpu(percpu);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ame(c->default_c",
          "args": [
            "mpr));\n\t\terr = -"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resent(c->default_c",
          "args": [
            "mpr)) {\n\t\tubifs_"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perblock(c);\n\tif (err",
          "args": [],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESSED_D",
          "args": [
            "TA_NODE_BUF_SZ,",
            "if (!c->"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (!c",
          "args": [
            ">"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!c->"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!c->s"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_UP_HE",
          "args": [
            "GHT * sizeof(int), GFP_KERNEL)",
            "if (!c->b"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot moun",
          "args": [
            "read-write - read-only media\");\n\t\terr = -E"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n't forma",
          "args": [
            "empty UBI volume: read-only %s\",\n\t\t\t  c->ro_",
            "\"UBI volume\" : \"mount\");\n\t\terr = -E"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty(c);\n\tif (err",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng_init(c);\n\tif (err",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_early(c);\n\tif (err",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nunt_ubifs(struct ubifs_info *c)\n{\n\tint err;\n\tlong long x, y;\n\tsize_t sz;\n\n\tc->ro_mount = !!(c->vfs_sb->s_flags & MS_RDONLY);\n\t/* Suppress error messages while probing if MS_SILENT is set */\n\tc->probing = !!(c->vfs_sb->s_flags & MS_SILENT);\n\n\terr = init_constants_early(c);\n\tif (err)\n\t\treturn err;\n\n\terr = ubifs_debugging_init(c);\n\tif (err)\n\t\treturn err;\n\n\terr = check_volume_empty(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (c->empty && (c->ro_mount || c->ro_media)) {\n\t\t/*\n\t\t * This UBI volume is empty, and read-only, or the file system\n\t\t * is mounted read-only - we cannot format it.\n\t\t */\n\t\tubifs_err(\"can't format empty UBI volume: read-only %s\",\n\t\t\t  c->ro_media ? \"UBI volume\" : \"mount\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\tif (c->ro_media && !c->ro_mount) {\n\t\tubifs_err(\"cannot mount read-write - read-only media\");\n\t\terr = -EROFS;\n\t\tgoto out_free;\n\t}\n\n\t/*\n\t * The requirement for the buffer is that it should fit indexing B-tree\n\t * height amount of integers. We assume the height if the TNC tree will\n\t * never exceed 64.\n\t */\n\terr = -ENOMEM;\n\tc->bottom_up_buf = kmalloc(BOTTOM_UP_HEIGHT * sizeof(int), GFP_KERNEL);\n\tif (!c->bottom_up_buf)\n\t\tgoto out_free;\n\n\tc->sbuf = vmalloc(c->leb_size);\n\tif (!c->sbuf)\n\t\tgoto out_free;\n\n\tif (!c->ro_mount) {\n\t\tc->ileb_buf = vmalloc(c->leb_size);\n\t\tif (!c->ileb_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tif (c->bulk_read == 1)\n\t\tbu_init(c);\n\n\tif (!c->ro_mount) {\n\t\tc->write_reserve_buf = kmalloc(COMPRESSED_DATA_NODE_BUF_SZ,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!c->write_reserve_buf)\n\t\t\tgoto out_free;\n\t}\n\n\tc->mounting = 1;\n\n\terr = ubifs_read_superblock(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tc->probing = 0;\n\n\t/*\n\t * Make sure the compressor which is set as default in the superblock\n\t * or overridden by mount options is actually compiled in.\n\t */\n\tif (!ubifs_compr_present(c->default_compr)) {\n\t\tubifs_err(\"'compressor \\\"%s\\\" is not compiled in\",\n\t\t\t  ubifs_compr_name(c->default_compr));\n\t\terr = -ENOTSUPP;\n\t\tgoto out_free;\n\t}\n\n\terr = init_constants_sb(c);\n\tif (err)\n\t\tgoto out_free;\n\n\tsz = ALIGN(c->max_idx_node_sz, c->min_io_size);\n\tsz = ALIGN(sz + c->max_idx_node_sz, c->min_io_size);\n\tc->cbuf = kmalloc(sz, GFP_NOFS);\n\tif (!c->cbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = alloc_wbufs(c);\n\tif (err)\n\t\tgoto out_cbuf;\n\n\tsprintf(c->bgt_name, BGT_NAME_PATTERN, c->vi.ubi_num, c->vi.vol_id);\n\tif (!c->ro_mount) {\n\t\t/* Create background thread */\n\t\tc->bgt = kthread_create(ubifs_bg_thread, c, \"%s\", c->bgt_name);\n\t\tif (IS_ERR(c->bgt)) {\n\t\t\terr = PTR_ERR(c->bgt);\n\t\t\tc->bgt = NULL;\n\t\t\tubifs_err(\"cannot spawn \\\"%s\\\", error %d\",\n\t\t\t\t  c->bgt_name, err);\n\t\t\tgoto out_wbufs;\n\t\t}\n\t\twake_up_process(c->bgt);\n\t}\n\n\terr = ubifs_read_master(c);\n\tif (err)\n\t\tgoto out_master;\n\n\tinit_constants_master(c);\n\n\tif ((c->mst_node->flags & cpu_to_le32(UBIFS_MST_DIRTY)) != 0) {\n\t\tubifs_msg(\"recovery needed\");\n\t\tc->need_recovery = 1;\n\t}\n\n\tif (c->need_recovery && !c->ro_mount) {\n\t\terr = ubifs_recover_inl_heads(c, c->sbuf);\n\t\tif (err)\n\t\t\tgoto out_master;\n\t}\n\n\terr = ubifs_lpt_init(c, 1, !c->ro_mount);\n\tif (err)\n\t\tgoto out_master;\n\n\tif (!c->ro_mount && c->space_fixup) {\n\t\terr = ubifs_fixup_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\tif (!c->ro_mount) {\n\t\t/*\n\t\t * Set the \"dirty\" flag so that if we reboot uncleanly we\n\t\t * will notice this immediately on the next mount.\n\t\t */\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t\terr = ubifs_write_master(c);\n\t\tif (err)\n\t\t\tgoto out_lpt;\n\t}\n\n\terr = dbg_check_idx_size(c, c->bi.old_idx_sz);\n\tif (err)\n\t\tgoto out_lpt;\n\n\terr = ubifs_replay_journal(c);\n\tif (err)\n\t\tgoto out_journal;\n\n\t/* Calculate 'min_idx_lebs' after journal replay */\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\terr = ubifs_mount_orphans(c, c->need_recovery, c->ro_mount);\n\tif (err)\n\t\tgoto out_orphans;\n\n\tif (!c->ro_mount) {\n\t\tint lnum;\n\n\t\terr = check_free_space(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\n\t\t/* Check for enough log space */\n\t\tlnum = c->lhead_lnum + 1;\n\t\tif (lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\t\tlnum = UBIFS_LOG_LNUM;\n\t\tif (lnum == c->ltail_lnum) {\n\t\t\terr = ubifs_consolidate_log(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\tif (c->need_recovery) {\n\t\t\terr = ubifs_recover_size(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t\terr = ubifs_rcvry_gc_commit(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t} else {\n\t\t\terr = take_gc_lnum(c);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\n\t\t\t/*\n\t\t\t * GC LEB may contain garbage if there was an unclean\n\t\t\t * reboot, and it should be un-mapped.\n\t\t\t */\n\t\t\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\t\t\tif (err)\n\t\t\t\tgoto out_orphans;\n\t\t}\n\n\t\terr = dbg_check_lprops(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else if (c->need_recovery) {\n\t\terr = ubifs_recover_size(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t} else {\n\t\t/*\n\t\t * Even if we mount read-only, we have to set space in GC LEB\n\t\t * to proper value because this affects UBIFS free space\n\t\t * reporting. We do not want to have a situation when\n\t\t * re-mounting from R/O to R/W changes amount of free space.\n\t\t */\n\t\terr = take_gc_lnum(c);\n\t\tif (err)\n\t\t\tgoto out_orphans;\n\t}\n\n\tspin_lock(&ubifs_infos_lock);\n\tlist_add_tail(&c->infos_list, &ubifs_infos);\n\tspin_unlock(&ubifs_infos_lock);\n\n\tif (c->need_recovery) {\n\t\tif (c->ro_mount)\n\t\t\tubifs_msg(\"recovery deferred\");\n\t\telse {\n\t\t\tc->need_recovery = 0;\n\t\t\tubifs_msg(\"recovery completed\");\n\t\t\t/*\n\t\t\t * GC LEB has to be empty and taken at this point. But\n\t\t\t * the journal head LEBs may also be accounted as\n\t\t\t * \"empty taken\" if they are empty.\n\t\t\t */\n\t\t\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\t\t}\n\t} else\n\t\tubifs_assert(c->lst.taken_empty_lebs > 0);\n\n\terr = dbg_check_filesystem(c);\n\tif (err)\n\t\tgoto out_infos;\n\n\terr = dbg_debugfs_init_fs(c);\n\tif (err)\n\t\tgoto out_infos;\n\n\tc->mounting = 0;\n\n\tubifs_msg(\"mounted UBI device %d, volume %d, name \\\"%s\\\"%s\",\n\t\t  c->vi.ubi_num, c->vi.vol_id, c->vi.name,\n\t\t  c->ro_mount ? \", R/O mode\" : \"\");\n\tx = (long long)c->main_lebs * c->leb_size;\n\ty = (long long)c->log_lebs * c->leb_size + c->max_bud_bytes;\n\tubifs_msg(\"LEB size: %d bytes (%d KiB), min./max. I/O unit sizes: %d bytes/%d bytes\",\n\t\t  c->leb_size, c->leb_size >> 10, c->min_io_size,\n\t\t  c->max_write_size);\n\tubifs_msg(\"FS size: %lld bytes (%lld MiB, %d LEBs), journal size %lld bytes (%lld MiB, %d LEBs)\",\n\t\t  x, x >> 20, c->main_lebs,\n\t\t  y, y >> 20, c->log_lebs + c->max_bud_cnt);\n\tubifs_msg(\"reserved for root: %llu bytes (%llu KiB)\",\n\t\t  c->report_rp_size, c->report_rp_size >> 10);\n\tubifs_msg(\"media format: w%d/r%d (latest is w%d/r%d), UUID %pUB%s\",\n\t\t  c->fmt_version, c->ro_compat_version,\n\t\t  UBIFS_FORMAT_VERSION, UBIFS_RO_COMPAT_VERSION, c->uuid,\n\t\t  c->big_lpt ? \", big LPT model\" : \", small LPT model\");\n\n\tdbg_gen(\"default compressor:  %s\", ubifs_compr_name(c->default_compr));\n\tdbg_gen(\"data journal heads:  %d\",\n\t\tc->jhead_cnt - NONDATA_JHEADS_CNT);\n\tdbg_gen(\"log LEBs:            %d (%d - %d)\",\n\t\tc->log_lebs, UBIFS_LOG_LNUM, c->log_last);\n\tdbg_gen(\"LPT area LEBs:       %d (%d - %d)\",\n\t\tc->lpt_lebs, c->lpt_first, c->lpt_last);\n\tdbg_gen(\"orphan area LEBs:    %d (%d - %d)\",\n\t\tc->orph_lebs, c->orph_first, c->orph_last);\n\tdbg_gen(\"main area LEBs:      %d (%d - %d)\",\n\t\tc->main_lebs, c->main_first, c->leb_cnt - 1);\n\tdbg_gen(\"index LEBs:          %d\", c->lst.idx_lebs);\n\tdbg_gen(\"total index bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->bi.old_idx_sz, c->bi.old_idx_sz >> 10,\n\t\tc->bi.old_idx_sz >> 20);\n\tdbg_gen(\"key hash type:       %d\", c->key_hash_type);\n\tdbg_gen(\"tree fanout:         %d\", c->fanout);\n\tdbg_gen(\"reserved GC LEB:     %d\", c->gc_lnum);\n\tdbg_gen(\"max. znode size      %d\", c->max_znode_sz);\n\tdbg_gen(\"max. index node size %d\", c->max_idx_node_sz);\n\tdbg_gen(\"node sizes:          data %zu, inode %zu, dentry %zu\",\n\t\tUBIFS_DATA_NODE_SZ, UBIFS_INO_NODE_SZ, UBIFS_DENT_NODE_SZ);\n\tdbg_gen(\"node sizes:          trun %zu, sb %zu, master %zu\",\n\t\tUBIFS_TRUN_NODE_SZ, UBIFS_SB_NODE_SZ, UBIFS_MST_NODE_SZ);\n\tdbg_gen(\"node sizes:          ref %zu, cmt. start %zu, orph %zu\",\n\t\tUBIFS_REF_NODE_SZ, UBIFS_CS_NODE_SZ, UBIFS_ORPH_NODE_SZ);\n\tdbg_gen(\"max. node sizes:     data %zu, inode %zu dentry %zu, idx %d\",\n\t\tUBIFS_MAX_DATA_NODE_SZ, UBIFS_MAX_INO_NODE_SZ,\n\t\tUBIFS_MAX_DENT_NODE_SZ, ubifs_idx_node_sz(c, c->fanout));\n\tdbg_gen(\"dead watermark:      %d\", c->dead_wm);\n\tdbg_gen(\"dark watermark:      %d\", c->dark_wm);\n\tdbg_gen(\"LEB overhead:        %d\", c->leb_overhead);\n\tx = (long long)c->main_lebs * c->dark_wm;\n\tdbg_gen(\"max. dark space:     %lld (%lld KiB, %lld MiB)\",\n\t\tx, x >> 10, x >> 20);\n\tdbg_gen(\"maximum bud bytes:   %lld (%lld KiB, %lld MiB)\",\n\t\tc->max_bud_bytes, c->max_bud_bytes >> 10,\n\t\tc->max_bud_bytes >> 20);\n\tdbg_gen(\"BG commit bud bytes: %lld (%lld KiB, %lld MiB)\",\n\t\tc->bg_bud_bytes, c->bg_bud_bytes >> 10,\n\t\tc->bg_bud_bytes >> 20);\n\tdbg_gen(\"current bud bytes    %lld (%lld KiB, %lld MiB)\",\n\t\tc->bud_bytes, c->bud_bytes >> 10, c->bud_bytes >> 20);\n\tdbg_gen(\"max. seq. number:    %llu\", c->max_sqnum);\n\tdbg_gen(\"commit number:       %llu\", c->cmt_no);\n\n\treturn 0;\n\nout_infos:\n\tspin_lock(&ubifs_infos_lock);\n\tlist_del(&c->infos_list);\n\tspin_unlock(&ubifs_infos_lock);\nout_orphans:\n\tfree_orphans(c);\nout_journal:\n\tdestroy_journal(c);\nout_lpt:\n\tubifs_lpt_free(c, 0);\nout_master:\n\tkfree(c->mst_node);\n\tkfree(c->rcvrd_mst_node);\n\tif (c->bgt)\n\t\tkthread_stop(c->bgt);\nout_wbufs:\n\tfree_wbufs(c);\nout_cbuf:\n\tkfree(c->cbuf);\nout_free:\n\tkfree(c->write_reserve_buf);\n\tkfree(c->bu.buf);\n\tvfree(c->ileb_buf);\n\tvfree(c->sbuf);\n\tkfree(c->bottom_up_buf);\n\tubifs_debugging_exit(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ace(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1123-1133",
    "snippet": "eck_free_space(struct ubifs_info *c)\n{\n\tubifs_assert(c->dark_wm > 0);\n\tif (c->lst.total_free + c->lst.total_dirty < c->dark_wm) {\n\t\tubifs_err(\"insufficient free space to mount in R/W mode\");\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n/**\n * moun",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rops(c);\n\t\treturn",
          "args": [
            "-"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "ifs_du"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sufficien",
          "args": [
            "free space to mount in R/W mode\");\n\t\tubifs_du"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->dark_wm >",
          "args": [
            "0);\n\tif (c->ls"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\neck_free_space(struct ubifs_info *c)\n{\n\tubifs_assert(c->dark_wm > 0);\n\tif (c->lst.total_free + c->lst.total_dirty < c->dark_wm) {\n\t\tubifs_err(\"insufficient free space to mount in R/W mode\");\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n/**\n * moun"
  },
  {
    "function_name": "t ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1092-1114",
    "snippet": "u_init(struct ubifs_info *c)\n{\n\tubifs_assert(c->bulk_read == 1);\n\n\tif (c->bu.buf)\n\t\treturn; /* Already initialized */\n\nagain:\n\tc->bu.buf = kmalloc(c->max_bu_buf_len, GFP_KERNEL | __GFP_NOWARN);\n\tif (!c->bu.buf) {\n\t\tif (c->max_bu_buf_len > UBIFS_KMALLOC_OK) {\n\t\t\tc->max_bu_buf_len = UBIFS_KMALLOC_OK;\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Just disable bulk-read */\n\t\tubifs_warn(\"cannot allocate %d bytes of memory for bulk-read, disabling it\",\n\t\t\t   c->max_bu_buf_len);\n\t\tc->mount_opts.bulk_read = 1;\n\t\tc->bulk_read = 0;\n\t\treturn;\n\t}\n}\n\n/**\n * chec",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "annot allo",
          "args": [
            "ate %d bytes of memory for bulk-read, disabling it\",\n\t\t\t   c->ma",
            "_len);\n\t\tc->mount"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_bu_bu",
          "args": [
            "_len, GFP_KERNEL",
            "__GFP_NOWARN);\n\tif (!c->b"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bulk_read",
          "args": [
            "== 1);\n\n\tif (c->b"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nu_init(struct ubifs_info *c)\n{\n\tubifs_assert(c->bulk_read == 1);\n\n\tif (c->bu.buf)\n\t\treturn; /* Already initialized */\n\nagain:\n\tc->bu.buf = kmalloc(c->max_bu_buf_len, GFP_KERNEL | __GFP_NOWARN);\n\tif (!c->bu.buf) {\n\t\tif (c->max_bu_buf_len > UBIFS_KMALLOC_OK) {\n\t\t\tc->max_bu_buf_len = UBIFS_KMALLOC_OK;\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* Just disable bulk-read */\n\t\tubifs_warn(\"cannot allocate %d bytes of memory for bulk-read, disabling it\",\n\t\t\t   c->max_bu_buf_len);\n\t\tc->mount_opts.bulk_read = 1;\n\t\tc->bulk_read = 0;\n\t\treturn;\n\t}\n}\n\n/**\n * chec"
  },
  {
    "function_name": "al(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "1065-1086",
    "snippet": "estroy_journal(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tubifs_destroy_idx_gc(c);\n\tubifs_destroy_size_tree(c);\n\tubifs_tnc_close(c);\n\tfree_buds(c);\n}\n\n/**\n * bu_i",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/**",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "se(c);\n\tfree_bu",
          "args": [
            "s"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size_tree(c);\n\tubifs_t",
          "args": [
            "c"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx_gc(c);\n\tubifs_d",
          "args": [
            "s"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tub",
          "args": [
            "fs_"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->list);",
          "args": [
            "kfree(bu"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">old_buds.",
          "args": [
            "ext, struct ubif",
            "bud, lst);\n\t\tli",
            "_del"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->old_buds",
          "args": [
            ") {\n\t\tstruct"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "hile"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->list",
          "args": [
            ";\n\t\tkfree(uc"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">unclean_l",
          "args": [
            "b_list.next,\n\t\t\t\t   stru",
            "unclea_leb, list);\n\t\tli",
            "_del"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->unclean_",
          "args": [
            "eb_list)) {\n\t\tstruct"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nestroy_journal(struct ubifs_info *c)\n{\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tubifs_destroy_idx_gc(c);\n\tubifs_destroy_size_tree(c);\n\tubifs_tnc_close(c);\n\tfree_buds(c);\n}\n\n/**\n * bu_i"
  },
  {
    "function_name": "ptions(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "972-1056",
    "snippet": "ifs_parse_options(struct ubifs_info *c, char *options,\n\t\t\t       int is_remount)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\t/*\n\t\t * %Opt_fast_unmount and %Opt_norm_unmount options are ignored.\n\t\t * We accept them in order to be backward-compatible. But this\n\t\t * should be removed at some point.\n\t\t */\n\t\tcase Opt_fast_unmount:\n\t\t\tc->mount_opts.unmount_mode = 2;\n\t\t\tbreak;\n\t\tcase Opt_norm_unmount:\n\t\t\tc->mount_opts.unmount_mode = 1;\n\t\t\tbreak;\n\t\tcase Opt_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 2;\n\t\t\tc->bulk_read = 1;\n\t\t\tbreak;\n\t\tcase Opt_no_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 1;\n\t\t\tc->bulk_read = 0;\n\t\t\tbreak;\n\t\tcase Opt_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 2;\n\t\t\tc->no_chk_data_crc = 0;\n\t\t\tbreak;\n\t\tcase Opt_no_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 1;\n\t\t\tc->no_chk_data_crc = 1;\n\t\t\tbreak;\n\t\tcase Opt_override_compr:\n\t\t{\n\t\t\tchar *name = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!strcmp(name, \"none\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_NONE;\n\t\t\telse if (!strcmp(name, \"lzo\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_LZO;\n\t\t\telse if (!strcmp(name, \"zlib\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_ZLIB;\n\t\t\telse {\n\t\t\t\tubifs_err(\"unknown compressor \\\"%s\\\"\", name);\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tc->mount_opts.override_compr = 1;\n\t\t\tc->default_compr = c->mount_opts.compr_type;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tunsigned long flag;\n\t\t\tstruct super_block *sb = c->vfs_sb;\n\n\t\t\tflag = parse_standard_option(p);\n\t\t\tif (!flag) {\n\t\t\t\tubifs_err(\"unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\t\t  p);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsb->s_flags |= flag;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "match_table_t tokens = {\n\t{Opt_fast_unmount, \"fast_unmount\"},\n\t{Opt_norm_unmount, \"norm_unmount\"},\n\t{Opt_bulk_read, \"bulk_read\"},\n\t{Opt_no_bulk_read, \"no_bulk_read\"},\n\t{Opt_chk_data_crc, \"chk_data_crc\"},\n\t{Opt_no_chk_data_crc, \"no_chk_data_crc\"},\n\t{Opt_override_compr, \"compr=%s\"},\n\t{Opt_err, NULL},\n};\n\n/**\n * pars"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recognize",
          "args": [
            "mount option \\\"%s\\\" or missing value\",\n\t\t\t\t\t  p);",
            "n"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_option(p);\n\t\t\tif (!",
          "args": [
            "l"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c-",
          "args": [
            "moun"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "turn"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "or(void *obj)\n{",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
          "lines": "2174-2178",
          "snippet": "node_slab_ctor(void *obj)\n{\n\tstruct ubifs_inode *ui = obj;\n\tinode_init_once(&ui->vfs_inode);\n}\n\nstatic int",
          "includes": [
            "fs.h\"\n\n/*\n * Maximu",
            "ux/writeback.h>\n#include \"ubi",
            "ux/math64.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/seq_file.h>\n#include <lin",
            "ux/parser.h>\n#include <lin",
            "ux/kthread.h>\n#include <lin",
            "ux/ctype.h>\n#include <lin",
            "ux/module.h>\n#include <lin",
            "ux/slab.h>\n#include <lin",
            "ux/init.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nnode_slab_ctor(void *obj)\n{\n\tstruct ubifs_inode *ui = obj;\n\tinode_init_once(&ui->vfs_inode);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "known com",
          "args": [
            "ressor \\\"%s\\\"\", name);",
            "ree("
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"zlib\"",
          "args": [
            ")",
            "c->mou"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"lzo\")",
          "args": [
            "->mou"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"none\"",
          "args": [
            ")",
            "c->mou"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&args[0]);",
          "args": [
            "if (!n"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", tokens, a",
          "args": [
            "g",
            ";\n\t\tsw",
            "ch ("
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns, \",",
          "args": [
            "))) {",
            "t t"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nmatch_table_t tokens = {\n\t{Opt_fast_unmount, \"fast_unmount\"},\n\t{Opt_norm_unmount, \"norm_unmount\"},\n\t{Opt_bulk_read, \"bulk_read\"},\n\t{Opt_no_bulk_read, \"no_bulk_read\"},\n\t{Opt_chk_data_crc, \"chk_data_crc\"},\n\t{Opt_no_chk_data_crc, \"no_chk_data_crc\"},\n\t{Opt_override_compr, \"compr=%s\"},\n\t{Opt_err, NULL},\n};\n\n/**\n * pars;\n\nifs_parse_options(struct ubifs_info *c, char *options,\n\t\t\t       int is_remount)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\"))) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\t/*\n\t\t * %Opt_fast_unmount and %Opt_norm_unmount options are ignored.\n\t\t * We accept them in order to be backward-compatible. But this\n\t\t * should be removed at some point.\n\t\t */\n\t\tcase Opt_fast_unmount:\n\t\t\tc->mount_opts.unmount_mode = 2;\n\t\t\tbreak;\n\t\tcase Opt_norm_unmount:\n\t\t\tc->mount_opts.unmount_mode = 1;\n\t\t\tbreak;\n\t\tcase Opt_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 2;\n\t\t\tc->bulk_read = 1;\n\t\t\tbreak;\n\t\tcase Opt_no_bulk_read:\n\t\t\tc->mount_opts.bulk_read = 1;\n\t\t\tc->bulk_read = 0;\n\t\t\tbreak;\n\t\tcase Opt_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 2;\n\t\t\tc->no_chk_data_crc = 0;\n\t\t\tbreak;\n\t\tcase Opt_no_chk_data_crc:\n\t\t\tc->mount_opts.chk_data_crc = 1;\n\t\t\tc->no_chk_data_crc = 1;\n\t\t\tbreak;\n\t\tcase Opt_override_compr:\n\t\t{\n\t\t\tchar *name = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!strcmp(name, \"none\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_NONE;\n\t\t\telse if (!strcmp(name, \"lzo\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_LZO;\n\t\t\telse if (!strcmp(name, \"zlib\"))\n\t\t\t\tc->mount_opts.compr_type = UBIFS_COMPR_ZLIB;\n\t\t\telse {\n\t\t\t\tubifs_err(\"unknown compressor \\\"%s\\\"\", name);\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tc->mount_opts.override_compr = 1;\n\t\t\tc->default_compr = c->mount_opts.compr_type;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tunsigned long flag;\n\t\t\tstruct super_block *sb = c->vfs_sb;\n\n\t\t\tflag = parse_standard_option(p);\n\t\t\tif (!flag) {\n\t\t\t\tubifs_err(\"unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\t\t  p);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsb->s_flags |= flag;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest"
  },
  {
    "function_name": "d_option(const char *",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "955-961",
    "snippet": "rse_standard_option(const char *option)\n{\n\tubifs_msg(\"parse %s\", option);\n\tif (!strcmp(option, \"sync\"))\n\t\treturn MS_SYNCHRONOUS;\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ", \"syn",
          "args": [
            "\"))",
            "turn M"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rse %s\",",
          "args": [
            "ption);\n\ti",
            "(!strc"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nrse_standard_option(const char *option)\n{\n\tubifs_msg(\"parse %s\", option);\n\tif (!strcmp(option, \"sync\"))\n\t\treturn MS_SYNCHRONOUS;\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "empty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "888-906",
    "snippet": "eck_volume_empty(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tc->empty = 1;\n\tfor (lnum = 0; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_is_mapped(c, lnum);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\tc->empty = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\n/*\n * UBIFS",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\t}\n\n\tretu",
          "args": [],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "< 0))",
          "args": [
            "return"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(c, lnum);",
          "args": [
            "f",
            "unli"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\neck_volume_empty(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tc->empty = 1;\n\tfor (lnum = 0; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_is_mapped(c, lnum);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\tc->empty = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\n/*\n * UBIFS"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "871-877",
    "snippet": "ree_buds(struct ubifs_info *c)\n{\n\tstruct ubifs_bud *bud, *n;\n\n\trbtree_postorder_for_each_entry_safe(bud, n, &c->buds, rb)\n\t\tkfree(bud);\n}\n\n/**\n * chec",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "/**",
          "args": [
            "*"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "der_for_each_entry_safe(bud, n, &c->",
          "args": [
            "uds",
            "r",
            "kfree",
            "ud"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nree_buds(struct ubifs_info *c)\n{\n\tstruct ubifs_bud *bud, *n;\n\n\trbtree_postorder_for_each_entry_safe(bud, n, &c->buds, rb)\n\t\tkfree(bud);\n}\n\n/**\n * chec"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "845-865",
    "snippet": "ree_orphans(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orph;\n\n\twhile (c->orph_dnext) {\n\t\torph = c->orph_dnext;\n\t\tc->orph_dnext = orph->dnext;\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t}\n\n\twhile (!list_empty(&c->orph_list)) {\n\t\torph = list_entry(c->orph_list.next, struct ubifs_orphan, list);\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t\tubifs_err(\"orphan list not empty at unmount\");\n\t}\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_buf)",
          "args": [
            "c->orph_b"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phan list",
          "args": [
            "not empty at unmount\");\n\t}\n\n\tvfree"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubi",
          "args": [
            "s_er"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "id)\n{\n\tubi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
          "lines": "2277-2293",
          "snippet": "_exit ubifs_exit(void)\n{\n\tubifs_assert(list_empty(&ubifs_infos));\n\tubifs_assert(atomic_long_read(&ubifs_clean_zn_cnt) == 0);\n\n\tdbg_debugfs_exit();\n\tubifs_compressors_exit();\n\tunregister_shrinker(&ubifs_shrinker_info);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ubifs_inode_slab);\n\tunregister_filesystem(&ubifs_fs_type);\n}\nmodule_exit(",
          "includes": [
            "fs.h\"\n\n/*\n * Maximu",
            "ux/writeback.h>\n#include \"ubi",
            "ux/math64.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/seq_file.h>\n#include <lin",
            "ux/parser.h>\n#include <lin",
            "ux/kthread.h>\n#include <lin",
            "ux/ctype.h>\n#include <lin",
            "ux/module.h>\n#include <lin",
            "ux/slab.h>\n#include <lin",
            "ux/init.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "shrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali",
            "file_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nshrinker ubifs_shrinker_info = {\n\t.scan_objects = ubifs_shrink_scan,\n\t.count_objects = ubifs_shrink_count,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n/**\n * vali;\nfile_system_type ubifs_fs_type = {\n\t.name    = \"ubifs\",\n\t.owner   = THIS_MODULE,\n\t.mount   = ubifs_mount,\n\t.kill_sb = kill_ubifs_super,\n};\nMODULE_ALIAS;\n\n_exit ubifs_exit(void)\n{\n\tubifs_assert(list_empty(&ubifs_infos));\n\tubifs_assert(atomic_long_read(&ubifs_clean_zn_cnt) == 0);\n\n\tdbg_debugfs_exit();\n\tubifs_compressors_exit();\n\tunregister_shrinker(&ubifs_shrinker_info);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ubifs_inode_slab);\n\tunregister_filesystem(&ubifs_fs_type);\n}\nmodule_exit("
        }
      },
      {
        "call_info": {
          "callee": "h->list)",
          "args": [
            "kfree(or"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">orph_list",
          "args": [
            "next, struct ubif",
            "orphan list);\n\t\tli",
            "_del"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->orph_lis",
          "args": [
            ")) {\n\t\torph ="
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "hile"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->list)",
          "args": [
            "kfree(or"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nree_orphans(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orph;\n\n\twhile (c->orph_dnext) {\n\t\torph = c->orph_dnext;\n\t\tc->orph_dnext = orph->dnext;\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t}\n\n\twhile (!list_empty(&c->orph_list)) {\n\t\torph = list_entry(c->orph_list.next, struct ubifs_orphan, list);\n\t\tlist_del(&orph->list);\n\t\tkfree(orph);\n\t\tubifs_err(\"orphan list not empty at unmount\");\n\t}\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n}\n\n/**\n * free"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "827-839",
    "snippet": "ree_wbufs(struct ubifs_info *c)\n{\n\tint i;\n\n\tif (c->jheads) {\n\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\tkfree(c->jheads[i].wbuf.buf);\n\t\t\tkfree(c->jheads[i].wbuf.inodes);\n\t\t}\n\t\tkfree(c->jheads);\n\t\tc->jheads = NULL;\n\t}\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ds);",
          "args": [
            "c->jhead"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ds[i]",
          "args": [
            "wbuf.inodes);\n\t\t}\n\t\tkfre"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ds[i]",
          "args": [
            "wbuf.buf);\n\t\t\tkfree(c"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nree_wbufs(struct ubifs_info *c)\n{\n\tint i;\n\n\tif (c->jheads) {\n\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\tkfree(c->jheads[i].wbuf.buf);\n\t\t\tkfree(c->jheads[i].wbuf.inodes);\n\t\t}\n\t\tkfree(c->jheads);\n\t\tc->jheads = NULL;\n\t}\n}\n\n/**\n * free"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "792-821",
    "snippet": "loc_wbufs(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tc->jheads = kcalloc(c->jhead_cnt, sizeof(struct ubifs_jhead),\n\t\t\t    GFP_KERNEL);\n\tif (!c->jheads)\n\t\treturn -ENOMEM;\n\n\t/* Initialize journal heads */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tINIT_LIST_HEAD(&c->jheads[i].buds_list);\n\t\terr = ubifs_wbuf_init(c, &c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tc->jheads[i].wbuf.sync_callback = &bud_wbuf_callback;\n\t\tc->jheads[i].wbuf.jhead = i;\n\t\tc->jheads[i].grouped = 1;\n\t}\n\n\t/*\n\t * Garbage Collector head does not need to be synchronized by timer.\n\t * Also GC head nodes are not grouped.\n\t */\n\tc->jheads[GCHD].wbuf.no_timer = 1;\n\tc->jheads[GCHD].grouped = 0;\n\n\treturn 0;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "it(c, &c->jhead",
          "args": [
            "[",
            ".wbuf);\n\t\tif (err)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&c->jheads[i",
          "args": [
            ".buds_list);\n\t\terr = ub"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead_cnt",
          "args": [
            "sizeof(stru",
            "ubifs_jhead),\n\t\t\t    GFP_",
            "if (!c->j"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nloc_wbufs(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tc->jheads = kcalloc(c->jhead_cnt, sizeof(struct ubifs_jhead),\n\t\t\t    GFP_KERNEL);\n\tif (!c->jheads)\n\t\treturn -ENOMEM;\n\n\t/* Initialize journal heads */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tINIT_LIST_HEAD(&c->jheads[i].buds_list);\n\t\terr = ubifs_wbuf_init(c, &c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tc->jheads[i].wbuf.sync_callback = &bud_wbuf_callback;\n\t\tc->jheads[i].wbuf.jhead = i;\n\t\tc->jheads[i].grouped = 1;\n\t}\n\n\t/*\n\t * Garbage Collector head does not need to be synchronized by timer.\n\t * Also GC head nodes are not grouped.\n\t */\n\tc->jheads[GCHD].wbuf.no_timer = 1;\n\tc->jheads[GCHD].grouped = 0;\n\n\treturn 0;\n}\n\n/**\n * free"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "770-783",
    "snippet": "ke_gc_lnum(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->gc_lnum == -1) {\n\t\tubifs_err(\"no LEB for GC\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And we have to tell lprops that this LEB is taken */\n\terr = ubifs_change_one_lp(c, c->gc_lnum, c->leb_size, 0,\n\t\t\t\t  LPROPS_TAKEN, 0, 0);\n\treturn err;\n}\n\n/**\n * allo",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "one_lp(c, c->gc_lnu",
          "args": [
            ",",
            "->leb_size",
            "0,\n\t\t\t\t  LP",
            "P",
            "0, 0);\n\tret",
            "n",
            "r"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB for",
          "args": [
            "C\");\n\t\treturn -"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nke_gc_lnum(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->gc_lnum == -1) {\n\t\tubifs_err(\"no LEB for GC\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And we have to tell lprops that this LEB is taken */\n\terr = ubifs_change_one_lp(c, c->gc_lnum, c->leb_size, 0,\n\t\t\t\t  LPROPS_TAKEN, 0, 0);\n\treturn err;\n}\n\n/**\n * allo"
  },
  {
    "function_name": "s_master(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "737-757",
    "snippet": "nit_constants_master(struct ubifs_info *c)\n{\n\tlong long tmp64;\n\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tc->report_rp_size = ubifs_reported_space(c, c->rp_size);\n\n\t/*\n\t * Calculate total amount of FS blocks. This number is not used\n\t * internally because it does not make much sense for UBIFS, but it is\n\t * necessary to report something for the 'statfs()' call.\n\t *\n\t * Subtract the LEB reserved for GC, the LEB which is reserved for\n\t * deletions, minimum LEBs for the index, and assume only one journal\n\t * head is available.\n\t */\n\ttmp64 = c->main_lebs - 1 - 1 - MIN_INDEX_LEBS - c->jhead_cnt + 1;\n\ttmp64 *= (long long)c->leb_size - c->leb_overhead;\n\ttmp64 = ubifs_reported_space(c, tmp64);\n\tc->block_cnt = tmp64 >> UBIFS_BLOCK_SHIFT;\n}\n\n/**\n * take",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_space(c, tmp64);",
          "args": [
            "-",
            "lock_"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_space(c, c->rp_siz",
          "args": [
            ")",
            "/*\n\t * C"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\tc->repo",
          "args": [
            "t"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nnit_constants_master(struct ubifs_info *c)\n{\n\tlong long tmp64;\n\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tc->report_rp_size = ubifs_reported_space(c, c->rp_size);\n\n\t/*\n\t * Calculate total amount of FS blocks. This number is not used\n\t * internally because it does not make much sense for UBIFS, but it is\n\t * necessary to report something for the 'statfs()' call.\n\t *\n\t * Subtract the LEB reserved for GC, the LEB which is reserved for\n\t * deletions, minimum LEBs for the index, and assume only one journal\n\t * head is available.\n\t */\n\ttmp64 = c->main_lebs - 1 - 1 - MIN_INDEX_LEBS - c->jhead_cnt + 1;\n\ttmp64 *= (long long)c->leb_size - c->leb_overhead;\n\ttmp64 = ubifs_reported_space(c, tmp64);\n\tc->block_cnt = tmp64 >> UBIFS_BLOCK_SHIFT;\n}\n\n/**\n * take"
  },
  {
    "function_name": "s_sb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "647-727",
    "snippet": "it_constants_sb(struct ubifs_info *c)\n{\n\tint tmp, err;\n\tlong long tmp64;\n\n\tc->main_bytes = (long long)c->main_lebs * c->leb_size;\n\tc->max_znode_sz = sizeof(struct ubifs_znode) +\n\t\t\t\tc->fanout * sizeof(struct ubifs_zbranch);\n\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tc->ranges[UBIFS_IDX_NODE].min_len = tmp;\n\tc->min_idx_node_sz = ALIGN(tmp, 8);\n\n\ttmp = ubifs_idx_node_sz(c, c->fanout);\n\tc->ranges[UBIFS_IDX_NODE].max_len = tmp;\n\tc->max_idx_node_sz = ALIGN(tmp, 8);\n\n\t/* Make sure LEB size is large enough to fit full commit */\n\ttmp = UBIFS_CS_NODE_SZ + UBIFS_REF_NODE_SZ * c->jhead_cnt;\n\ttmp = ALIGN(tmp, c->min_io_size);\n\tif (tmp > c->leb_size) {\n\t\tubifs_err(\"too small LEB size %d, at least %d needed\",\n\t\t\t  c->leb_size, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Make sure that the log is large enough to fit reference nodes for\n\t * all buds plus one reserved LEB.\n\t */\n\ttmp64 = c->max_bud_bytes + c->leb_size - 1;\n\tc->max_bud_cnt = div_u64(tmp64, c->leb_size);\n\ttmp = (c->ref_node_alsz * c->max_bud_cnt + c->leb_size - 1);\n\ttmp /= c->leb_size;\n\ttmp += 1;\n\tif (c->log_lebs < tmp) {\n\t\tubifs_err(\"too small log %d LEBs, required min. %d LEBs\",\n\t\t\t  c->log_lebs, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * When budgeting we assume worst-case scenarios when the pages are not\n\t * be compressed and direntries are of the maximum size.\n\t *\n\t * Note, data, which may be stored in inodes is budgeted separately, so\n\t * it is not included into 'c->bi.inode_budget'.\n\t */\n\tc->bi.page_budget = UBIFS_MAX_DATA_NODE_SZ * UBIFS_BLOCKS_PER_PAGE;\n\tc->bi.inode_budget = UBIFS_INO_NODE_SZ;\n\tc->bi.dent_budget = UBIFS_MAX_DENT_NODE_SZ;\n\n\t/*\n\t * When the amount of flash space used by buds becomes\n\t * 'c->max_bud_bytes', UBIFS just blocks all writers and starts commit.\n\t * The writers are unblocked when the commit is finished. To avoid\n\t * writers to be blocked UBIFS initiates background commit in advance,\n\t * when number of bud bytes becomes above the limit defined below.\n\t */\n\tc->bg_bud_bytes = (c->max_bud_bytes * 13) >> 4;\n\n\t/*\n\t * Ensure minimum journal size. All the bytes in the journal heads are\n\t * considered to be used, when calculating the current journal usage.\n\t * Consequently, if the journal is too small, UBIFS will treat it as\n\t * always full.\n\t */\n\ttmp64 = (long long)(c->jhead_cnt + 1) * c->leb_size + 1;\n\tif (c->bg_bud_bytes < tmp64)\n\t\tc->bg_bud_bytes = tmp64;\n\tif (c->max_bud_bytes < tmp64 + c->leb_size)\n\t\tc->max_bud_bytes = tmp64 + c->leb_size;\n\n\terr = ubifs_calc_lpt_geom(c);\n\tif (err)\n\t\treturn err;\n\n\t/* Initialize effective LEB size used in budgeting calculations */\n\tc->idx_leb_size = c->leb_size - c->max_idx_node_sz;\n\treturn 0;\n}\n\n/*\n * init_",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_geom(c);\n\tif (err",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o small l",
          "args": [
            "g %d LEBs, required min. %d LEBs\",\n\t\t\t  c->log",
            "tmp);\n\t\tret",
            "n -"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->le",
          "args": [
            "_size",
            "tmp = (c-"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o small L",
          "args": [
            "B size %d, at least %d needed\",\n\t\t\t  c->leb",
            "tmp);\n\t\tret",
            "n -"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\tif (tmp >"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\t/",
          "args": [
            "Ma"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->fanout",
          "args": [
            ";",
            "c->ranges"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tt",
          "args": [
            "p =",
            "b"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1);\n\tc->r",
          "args": [
            "n",
            "s"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nit_constants_sb(struct ubifs_info *c)\n{\n\tint tmp, err;\n\tlong long tmp64;\n\n\tc->main_bytes = (long long)c->main_lebs * c->leb_size;\n\tc->max_znode_sz = sizeof(struct ubifs_znode) +\n\t\t\t\tc->fanout * sizeof(struct ubifs_zbranch);\n\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tc->ranges[UBIFS_IDX_NODE].min_len = tmp;\n\tc->min_idx_node_sz = ALIGN(tmp, 8);\n\n\ttmp = ubifs_idx_node_sz(c, c->fanout);\n\tc->ranges[UBIFS_IDX_NODE].max_len = tmp;\n\tc->max_idx_node_sz = ALIGN(tmp, 8);\n\n\t/* Make sure LEB size is large enough to fit full commit */\n\ttmp = UBIFS_CS_NODE_SZ + UBIFS_REF_NODE_SZ * c->jhead_cnt;\n\ttmp = ALIGN(tmp, c->min_io_size);\n\tif (tmp > c->leb_size) {\n\t\tubifs_err(\"too small LEB size %d, at least %d needed\",\n\t\t\t  c->leb_size, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Make sure that the log is large enough to fit reference nodes for\n\t * all buds plus one reserved LEB.\n\t */\n\ttmp64 = c->max_bud_bytes + c->leb_size - 1;\n\tc->max_bud_cnt = div_u64(tmp64, c->leb_size);\n\ttmp = (c->ref_node_alsz * c->max_bud_cnt + c->leb_size - 1);\n\ttmp /= c->leb_size;\n\ttmp += 1;\n\tif (c->log_lebs < tmp) {\n\t\tubifs_err(\"too small log %d LEBs, required min. %d LEBs\",\n\t\t\t  c->log_lebs, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * When budgeting we assume worst-case scenarios when the pages are not\n\t * be compressed and direntries are of the maximum size.\n\t *\n\t * Note, data, which may be stored in inodes is budgeted separately, so\n\t * it is not included into 'c->bi.inode_budget'.\n\t */\n\tc->bi.page_budget = UBIFS_MAX_DATA_NODE_SZ * UBIFS_BLOCKS_PER_PAGE;\n\tc->bi.inode_budget = UBIFS_INO_NODE_SZ;\n\tc->bi.dent_budget = UBIFS_MAX_DENT_NODE_SZ;\n\n\t/*\n\t * When the amount of flash space used by buds becomes\n\t * 'c->max_bud_bytes', UBIFS just blocks all writers and starts commit.\n\t * The writers are unblocked when the commit is finished. To avoid\n\t * writers to be blocked UBIFS initiates background commit in advance,\n\t * when number of bud bytes becomes above the limit defined below.\n\t */\n\tc->bg_bud_bytes = (c->max_bud_bytes * 13) >> 4;\n\n\t/*\n\t * Ensure minimum journal size. All the bytes in the journal heads are\n\t * considered to be used, when calculating the current journal usage.\n\t * Consequently, if the journal is too small, UBIFS will treat it as\n\t * always full.\n\t */\n\ttmp64 = (long long)(c->jhead_cnt + 1) * c->leb_size + 1;\n\tif (c->bg_bud_bytes < tmp64)\n\t\tc->bg_bud_bytes = tmp64;\n\tif (c->max_bud_bytes < tmp64 + c->leb_size)\n\t\tc->max_bud_bytes = tmp64 + c->leb_size;\n\n\terr = ubifs_calc_lpt_geom(c);\n\tif (err)\n\t\treturn err;\n\n\t/* Initialize effective LEB size used in budgeting calculations */\n\tc->idx_leb_size = c->leb_size - c->max_idx_node_sz;\n\treturn 0;\n}\n\n/*\n * init_"
  },
  {
    "function_name": "back(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "633-636",
    "snippet": "d_wbuf_callback(struct ubifs_info *c, int lnum, int free, int pad)\n{\n\treturn ubifs_update_one_lp(c, lnum, free, pad, 0, 0);\n}\n\n/*\n * init_",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "one_lp(c, lnum, fre",
          "args": [
            ",",
            "ad,",
            "0);",
            "/",
            "i"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nd_wbuf_callback(struct ubifs_info *c, int lnum, int free, int pad)\n{\n\treturn ubifs_update_one_lp(c, lnum, free, pad, 0, 0);\n}\n\n/*\n * init_"
  },
  {
    "function_name": "s_early(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "492-616",
    "snippet": "it_constants_early(struct ubifs_info *c)\n{\n\tif (c->vi.corrupted) {\n\t\tubifs_warn(\"UBI volume is corrupted - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->di.ro_mode) {\n\t\tubifs_msg(\"read-only UBI device\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->vi.vol_type == UBI_STATIC_VOLUME) {\n\t\tubifs_msg(\"static UBI volume - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tc->leb_cnt = c->vi.size;\n\tc->leb_size = c->vi.usable_leb_size;\n\tc->leb_start = c->di.leb_start;\n\tc->half_leb_size = c->leb_size / 2;\n\tc->min_io_size = c->di.min_io_size;\n\tc->min_io_shift = fls(c->min_io_size) - 1;\n\tc->max_write_size = c->di.max_write_size;\n\tc->max_write_shift = fls(c->max_write_size) - 1;\n\n\tif (c->leb_size < UBIFS_MIN_LEB_SZ) {\n\t\tubifs_err(\"too small LEBs (%d bytes), min. is %d bytes\",\n\t\t\t  c->leb_size, UBIFS_MIN_LEB_SZ);\n\t\treturn -EINVAL;\n\t}\n\n\tif (c->leb_cnt < UBIFS_MIN_LEB_CNT) {\n\t\tubifs_err(\"too few LEBs (%d), min. is %d\",\n\t\t\t  c->leb_cnt, UBIFS_MIN_LEB_CNT);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(c->min_io_size)) {\n\t\tubifs_err(\"bad min. I/O size %d\", c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Maximum write size has to be greater or equivalent to min. I/O\n\t * size, and be multiple of min. I/O size.\n\t */\n\tif (c->max_write_size < c->min_io_size ||\n\t    c->max_write_size % c->min_io_size ||\n\t    !is_power_of_2(c->max_write_size)) {\n\t\tubifs_err(\"bad write buffer size %d for %d min. I/O unit\",\n\t\t\t  c->max_write_size, c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * UBIFS aligns all node to 8-byte boundary, so to make function in\n\t * io.c simpler, assume minimum I/O unit size to be 8 bytes if it is\n\t * less than 8.\n\t */\n\tif (c->min_io_size < 8) {\n\t\tc->min_io_size = 8;\n\t\tc->min_io_shift = 3;\n\t\tif (c->max_write_size < c->min_io_size) {\n\t\t\tc->max_write_size = c->min_io_size;\n\t\t\tc->max_write_shift = c->min_io_shift;\n\t\t}\n\t}\n\n\tc->ref_node_alsz = ALIGN(UBIFS_REF_NODE_SZ, c->min_io_size);\n\tc->mst_node_alsz = ALIGN(UBIFS_MST_NODE_SZ, c->min_io_size);\n\n\t/*\n\t * Initialize node length ranges which are mostly needed for node\n\t * length validation.\n\t */\n\tc->ranges[UBIFS_PAD_NODE].len  = UBIFS_PAD_NODE_SZ;\n\tc->ranges[UBIFS_SB_NODE].len   = UBIFS_SB_NODE_SZ;\n\tc->ranges[UBIFS_MST_NODE].len  = UBIFS_MST_NODE_SZ;\n\tc->ranges[UBIFS_REF_NODE].len  = UBIFS_REF_NODE_SZ;\n\tc->ranges[UBIFS_TRUN_NODE].len = UBIFS_TRUN_NODE_SZ;\n\tc->ranges[UBIFS_CS_NODE].len   = UBIFS_CS_NODE_SZ;\n\n\tc->ranges[UBIFS_INO_NODE].min_len  = UBIFS_INO_NODE_SZ;\n\tc->ranges[UBIFS_INO_NODE].max_len  = UBIFS_MAX_INO_NODE_SZ;\n\tc->ranges[UBIFS_ORPH_NODE].min_len =\n\t\t\t\tUBIFS_ORPH_NODE_SZ + sizeof(__le64);\n\tc->ranges[UBIFS_ORPH_NODE].max_len = c->leb_size;\n\tc->ranges[UBIFS_DENT_NODE].min_len = UBIFS_DENT_NODE_SZ;\n\tc->ranges[UBIFS_DENT_NODE].max_len = UBIFS_MAX_DENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].min_len = UBIFS_XENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].max_len = UBIFS_MAX_XENT_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].min_len = UBIFS_DATA_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].max_len = UBIFS_MAX_DATA_NODE_SZ;\n\t/*\n\t * Minimum indexing node size is amended later when superblock is\n\t * read and the key length is known.\n\t */\n\tc->ranges[UBIFS_IDX_NODE].min_len = UBIFS_IDX_NODE_SZ + UBIFS_BRANCH_SZ;\n\t/*\n\t * Maximum indexing node size is amended later when superblock is\n\t * read and the fanout is known.\n\t */\n\tc->ranges[UBIFS_IDX_NODE].max_len = INT_MAX;\n\n\t/*\n\t * Initialize dead and dark LEB space watermarks. See gc.c for comments\n\t * about these values.\n\t */\n\tc->dead_wm = ALIGN(MIN_WRITE_SZ, c->min_io_size);\n\tc->dark_wm = ALIGN(UBIFS_MAX_NODE_SZ, c->min_io_size);\n\n\t/*\n\t * Calculate how many bytes would be wasted at the end of LEB if it was\n\t * fully filled with data nodes of maximum size. This is used in\n\t * calculations when reporting free space.\n\t */\n\tc->leb_overhead = c->leb_size % UBIFS_MAX_DATA_NODE_SZ;\n\n\t/* Buffer size for bulk-reads */\n\tc->max_bu_buf_len = UBIFS_MAX_BULK_READ * UBIFS_MAX_DATA_NODE_SZ;\n\tif (c->max_bu_buf_len > c->leb_size)\n\t\tc->max_bu_buf_len = c->leb_size;\n\treturn 0;\n}\n\n/**\n * bud_",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AX_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e);\n\n\t/*\n\t * C"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TE_SZ",
          "args": [
            "c->min_io_s",
            "e);\n\tc->dark_w"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ST_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e);\n\n\t/*\n\t * I"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EF_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e);\n\tc->mst_no"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d write b",
          "args": [
            "ffer size %d for %d min. I/O unit\",\n\t\t\t  c->max",
            "size, c->min_io_s",
            "e);\n\t\treturn -"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->max_write",
          "args": [
            "size)) {\n\t\tubifs_"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d min. I/",
          "args": [
            "size %d\", c->min_io_s",
            "e);\n\t\treturn -"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->min_io_si",
          "args": [
            "e)) {\n\t\tubifs_"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o few LEB",
          "args": [
            "(%d), min. is %d\",\n\t\t\t  c->leb",
            "BIFS_MIN_L",
            "_CNT);\n\t\treturn -"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o small L",
          "args": [
            "Bs (%d bytes), min. is %d bytes\",\n\t\t\t  c->leb",
            "UBIFS_MIN_L",
            "_SZ);\n\t\treturn -"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ite",
          "args": [
            "size) - 1;\n\n\tif ("
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sbi_write_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "321-352",
          "snippet": "int exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));\n\nint exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_si",
          "args": [
            "e) - 1;\n\tc->ma"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atic UBI",
          "args": [
            "olume - read-only mode\");\n\t\tc->ro_me"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad-only U",
          "args": [
            "I device\");\n\t\tc->ro_me"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BI volume",
          "args": [
            "s corrupted - read-only mode\");\n\t\tc->ro_me"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nit_constants_early(struct ubifs_info *c)\n{\n\tif (c->vi.corrupted) {\n\t\tubifs_warn(\"UBI volume is corrupted - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->di.ro_mode) {\n\t\tubifs_msg(\"read-only UBI device\");\n\t\tc->ro_media = 1;\n\t}\n\n\tif (c->vi.vol_type == UBI_STATIC_VOLUME) {\n\t\tubifs_msg(\"static UBI volume - read-only mode\");\n\t\tc->ro_media = 1;\n\t}\n\n\tc->leb_cnt = c->vi.size;\n\tc->leb_size = c->vi.usable_leb_size;\n\tc->leb_start = c->di.leb_start;\n\tc->half_leb_size = c->leb_size / 2;\n\tc->min_io_size = c->di.min_io_size;\n\tc->min_io_shift = fls(c->min_io_size) - 1;\n\tc->max_write_size = c->di.max_write_size;\n\tc->max_write_shift = fls(c->max_write_size) - 1;\n\n\tif (c->leb_size < UBIFS_MIN_LEB_SZ) {\n\t\tubifs_err(\"too small LEBs (%d bytes), min. is %d bytes\",\n\t\t\t  c->leb_size, UBIFS_MIN_LEB_SZ);\n\t\treturn -EINVAL;\n\t}\n\n\tif (c->leb_cnt < UBIFS_MIN_LEB_CNT) {\n\t\tubifs_err(\"too few LEBs (%d), min. is %d\",\n\t\t\t  c->leb_cnt, UBIFS_MIN_LEB_CNT);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(c->min_io_size)) {\n\t\tubifs_err(\"bad min. I/O size %d\", c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Maximum write size has to be greater or equivalent to min. I/O\n\t * size, and be multiple of min. I/O size.\n\t */\n\tif (c->max_write_size < c->min_io_size ||\n\t    c->max_write_size % c->min_io_size ||\n\t    !is_power_of_2(c->max_write_size)) {\n\t\tubifs_err(\"bad write buffer size %d for %d min. I/O unit\",\n\t\t\t  c->max_write_size, c->min_io_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * UBIFS aligns all node to 8-byte boundary, so to make function in\n\t * io.c simpler, assume minimum I/O unit size to be 8 bytes if it is\n\t * less than 8.\n\t */\n\tif (c->min_io_size < 8) {\n\t\tc->min_io_size = 8;\n\t\tc->min_io_shift = 3;\n\t\tif (c->max_write_size < c->min_io_size) {\n\t\t\tc->max_write_size = c->min_io_size;\n\t\t\tc->max_write_shift = c->min_io_shift;\n\t\t}\n\t}\n\n\tc->ref_node_alsz = ALIGN(UBIFS_REF_NODE_SZ, c->min_io_size);\n\tc->mst_node_alsz = ALIGN(UBIFS_MST_NODE_SZ, c->min_io_size);\n\n\t/*\n\t * Initialize node length ranges which are mostly needed for node\n\t * length validation.\n\t */\n\tc->ranges[UBIFS_PAD_NODE].len  = UBIFS_PAD_NODE_SZ;\n\tc->ranges[UBIFS_SB_NODE].len   = UBIFS_SB_NODE_SZ;\n\tc->ranges[UBIFS_MST_NODE].len  = UBIFS_MST_NODE_SZ;\n\tc->ranges[UBIFS_REF_NODE].len  = UBIFS_REF_NODE_SZ;\n\tc->ranges[UBIFS_TRUN_NODE].len = UBIFS_TRUN_NODE_SZ;\n\tc->ranges[UBIFS_CS_NODE].len   = UBIFS_CS_NODE_SZ;\n\n\tc->ranges[UBIFS_INO_NODE].min_len  = UBIFS_INO_NODE_SZ;\n\tc->ranges[UBIFS_INO_NODE].max_len  = UBIFS_MAX_INO_NODE_SZ;\n\tc->ranges[UBIFS_ORPH_NODE].min_len =\n\t\t\t\tUBIFS_ORPH_NODE_SZ + sizeof(__le64);\n\tc->ranges[UBIFS_ORPH_NODE].max_len = c->leb_size;\n\tc->ranges[UBIFS_DENT_NODE].min_len = UBIFS_DENT_NODE_SZ;\n\tc->ranges[UBIFS_DENT_NODE].max_len = UBIFS_MAX_DENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].min_len = UBIFS_XENT_NODE_SZ;\n\tc->ranges[UBIFS_XENT_NODE].max_len = UBIFS_MAX_XENT_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].min_len = UBIFS_DATA_NODE_SZ;\n\tc->ranges[UBIFS_DATA_NODE].max_len = UBIFS_MAX_DATA_NODE_SZ;\n\t/*\n\t * Minimum indexing node size is amended later when superblock is\n\t * read and the key length is known.\n\t */\n\tc->ranges[UBIFS_IDX_NODE].min_len = UBIFS_IDX_NODE_SZ + UBIFS_BRANCH_SZ;\n\t/*\n\t * Maximum indexing node size is amended later when superblock is\n\t * read and the fanout is known.\n\t */\n\tc->ranges[UBIFS_IDX_NODE].max_len = INT_MAX;\n\n\t/*\n\t * Initialize dead and dark LEB space watermarks. See gc.c for comments\n\t * about these values.\n\t */\n\tc->dead_wm = ALIGN(MIN_WRITE_SZ, c->min_io_size);\n\tc->dark_wm = ALIGN(UBIFS_MAX_NODE_SZ, c->min_io_size);\n\n\t/*\n\t * Calculate how many bytes would be wasted at the end of LEB if it was\n\t * fully filled with data nodes of maximum size. This is used in\n\t * calculations when reporting free space.\n\t */\n\tc->leb_overhead = c->leb_size % UBIFS_MAX_DATA_NODE_SZ;\n\n\t/* Buffer size for bulk-reads */\n\tc->max_bu_buf_len = UBIFS_MAX_BULK_READ * UBIFS_MAX_DATA_NODE_SZ;\n\tif (c->max_bu_buf_len > c->leb_size)\n\t\tc->max_bu_buf_len = c->leb_size;\n\treturn 0;\n}\n\n/**\n * bud_"
  },
  {
    "function_name": "(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "446-481",
    "snippet": "ifs_sync_fs(struct super_block *sb, int wait)\n{\n\tint i, err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\t/*\n\t * Zero @wait is just an advisory thing to help the file system shove\n\t * lots of data into the queues, and there will be the second\n\t * '->sync_fs()' call, with non-zero @wait.\n\t */\n\tif (!wait)\n\t\treturn 0;\n\n\t/*\n\t * Synchronize write buffers, because 'ubifs_run_commit()' does not\n\t * do this if it waits for an already running commit.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/*\n\t * Strictly speaking, it is not necessary to commit the journal here,\n\t * synchronizing write-buffers would be enough. But committing makes\n\t * UBIFS free space predictions much more accurate, so we want to let\n\t * the user be able to get more accurate results of 'statfs()' after\n\t * they synchronize the file system.\n\t */\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\treturn ubi_sync(c->vi.ubi_num);\n}\n\n/**\n * init",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i.ubi_nu",
          "args": [
            ");\n}\n\n/**\n *"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit(c);\n\tif (err",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->jheads[i",
          "args": [
            ".wbuf);\n\t\tif (err)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_sync_fs(struct super_block *sb, int wait)\n{\n\tint i, err;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\n\t/*\n\t * Zero @wait is just an advisory thing to help the file system shove\n\t * lots of data into the queues, and there will be the second\n\t * '->sync_fs()' call, with non-zero @wait.\n\t */\n\tif (!wait)\n\t\treturn 0;\n\n\t/*\n\t * Synchronize write buffers, because 'ubifs_run_commit()' does not\n\t * do this if it waits for an already running commit.\n\t */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\terr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/*\n\t * Strictly speaking, it is not necessary to commit the journal here,\n\t * synchronizing write-buffers would be enough. But committing makes\n\t * UBIFS free space predictions much more accurate, so we want to let\n\t * the user be able to get more accurate results of 'statfs()' after\n\t * they synchronize the file system.\n\t */\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\treturn ubi_sync(c->vi.ubi_num);\n}\n\n/**\n * init"
  },
  {
    "function_name": "tions(struct seq_f",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "419-444",
    "snippet": "ifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ubifs_info *c = root->d_sb->s_fs_info;\n\n\tif (c->mount_opts.unmount_mode == 2)\n\t\tseq_puts(s, \",fast_unmount\");\n\telse if (c->mount_opts.unmount_mode == 1)\n\t\tseq_puts(s, \",norm_unmount\");\n\n\tif (c->mount_opts.bulk_read == 2)\n\t\tseq_puts(s, \",bulk_read\");\n\telse if (c->mount_opts.bulk_read == 1)\n\t\tseq_puts(s, \",no_bulk_read\");\n\n\tif (c->mount_opts.chk_data_crc == 2)\n\t\tseq_puts(s, \",chk_data_crc\");\n\telse if (c->mount_opts.chk_data_crc == 1)\n\t\tseq_puts(s, \",no_chk_data_crc\");\n\n\tif (c->mount_opts.override_compr) {\n\t\tseq_printf(s, \",compr=%s\",\n\t\t\t   ubifs_compr_name(c->mount_opts.compr_type));\n\t}\n\n\treturn 0;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\",compr=%",
          "args": [
            "\"",
            "ubifs",
            "ame(c->mount_opts.compr_type));\n\t}\n\n\tretur"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame(c->mount_opt",
          "args": [
            ".compr_type));\n\t}\n\n\tretu"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",no_chk_",
          "args": [
            "a",
            "_crc\");\n\n\tif (c->m"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",chk_dat",
          "args": [
            "_",
            "c\");\n\telse if ("
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",no_bulk",
          "args": [
            "r",
            "d\");\n\n\tif (c->m"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",bulk_re",
          "args": [
            "d",
            ";\n\telse if ("
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",norm_un",
          "args": [
            "o",
            "t\");\n\n\tif (c->m"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ",fast_un",
          "args": [
            "o",
            "t\");\n\telse if ("
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ubifs_info *c = root->d_sb->s_fs_info;\n\n\tif (c->mount_opts.unmount_mode == 2)\n\t\tseq_puts(s, \",fast_unmount\");\n\telse if (c->mount_opts.unmount_mode == 1)\n\t\tseq_puts(s, \",norm_unmount\");\n\n\tif (c->mount_opts.bulk_read == 2)\n\t\tseq_puts(s, \",bulk_read\");\n\telse if (c->mount_opts.bulk_read == 1)\n\t\tseq_puts(s, \",no_bulk_read\");\n\n\tif (c->mount_opts.chk_data_crc == 2)\n\t\tseq_puts(s, \",chk_data_crc\");\n\telse if (c->mount_opts.chk_data_crc == 1)\n\t\tseq_puts(s, \",no_chk_data_crc\");\n\n\tif (c->mount_opts.override_compr) {\n\t\tseq_printf(s, \",compr=%s\",\n\t\t\t   ubifs_compr_name(c->mount_opts.compr_type));\n\t}\n\n\treturn 0;\n}\n\nstatic int"
  },
  {
    "function_name": "struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "392-417",
    "snippet": "ifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ubifs_info *c = dentry->d_sb->s_fs_info;\n\tunsigned long long free;\n\t__le32 *uuid = (__le32 *)c->uuid;\n\n\tfree = ubifs_get_free_space(c);\n\tdbg_gen(\"free space %lld bytes (%lld blocks)\",\n\t\tfree, free >> UBIFS_BLOCK_SHIFT);\n\n\tbuf->f_type = UBIFS_SUPER_MAGIC;\n\tbuf->f_bsize = UBIFS_BLOCK_SIZE;\n\tbuf->f_blocks = c->block_cnt;\n\tbuf->f_bfree = free >> UBIFS_BLOCK_SHIFT;\n\tif (free > c->report_rp_size)\n\t\tbuf->f_bavail = (free - c->report_rp_size) >> UBIFS_BLOCK_SHIFT;\n\telse\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = UBIFS_MAX_NLEN;\n\tbuf->f_fsid.val[0] = le32_to_cpu(uuid[0]) ^ le32_to_cpu(uuid[2]);\n\tbuf->f_fsid.val[1] = le32_to_cpu(uuid[1]) ^ le32_to_cpu(uuid[3]);\n\tubifs_assert(buf->f_bfree <= c->block_cnt);\n\treturn 0;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buf->f_bfree",
          "args": [
            "<= c->block_cnt);\n\treturn 0;"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid[3]);\n\tu",
          "args": [
            "ifs_ass"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid[1]) ^ l",
          "args": [
            "32_to_c"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid[2]);\n\tb",
          "args": [
            "f->f_fs"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid[0]) ^ l",
          "args": [
            "32_to_c"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space",
          "args": [
            "lld bytes (%lld blocks)\",\n\t\tfree, fre",
            "UBI",
            "_BLOCK_SHIFT);\n\n\tbuf->f_t"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1976-2002",
          "snippet": "int ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e_space(c);\n\tdbg_gen",
          "args": [
            "\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ubifs_info *c = dentry->d_sb->s_fs_info;\n\tunsigned long long free;\n\t__le32 *uuid = (__le32 *)c->uuid;\n\n\tfree = ubifs_get_free_space(c);\n\tdbg_gen(\"free space %lld bytes (%lld blocks)\",\n\t\tfree, free >> UBIFS_BLOCK_SHIFT);\n\n\tbuf->f_type = UBIFS_SUPER_MAGIC;\n\tbuf->f_bsize = UBIFS_BLOCK_SIZE;\n\tbuf->f_blocks = c->block_cnt;\n\tbuf->f_bfree = free >> UBIFS_BLOCK_SHIFT;\n\tif (free > c->report_rp_size)\n\t\tbuf->f_bavail = (free - c->report_rp_size) >> UBIFS_BLOCK_SHIFT;\n\telse\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = UBIFS_MAX_NLEN;\n\tbuf->f_fsid.val[0] = le32_to_cpu(uuid[0]) ^ le32_to_cpu(uuid[2]);\n\tbuf->f_fsid.val[1] = le32_to_cpu(uuid[1]) ^ le32_to_cpu(uuid[3]);\n\tubifs_assert(buf->f_bfree <= c->block_cnt);\n\treturn 0;\n}\n\nstatic int"
  },
  {
    "function_name": "node(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "381-390",
    "snippet": "bifs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\tif (!ui->dirty) {\n\t\tui->dirty = 1;\n\t\tdbg_gen(\"inode %lu\",  inode->i_ino);\n\t}\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e %lu\",",
          "args": [
            "inode->i_i",
            ";\n\t}\n}\n\nstat"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ui->ui_mutex));\n\tif (!ui->"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ui->ui_mute",
          "args": [
            "));\n\tif (!ui-"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tub",
          "args": [
            "fs_as"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\tif (!ui->dirty) {\n\t\tui->dirty = 1;\n\t\tdbg_gen(\"inode %lu\",  inode->i_ino);\n\t}\n}\n\nstatic int"
  },
  {
    "function_name": "node(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "334-379",
    "snippet": "bifs_evict_inode(struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (ui->xattr)\n\t\t/*\n\t\t * Extended attribute inode deletions are fully handled in\n\t\t * 'ubifs_removexattr()'. These inodes are special and have\n\t\t * limited usage, so there is nothing to do here.\n\t\t */\n\t\tgoto out;\n\n\tdbg_gen(\"inode %lu, mode %#x\", inode->i_ino, (int)inode->i_mode);\n\tubifs_assert(!atomic_read(&inode->i_count));\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (inode->i_nlink)\n\t\tgoto done;\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tui->ui_size = inode->i_size = 0;\n\terr = ubifs_jnl_delete_inode(c, inode);\n\tif (err)\n\t\t/*\n\t\t * Worst case we have a lost orphan inode wasting space, so a\n\t\t * simple error message is OK here.\n\t\t */\n\t\tubifs_err(\"can't delete inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\nout:\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\ndone:\n\tclear_inode(inode);\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node);\n}\n\ns",
          "args": [
            "atic"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "done:",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_global_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3148-3151",
          "snippet": "static inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\tels",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n't delet",
          "args": [
            "inode %lu, error %d\",\n\t\t\t  inode-",
            "err);\n\nout:",
            "if"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ete_inode(c, inode);",
          "args": [
            "f",
            "err)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode))\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_pages_final(&inode->i_da",
          "args": [
            "a);\n\n\tif (inod"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!atomic_read",
          "args": [
            "&inode->i_count));\n\n\ttruncate"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_co",
          "args": [
            "nt));\n\n\ttruncat"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e %lu,",
          "args": [
            "ode %#x\", inode->i_in",
            "(int)inode-",
            "_mode);\n\tubifs_ass"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tif",
          "args": [
            "(ui->"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_evict_inode(struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (ui->xattr)\n\t\t/*\n\t\t * Extended attribute inode deletions are fully handled in\n\t\t * 'ubifs_removexattr()'. These inodes are special and have\n\t\t * limited usage, so there is nothing to do here.\n\t\t */\n\t\tgoto out;\n\n\tdbg_gen(\"inode %lu, mode %#x\", inode->i_ino, (int)inode->i_mode);\n\tubifs_assert(!atomic_read(&inode->i_count));\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (inode->i_nlink)\n\t\tgoto done;\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tui->ui_size = inode->i_size = 0;\n\terr = ubifs_jnl_delete_inode(c, inode);\n\tif (err)\n\t\t/*\n\t\t * Worst case we have a lost orphan inode wasting space, so a\n\t\t * simple error message is OK here.\n\t\t */\n\t\tubifs_err(\"can't delete inode %lu, error %d\",\n\t\t\t  inode->i_ino, err);\n\nout:\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\telse {\n\t\t/* We've deleted something - clean the \"no space\" flags */\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\ndone:\n\tclear_inode(inode);\n}\n\nstatic void"
  },
  {
    "function_name": "node(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "290-332",
    "snippet": "ifs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(!ui->xattr);\n\tif (is_bad_inode(inode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\t/*\n\t * Due to races between write-back forced by budgeting\n\t * (see 'sync_some_inodes()') and background write-back, the inode may\n\t * have already been synchronized, do not do this again. This might\n\t * also happen if it was synchronized in an VFS operation, e.g.\n\t * 'ubifs_link()'.\n\t */\n\tif (!ui->dirty) {\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * As an optimization, do not write orphan inodes to the media just\n\t * because this is not needed.\n\t */\n\tdbg_gen(\"inode %lu, mode %#x, nlink %u\",\n\t\tinode->i_ino, (int)inode->i_mode, inode->i_nlink);\n\tif (inode->i_nlink) {\n\t\terr = ubifs_jnl_write_inode(c, inode);\n\t\tif (err)\n\t\t\tubifs_err(\"can't write inode %lu, error %d\",\n\t\t\t\t  inode->i_ino, err);\n\t\telse\n\t\t\terr = dbg_check_inode_size(c, inode, ui->ui_size);\n\t}\n\n\tui->dirty = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_dirty_inode_budget(c, ui);\n\treturn err;\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\tret",
          "args": [
            "r",
            "er"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\tubifs_rel"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_size(c, inode, ui",
          "args": [
            ">",
            "_size",
            "}\n\n\tui->d"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n't write",
          "args": [
            "inode %lu, error %d\",\n\t\t\t\t  inode",
            "err);\n\t\tels"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te_inode(c, inode);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e %lu,",
          "args": [
            "ode %#x, nlink %u\",\n\t\tinode->i_",
            "(int)inode-",
            "_mode, inode->i_nl",
            "k);\n\tif (inode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t\treturn 0"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t/*\n\t * Du"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode))\n\t\tre",
          "args": [
            "urn 0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ui->xattr);",
          "args": [
            "if (is_ba"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tub",
          "args": [
            "fs_as"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nifs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(!ui->xattr);\n\tif (is_bad_inode(inode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\t/*\n\t * Due to races between write-back forced by budgeting\n\t * (see 'sync_some_inodes()') and background write-back, the inode may\n\t * have already been synchronized, do not do this again. This might\n\t * also happen if it was synchronized in an VFS operation, e.g.\n\t * 'ubifs_link()'.\n\t */\n\tif (!ui->dirty) {\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * As an optimization, do not write orphan inodes to the media just\n\t * because this is not needed.\n\t */\n\tdbg_gen(\"inode %lu, mode %#x, nlink %u\",\n\t\tinode->i_ino, (int)inode->i_mode, inode->i_nlink);\n\tif (inode->i_nlink) {\n\t\terr = ubifs_jnl_write_inode(c, inode);\n\t\tif (err)\n\t\t\tubifs_err(\"can't write inode %lu, error %d\",\n\t\t\t\t  inode->i_ino, err);\n\t\telse\n\t\t\terr = dbg_check_inode_size(c, inode, ui->ui_size);\n\t}\n\n\tui->dirty = 0;\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_dirty_inode_budget(c, ui);\n\treturn err;\n}\n\nstatic void"
  },
  {
    "function_name": "_inode(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "279-285",
    "snippet": "bifs_destroy_inode(struct inode *inode)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tkfree(ui->data);\n\tcall_rcu(&inode->i_rcu, ubifs_i_callback);\n}\n\n/*\n * Note,",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de->i_rc",
          "args": [
            ", ubifs_i_cal",
            "ack);\n}\n\n/*\n * N"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a);",
          "args": [
            "all_rcu("
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tkf",
          "args": [
            "ee(ui"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_destroy_inode(struct inode *inode)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tkfree(ui->data);\n\tcall_rcu(&inode->i_rcu, ubifs_i_callback);\n}\n\n/*\n * Note,"
  },
  {
    "function_name": "ack(struct rcu_h",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "272-277",
    "snippet": "bifs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tkmem_cache_free(ubifs_inode_slab, ui);\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee(ubifs_inode_",
          "args": [
            "lab, ui);\n}\n\nsta",
            "c"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tkme",
          "args": [
            "_cach"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "head, struct",
          "args": [
            "inod",
            "i_rcu;\n\tst",
            "ct ub"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tkmem_cache_free(ubifs_inode_slab, ui);\n}\n\nstatic void"
  },
  {
    "function_name": "node(struct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "257-270",
    "snippet": "inode *ubifs_alloc_inode(struct super_block *sb)\n{\n\tstruct ubifs_inode *ui;\n\n\tui = kmem_cache_alloc(ubifs_inode_slab, GFP_NOFS);\n\tif (!ui)\n\t\treturn NULL;\n\n\tmemset((void *)ui + sizeof(struct inode), 0,\n\t       sizeof(struct ubifs_inode) - sizeof(struct inode));\n\tmutex_init(&ui->ui_mutex);\n\tspin_lock_init(&ui->ui_lock);\n\treturn &ui->vfs_inode;\n};\n\nstatic voi",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t(&ui->ui_lock",
          "args": [
            ";\n\treturn &u"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\tspin_lock"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*)ui +",
          "args": [
            "sizeof(struct inode), 0,",
            "z",
            "ubifs_inode) - sizeof(struct inode));\n\tmutex_ini"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc(ubifs_inode_",
          "args": [
            "lab, GFP_NOFS);",
            "f (!ui)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\ninode *ubifs_alloc_inode(struct super_block *sb)\n{\n\tstruct ubifs_inode *ui;\n\n\tui = kmem_cache_alloc(ubifs_inode_slab, GFP_NOFS);\n\tif (!ui)\n\t\treturn NULL;\n\n\tmemset((void *)ui + sizeof(struct inode), 0,\n\t       sizeof(struct ubifs_inode) - sizeof(struct inode));\n\tmutex_init(&ui->ui_mutex);\n\tspin_lock_init(&ui->ui_lock);\n\treturn &ui->vfs_inode;\n};\n\nstatic voi"
  },
  {
    "function_name": "ruct super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "101-255",
    "snippet": "*ubifs_iget(struct super_block *sb, unsigned long inum)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tdbg_gen(\"inode %lu\", inum);\n\n\tinode = iget_locked(sb, inum);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\tui = ubifs_inode(inode);\n\n\tino = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ino) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tino_key_init(c, &key, inode->i_ino);\n\n\terr = ubifs_tnc_lookup(c, &key, ino);\n\tif (err)\n\t\tgoto out_ino;\n\n\tinode->i_flags |= (S_NOCMTIME | S_NOATIME);\n\tset_nlink(inode, le32_to_cpu(ino->nlink));\n\ti_uid_write(inode, le32_to_cpu(ino->uid));\n\ti_gid_write(inode, le32_to_cpu(ino->gid));\n\tinode->i_atime.tv_sec  = (int64_t)le64_to_cpu(ino->atime_sec);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ino->atime_nsec);\n\tinode->i_mtime.tv_sec  = (int64_t)le64_to_cpu(ino->mtime_sec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ino->mtime_nsec);\n\tinode->i_ctime.tv_sec  = (int64_t)le64_to_cpu(ino->ctime_sec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ino->ctime_nsec);\n\tinode->i_mode = le32_to_cpu(ino->mode);\n\tinode->i_size = le64_to_cpu(ino->size);\n\n\tui->data_len    = le32_to_cpu(ino->data_len);\n\tui->flags       = le32_to_cpu(ino->flags);\n\tui->compr_type  = le16_to_cpu(ino->compr_type);\n\tui->creat_sqnum = le64_to_cpu(ino->creat_sqnum);\n\tui->xattr_cnt   = le32_to_cpu(ino->xattr_cnt);\n\tui->xattr_size  = le32_to_cpu(ino->xattr_size);\n\tui->xattr_names = le32_to_cpu(ino->xattr_names);\n\tui->synced_i_size = ui->ui_size = inode->i_size;\n\n\tui->xattr = (ui->flags & UBIFS_XATTR_FL) ? 1 : 0;\n\n\terr = validate_inode(c, inode);\n\tif (err)\n\t\tgoto out_invalid;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tif (ui->xattr) {\n\t\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\t\tif (!ui->data) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_ino;\n\t\t\t}\n\t\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\t} else if (ui->data_len != 0) {\n\t\t\terr = 10;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 11;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tif (ui->data_len <= 0 || ui->data_len > UBIFS_MAX_INO_DATA) {\n\t\t\terr = 12;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t{\n\t\tdev_t rdev;\n\t\tunion ubifs_dev_desc *dev;\n\n\t\tui->data = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\n\t\tdev = (union ubifs_dev_desc *)ino->data;\n\t\tif (ui->data_len == sizeof(dev->new))\n\t\t\trdev = new_decode_dev(le32_to_cpu(dev->new));\n\t\telse if (ui->data_len == sizeof(dev->huge))\n\t\t\trdev = huge_decode_dev(le64_to_cpu(dev->huge));\n\t\telse {\n\t\t\terr = 13;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\t}\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 14;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = 15;\n\t\tgoto out_invalid;\n\t}\n\n\tkfree(ino);\n\tubifs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nout_invalid:\n\tubifs_err(\"inode %lu validation failed, error %d\", inode->i_ino, err);\n\tubifs_dump_node(c, ino);\n\tubifs_dump_inode(c, inode);\n\terr = -EINVAL;\nout_ino:\n\tkfree(ino);\nout:\n\tubifs_err(\"failed to read inode %lu, error %d\", inode->i_ino, err);\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic stru",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\nsta",
          "args": [
            "ic"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tret",
          "args": [
            "rn ER"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled to r",
          "args": [
            "ad inode %lu, error %d\", inode->i_in",
            "err);\n\tiget",
            "ail"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut:",
          "args": [
            "bif"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "eneric_shutdown_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "393-425",
          "snippet": "oid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ode(c, inode);",
          "args": [
            "r",
            "= -EI"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, ino);\n\tub",
          "args": [
            "f",
            "dum"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu v",
          "args": [
            "lidation failed, error %d\", inode->i_in",
            "err);\n\tubif",
            "dum"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(inode);\n\tret",
          "args": [
            "rn in"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_flags(inode);\n\tunl",
          "args": [
            "ck_ne"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs",
          "args": [
            "set"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "_ro(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
          "lines": "1711-1748",
          "snippet": "bifs_remount_ro(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tubifs_assert(!c->need_recovery);\n\tubifs_assert(!c->ro_mount);\n\n\tmutex_lock(&c->umount_mutex);\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\n\tdbg_save_space_info(c);\n\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\terr = ubifs_write_master(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->ro_mount = 1;\n\terr = dbg_check_space_info(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic void",
          "includes": [
            "fs.h\"\n\n/*\n * Maximu",
            "ux/writeback.h>\n#include \"ubi",
            "ux/math64.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/seq_file.h>\n#include <lin",
            "ux/parser.h>\n#include <lin",
            "ux/kthread.h>\n#include <lin",
            "ux/ctype.h>\n#include <lin",
            "ux/module.h>\n#include <lin",
            "ux/slab.h>\n#include <lin",
            "ux/init.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nbifs_remount_ro(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tubifs_assert(!c->need_recovery);\n\tubifs_assert(!c->ro_mount);\n\n\tmutex_lock(&c->umount_mutex);\n\tif (c->bgt) {\n\t\tkthread_stop(c->bgt);\n\t\tc->bgt = NULL;\n\t}\n\n\tdbg_save_space_info(c);\n\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tubifs_wbuf_sync(&c->jheads[i].wbuf);\n\n\tc->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_NO_ORPHS);\n\tc->mst_node->gc_lnum = cpu_to_le32(c->gc_lnum);\n\terr = ubifs_write_master(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\n\tvfree(c->orph_buf);\n\tc->orph_buf = NULL;\n\tkfree(c->write_reserve_buf);\n\tc->write_reserve_buf = NULL;\n\tvfree(c->ileb_buf);\n\tc->ileb_buf = NULL;\n\tubifs_lpt_free(c, 1);\n\tc->ro_mount = 1;\n\terr = dbg_check_space_info(c);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\tmutex_unlock(&c->umount_mutex);\n}\n\nstatic void"
        }
      },
      {
        "call_info": {
          "callee": "inode(inode, inode",
          "args": [
            ">i_mo",
            ", 0);\n\t\tif (u",
            ">"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode(inode, inode",
          "args": [
            ">i_mo",
            ", rdev);\n\t\tbr",
            "k;"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta, in",
          "args": [
            "->data,",
            "->data_le",
            ";\n\t\tinode->i"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev(le64_to_cpu(",
          "args": [
            "ev->huge));\n\t\telse {"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->huge));",
          "args": [
            "else {"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v(le32_to_cpu(",
          "args": [
            "ev->new));\n\t\telse if"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->new));",
          "args": [
            "else if"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(union",
          "args": [
            "ubifs_dev_desc), GFP_NOFS);",
            "if (!ui-"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta, in",
          "args": [
            "->data,",
            "->data_le",
            ";\n\t\t((char *"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_len",
          "args": [
            "+ 1, GFP_NOFS);",
            "if (!ui-"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta, in",
          "args": [
            "->data,",
            "->data_le",
            ";\n\t\t\t((char"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_len",
          "args": [
            "+ 1, GFP_NOFS);",
            "if (!ui"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, inode);",
          "args": [
            "f",
            "err)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_n",
          "args": [
            "mes);\n\tui->synce"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_s",
          "args": [
            "ze);\n\tui->xattr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_c",
          "args": [
            "t);\n\tui->xattr"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->creat_s",
          "args": [
            "num);\n\tui->xattr"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->compr_t",
          "args": [
            "pe);\n\tui->creat"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->flags);",
          "args": [
            "ui->compr"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->data_le",
          "args": [
            ");\n\tui->flags"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size);",
          "args": [
            "ui->data"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mode);",
          "args": [
            "inode->i_"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->ctime_n",
          "args": [
            "ec);\n\tinode->i_"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->ctime_s",
          "args": [
            "c);\n\tinode->i_"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mtime_n",
          "args": [
            "ec);\n\tinode->i_"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mtime_s",
          "args": [
            "c);\n\tinode->i_"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->atime_n",
          "args": [
            "ec);\n\tinode->i_"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->atime_s",
          "args": [
            "c);\n\tinode->i_"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node, le32_",
          "args": [
            "o_cpu",
            "no->gid));\n\tinode->i_"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->gid));",
          "args": [
            "inode->i"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node, le32_",
          "args": [
            "o_cpu",
            "no->uid));\n\ti_gid_wri"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->uid));",
          "args": [
            "i_gid_wr"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de, le32_",
          "args": [
            "o_cpu",
            "no->nlink));\n\ti_uid_wri"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->nlink))",
          "args": [
            "i_uid_wr"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, &key, ino",
          "args": [
            ";",
            "if (",
            "r)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, ino",
          "args": [
            "e",
            "i_in",
            ";\n\n\terr = ub"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_IN",
          "args": [
            "_NODE_SZ, GFP_NOFS);",
            "f (!ino)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tin",
          "args": [
            "= km"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);\n\ti",
          "args": [
            "(!(ino"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b, inum);",
          "args": [
            "f",
            "inod"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e %lu\",",
          "args": [
            "inum);\n\n\tin",
            "e ="
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\n*ubifs_iget(struct super_block *sb, unsigned long inum)\n{\n\tint err;\n\tunion ubifs_key key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_info *c = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tdbg_gen(\"inode %lu\", inum);\n\n\tinode = iget_locked(sb, inum);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\tui = ubifs_inode(inode);\n\n\tino = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ino) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tino_key_init(c, &key, inode->i_ino);\n\n\terr = ubifs_tnc_lookup(c, &key, ino);\n\tif (err)\n\t\tgoto out_ino;\n\n\tinode->i_flags |= (S_NOCMTIME | S_NOATIME);\n\tset_nlink(inode, le32_to_cpu(ino->nlink));\n\ti_uid_write(inode, le32_to_cpu(ino->uid));\n\ti_gid_write(inode, le32_to_cpu(ino->gid));\n\tinode->i_atime.tv_sec  = (int64_t)le64_to_cpu(ino->atime_sec);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ino->atime_nsec);\n\tinode->i_mtime.tv_sec  = (int64_t)le64_to_cpu(ino->mtime_sec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ino->mtime_nsec);\n\tinode->i_ctime.tv_sec  = (int64_t)le64_to_cpu(ino->ctime_sec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ino->ctime_nsec);\n\tinode->i_mode = le32_to_cpu(ino->mode);\n\tinode->i_size = le64_to_cpu(ino->size);\n\n\tui->data_len    = le32_to_cpu(ino->data_len);\n\tui->flags       = le32_to_cpu(ino->flags);\n\tui->compr_type  = le16_to_cpu(ino->compr_type);\n\tui->creat_sqnum = le64_to_cpu(ino->creat_sqnum);\n\tui->xattr_cnt   = le32_to_cpu(ino->xattr_cnt);\n\tui->xattr_size  = le32_to_cpu(ino->xattr_size);\n\tui->xattr_names = le32_to_cpu(ino->xattr_names);\n\tui->synced_i_size = ui->ui_size = inode->i_size;\n\n\tui->xattr = (ui->flags & UBIFS_XATTR_FL) ? 1 : 0;\n\n\terr = validate_inode(c, inode);\n\tif (err)\n\t\tgoto out_invalid;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_mapping->a_ops = &ubifs_file_address_operations;\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinode->i_fop = &ubifs_file_operations;\n\t\tif (ui->xattr) {\n\t\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\t\tif (!ui->data) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_ino;\n\t\t\t}\n\t\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\t} else if (ui->data_len != 0) {\n\t\t\terr = 10;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op  = &ubifs_dir_inode_operations;\n\t\tinode->i_fop = &ubifs_dir_operations;\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 11;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ubifs_symlink_inode_operations;\n\t\tif (ui->data_len <= 0 || ui->data_len > UBIFS_MAX_INO_DATA) {\n\t\t\terr = 12;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tui->data = kmalloc(ui->data_len + 1, GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\t((char *)ui->data)[ui->data_len] = '\\0';\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t{\n\t\tdev_t rdev;\n\t\tunion ubifs_dev_desc *dev;\n\n\t\tui->data = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);\n\t\tif (!ui->data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_ino;\n\t\t}\n\n\t\tdev = (union ubifs_dev_desc *)ino->data;\n\t\tif (ui->data_len == sizeof(dev->new))\n\t\t\trdev = new_decode_dev(le32_to_cpu(dev->new));\n\t\telse if (ui->data_len == sizeof(dev->huge))\n\t\t\trdev = huge_decode_dev(le64_to_cpu(dev->huge));\n\t\telse {\n\t\t\terr = 13;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tmemcpy(ui->data, ino->data, ui->data_len);\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\t}\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ubifs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tif (ui->data_len != 0) {\n\t\t\terr = 14;\n\t\t\tgoto out_invalid;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = 15;\n\t\tgoto out_invalid;\n\t}\n\n\tkfree(ino);\n\tubifs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nout_invalid:\n\tubifs_err(\"inode %lu validation failed, error %d\", inode->i_ino, err);\n\tubifs_dump_node(c, ino);\n\tubifs_dump_inode(c, inode);\n\terr = -EINVAL;\nout_ino:\n\tkfree(ino);\nout:\n\tubifs_err(\"failed to read inode %lu, error %d\", inode->i_ino, err);\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic stru"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/super.c",
    "lines": "67-99",
    "snippet": "lidate_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (inode->i_size > c->max_inode_sz) {\n\t\tubifs_err(\"inode is too large (%lld)\",\n\t\t\t  (long long)inode->i_size);\n\t\treturn 1;\n\t}\n\n\tif (ui->compr_type >= UBIFS_COMPR_TYPES_CNT) {\n\t\tubifs_err(\"unknown compression type %d\", ui->compr_type);\n\t\treturn 2;\n\t}\n\n\tif (ui->xattr_names + ui->xattr_cnt > XATTR_LIST_MAX)\n\t\treturn 3;\n\n\tif (ui->data_len < 0 || ui->data_len > UBIFS_MAX_INO_DATA)\n\t\treturn 4;\n\n\tif (ui->xattr && !S_ISREG(inode->i_mode))\n\t\treturn 5;\n\n\tif (!ubifs_compr_present(ui->compr_type)) {\n\t\tubifs_warn(\"inode %lu uses '%s' compression, but it was not compiled in\",\n\t\t\t   inode->i_ino, ubifs_compr_name(ui->compr_type));\n\t}\n\n\terr = dbg_check_dir(c, inode);\n\treturn err;\n}\n\nstruct inod",
    "includes": [
      "fs.h\"\n\n/*\n * Maximu",
      "ux/writeback.h>\n#include \"ubi",
      "ux/math64.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/seq_file.h>\n#include <lin",
      "ux/parser.h>\n#include <lin",
      "ux/kthread.h>\n#include <lin",
      "ux/ctype.h>\n#include <lin",
      "ux/module.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "ux/init.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(c, inode);",
          "args": [
            "e",
            "rn er"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node %lu u",
          "args": [
            "es '%s' compression, but it was not compiled in\",\n\t\t\t   inode",
            "ubifs_compr",
            "ame(ui->compr_type));\n\t}\n\n\terr ="
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame(ui->compr_ty",
          "args": [
            "e));\n\t}\n\n\terr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resent(ui->compr_ty",
          "args": [
            "e)) {\n\t\tubifs_"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "))\n\t\treturn 5"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known com",
          "args": [
            "ression type %d\", ui->compr_t",
            "e);\n\t\treturn 2"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode is to",
          "args": [
            "large (%lld)\",\n\t\t\t  (long",
            "ode->i_size);\n\t\treturn 1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tif",
          "args": [
            "(inod"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/*\n * Maximu\nux/writeback.h>\n#include \"ubi\nux/math64.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/seq_file.h>\n#include <lin\nux/parser.h>\n#include <lin\nux/kthread.h>\n#include <lin\nux/ctype.h>\n#include <lin\nux/module.h>\n#include <lin\nux/slab.h>\n#include <lin\nux/init.h>\n#include <lin\n\nlidate_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (inode->i_size > c->max_inode_sz) {\n\t\tubifs_err(\"inode is too large (%lld)\",\n\t\t\t  (long long)inode->i_size);\n\t\treturn 1;\n\t}\n\n\tif (ui->compr_type >= UBIFS_COMPR_TYPES_CNT) {\n\t\tubifs_err(\"unknown compression type %d\", ui->compr_type);\n\t\treturn 2;\n\t}\n\n\tif (ui->xattr_names + ui->xattr_cnt > XATTR_LIST_MAX)\n\t\treturn 3;\n\n\tif (ui->data_len < 0 || ui->data_len > UBIFS_MAX_INO_DATA)\n\t\treturn 4;\n\n\tif (ui->xattr && !S_ISREG(inode->i_mode))\n\t\treturn 5;\n\n\tif (!ubifs_compr_present(ui->compr_type)) {\n\t\tubifs_warn(\"inode %lu uses '%s' compression, but it was not compiled in\",\n\t\t\t   inode->i_ino, ubifs_compr_name(ui->compr_type));\n\t}\n\n\terr = dbg_check_dir(c, inode);\n\treturn err;\n}\n\nstruct inod"
  }
]