[
  {
    "function_name": "filldir64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
    "lines": "237-275",
    "snippet": "static int filldir64(struct dir_context *ctx, const char *name, int namlen,\n\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent64 __user *dirent;\n\tstruct getdents_callback64 *buf =\n\t\tcontainer_of(ctx, struct getdents_callback64, ctx);\n\tint reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,\n\t\tsizeof(u64));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(0, &dirent->d_off))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (__put_user(d_type, &dirent->d_type))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_type",
            "&dirent->d_type"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reclen",
            "&dirent->d_reclen"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&dirent->d_off"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ino",
            "&dirent->d_ino"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_off"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offsetof(struct linux_dirent64, d_name) + namlen + 1",
            "sizeof(u64)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structgetdents_callback64",
            "ctx"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int filldir64(struct dir_context *ctx, const char *name, int namlen,\n\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent64 __user *dirent;\n\tstruct getdents_callback64 *buf =\n\t\tcontainer_of(ctx, struct getdents_callback64, ctx);\n\tint reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,\n\t\tsizeof(u64));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(0, &dirent->d_off))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (__put_user(d_type, &dirent->d_type))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
    "lines": "152-194",
    "snippet": "static int filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent __user * dirent;\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tunsigned long d_ino;\n\tint reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,\n\t\tsizeof(long));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_type",
            "(char __user *) dirent + reclen - 1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reclen",
            "&dirent->d_reclen"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_off"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offsetof(struct linux_dirent, d_name) + namlen + 2",
            "sizeof(long)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structgetdents_callback",
            "ctx"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent __user * dirent;\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tunsigned long d_ino;\n\tint reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,\n\t\tsizeof(long));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "fillonedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
    "lines": "77-108",
    "snippet": "static int fillonedir(struct dir_context *ctx, const char *name, int namlen,\n\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_callback *buf =\n\t\tcontainer_of(ctx, struct readdir_callback, ctx);\n\tstruct old_linux_dirent __user * dirent;\n\tunsigned long d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "namlen",
            "&dirent->d_namlen"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_offset"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "dirent",
            "(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structreaddir_callback",
            "ctx"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int fillonedir(struct dir_context *ctx, const char *name, int namlen,\n\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_callback *buf =\n\t\tcontainer_of(ctx, struct readdir_callback, ctx);\n\tstruct old_linux_dirent __user * dirent;\n\tunsigned long d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "iterate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
    "lines": "24-50",
    "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->iterate",
          "args": [
            "file",
            "ctx"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "inode"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "MAY_READ"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
  }
]