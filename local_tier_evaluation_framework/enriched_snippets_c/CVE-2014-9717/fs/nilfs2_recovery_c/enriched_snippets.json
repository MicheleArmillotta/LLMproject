[
  {
    "function_name": "nilfs_search_super_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "813-964",
    "snippet": "int nilfs_search_super_root(struct the_nilfs *nilfs,\n\t\t\t    struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start, pseg_end, sr_pseg_start = 0;\n\tsector_t seg_start, seg_end; /* range of full segment (block number) */\n\tsector_t b, end;\n\tunsigned long nblocks;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\t__u64 cno;\n\tLIST_HEAD(segments);\n\tint empty_seg = 0, scan_newer = 0;\n\tint ret;\n\n\tpseg_start = nilfs->ns_last_pseg;\n\tseg_seq = nilfs->ns_last_seq;\n\tcno = nilfs->ns_last_cno;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\n\t/* Calculate range of segment */\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\t/* Read ahead segment */\n\tb = seg_start;\n\twhile (b <= seg_end)\n\t\t__breadahead(nilfs->ns_bdev, b++, nilfs->ns_blocksize);\n\n\tfor (;;) {\n\t\tbrelse(bh_sum);\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum)\n\t\t\tgoto failed;\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO)\n\t\t\t\tgoto failed;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tnblocks = le32_to_cpu(sum->ss_nblocks);\n\t\tpseg_end = pseg_start + nblocks - 1;\n\t\tif (unlikely(pseg_end > seg_end)) {\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\t/* A valid partial segment */\n\t\tri->ri_pseg_start = pseg_start;\n\t\tri->ri_seq = seg_seq;\n\t\tri->ri_segnum = segnum;\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tri->ri_nextnum = nextnum;\n\t\tempty_seg = 0;\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (!(flags & NILFS_SS_SR) && !scan_newer) {\n\t\t\t/* This will never happen because a superblock\n\t\t\t   (last_segment) always points to a pseg\n\t\t\t   having a super root. */\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (pseg_start == seg_start) {\n\t\t\tnilfs_get_segment_range(nilfs, nextnum, &b, &end);\n\t\t\twhile (b <= end)\n\t\t\t\t__breadahead(nilfs->ns_bdev, b++,\n\t\t\t\t\t     nilfs->ns_blocksize);\n\t\t}\n\t\tif (!(flags & NILFS_SS_SR)) {\n\t\t\tif (!ri->ri_lsegs_start && (flags & NILFS_SS_LOGBGN)) {\n\t\t\t\tri->ri_lsegs_start = pseg_start;\n\t\t\t\tri->ri_lsegs_start_seq = seg_seq;\n\t\t\t}\n\t\t\tif (flags & NILFS_SS_LOGEND)\n\t\t\t\tri->ri_lsegs_end = pseg_start;\n\t\t\tgoto try_next_pseg;\n\t\t}\n\n\t\t/* A valid super root was found. */\n\t\tri->ri_cno = cno++;\n\t\tri->ri_super_root = pseg_end;\n\t\tri->ri_lsegs_start = ri->ri_lsegs_end = 0;\n\n\t\tnilfs_dispose_segment_list(&segments);\n\t\tsr_pseg_start = pseg_start;\n\t\tnilfs->ns_pseg_offset = pseg_start + nblocks - seg_start;\n\t\tnilfs->ns_seg_seq = seg_seq;\n\t\tnilfs->ns_segnum = segnum;\n\t\tnilfs->ns_cno = cno;  /* nilfs->ns_cno = ri->ri_cno + 1 */\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tnilfs->ns_nextnum = nextnum;\n\n\t\tif (scan_newer)\n\t\t\tri->ri_need_recovery = NILFS_RECOVERY_SR_UPDATED;\n\t\telse {\n\t\t\tif (nilfs->ns_mount_state & NILFS_VALID_FS)\n\t\t\t\tgoto super_root_found;\n\t\t\tscan_newer = 1;\n\t\t}\n\n try_next_pseg:\n\t\t/* Standing on a course, or met an inconsistent state */\n\t\tpseg_start += nblocks;\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\t/* Off the trail */\n\t\tif (!scan_newer)\n\t\t\t/*\n\t\t\t * This can happen if a checkpoint was written without\n\t\t\t * barriers, or as a result of an I/O failure.\n\t\t\t */\n\t\t\tgoto failed;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tgoto super_root_found; /* found a valid super root */\n\n\t\tret = nilfs_segment_list_add(&segments, segnum);\n\t\tif (unlikely(ret))\n\t\t\tgoto failed;\n\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n super_root_found:\n\t/* Updating pointers relating to the latest checkpoint */\n\tbrelse(bh_sum);\n\tlist_splice_tail(&segments, &ri->ri_used_segments);\n\tnilfs->ns_last_pseg = sr_pseg_start;\n\tnilfs->ns_last_seq = nilfs->ns_seg_seq;\n\tnilfs->ns_last_cno = ri->ri_cno;\n\treturn 0;\n\n failed:\n\tbrelse(bh_sum);\n\tnilfs_dispose_segment_list(&segments);\n\treturn (ret < 0) ? ret : nilfs_warn_segment_error(ret);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_warn_segment_error",
          "args": [
            "ret"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warn_segment_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "59-92",
          "snippet": "static int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_dispose_segment_list",
          "args": [
            "&segments"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dispose_segment_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "416-425",
          "snippet": "void nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_sum"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&segments",
            "&ri->ri_used_segments"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_get_segment_range",
          "args": [
            "nilfs",
            "segnum",
            "&seg_start",
            "&seg_end"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segment_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "319-327",
          "snippet": "static inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segment_list_add",
          "args": [
            "&segments",
            "segnum"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segment_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "403-414",
          "snippet": "static int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sum->ss_create"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__breadahead",
          "args": [
            "nilfs->ns_bdev",
            "b++",
            "nilfs->ns_blocksize"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sum->ss_flags"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_segnum_of_block",
          "args": [
            "nilfs",
            "le64_to_cpu(sum->ss_next)"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segnum_of_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "336-343",
          "snippet": "static inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pseg_end > seg_end"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sum->ss_nblocks"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_validate_log",
          "args": [
            "nilfs",
            "seg_seq",
            "bh_sum",
            "sum"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_validate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "211-245",
          "snippet": "static int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_read_log_header",
          "args": [
            "nilfs",
            "pseg_start",
            "&sum"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "192-202",
          "snippet": "static struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "segments"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_search_super_root(struct the_nilfs *nilfs,\n\t\t\t    struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start, pseg_end, sr_pseg_start = 0;\n\tsector_t seg_start, seg_end; /* range of full segment (block number) */\n\tsector_t b, end;\n\tunsigned long nblocks;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\t__u64 cno;\n\tLIST_HEAD(segments);\n\tint empty_seg = 0, scan_newer = 0;\n\tint ret;\n\n\tpseg_start = nilfs->ns_last_pseg;\n\tseg_seq = nilfs->ns_last_seq;\n\tcno = nilfs->ns_last_cno;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\n\t/* Calculate range of segment */\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\t/* Read ahead segment */\n\tb = seg_start;\n\twhile (b <= seg_end)\n\t\t__breadahead(nilfs->ns_bdev, b++, nilfs->ns_blocksize);\n\n\tfor (;;) {\n\t\tbrelse(bh_sum);\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum)\n\t\t\tgoto failed;\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO)\n\t\t\t\tgoto failed;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tnblocks = le32_to_cpu(sum->ss_nblocks);\n\t\tpseg_end = pseg_start + nblocks - 1;\n\t\tif (unlikely(pseg_end > seg_end)) {\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\t/* A valid partial segment */\n\t\tri->ri_pseg_start = pseg_start;\n\t\tri->ri_seq = seg_seq;\n\t\tri->ri_segnum = segnum;\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tri->ri_nextnum = nextnum;\n\t\tempty_seg = 0;\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (!(flags & NILFS_SS_SR) && !scan_newer) {\n\t\t\t/* This will never happen because a superblock\n\t\t\t   (last_segment) always points to a pseg\n\t\t\t   having a super root. */\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (pseg_start == seg_start) {\n\t\t\tnilfs_get_segment_range(nilfs, nextnum, &b, &end);\n\t\t\twhile (b <= end)\n\t\t\t\t__breadahead(nilfs->ns_bdev, b++,\n\t\t\t\t\t     nilfs->ns_blocksize);\n\t\t}\n\t\tif (!(flags & NILFS_SS_SR)) {\n\t\t\tif (!ri->ri_lsegs_start && (flags & NILFS_SS_LOGBGN)) {\n\t\t\t\tri->ri_lsegs_start = pseg_start;\n\t\t\t\tri->ri_lsegs_start_seq = seg_seq;\n\t\t\t}\n\t\t\tif (flags & NILFS_SS_LOGEND)\n\t\t\t\tri->ri_lsegs_end = pseg_start;\n\t\t\tgoto try_next_pseg;\n\t\t}\n\n\t\t/* A valid super root was found. */\n\t\tri->ri_cno = cno++;\n\t\tri->ri_super_root = pseg_end;\n\t\tri->ri_lsegs_start = ri->ri_lsegs_end = 0;\n\n\t\tnilfs_dispose_segment_list(&segments);\n\t\tsr_pseg_start = pseg_start;\n\t\tnilfs->ns_pseg_offset = pseg_start + nblocks - seg_start;\n\t\tnilfs->ns_seg_seq = seg_seq;\n\t\tnilfs->ns_segnum = segnum;\n\t\tnilfs->ns_cno = cno;  /* nilfs->ns_cno = ri->ri_cno + 1 */\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tnilfs->ns_nextnum = nextnum;\n\n\t\tif (scan_newer)\n\t\t\tri->ri_need_recovery = NILFS_RECOVERY_SR_UPDATED;\n\t\telse {\n\t\t\tif (nilfs->ns_mount_state & NILFS_VALID_FS)\n\t\t\t\tgoto super_root_found;\n\t\t\tscan_newer = 1;\n\t\t}\n\n try_next_pseg:\n\t\t/* Standing on a course, or met an inconsistent state */\n\t\tpseg_start += nblocks;\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\t/* Off the trail */\n\t\tif (!scan_newer)\n\t\t\t/*\n\t\t\t * This can happen if a checkpoint was written without\n\t\t\t * barriers, or as a result of an I/O failure.\n\t\t\t */\n\t\t\tgoto failed;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tgoto super_root_found; /* found a valid super root */\n\n\t\tret = nilfs_segment_list_add(&segments, segnum);\n\t\tif (unlikely(ret))\n\t\t\tgoto failed;\n\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n super_root_found:\n\t/* Updating pointers relating to the latest checkpoint */\n\tbrelse(bh_sum);\n\tlist_splice_tail(&segments, &ri->ri_used_segments);\n\tnilfs->ns_last_pseg = sr_pseg_start;\n\tnilfs->ns_last_seq = nilfs->ns_seg_seq;\n\tnilfs->ns_last_cno = ri->ri_cno;\n\treturn 0;\n\n failed:\n\tbrelse(bh_sum);\n\tnilfs_dispose_segment_list(&segments);\n\treturn (ret < 0) ? ret : nilfs_warn_segment_error(ret);\n}"
  },
  {
    "function_name": "nilfs_salvage_orphan_logs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "744-793",
    "snippet": "int nilfs_salvage_orphan_logs(struct the_nilfs *nilfs,\n\t\t\t      struct super_block *sb,\n\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct nilfs_root *root;\n\tint err;\n\n\tif (ri->ri_lsegs_start == 0 || ri->ri_lsegs_end == 0)\n\t\treturn 0;\n\n\terr = nilfs_attach_checkpoint(sb, ri->ri_cno, true, &root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: error loading the latest checkpoint.\\n\");\n\t\treturn err;\n\t}\n\n\terr = nilfs_do_roll_forward(nilfs, sb, root, ri);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (ri->ri_need_recovery == NILFS_RECOVERY_ROLLFORWARD_DONE) {\n\t\terr = nilfs_prepare_segment_for_recovery(nilfs, sb, ri);\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Error preparing segments for \"\n\t\t\t       \"recovery.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tset_nilfs_discontinued(nilfs);\n\t\terr = nilfs_construct_segment(sb);\n\t\tnilfs_detach_log_writer(sb);\n\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Oops! recovery failed. \"\n\t\t\t       \"(err=%d)\\n\", err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnilfs_finish_roll_forward(nilfs, ri);\n\t}\n\n failed:\n\tnilfs_put_root(root);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "root"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_finish_roll_forward",
          "args": [
            "nilfs",
            "ri"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_finish_roll_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "703-723",
          "snippet": "static void nilfs_finish_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (nilfs_get_segnum_of_block(nilfs, ri->ri_lsegs_start) !=\n\t    nilfs_get_segnum_of_block(nilfs, ri->ri_super_root))\n\t\treturn;\n\n\tbh = __getblk(nilfs->ns_bdev, ri->ri_lsegs_start, nilfs->ns_blocksize);\n\tBUG_ON(!bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_dirty(bh);\n\terr = sync_dirty_buffer(bh);\n\tif (unlikely(err))\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: buffer sync write failed during \"\n\t\t       \"post-cleaning of recovery.\\n\");\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_finish_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (nilfs_get_segnum_of_block(nilfs, ri->ri_lsegs_start) !=\n\t    nilfs_get_segnum_of_block(nilfs, ri->ri_super_root))\n\t\treturn;\n\n\tbh = __getblk(nilfs->ns_bdev, ri->ri_lsegs_start, nilfs->ns_blocksize);\n\tBUG_ON(!bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_dirty(bh);\n\terr = sync_dirty_buffer(bh);\n\tif (unlikely(err))\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: buffer sync write failed during \"\n\t\t       \"post-cleaning of recovery.\\n\");\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: Oops! recovery failed. \"\n\t\t\t       \"(err=%d)\\n\"",
            "err"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_detach_log_writer",
          "args": [
            "sb"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_detach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2737-2759",
          "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "sb"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_attach_log_writer",
          "args": [
            "sb",
            "root"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2704-2728",
          "snippet": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_segment_for_recovery",
          "args": [
            "nilfs",
            "sb",
            "ri"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_segment_for_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "427-483",
          "snippet": "static int nilfs_prepare_segment_for_recovery(struct the_nilfs *nilfs,\n\t\t\t\t\t      struct super_block *sb,\n\t\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t/*\n\t * Releasing the next segment of the latest super root.\n\t * The next segment is invalidated by this recovery.\n\t */\n\terr = nilfs_sufile_free(sufile, segnum[1]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tfor (i = 1; i < 4; i++) {\n\t\terr = nilfs_segment_list_add(head, segnum[i]);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Collecting segments written after the latest super root.\n\t * These are marked dirty to avoid being reallocated in the next write.\n\t */\n\tlist_for_each_entry_safe(ent, n, head, list) {\n\t\tif (ent->segnum != segnum[0]) {\n\t\t\terr = nilfs_sufile_scrap(sufile, ent->segnum);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t}\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n\n\t/* Allocate new segments for recovery */\n\terr = nilfs_sufile_alloc(sufile, &segnum[0]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq = ri->ri_seq + 2;\n\tnilfs->ns_nextnum = nilfs->ns_segnum = segnum[0];\n\n failed:\n\t/* No need to recover sufile because it will be destroyed on error */\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_prepare_segment_for_recovery(struct the_nilfs *nilfs,\n\t\t\t\t\t      struct super_block *sb,\n\t\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t/*\n\t * Releasing the next segment of the latest super root.\n\t * The next segment is invalidated by this recovery.\n\t */\n\terr = nilfs_sufile_free(sufile, segnum[1]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tfor (i = 1; i < 4; i++) {\n\t\terr = nilfs_segment_list_add(head, segnum[i]);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Collecting segments written after the latest super root.\n\t * These are marked dirty to avoid being reallocated in the next write.\n\t */\n\tlist_for_each_entry_safe(ent, n, head, list) {\n\t\tif (ent->segnum != segnum[0]) {\n\t\t\terr = nilfs_sufile_scrap(sufile, ent->segnum);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t}\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n\n\t/* Allocate new segments for recovery */\n\terr = nilfs_sufile_alloc(sufile, &segnum[0]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq = ri->ri_seq + 2;\n\tnilfs->ns_nextnum = nilfs->ns_segnum = segnum[0];\n\n failed:\n\t/* No need to recover sufile because it will be destroyed on error */\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_do_roll_forward",
          "args": [
            "nilfs",
            "sb",
            "root",
            "ri"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_do_roll_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "579-701",
          "snippet": "static int nilfs_do_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start;\n\tsector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */\n\tunsigned long nsalvaged_blocks = 0;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\tint empty_seg = 0;\n\tint err = 0, ret;\n\tLIST_HEAD(dsync_blocks);  /* list of data blocks to be recovered */\n\tenum {\n\t\tRF_INIT_ST,\n\t\tRF_DSYNC_ST,   /* scanning data-sync segments */\n\t};\n\tint state = RF_INIT_ST;\n\n\tpseg_start = ri->ri_lsegs_start;\n\tseg_seq = ri->ri_lsegs_start_seq;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\twhile (segnum != ri->ri_segnum || pseg_start <= ri->ri_pseg_start) {\n\t\tbrelse(bh_sum);\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum) {\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (flags & NILFS_SS_SR)\n\t\t\tgoto confused;\n\n\t\t/* Found a valid partial segment; do recovery actions */\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tempty_seg = 0;\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tif (!(flags & NILFS_SS_GC))\n\t\t\tnilfs->ns_nongc_ctime = nilfs->ns_ctime;\n\n\t\tswitch (state) {\n\t\tcase RF_INIT_ST:\n\t\t\tif (!(flags & NILFS_SS_LOGBGN) ||\n\t\t\t    !(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto try_next_pseg;\n\t\t\tstate = RF_DSYNC_ST;\n\t\t\t/* Fall through */\n\t\tcase RF_DSYNC_ST:\n\t\t\tif (!(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto confused;\n\n\t\t\terr = nilfs_scan_dsync_log(nilfs, pseg_start, sum,\n\t\t\t\t\t\t   &dsync_blocks);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t\tif (flags & NILFS_SS_LOGEND) {\n\t\t\t\terr = nilfs_recover_dsync_blocks(\n\t\t\t\t\tnilfs, sb, root, &dsync_blocks,\n\t\t\t\t\t&nsalvaged_blocks);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto failed;\n\t\t\t\tstate = RF_INIT_ST;\n\t\t\t}\n\t\t\tbreak; /* Fall through to try_next_pseg */\n\t\t}\n\n try_next_pseg:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\t\tpseg_start += le32_to_cpu(sum->ss_nblocks);\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tbreak;\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n\tif (nsalvaged_blocks) {\n\t\tprintk(KERN_INFO \"NILFS (device %s): salvaged %lu blocks\\n\",\n\t\t       sb->s_id, nsalvaged_blocks);\n\t\tri->ri_need_recovery = NILFS_RECOVERY_ROLLFORWARD_DONE;\n\t}\n out:\n\tbrelse(bh_sum);\n\tdispose_recovery_list(&dsync_blocks);\n\treturn err;\n\n confused:\n\terr = -EINVAL;\n failed:\n\tprintk(KERN_ERR\n\t       \"NILFS (device %s): Error roll-forwarding \"\n\t       \"(err=%d, pseg block=%llu). \",\n\t       sb->s_id, err, (unsigned long long)pseg_start);\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_do_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start;\n\tsector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */\n\tunsigned long nsalvaged_blocks = 0;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\tint empty_seg = 0;\n\tint err = 0, ret;\n\tLIST_HEAD(dsync_blocks);  /* list of data blocks to be recovered */\n\tenum {\n\t\tRF_INIT_ST,\n\t\tRF_DSYNC_ST,   /* scanning data-sync segments */\n\t};\n\tint state = RF_INIT_ST;\n\n\tpseg_start = ri->ri_lsegs_start;\n\tseg_seq = ri->ri_lsegs_start_seq;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\twhile (segnum != ri->ri_segnum || pseg_start <= ri->ri_pseg_start) {\n\t\tbrelse(bh_sum);\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum) {\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (flags & NILFS_SS_SR)\n\t\t\tgoto confused;\n\n\t\t/* Found a valid partial segment; do recovery actions */\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tempty_seg = 0;\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tif (!(flags & NILFS_SS_GC))\n\t\t\tnilfs->ns_nongc_ctime = nilfs->ns_ctime;\n\n\t\tswitch (state) {\n\t\tcase RF_INIT_ST:\n\t\t\tif (!(flags & NILFS_SS_LOGBGN) ||\n\t\t\t    !(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto try_next_pseg;\n\t\t\tstate = RF_DSYNC_ST;\n\t\t\t/* Fall through */\n\t\tcase RF_DSYNC_ST:\n\t\t\tif (!(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto confused;\n\n\t\t\terr = nilfs_scan_dsync_log(nilfs, pseg_start, sum,\n\t\t\t\t\t\t   &dsync_blocks);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t\tif (flags & NILFS_SS_LOGEND) {\n\t\t\t\terr = nilfs_recover_dsync_blocks(\n\t\t\t\t\tnilfs, sb, root, &dsync_blocks,\n\t\t\t\t\t&nsalvaged_blocks);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto failed;\n\t\t\t\tstate = RF_INIT_ST;\n\t\t\t}\n\t\t\tbreak; /* Fall through to try_next_pseg */\n\t\t}\n\n try_next_pseg:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\t\tpseg_start += le32_to_cpu(sum->ss_nblocks);\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tbreak;\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n\tif (nsalvaged_blocks) {\n\t\tprintk(KERN_INFO \"NILFS (device %s): salvaged %lu blocks\\n\",\n\t\t       sb->s_id, nsalvaged_blocks);\n\t\tri->ri_need_recovery = NILFS_RECOVERY_ROLLFORWARD_DONE;\n\t}\n out:\n\tbrelse(bh_sum);\n\tdispose_recovery_list(&dsync_blocks);\n\treturn err;\n\n confused:\n\terr = -EINVAL;\n failed:\n\tprintk(KERN_ERR\n\t       \"NILFS (device %s): Error roll-forwarding \"\n\t       \"(err=%d, pseg block=%llu). \",\n\t       sb->s_id, err, (unsigned long long)pseg_start);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_attach_checkpoint",
          "args": [
            "sb",
            "ri->ri_cno",
            "true",
            "&root"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "526-580",
          "snippet": "int nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_salvage_orphan_logs(struct the_nilfs *nilfs,\n\t\t\t      struct super_block *sb,\n\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct nilfs_root *root;\n\tint err;\n\n\tif (ri->ri_lsegs_start == 0 || ri->ri_lsegs_end == 0)\n\t\treturn 0;\n\n\terr = nilfs_attach_checkpoint(sb, ri->ri_cno, true, &root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: error loading the latest checkpoint.\\n\");\n\t\treturn err;\n\t}\n\n\terr = nilfs_do_roll_forward(nilfs, sb, root, ri);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (ri->ri_need_recovery == NILFS_RECOVERY_ROLLFORWARD_DONE) {\n\t\terr = nilfs_prepare_segment_for_recovery(nilfs, sb, ri);\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Error preparing segments for \"\n\t\t\t       \"recovery.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tset_nilfs_discontinued(nilfs);\n\t\terr = nilfs_construct_segment(sb);\n\t\tnilfs_detach_log_writer(sb);\n\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Oops! recovery failed. \"\n\t\t\t       \"(err=%d)\\n\", err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnilfs_finish_roll_forward(nilfs, ri);\n\t}\n\n failed:\n\tnilfs_put_root(root);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_finish_roll_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "703-723",
    "snippet": "static void nilfs_finish_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (nilfs_get_segnum_of_block(nilfs, ri->ri_lsegs_start) !=\n\t    nilfs_get_segnum_of_block(nilfs, ri->ri_super_root))\n\t\treturn;\n\n\tbh = __getblk(nilfs->ns_bdev, ri->ri_lsegs_start, nilfs->ns_blocksize);\n\tBUG_ON(!bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_dirty(bh);\n\terr = sync_dirty_buffer(bh);\n\tif (unlikely(err))\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: buffer sync write failed during \"\n\t\t       \"post-cleaning of recovery.\\n\");\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"NILFS warning: buffer sync write failed during \"\n\t\t       \"post-cleaning of recovery.\\n\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "bh->b_size"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "nilfs->ns_bdev",
            "ri->ri_lsegs_start",
            "nilfs->ns_blocksize"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_get_segnum_of_block",
          "args": [
            "nilfs",
            "ri->ri_super_root"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segnum_of_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "336-343",
          "snippet": "static inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_finish_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (nilfs_get_segnum_of_block(nilfs, ri->ri_lsegs_start) !=\n\t    nilfs_get_segnum_of_block(nilfs, ri->ri_super_root))\n\t\treturn;\n\n\tbh = __getblk(nilfs->ns_bdev, ri->ri_lsegs_start, nilfs->ns_blocksize);\n\tBUG_ON(!bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_dirty(bh);\n\terr = sync_dirty_buffer(bh);\n\tif (unlikely(err))\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: buffer sync write failed during \"\n\t\t       \"post-cleaning of recovery.\\n\");\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "nilfs_do_roll_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "579-701",
    "snippet": "static int nilfs_do_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start;\n\tsector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */\n\tunsigned long nsalvaged_blocks = 0;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\tint empty_seg = 0;\n\tint err = 0, ret;\n\tLIST_HEAD(dsync_blocks);  /* list of data blocks to be recovered */\n\tenum {\n\t\tRF_INIT_ST,\n\t\tRF_DSYNC_ST,   /* scanning data-sync segments */\n\t};\n\tint state = RF_INIT_ST;\n\n\tpseg_start = ri->ri_lsegs_start;\n\tseg_seq = ri->ri_lsegs_start_seq;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\twhile (segnum != ri->ri_segnum || pseg_start <= ri->ri_pseg_start) {\n\t\tbrelse(bh_sum);\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum) {\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (flags & NILFS_SS_SR)\n\t\t\tgoto confused;\n\n\t\t/* Found a valid partial segment; do recovery actions */\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tempty_seg = 0;\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tif (!(flags & NILFS_SS_GC))\n\t\t\tnilfs->ns_nongc_ctime = nilfs->ns_ctime;\n\n\t\tswitch (state) {\n\t\tcase RF_INIT_ST:\n\t\t\tif (!(flags & NILFS_SS_LOGBGN) ||\n\t\t\t    !(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto try_next_pseg;\n\t\t\tstate = RF_DSYNC_ST;\n\t\t\t/* Fall through */\n\t\tcase RF_DSYNC_ST:\n\t\t\tif (!(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto confused;\n\n\t\t\terr = nilfs_scan_dsync_log(nilfs, pseg_start, sum,\n\t\t\t\t\t\t   &dsync_blocks);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t\tif (flags & NILFS_SS_LOGEND) {\n\t\t\t\terr = nilfs_recover_dsync_blocks(\n\t\t\t\t\tnilfs, sb, root, &dsync_blocks,\n\t\t\t\t\t&nsalvaged_blocks);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto failed;\n\t\t\t\tstate = RF_INIT_ST;\n\t\t\t}\n\t\t\tbreak; /* Fall through to try_next_pseg */\n\t\t}\n\n try_next_pseg:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\t\tpseg_start += le32_to_cpu(sum->ss_nblocks);\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tbreak;\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n\tif (nsalvaged_blocks) {\n\t\tprintk(KERN_INFO \"NILFS (device %s): salvaged %lu blocks\\n\",\n\t\t       sb->s_id, nsalvaged_blocks);\n\t\tri->ri_need_recovery = NILFS_RECOVERY_ROLLFORWARD_DONE;\n\t}\n out:\n\tbrelse(bh_sum);\n\tdispose_recovery_list(&dsync_blocks);\n\treturn err;\n\n confused:\n\terr = -EINVAL;\n failed:\n\tprintk(KERN_ERR\n\t       \"NILFS (device %s): Error roll-forwarding \"\n\t       \"(err=%d, pseg block=%llu). \",\n\t       sb->s_id, err, (unsigned long long)pseg_start);\n\tgoto out;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t       \"NILFS (device %s): Error roll-forwarding \"\n\t       \"(err=%d, pseg block=%llu). \"",
            "sb->s_id",
            "err",
            "(unsigned long long)pseg_start"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispose_recovery_list",
          "args": [
            "&dsync_blocks"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "387-396",
          "snippet": "static void dispose_recovery_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_recovery_block *rb;\n\n\t\trb = list_first_entry(head, struct nilfs_recovery_block, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void dispose_recovery_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_recovery_block *rb;\n\n\t\trb = list_first_entry(head, struct nilfs_recovery_block, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_sum"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_segment_range",
          "args": [
            "nilfs",
            "segnum",
            "&seg_start",
            "&seg_end"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segment_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "319-327",
          "snippet": "static inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sum->ss_nblocks"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_recover_dsync_blocks",
          "args": [
            "nilfs",
            "sb",
            "root",
            "&dsync_blocks",
            "&nsalvaged_blocks"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_recover_dsync_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "503-570",
          "snippet": "static int nilfs_recover_dsync_blocks(struct the_nilfs *nilfs,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct nilfs_root *root,\n\t\t\t\t      struct list_head *head,\n\t\t\t\t      unsigned long *nr_salvaged_blocks)\n{\n\tstruct inode *inode;\n\tstruct nilfs_recovery_block *rb, *n;\n\tunsigned blocksize = nilfs->ns_blocksize;\n\tstruct page *page;\n\tloff_t pos;\n\tint err = 0, err2 = 0;\n\n\tlist_for_each_entry_safe(rb, n, head, list) {\n\t\tinode = nilfs_iget(sb, root, rb->ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\tpos = rb->blkoff << inode->i_blkbits;\n\t\terr = block_write_begin(inode->i_mapping, pos, blocksize,\n\t\t\t\t\t0, &page, nilfs_get_block);\n\t\tif (unlikely(err)) {\n\t\t\tloff_t isize = inode->i_size;\n\t\t\tif (pos + blocksize > isize)\n\t\t\t\tnilfs_write_failed(inode->i_mapping,\n\t\t\t\t\t\t\tpos + blocksize);\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\terr = nilfs_recovery_copy_block(nilfs, rb, page);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\terr = nilfs_set_file_dirty(inode, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\tblock_write_end(NULL, inode->i_mapping, pos, blocksize,\n\t\t\t\tblocksize, page, NULL);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\t(*nr_salvaged_blocks)++;\n\t\tgoto next;\n\n failed_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n failed_inode:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: error recovering data block \"\n\t\t       \"(err=%d, ino=%lu, block-offset=%llu)\\n\",\n\t\t       err, (unsigned long)rb->ino,\n\t\t       (unsigned long long)rb->blkoff);\n\t\tif (!err2)\n\t\t\terr2 = err;\n next:\n\t\tiput(inode); /* iput(NULL) is just ignored */\n\t\tlist_del_init(&rb->list);\n\t\tkfree(rb);\n\t}\n\treturn err2;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_recover_dsync_blocks(struct the_nilfs *nilfs,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct nilfs_root *root,\n\t\t\t\t      struct list_head *head,\n\t\t\t\t      unsigned long *nr_salvaged_blocks)\n{\n\tstruct inode *inode;\n\tstruct nilfs_recovery_block *rb, *n;\n\tunsigned blocksize = nilfs->ns_blocksize;\n\tstruct page *page;\n\tloff_t pos;\n\tint err = 0, err2 = 0;\n\n\tlist_for_each_entry_safe(rb, n, head, list) {\n\t\tinode = nilfs_iget(sb, root, rb->ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\tpos = rb->blkoff << inode->i_blkbits;\n\t\terr = block_write_begin(inode->i_mapping, pos, blocksize,\n\t\t\t\t\t0, &page, nilfs_get_block);\n\t\tif (unlikely(err)) {\n\t\t\tloff_t isize = inode->i_size;\n\t\t\tif (pos + blocksize > isize)\n\t\t\t\tnilfs_write_failed(inode->i_mapping,\n\t\t\t\t\t\t\tpos + blocksize);\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\terr = nilfs_recovery_copy_block(nilfs, rb, page);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\terr = nilfs_set_file_dirty(inode, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\tblock_write_end(NULL, inode->i_mapping, pos, blocksize,\n\t\t\t\tblocksize, page, NULL);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\t(*nr_salvaged_blocks)++;\n\t\tgoto next;\n\n failed_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n failed_inode:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: error recovering data block \"\n\t\t       \"(err=%d, ino=%lu, block-offset=%llu)\\n\",\n\t\t       err, (unsigned long)rb->ino,\n\t\t       (unsigned long long)rb->blkoff);\n\t\tif (!err2)\n\t\t\terr2 = err;\n next:\n\t\tiput(inode); /* iput(NULL) is just ignored */\n\t\tlist_del_init(&rb->list);\n\t\tkfree(rb);\n\t}\n\treturn err2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_scan_dsync_log",
          "args": [
            "nilfs",
            "pseg_start",
            "sum",
            "&dsync_blocks"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_scan_dsync_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "316-385",
          "snippet": "static int nilfs_scan_dsync_log(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t\t\tstruct nilfs_segment_summary *sum,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct buffer_head *bh;\n\tunsigned int offset;\n\tu32 nfinfo, sumbytes;\n\tsector_t blocknr;\n\tino_t ino;\n\tint err = -EIO;\n\n\tnfinfo = le32_to_cpu(sum->ss_nfinfo);\n\tif (!nfinfo)\n\t\treturn 0;\n\n\tsumbytes = le32_to_cpu(sum->ss_sumbytes);\n\tblocknr = start_blocknr + DIV_ROUND_UP(sumbytes, nilfs->ns_blocksize);\n\tbh = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh))\n\t\tgoto out;\n\n\toffset = le16_to_cpu(sum->ss_bytes);\n\tfor (;;) {\n\t\tunsigned long nblocks, ndatablk, nnodeblk;\n\t\tstruct nilfs_finfo *finfo;\n\n\t\tfinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\tsizeof(*finfo));\n\t\tif (unlikely(!finfo))\n\t\t\tgoto out;\n\n\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\t\tnnodeblk = nblocks - ndatablk;\n\n\t\twhile (ndatablk-- > 0) {\n\t\t\tstruct nilfs_recovery_block *rb;\n\t\t\tstruct nilfs_binfo_v *binfo;\n\n\t\t\tbinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\t\tsizeof(*binfo));\n\t\t\tif (unlikely(!binfo))\n\t\t\t\tgoto out;\n\n\t\t\trb = kmalloc(sizeof(*rb), GFP_NOFS);\n\t\t\tif (unlikely(!rb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trb->ino = ino;\n\t\t\trb->blocknr = blocknr++;\n\t\t\trb->vblocknr = le64_to_cpu(binfo->bi_vblocknr);\n\t\t\trb->blkoff = le64_to_cpu(binfo->bi_blkoff);\n\t\t\t/* INIT_LIST_HEAD(&rb->list); */\n\t\t\tlist_add_tail(&rb->list, head);\n\t\t}\n\t\tif (--nfinfo == 0)\n\t\t\tbreak;\n\t\tblocknr += nnodeblk; /* always 0 for data sync logs */\n\t\tnilfs_skip_summary_info(nilfs, &bh, &offset, sizeof(__le64),\n\t\t\t\t\tnnodeblk);\n\t\tif (unlikely(!bh))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tbrelse(bh);   /* brelse(NULL) is just ignored */\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_scan_dsync_log(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t\t\tstruct nilfs_segment_summary *sum,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct buffer_head *bh;\n\tunsigned int offset;\n\tu32 nfinfo, sumbytes;\n\tsector_t blocknr;\n\tino_t ino;\n\tint err = -EIO;\n\n\tnfinfo = le32_to_cpu(sum->ss_nfinfo);\n\tif (!nfinfo)\n\t\treturn 0;\n\n\tsumbytes = le32_to_cpu(sum->ss_sumbytes);\n\tblocknr = start_blocknr + DIV_ROUND_UP(sumbytes, nilfs->ns_blocksize);\n\tbh = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh))\n\t\tgoto out;\n\n\toffset = le16_to_cpu(sum->ss_bytes);\n\tfor (;;) {\n\t\tunsigned long nblocks, ndatablk, nnodeblk;\n\t\tstruct nilfs_finfo *finfo;\n\n\t\tfinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\tsizeof(*finfo));\n\t\tif (unlikely(!finfo))\n\t\t\tgoto out;\n\n\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\t\tnnodeblk = nblocks - ndatablk;\n\n\t\twhile (ndatablk-- > 0) {\n\t\t\tstruct nilfs_recovery_block *rb;\n\t\t\tstruct nilfs_binfo_v *binfo;\n\n\t\t\tbinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\t\tsizeof(*binfo));\n\t\t\tif (unlikely(!binfo))\n\t\t\t\tgoto out;\n\n\t\t\trb = kmalloc(sizeof(*rb), GFP_NOFS);\n\t\t\tif (unlikely(!rb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trb->ino = ino;\n\t\t\trb->blocknr = blocknr++;\n\t\t\trb->vblocknr = le64_to_cpu(binfo->bi_vblocknr);\n\t\t\trb->blkoff = le64_to_cpu(binfo->bi_blkoff);\n\t\t\t/* INIT_LIST_HEAD(&rb->list); */\n\t\t\tlist_add_tail(&rb->list, head);\n\t\t}\n\t\tif (--nfinfo == 0)\n\t\t\tbreak;\n\t\tblocknr += nnodeblk; /* always 0 for data sync logs */\n\t\tnilfs_skip_summary_info(nilfs, &bh, &offset, sizeof(__le64),\n\t\t\t\t\tnnodeblk);\n\t\tif (unlikely(!bh))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tbrelse(bh);   /* brelse(NULL) is just ignored */\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sum->ss_create"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_segnum_of_block",
          "args": [
            "nilfs",
            "le64_to_cpu(sum->ss_next)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segnum_of_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "336-343",
          "snippet": "static inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sum->ss_flags"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_validate_log",
          "args": [
            "nilfs",
            "seg_seq",
            "bh_sum",
            "sum"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_validate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "211-245",
          "snippet": "static int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_read_log_header",
          "args": [
            "nilfs",
            "pseg_start",
            "&sum"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "192-202",
          "snippet": "static struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dsync_blocks"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_do_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start;\n\tsector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */\n\tunsigned long nsalvaged_blocks = 0;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\tint empty_seg = 0;\n\tint err = 0, ret;\n\tLIST_HEAD(dsync_blocks);  /* list of data blocks to be recovered */\n\tenum {\n\t\tRF_INIT_ST,\n\t\tRF_DSYNC_ST,   /* scanning data-sync segments */\n\t};\n\tint state = RF_INIT_ST;\n\n\tpseg_start = ri->ri_lsegs_start;\n\tseg_seq = ri->ri_lsegs_start_seq;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\twhile (segnum != ri->ri_segnum || pseg_start <= ri->ri_pseg_start) {\n\t\tbrelse(bh_sum);\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum) {\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (flags & NILFS_SS_SR)\n\t\t\tgoto confused;\n\n\t\t/* Found a valid partial segment; do recovery actions */\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tempty_seg = 0;\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tif (!(flags & NILFS_SS_GC))\n\t\t\tnilfs->ns_nongc_ctime = nilfs->ns_ctime;\n\n\t\tswitch (state) {\n\t\tcase RF_INIT_ST:\n\t\t\tif (!(flags & NILFS_SS_LOGBGN) ||\n\t\t\t    !(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto try_next_pseg;\n\t\t\tstate = RF_DSYNC_ST;\n\t\t\t/* Fall through */\n\t\tcase RF_DSYNC_ST:\n\t\t\tif (!(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto confused;\n\n\t\t\terr = nilfs_scan_dsync_log(nilfs, pseg_start, sum,\n\t\t\t\t\t\t   &dsync_blocks);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t\tif (flags & NILFS_SS_LOGEND) {\n\t\t\t\terr = nilfs_recover_dsync_blocks(\n\t\t\t\t\tnilfs, sb, root, &dsync_blocks,\n\t\t\t\t\t&nsalvaged_blocks);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto failed;\n\t\t\t\tstate = RF_INIT_ST;\n\t\t\t}\n\t\t\tbreak; /* Fall through to try_next_pseg */\n\t\t}\n\n try_next_pseg:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\t\tpseg_start += le32_to_cpu(sum->ss_nblocks);\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tbreak;\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n\tif (nsalvaged_blocks) {\n\t\tprintk(KERN_INFO \"NILFS (device %s): salvaged %lu blocks\\n\",\n\t\t       sb->s_id, nsalvaged_blocks);\n\t\tri->ri_need_recovery = NILFS_RECOVERY_ROLLFORWARD_DONE;\n\t}\n out:\n\tbrelse(bh_sum);\n\tdispose_recovery_list(&dsync_blocks);\n\treturn err;\n\n confused:\n\terr = -EINVAL;\n failed:\n\tprintk(KERN_ERR\n\t       \"NILFS (device %s): Error roll-forwarding \"\n\t       \"(err=%d, pseg block=%llu). \",\n\t       sb->s_id, err, (unsigned long long)pseg_start);\n\tgoto out;\n}"
  },
  {
    "function_name": "nilfs_recover_dsync_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "503-570",
    "snippet": "static int nilfs_recover_dsync_blocks(struct the_nilfs *nilfs,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct nilfs_root *root,\n\t\t\t\t      struct list_head *head,\n\t\t\t\t      unsigned long *nr_salvaged_blocks)\n{\n\tstruct inode *inode;\n\tstruct nilfs_recovery_block *rb, *n;\n\tunsigned blocksize = nilfs->ns_blocksize;\n\tstruct page *page;\n\tloff_t pos;\n\tint err = 0, err2 = 0;\n\n\tlist_for_each_entry_safe(rb, n, head, list) {\n\t\tinode = nilfs_iget(sb, root, rb->ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\tpos = rb->blkoff << inode->i_blkbits;\n\t\terr = block_write_begin(inode->i_mapping, pos, blocksize,\n\t\t\t\t\t0, &page, nilfs_get_block);\n\t\tif (unlikely(err)) {\n\t\t\tloff_t isize = inode->i_size;\n\t\t\tif (pos + blocksize > isize)\n\t\t\t\tnilfs_write_failed(inode->i_mapping,\n\t\t\t\t\t\t\tpos + blocksize);\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\terr = nilfs_recovery_copy_block(nilfs, rb, page);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\terr = nilfs_set_file_dirty(inode, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\tblock_write_end(NULL, inode->i_mapping, pos, blocksize,\n\t\t\t\tblocksize, page, NULL);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\t(*nr_salvaged_blocks)++;\n\t\tgoto next;\n\n failed_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n failed_inode:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: error recovering data block \"\n\t\t       \"(err=%d, ino=%lu, block-offset=%llu)\\n\",\n\t\t       err, (unsigned long)rb->ino,\n\t\t       (unsigned long long)rb->blkoff);\n\t\tif (!err2)\n\t\t\terr2 = err;\n next:\n\t\tiput(inode); /* iput(NULL) is just ignored */\n\t\tlist_del_init(&rb->list);\n\t\tkfree(rb);\n\t}\n\treturn err2;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rb->list"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"NILFS warning: error recovering data block \"\n\t\t       \"(err=%d, ino=%lu, block-offset=%llu)\\n\"",
            "err",
            "(unsigned long)rb->ino",
            "(unsigned long long)rb->blkoff"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "NULL",
            "inode->i_mapping",
            "pos",
            "blocksize",
            "blocksize",
            "page",
            "NULL"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_file_dirty",
          "args": [
            "inode",
            "1"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_file_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "927-957",
          "snippet": "int nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t/* Because this routine may race with nilfs_dispose_list(),\n\t\t   we have to check NILFS_I_QUEUED here, too. */\n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t/* This will happen when somebody is freeing\n\t\t\t   this inode. */\n\t\t\tnilfs_warning(inode->i_sb, __func__,\n\t\t\t\t      \"cannot get inode (ino=%lu)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL; /* NILFS_I_DIRTY may remain for\n\t\t\t\t\t   freeing inode */\n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_recovery_copy_block",
          "args": [
            "nilfs",
            "rb",
            "page"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_recovery_copy_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "485-501",
          "snippet": "static int nilfs_recovery_copy_block(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_recovery_block *rb,\n\t\t\t\t     struct page *page)\n{\n\tstruct buffer_head *bh_org;\n\tvoid *kaddr;\n\n\tbh_org = __bread(nilfs->ns_bdev, rb->blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh_org))\n\t\treturn -EIO;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr + bh_offset(bh_org), bh_org->b_data, bh_org->b_size);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh_org);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_recovery_copy_block(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_recovery_block *rb,\n\t\t\t\t     struct page *page)\n{\n\tstruct buffer_head *bh_org;\n\tvoid *kaddr;\n\n\tbh_org = __bread(nilfs->ns_bdev, rb->blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh_org))\n\t\treturn -EIO;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr + bh_offset(bh_org), bh_org->b_data, bh_org->b_size);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh_org);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_write_failed",
          "args": [
            "inode->i_mapping",
            "pos + blocksize"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "259-267",
          "snippet": "void nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "inode->i_mapping",
            "pos",
            "blocksize",
            "0",
            "&page",
            "nilfs_get_block"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget",
          "args": [
            "sb",
            "root",
            "rb->ino"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_for_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "629-651",
          "snippet": "struct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rb",
            "n",
            "head",
            "list"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_recover_dsync_blocks(struct the_nilfs *nilfs,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct nilfs_root *root,\n\t\t\t\t      struct list_head *head,\n\t\t\t\t      unsigned long *nr_salvaged_blocks)\n{\n\tstruct inode *inode;\n\tstruct nilfs_recovery_block *rb, *n;\n\tunsigned blocksize = nilfs->ns_blocksize;\n\tstruct page *page;\n\tloff_t pos;\n\tint err = 0, err2 = 0;\n\n\tlist_for_each_entry_safe(rb, n, head, list) {\n\t\tinode = nilfs_iget(sb, root, rb->ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\tpos = rb->blkoff << inode->i_blkbits;\n\t\terr = block_write_begin(inode->i_mapping, pos, blocksize,\n\t\t\t\t\t0, &page, nilfs_get_block);\n\t\tif (unlikely(err)) {\n\t\t\tloff_t isize = inode->i_size;\n\t\t\tif (pos + blocksize > isize)\n\t\t\t\tnilfs_write_failed(inode->i_mapping,\n\t\t\t\t\t\t\tpos + blocksize);\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\terr = nilfs_recovery_copy_block(nilfs, rb, page);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\terr = nilfs_set_file_dirty(inode, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\tblock_write_end(NULL, inode->i_mapping, pos, blocksize,\n\t\t\t\tblocksize, page, NULL);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\t(*nr_salvaged_blocks)++;\n\t\tgoto next;\n\n failed_page:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n failed_inode:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: error recovering data block \"\n\t\t       \"(err=%d, ino=%lu, block-offset=%llu)\\n\",\n\t\t       err, (unsigned long)rb->ino,\n\t\t       (unsigned long long)rb->blkoff);\n\t\tif (!err2)\n\t\t\terr2 = err;\n next:\n\t\tiput(inode); /* iput(NULL) is just ignored */\n\t\tlist_del_init(&rb->list);\n\t\tkfree(rb);\n\t}\n\treturn err2;\n}"
  },
  {
    "function_name": "nilfs_recovery_copy_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "485-501",
    "snippet": "static int nilfs_recovery_copy_block(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_recovery_block *rb,\n\t\t\t\t     struct page *page)\n{\n\tstruct buffer_head *bh_org;\n\tvoid *kaddr;\n\n\tbh_org = __bread(nilfs->ns_bdev, rb->blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh_org))\n\t\treturn -EIO;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr + bh_offset(bh_org), bh_org->b_data, bh_org->b_size);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh_org);\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_org"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + bh_offset(bh_org)",
            "bh_org->b_data",
            "bh_org->b_size"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh_org"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh_org"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "rb->blocknr",
            "nilfs->ns_blocksize"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_recovery_copy_block(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_recovery_block *rb,\n\t\t\t\t     struct page *page)\n{\n\tstruct buffer_head *bh_org;\n\tvoid *kaddr;\n\n\tbh_org = __bread(nilfs->ns_bdev, rb->blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh_org))\n\t\treturn -EIO;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr + bh_offset(bh_org), bh_org->b_data, bh_org->b_size);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh_org);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_prepare_segment_for_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "427-483",
    "snippet": "static int nilfs_prepare_segment_for_recovery(struct the_nilfs *nilfs,\n\t\t\t\t\t      struct super_block *sb,\n\t\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t/*\n\t * Releasing the next segment of the latest super root.\n\t * The next segment is invalidated by this recovery.\n\t */\n\terr = nilfs_sufile_free(sufile, segnum[1]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tfor (i = 1; i < 4; i++) {\n\t\terr = nilfs_segment_list_add(head, segnum[i]);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Collecting segments written after the latest super root.\n\t * These are marked dirty to avoid being reallocated in the next write.\n\t */\n\tlist_for_each_entry_safe(ent, n, head, list) {\n\t\tif (ent->segnum != segnum[0]) {\n\t\t\terr = nilfs_sufile_scrap(sufile, ent->segnum);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t}\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n\n\t/* Allocate new segments for recovery */\n\terr = nilfs_sufile_alloc(sufile, &segnum[0]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq = ri->ri_seq + 2;\n\tnilfs->ns_nextnum = nilfs->ns_segnum = segnum[0];\n\n failed:\n\t/* No need to recover sufile because it will be destroyed on error */\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_alloc",
          "args": [
            "sufile",
            "&segnum[0]"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "311-407",
          "snippet": "int nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ent"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ent->list"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_scrap",
          "args": [
            "sufile",
            "ent->segnum"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_scrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "76-79",
          "snippet": "static inline int nilfs_sufile_scrap(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 1, nilfs_sufile_do_scrap);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_scrap(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 1, nilfs_sufile_do_scrap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ent",
            "n",
            "head",
            "list"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segment_list_add",
          "args": [
            "head",
            "segnum[i]"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segment_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "403-414",
          "snippet": "static int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_free",
          "args": [
            "sufile",
            "segnum[1]"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "86-89",
          "snippet": "static inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_prepare_segment_for_recovery(struct the_nilfs *nilfs,\n\t\t\t\t\t      struct super_block *sb,\n\t\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t/*\n\t * Releasing the next segment of the latest super root.\n\t * The next segment is invalidated by this recovery.\n\t */\n\terr = nilfs_sufile_free(sufile, segnum[1]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tfor (i = 1; i < 4; i++) {\n\t\terr = nilfs_segment_list_add(head, segnum[i]);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Collecting segments written after the latest super root.\n\t * These are marked dirty to avoid being reallocated in the next write.\n\t */\n\tlist_for_each_entry_safe(ent, n, head, list) {\n\t\tif (ent->segnum != segnum[0]) {\n\t\t\terr = nilfs_sufile_scrap(sufile, ent->segnum);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t}\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n\n\t/* Allocate new segments for recovery */\n\terr = nilfs_sufile_alloc(sufile, &segnum[0]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq = ri->ri_seq + 2;\n\tnilfs->ns_nextnum = nilfs->ns_segnum = segnum[0];\n\n failed:\n\t/* No need to recover sufile because it will be destroyed on error */\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_dispose_segment_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "416-425",
    "snippet": "void nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ent"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ent->list"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structnilfs_segment_entry",
            "list"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
  },
  {
    "function_name": "nilfs_segment_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "403-414",
    "snippet": "static int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ent->list",
            "head"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ent->list"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ent"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ent)",
            "GFP_NOFS"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}"
  },
  {
    "function_name": "dispose_recovery_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "387-396",
    "snippet": "static void dispose_recovery_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_recovery_block *rb;\n\n\t\trb = list_first_entry(head, struct nilfs_recovery_block, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rb->list"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structnilfs_recovery_block",
            "list"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void dispose_recovery_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_recovery_block *rb;\n\n\t\trb = list_first_entry(head, struct nilfs_recovery_block, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n}"
  },
  {
    "function_name": "nilfs_scan_dsync_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "316-385",
    "snippet": "static int nilfs_scan_dsync_log(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t\t\tstruct nilfs_segment_summary *sum,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct buffer_head *bh;\n\tunsigned int offset;\n\tu32 nfinfo, sumbytes;\n\tsector_t blocknr;\n\tino_t ino;\n\tint err = -EIO;\n\n\tnfinfo = le32_to_cpu(sum->ss_nfinfo);\n\tif (!nfinfo)\n\t\treturn 0;\n\n\tsumbytes = le32_to_cpu(sum->ss_sumbytes);\n\tblocknr = start_blocknr + DIV_ROUND_UP(sumbytes, nilfs->ns_blocksize);\n\tbh = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh))\n\t\tgoto out;\n\n\toffset = le16_to_cpu(sum->ss_bytes);\n\tfor (;;) {\n\t\tunsigned long nblocks, ndatablk, nnodeblk;\n\t\tstruct nilfs_finfo *finfo;\n\n\t\tfinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\tsizeof(*finfo));\n\t\tif (unlikely(!finfo))\n\t\t\tgoto out;\n\n\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\t\tnnodeblk = nblocks - ndatablk;\n\n\t\twhile (ndatablk-- > 0) {\n\t\t\tstruct nilfs_recovery_block *rb;\n\t\t\tstruct nilfs_binfo_v *binfo;\n\n\t\t\tbinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\t\tsizeof(*binfo));\n\t\t\tif (unlikely(!binfo))\n\t\t\t\tgoto out;\n\n\t\t\trb = kmalloc(sizeof(*rb), GFP_NOFS);\n\t\t\tif (unlikely(!rb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trb->ino = ino;\n\t\t\trb->blocknr = blocknr++;\n\t\t\trb->vblocknr = le64_to_cpu(binfo->bi_vblocknr);\n\t\t\trb->blkoff = le64_to_cpu(binfo->bi_blkoff);\n\t\t\t/* INIT_LIST_HEAD(&rb->list); */\n\t\t\tlist_add_tail(&rb->list, head);\n\t\t}\n\t\tif (--nfinfo == 0)\n\t\t\tbreak;\n\t\tblocknr += nnodeblk; /* always 0 for data sync logs */\n\t\tnilfs_skip_summary_info(nilfs, &bh, &offset, sizeof(__le64),\n\t\t\t\t\tnnodeblk);\n\t\tif (unlikely(!bh))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tbrelse(bh);   /* brelse(NULL) is just ignored */\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_skip_summary_info",
          "args": [
            "nilfs",
            "&bh",
            "&offset",
            "sizeof(__le64)",
            "nnodeblk"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_skip_summary_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "284-307",
          "snippet": "static void nilfs_skip_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t    struct buffer_head **pbh,\n\t\t\t\t    unsigned int *offset, unsigned int bytes,\n\t\t\t\t    unsigned long count)\n{\n\tunsigned int rest_item_in_current_block\n\t\t= ((*pbh)->b_size - *offset) / bytes;\n\n\tif (count <= rest_item_in_current_block) {\n\t\t*offset += bytes * count;\n\t} else {\n\t\tsector_t blocknr = (*pbh)->b_blocknr;\n\t\tunsigned int nitem_per_block = (*pbh)->b_size / bytes;\n\t\tunsigned int bcnt;\n\n\t\tcount -= rest_item_in_current_block;\n\t\tbcnt = DIV_ROUND_UP(count, nitem_per_block);\n\t\t*offset = bytes * (count - (bcnt - 1) * nitem_per_block);\n\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + bcnt,\n\t\t\t       nilfs->ns_blocksize);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_skip_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t    struct buffer_head **pbh,\n\t\t\t\t    unsigned int *offset, unsigned int bytes,\n\t\t\t\t    unsigned long count)\n{\n\tunsigned int rest_item_in_current_block\n\t\t= ((*pbh)->b_size - *offset) / bytes;\n\n\tif (count <= rest_item_in_current_block) {\n\t\t*offset += bytes * count;\n\t} else {\n\t\tsector_t blocknr = (*pbh)->b_blocknr;\n\t\tunsigned int nitem_per_block = (*pbh)->b_size / bytes;\n\t\tunsigned int bcnt;\n\n\t\tcount -= rest_item_in_current_block;\n\t\tbcnt = DIV_ROUND_UP(count, nitem_per_block);\n\t\t*offset = bytes * (count - (bcnt - 1) * nitem_per_block);\n\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + bcnt,\n\t\t\t       nilfs->ns_blocksize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rb->list",
            "head"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "binfo->bi_blkoff"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rb"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rb)",
            "GFP_NOFS"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!binfo"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_read_summary_info",
          "args": [
            "nilfs",
            "&bh",
            "&offset",
            "sizeof(*binfo)"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_summary_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "254-274",
          "snippet": "static void *nilfs_read_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t     struct buffer_head **pbh,\n\t\t\t\t     unsigned int *offset, unsigned int bytes)\n{\n\tvoid *ptr;\n\tsector_t blocknr;\n\n\tBUG_ON((*pbh)->b_size < *offset);\n\tif (bytes > (*pbh)->b_size - *offset) {\n\t\tblocknr = (*pbh)->b_blocknr;\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + 1,\n\t\t\t       nilfs->ns_blocksize);\n\t\tif (unlikely(!*pbh))\n\t\t\treturn NULL;\n\t\t*offset = 0;\n\t}\n\tptr = (*pbh)->b_data + *offset;\n\t*offset += bytes;\n\treturn ptr;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void *nilfs_read_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t     struct buffer_head **pbh,\n\t\t\t\t     unsigned int *offset, unsigned int bytes)\n{\n\tvoid *ptr;\n\tsector_t blocknr;\n\n\tBUG_ON((*pbh)->b_size < *offset);\n\tif (bytes > (*pbh)->b_size - *offset) {\n\t\tblocknr = (*pbh)->b_blocknr;\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + 1,\n\t\t\t       nilfs->ns_blocksize);\n\t\tif (unlikely(!*pbh))\n\t\t\treturn NULL;\n\t\t*offset = 0;\n\t}\n\tptr = (*pbh)->b_data + *offset;\n\t*offset += bytes;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "finfo->fi_ndatablk"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!finfo"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sum->ss_bytes"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "start_blocknr",
            "nilfs->ns_blocksize"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sumbytes",
            "nilfs->ns_blocksize"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_scan_dsync_log(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t\t\tstruct nilfs_segment_summary *sum,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct buffer_head *bh;\n\tunsigned int offset;\n\tu32 nfinfo, sumbytes;\n\tsector_t blocknr;\n\tino_t ino;\n\tint err = -EIO;\n\n\tnfinfo = le32_to_cpu(sum->ss_nfinfo);\n\tif (!nfinfo)\n\t\treturn 0;\n\n\tsumbytes = le32_to_cpu(sum->ss_sumbytes);\n\tblocknr = start_blocknr + DIV_ROUND_UP(sumbytes, nilfs->ns_blocksize);\n\tbh = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh))\n\t\tgoto out;\n\n\toffset = le16_to_cpu(sum->ss_bytes);\n\tfor (;;) {\n\t\tunsigned long nblocks, ndatablk, nnodeblk;\n\t\tstruct nilfs_finfo *finfo;\n\n\t\tfinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\tsizeof(*finfo));\n\t\tif (unlikely(!finfo))\n\t\t\tgoto out;\n\n\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\t\tnnodeblk = nblocks - ndatablk;\n\n\t\twhile (ndatablk-- > 0) {\n\t\t\tstruct nilfs_recovery_block *rb;\n\t\t\tstruct nilfs_binfo_v *binfo;\n\n\t\t\tbinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\t\tsizeof(*binfo));\n\t\t\tif (unlikely(!binfo))\n\t\t\t\tgoto out;\n\n\t\t\trb = kmalloc(sizeof(*rb), GFP_NOFS);\n\t\t\tif (unlikely(!rb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trb->ino = ino;\n\t\t\trb->blocknr = blocknr++;\n\t\t\trb->vblocknr = le64_to_cpu(binfo->bi_vblocknr);\n\t\t\trb->blkoff = le64_to_cpu(binfo->bi_blkoff);\n\t\t\t/* INIT_LIST_HEAD(&rb->list); */\n\t\t\tlist_add_tail(&rb->list, head);\n\t\t}\n\t\tif (--nfinfo == 0)\n\t\t\tbreak;\n\t\tblocknr += nnodeblk; /* always 0 for data sync logs */\n\t\tnilfs_skip_summary_info(nilfs, &bh, &offset, sizeof(__le64),\n\t\t\t\t\tnnodeblk);\n\t\tif (unlikely(!bh))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tbrelse(bh);   /* brelse(NULL) is just ignored */\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_skip_summary_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "284-307",
    "snippet": "static void nilfs_skip_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t    struct buffer_head **pbh,\n\t\t\t\t    unsigned int *offset, unsigned int bytes,\n\t\t\t\t    unsigned long count)\n{\n\tunsigned int rest_item_in_current_block\n\t\t= ((*pbh)->b_size - *offset) / bytes;\n\n\tif (count <= rest_item_in_current_block) {\n\t\t*offset += bytes * count;\n\t} else {\n\t\tsector_t blocknr = (*pbh)->b_blocknr;\n\t\tunsigned int nitem_per_block = (*pbh)->b_size / bytes;\n\t\tunsigned int bcnt;\n\n\t\tcount -= rest_item_in_current_block;\n\t\tbcnt = DIV_ROUND_UP(count, nitem_per_block);\n\t\t*offset = bytes * (count - (bcnt - 1) * nitem_per_block);\n\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + bcnt,\n\t\t\t       nilfs->ns_blocksize);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "blocknr + bcnt",
            "nilfs->ns_blocksize"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*pbh"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "count",
            "nitem_per_block"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_skip_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t    struct buffer_head **pbh,\n\t\t\t\t    unsigned int *offset, unsigned int bytes,\n\t\t\t\t    unsigned long count)\n{\n\tunsigned int rest_item_in_current_block\n\t\t= ((*pbh)->b_size - *offset) / bytes;\n\n\tif (count <= rest_item_in_current_block) {\n\t\t*offset += bytes * count;\n\t} else {\n\t\tsector_t blocknr = (*pbh)->b_blocknr;\n\t\tunsigned int nitem_per_block = (*pbh)->b_size / bytes;\n\t\tunsigned int bcnt;\n\n\t\tcount -= rest_item_in_current_block;\n\t\tbcnt = DIV_ROUND_UP(count, nitem_per_block);\n\t\t*offset = bytes * (count - (bcnt - 1) * nitem_per_block);\n\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + bcnt,\n\t\t\t       nilfs->ns_blocksize);\n\t}\n}"
  },
  {
    "function_name": "nilfs_read_summary_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "254-274",
    "snippet": "static void *nilfs_read_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t     struct buffer_head **pbh,\n\t\t\t\t     unsigned int *offset, unsigned int bytes)\n{\n\tvoid *ptr;\n\tsector_t blocknr;\n\n\tBUG_ON((*pbh)->b_size < *offset);\n\tif (bytes > (*pbh)->b_size - *offset) {\n\t\tblocknr = (*pbh)->b_blocknr;\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + 1,\n\t\t\t       nilfs->ns_blocksize);\n\t\tif (unlikely(!*pbh))\n\t\t\treturn NULL;\n\t\t*offset = 0;\n\t}\n\tptr = (*pbh)->b_data + *offset;\n\t*offset += bytes;\n\treturn ptr;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*pbh"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "blocknr + 1",
            "nilfs->ns_blocksize"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*pbh"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(*pbh)->b_size < *offset"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic void *nilfs_read_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t     struct buffer_head **pbh,\n\t\t\t\t     unsigned int *offset, unsigned int bytes)\n{\n\tvoid *ptr;\n\tsector_t blocknr;\n\n\tBUG_ON((*pbh)->b_size < *offset);\n\tif (bytes > (*pbh)->b_size - *offset) {\n\t\tblocknr = (*pbh)->b_blocknr;\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + 1,\n\t\t\t       nilfs->ns_blocksize);\n\t\tif (unlikely(!*pbh))\n\t\t\treturn NULL;\n\t\t*offset = 0;\n\t}\n\tptr = (*pbh)->b_data + *offset;\n\t*offset += bytes;\n\treturn ptr;\n}"
  },
  {
    "function_name": "nilfs_validate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "211-245",
    "snippet": "static int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sum->ss_datasum"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_compute_checksum",
          "args": [
            "nilfs",
            "bh_sum",
            "&crc",
            "sizeof(sum->ss_datasum)",
            "((u64)nblock << nilfs->ns_blocksize_bits)",
            "bh_sum->b_blocknr",
            "nblock"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_compute_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "104-133",
          "snippet": "static int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nblock == 0 || nblock > nilfs->ns_blocks_per_segment"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sum->ss_seq"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t/* This limits the number of blocks read in the CRC check */\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_read_log_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "192-202",
    "snippet": "static struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "start_blocknr",
            "nilfs->ns_blocksize"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}"
  },
  {
    "function_name": "nilfs_read_super_root_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "142-184",
    "snippet": "int nilfs_read_super_root_block(struct the_nilfs *nilfs, sector_t sr_block,\n\t\t\t\tstruct buffer_head **pbh, int check)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *sr;\n\tu32 crc;\n\tint ret;\n\n\t*pbh = NULL;\n\tbh_sr = __bread(nilfs->ns_bdev, sr_block, nilfs->ns_blocksize);\n\tif (unlikely(!bh_sr)) {\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tgoto failed;\n\t}\n\n\tsr = (struct nilfs_super_root *)bh_sr->b_data;\n\tif (check) {\n\t\tunsigned bytes = le16_to_cpu(sr->sr_bytes);\n\n\t\tif (bytes == 0 || bytes > nilfs->ns_blocksize) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (nilfs_compute_checksum(\n\t\t\t    nilfs, bh_sr, &crc, sizeof(sr->sr_sum), bytes,\n\t\t\t    sr_block, 1)) {\n\t\t\tret = NILFS_SEG_FAIL_IO;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (crc != le32_to_cpu(sr->sr_sum)) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t}\n\t*pbh = bh_sr;\n\treturn 0;\n\n failed_bh:\n\tbrelse(bh_sr);\n\n failed:\n\treturn nilfs_warn_segment_error(ret);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_warn_segment_error",
          "args": [
            "ret"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warn_segment_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "59-92",
          "snippet": "static int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_sr"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sr->sr_sum"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_compute_checksum",
          "args": [
            "nilfs",
            "bh_sr",
            "&crc",
            "sizeof(sr->sr_sum)",
            "bytes",
            "sr_block",
            "1"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_compute_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "104-133",
          "snippet": "static int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sr->sr_bytes"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh_sr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "sr_block",
            "nilfs->ns_blocksize"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_super_root_block(struct the_nilfs *nilfs, sector_t sr_block,\n\t\t\t\tstruct buffer_head **pbh, int check)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *sr;\n\tu32 crc;\n\tint ret;\n\n\t*pbh = NULL;\n\tbh_sr = __bread(nilfs->ns_bdev, sr_block, nilfs->ns_blocksize);\n\tif (unlikely(!bh_sr)) {\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tgoto failed;\n\t}\n\n\tsr = (struct nilfs_super_root *)bh_sr->b_data;\n\tif (check) {\n\t\tunsigned bytes = le16_to_cpu(sr->sr_bytes);\n\n\t\tif (bytes == 0 || bytes > nilfs->ns_blocksize) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (nilfs_compute_checksum(\n\t\t\t    nilfs, bh_sr, &crc, sizeof(sr->sr_sum), bytes,\n\t\t\t    sr_block, 1)) {\n\t\t\tret = NILFS_SEG_FAIL_IO;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (crc != le32_to_cpu(sr->sr_sum)) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t}\n\t*pbh = bh_sr;\n\treturn 0;\n\n failed_bh:\n\tbrelse(bh_sr);\n\n failed:\n\treturn nilfs_warn_segment_error(ret);\n}"
  },
  {
    "function_name": "nilfs_compute_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "104-133",
    "snippet": "static int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "bh->b_data",
            "size"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "check_bytes",
            "blocksize"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "nilfs->ns_bdev",
            "++start",
            "blocksize"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "nilfs->ns_crc_seed",
            "(unsigned char *)bhs->b_data + offset",
            "size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "check_bytes",
            "blocksize - offset"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= blocksize"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_warn_segment_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
    "lines": "59-92",
    "snippet": "static int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"page.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\""
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_warn_segment_error(int err)\n{\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: I/O error on loading last segment\\n\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Segment magic number invalid\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Sequence number mismatch\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in super root\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Checksum error in segment payload\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: Inconsistent segment\\n\");\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: No super root in the last segment\\n\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
  }
]