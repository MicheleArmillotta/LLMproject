[
  {
    "function_name": "ovl_rename2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "679-909",
    "snippet": "static int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\tolddentry = ovl_dentry_upper(old);\n\tnewdentry = ovl_dentry_upper(new);\n\tif (newdentry) {\n\t\tif (opaquedir) {\n\t\t\tnewdentry = opaquedir;\n\t\t\topaquedir = NULL;\n\t\t} else {\n\t\t\tdget(newdentry);\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t\t   new->d_name.len);\n\t\terr = PTR_ERR(newdentry);\n\t\tif (IS_ERR(newdentry))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = -ESTALE;\n\tif (olddentry->d_parent != old_upperdir)\n\t\tgoto out_dput;\n\tif (newdentry->d_parent != new_upperdir)\n\t\tgoto out_dput;\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "opaquedir"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "old"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "new_upperdir",
            "old_upperdir"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_inc",
          "args": [
            "new->d_parent"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "223-229",
          "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "old_upperdir->d_inode",
            "newdentry"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "17-32",
          "snippet": "void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_set_opaque",
          "args": [
            "new",
            "old_opaque"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_set_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "202-206",
          "snippet": "void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_remove_opaque",
          "args": [
            "newdentry"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remove_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "124-133",
          "snippet": "static void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rename",
          "args": [
            "old_upperdir->d_inode",
            "olddentry",
            "new_upperdir->d_inode",
            "newdentry",
            "NULL",
            "flags"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4106-4237",
          "snippet": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flags & ~RENAME_EXCHANGE"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_do_rename",
          "args": [
            "old_upperdir->d_inode",
            "olddentry",
            "new_upperdir->d_inode",
            "newdentry",
            "flags"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "109-125",
          "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_set_opaque",
          "args": [
            "newdentry"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "119-122",
          "snippet": "static int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdentry"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newdentry"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "new->d_name.name",
            "new_upperdir",
            "new->d_name.len"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "newdentry"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "new"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_rename",
          "args": [
            "new_upperdir",
            "old_upperdir"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_check_empty_and_clear",
          "args": [
            "new"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_check_empty_and_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "287-311",
          "snippet": "static struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE_OR_LOWER",
          "args": [
            "new_type"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_CHOWN"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FSETID"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FOWNER"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_DAC_OVERRIDE"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_SYS_ADMIN"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_PURE_UPPER",
          "args": [
            "new_type"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_PURE_UPPER",
          "args": [
            "old_type"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "new"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "old"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_is_opaque",
          "args": [
            "new"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_is_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "196-200",
          "snippet": "bool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "old_type"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "new_type"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_lower",
          "args": [
            "new"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "124-129",
          "snippet": "struct dentry *ovl_dentry_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn __ovl_dentry_lower(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn __ovl_dentry_lower(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "old_type"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "new_type"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE_OR_LOWER",
          "args": [
            "new_type"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "new"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "new"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_check_sticky",
          "args": [
            "new"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_check_sticky",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "604-613",
          "snippet": "static inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE_OR_LOWER",
          "args": [
            "old_type"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "old"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\tolddentry = ovl_dentry_upper(old);\n\tnewdentry = ovl_dentry_upper(new);\n\tif (newdentry) {\n\t\tif (opaquedir) {\n\t\t\tnewdentry = opaquedir;\n\t\t\topaquedir = NULL;\n\t\t} else {\n\t\t\tdget(newdentry);\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t\t   new->d_name.len);\n\t\terr = PTR_ERR(newdentry);\n\t\tif (IS_ERR(newdentry))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = -ESTALE;\n\tif (olddentry->d_parent != old_upperdir)\n\t\tgoto out_dput;\n\tif (newdentry->d_parent != new_upperdir)\n\t\tgoto out_dput;\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "674-677",
    "snippet": "static int ovl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, true);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_do_remove",
          "args": [
            "dentry",
            "true"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "615-667",
          "snippet": "static int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, true);\n}"
  },
  {
    "function_name": "ovl_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "669-672",
    "snippet": "static int ovl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, false);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_do_remove",
          "args": [
            "dentry",
            "false"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "615-667",
          "snippet": "static int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ovl_do_remove(dentry, false);\n}"
  },
  {
    "function_name": "ovl_do_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "615-667",
    "snippet": "static int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_remove_and_whiteout",
          "args": [
            "dentry",
            "is_dir"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remove_and_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "498-570",
          "snippet": "static int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (is_dir && OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (is_dir && OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_CHOWN"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FSETID"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FOWNER"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_DAC_OVERRIDE"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_SYS_ADMIN"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_remove_upper",
          "args": [
            "dentry",
            "is_dir"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remove_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "572-602",
          "snippet": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\td_drop(dentry);\n\tmutex_unlock(&dir->i_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\td_drop(dentry);\n\tmutex_unlock(&dir->i_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_PURE_UPPER",
          "args": [
            "type"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "dentry"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "dentry->d_parent"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_check_sticky",
          "args": [
            "dentry"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_check_sticky",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "604-613",
          "snippet": "static inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_do_remove(struct dentry *dentry, bool is_dir)\n{\n\tenum ovl_path_type type;\n\tint err;\n\n\terr = ovl_check_sticky(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\ttype = ovl_path_type(dentry);\n\tif (OVL_TYPE_PURE_UPPER(type)) {\n\t\terr = ovl_remove_upper(dentry, is_dir);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_remove_and_whiteout(dentry, is_dir);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_check_sticky",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "604-613",
    "snippet": "static inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sticky",
          "args": [
            "dir",
            "inode"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__check_sticky",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2419-2428",
          "snippet": "int __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_real",
          "args": [
            "dentry"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "131-141",
          "snippet": "struct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic inline int ovl_check_sticky(struct dentry *dentry)\n{\n\tstruct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;\n\tstruct inode *inode = ovl_dentry_real(dentry)->d_inode;\n\n\tif (check_sticky(dir, inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_remove_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "572-602",
    "snippet": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\td_drop(dentry);\n\tmutex_unlock(&dir->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_inc",
          "args": [
            "dentry->d_parent"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "223-229",
          "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "upper"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_unlink",
          "args": [
            "dir",
            "upper",
            "NULL"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3715-3752",
          "snippet": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "dir",
            "upper"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3596-3632",
          "snippet": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "upper"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\t/*\n\t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n\t */\n\td_drop(dentry);\n\tmutex_unlock(&dir->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_remove_and_whiteout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "498-570",
    "snippet": "static int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (is_dir && OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "wdir",
            "whiteout"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "17-32",
          "snippet": "void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "opaquedir"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_inc",
          "args": [
            "dentry->d_parent"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "223-229",
          "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_rename",
          "args": [
            "wdir",
            "whiteout",
            "udir",
            "upper",
            "flags"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "109-125",
          "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "upper"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "upper"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dentry->d_name.name",
            "upperdir",
            "dentry->d_name.len"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "whiteout"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "whiteout"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_whiteout",
          "args": [
            "workdir",
            "dentry"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "52-70",
          "snippet": "static struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_lock_rename_workdir",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_check_empty_and_clear",
          "args": [
            "dentry"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_check_empty_and_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "287-311",
          "snippet": "static struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE_OR_LOWER",
          "args": [
            "ovl_path_type(dentry)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "dentry"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_workdir",
          "args": [
            "dentry"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "190-194",
          "snippet": "struct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *whiteout;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir = NULL;\n\tint err;\n\n\tif (is_dir && OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {\n\t\topaquedir = ovl_check_empty_and_clear(dentry);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir))\n\t\t\tgoto out;\n\t}\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out_dput;\n\n\twhiteout = ovl_whiteout(workdir, dentry);\n\terr = PTR_ERR(whiteout);\n\tif (IS_ERR(whiteout))\n\t\tgoto out_unlock;\n\n\tupper = ovl_dentry_upper(dentry);\n\tif (!upper) {\n\t\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t       dentry->d_name.len);\n\t\terr = PTR_ERR(upper);\n\t\tif (IS_ERR(upper))\n\t\t\tgoto kill_whiteout;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, 0);\n\t\tdput(upper);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (opaquedir)\n\t\t\tupper = opaquedir;\n\t\terr = -ESTALE;\n\t\tif (upper->d_parent != upperdir)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tflags |= RENAME_EXCHANGE;\n\n\t\terr = ovl_do_rename(wdir, whiteout, udir, upper, flags);\n\t\tif (err)\n\t\t\tgoto kill_whiteout;\n\n\t\tif (is_dir)\n\t\t\tovl_cleanup(wdir, upper);\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\nout_d_drop:\n\td_drop(dentry);\n\tdput(whiteout);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_dput:\n\tdput(opaquedir);\nout:\n\treturn err;\n\nkill_whiteout:\n\tovl_cleanup(wdir, whiteout);\n\tgoto out_d_drop;\n}"
  },
  {
    "function_name": "ovl_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "475-496",
    "snippet": "static int ovl_link(struct dentry *old, struct inode *newdir,\n\t\t    struct dentry *new)\n{\n\tint err;\n\tstruct dentry *upper;\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupper = ovl_dentry_upper(old);\n\terr = ovl_create_or_link(new, upper->d_inode->i_mode, 0, NULL, upper);\n\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "old"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_create_or_link",
          "args": [
            "new",
            "upper->d_inode->i_mode",
            "0",
            "NULL",
            "upper"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_or_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "379-432",
          "snippet": "static int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "old"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "old"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "old"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_link(struct dentry *old, struct inode *newdir,\n\t\t    struct dentry *new)\n{\n\tint err;\n\tstruct dentry *upper;\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupper = ovl_dentry_upper(old);\n\terr = ovl_create_or_link(new, upper->d_inode->i_mode, 0, NULL, upper);\n\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "469-473",
    "snippet": "static int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_create_object",
          "args": [
            "dentry",
            "S_IFLNK",
            "0",
            "link"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "434-446",
          "snippet": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}"
  },
  {
    "function_name": "ovl_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "459-467",
    "snippet": "static int ovl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\t/* Don't allow creation of \"whiteout\" on overlay */\n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\n\t\treturn -EPERM;\n\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_create_object",
          "args": [
            "dentry",
            "mode",
            "rdev",
            "NULL"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "434-446",
          "snippet": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\t/* Don't allow creation of \"whiteout\" on overlay */\n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\n\t\treturn -EPERM;\n\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\n}"
  },
  {
    "function_name": "ovl_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "454-457",
    "snippet": "static int ovl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_create_object",
          "args": [
            "dentry",
            "(mode & 07777) | S_IFDIR",
            "0",
            "NULL"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "434-446",
          "snippet": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);\n}"
  },
  {
    "function_name": "ovl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "448-452",
    "snippet": "static int ovl_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_create_object",
          "args": [
            "dentry",
            "(mode & 07777) | S_IFREG",
            "0",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "434-446",
          "snippet": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\n}"
  },
  {
    "function_name": "ovl_create_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "434-446",
    "snippet": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_create_or_link",
          "args": [
            "dentry",
            "mode",
            "rdev",
            "link",
            "NULL"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_or_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "379-432",
          "snippet": "static int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_create_or_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "379-432",
    "snippet": "static int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_create_over_whiteout",
          "args": [
            "dentry",
            "inode",
            "&stat",
            "link",
            "hardlink"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_over_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "313-377",
          "snippet": "static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FOWNER"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_DAC_OVERRIDE"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_SYS_ADMIN"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_create_upper",
          "args": [
            "dentry",
            "inode",
            "&stat",
            "link",
            "hardlink"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "161-190",
          "snippet": "static int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tmutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tmutex_unlock(&udir->i_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tmutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tmutex_unlock(&udir->i_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_is_opaque",
          "args": [
            "dentry"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_is_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "196-200",
          "snippet": "bool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "dentry->d_parent"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_new_inode",
          "args": [
            "dentry->d_sb",
            "mode",
            "dentry->d_fsdata"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "395-436",
          "snippet": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};",
            "static const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};\nstatic const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_or_link(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t      const char *link, struct dentry *hardlink)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct kstat stat = {\n\t\t.mode = mode,\n\t\t.rdev = rdev,\n\t};\n\n\terr = -ENOMEM;\n\tinode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry->d_parent);\n\tif (err)\n\t\tgoto out_iput;\n\n\tif (!ovl_dentry_is_opaque(dentry)) {\n\t\terr = ovl_create_upper(dentry, inode, &stat, link, hardlink);\n\t} else {\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_iput;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting opaque xattr\n\t\t * CAP_DAC_OVERRIDE for create in workdir, rename\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\told_cred = override_creds(override_cred);\n\n\t\terr = ovl_create_over_whiteout(dentry, inode, &stat, link,\n\t\t\t\t\t       hardlink);\n\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\n\tif (!err)\n\t\tinode = NULL;\nout_iput:\n\tiput(inode);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_create_over_whiteout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "313-377",
    "snippet": "static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "wdir",
            "newdentry"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "17-32",
          "snippet": "void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "newdentry"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copyattr",
          "args": [
            "newdentry->d_inode",
            "inode"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copyattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "179-183",
          "snippet": "static inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nstatic inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_update",
          "args": [
            "dentry",
            "newdentry"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "208-221",
          "snippet": "void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_inc",
          "args": [
            "dentry->d_parent"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "223-229",
          "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_rename",
          "args": [
            "wdir",
            "newdentry",
            "udir",
            "upper",
            "0"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "109-125",
          "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_set_opaque",
          "args": [
            "newdentry"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "119-122",
          "snippet": "static int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat->mode"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_create_real",
          "args": [
            "wdir",
            "newdentry",
            "stat",
            "link",
            "hardlink",
            "true"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "72-117",
          "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "upper"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "upper"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dentry->d_name.name",
            "upperdir",
            "dentry->d_name.len"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdentry"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newdentry"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lookup_temp",
          "args": [
            "workdir",
            "dentry"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lookup_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "34-49",
          "snippet": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_lock_rename_workdir",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry->d_parent"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_workdir",
          "args": [
            "dentry"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "190-194",
          "snippet": "struct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\n\t\t\t\t    struct kstat *stat, const char *link,\n\t\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tstruct dentry *newdentry;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_dput;\n\n\terr = ovl_create_real(wdir, newdentry, stat, link, hardlink, true);\n\tif (err)\n\t\tgoto out_dput2;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper,\n\t\t\t\t    RENAME_EXCHANGE);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\n\t\tovl_cleanup(wdir, upper);\n\t} else {\n\t\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput2:\n\tdput(upper);\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out_dput2;\n}"
  },
  {
    "function_name": "ovl_check_empty_and_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "287-311",
    "snippet": "static struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_cache_free",
          "args": [
            "&list"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "182-191",
          "snippet": "void ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_clear_empty",
          "args": [
            "dentry",
            "&list"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_clear_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "212-285",
          "snippet": "static struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&opaquedir->d_inode->i_mutex);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tmutex_unlock(&opaquedir->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&opaquedir->d_inode->i_mutex);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tmutex_unlock(&opaquedir->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_check_empty_dir",
          "args": [
            "dentry",
            "&list"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_check_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "507-533",
          "snippet": "int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct ovl_cache_entry *p;\n\n\terr = ovl_dir_read_merged(dentry, list);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\n\tlist_for_each_entry(p, list, l_node) {\n\t\tif (p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = -ENOTEMPTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct ovl_cache_entry *p;\n\n\terr = ovl_dir_read_merged(dentry, list);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\n\tlist_for_each_entry(p, list, l_node) {\n\t\tif (p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = -ENOTEMPTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_check_empty_and_clear(struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *ret = NULL;\n\tLIST_HEAD(list);\n\n\terr = ovl_check_empty_dir(dentry, &list);\n\tif (err)\n\t\tret = ERR_PTR(err);\n\telse {\n\t\t/*\n\t\t * If no upperdentry then skip clearing whiteouts.\n\t\t *\n\t\t * Can race with copy-up, since we don't hold the upperdir\n\t\t * mutex.  Doesn't matter, since copy-up can't create a\n\t\t * non-empty directory from an empty one.\n\t\t */\n\t\tif (ovl_dentry_upper(dentry))\n\t\t\tret = ovl_clear_empty(dentry, &list);\n\t}\n\n\tovl_cache_free(&list);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ovl_clear_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "212-285",
    "snippet": "static struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&opaquedir->d_inode->i_mutex);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tmutex_unlock(&opaquedir->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "opaquedir"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "wdir",
            "opaquedir"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "17-32",
          "snippet": "void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cleanup_whiteouts",
          "args": [
            "upper",
            "list"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup_whiteouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "535-557",
          "snippet": "void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_rename",
          "args": [
            "wdir",
            "opaquedir",
            "udir",
            "upper",
            "RENAME_EXCHANGE"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "109-125",
          "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&opaquedir->d_inode->i_mutex"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_set_attr",
          "args": [
            "opaquedir",
            "&stat"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "171-194",
          "snippet": "int ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&opaquedir->d_inode->i_mutex"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_set_opaque",
          "args": [
            "opaquedir"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "119-122",
          "snippet": "static int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_xattr",
          "args": [
            "upper",
            "opaquedir"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "23-71",
          "snippet": "int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_create_real",
          "args": [
            "wdir",
            "opaquedir",
            "&stat",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "72-117",
          "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "opaquedir"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lookup_temp",
          "args": [
            "workdir",
            "dentry"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lookup_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "34-49",
          "snippet": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat.mode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&upperpath",
            "&stat"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "&upperpath"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_lock_rename_workdir",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry->d_parent"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_workdir",
          "args": [
            "dentry"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "190-194",
          "snippet": "struct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_clear_empty(struct dentry *dentry,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct path upperpath;\n\tstruct dentry *upper;\n\tstruct dentry *opaquedir;\n\tstruct kstat stat;\n\tint err;\n\n\terr = ovl_lock_rename_workdir(workdir, upperdir);\n\tif (err)\n\t\tgoto out;\n\n\tovl_path_upper(dentry, &upperpath);\n\terr = vfs_getattr(&upperpath, &stat);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (!S_ISDIR(stat.mode))\n\t\tgoto out_unlock;\n\tupper = upperpath.dentry;\n\tif (upper->d_parent->d_inode != udir)\n\t\tgoto out_unlock;\n\n\topaquedir = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(opaquedir);\n\tif (IS_ERR(opaquedir))\n\t\tgoto out_unlock;\n\n\terr = ovl_create_real(wdir, opaquedir, &stat, NULL, NULL, true);\n\tif (err)\n\t\tgoto out_dput;\n\n\terr = ovl_copy_xattr(upper, opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_set_opaque(opaquedir);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&opaquedir->d_inode->i_mutex);\n\terr = ovl_set_attr(opaquedir, &stat);\n\tmutex_unlock(&opaquedir->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, opaquedir, udir, upper, RENAME_EXCHANGE);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_cleanup_whiteouts(upper, list);\n\tovl_cleanup(wdir, upper);\n\tunlock_rename(workdir, upperdir);\n\n\t/* dentry's upper doesn't match now, get rid of it */\n\td_drop(dentry);\n\n\treturn opaquedir;\n\nout_cleanup:\n\tovl_cleanup(wdir, opaquedir);\nout_dput:\n\tdput(opaquedir);\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ovl_lock_rename_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "192-210",
    "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to lock workdir+upperdir\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ovl_create_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "161-190",
    "snippet": "static int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tmutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tmutex_unlock(&udir->i_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&udir->i_mutex"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "newdentry"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copyattr",
          "args": [
            "newdentry->d_inode",
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copyattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "179-183",
          "snippet": "static inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nstatic inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_update",
          "args": [
            "dentry",
            "newdentry"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "208-221",
          "snippet": "void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_inc",
          "args": [
            "dentry->d_parent"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "223-229",
          "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_create_real",
          "args": [
            "udir",
            "newdentry",
            "stat",
            "link",
            "hardlink",
            "false"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "72-117",
          "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdentry"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newdentry"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dentry->d_name.name",
            "upperdir",
            "dentry->d_name.len"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&udir->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry->d_parent"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tmutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tmutex_unlock(&udir->i_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_dir_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "135-159",
    "snippet": "static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tint err;\n\tenum ovl_path_type type;\n\tstruct path realpath;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\terr = vfs_getattr(&realpath, stat);\n\tif (err)\n\t\treturn err;\n\n\tstat->dev = dentry->d_sb->s_dev;\n\tstat->ino = dentry->d_inode->i_ino;\n\n\t/*\n\t * It's probably not worth it to count subdirs to get the\n\t * correct link count.  nlink=1 seems to pacify 'find' and\n\t * other utilities.\n\t */\n\tif (OVL_TYPE_MERGE(type))\n\t\tstat->nlink = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE",
          "args": [
            "type"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&realpath",
            "stat"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tint err;\n\tenum ovl_path_type type;\n\tstruct path realpath;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\terr = vfs_getattr(&realpath, stat);\n\tif (err)\n\t\treturn err;\n\n\tstat->dev = dentry->d_sb->s_dev;\n\tstat->ino = dentry->d_inode->i_ino;\n\n\t/*\n\t * It's probably not worth it to count subdirs to get the\n\t * correct link count.  nlink=1 seems to pacify 'find' and\n\t * other utilities.\n\t */\n\tif (OVL_TYPE_MERGE(type))\n\t\tstat->nlink = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_remove_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "124-133",
    "snippet": "static void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"overlayfs: failed to remove opaque from '%s' (%i)\\n\"",
            "upperdentry->d_name.name",
            "err"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_do_removexattr",
          "args": [
            "upperdentry",
            "OVL_XATTR_OPAQUE"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "102-107",
          "snippet": "static inline int ovl_do_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err = vfs_removexattr(dentry, name);\n\tpr_debug(\"removexattr(%pd2, \\\"%s\\\") = %i\\n\", dentry, name, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "int ovl_removexattr(struct dentry *dentry, const char *name);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nint ovl_removexattr(struct dentry *dentry, const char *name);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err = vfs_removexattr(dentry, name);\n\tpr_debug(\"removexattr(%pd2, \\\"%s\\\") = %i\\n\", dentry, name, err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_remove_opaque(struct dentry *upperdentry)\n{\n\tint err;\n\n\terr = ovl_do_removexattr(upperdentry, OVL_XATTR_OPAQUE);\n\tif (err) {\n\t\tpr_warn(\"overlayfs: failed to remove opaque from '%s' (%i)\\n\",\n\t\t\tupperdentry->d_name.name, err);\n\t}\n}"
  },
  {
    "function_name": "ovl_set_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "119-122",
    "snippet": "static int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_do_setxattr",
          "args": [
            "upperdentry",
            "OVL_XATTR_OPAQUE",
            "\"y\"",
            "1",
            "0"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "93-100",
          "snippet": "static inline int ovl_do_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tint err = vfs_setxattr(dentry, name, value, size, flags);\n\tpr_debug(\"setxattr(%pd2, \\\"%s\\\", \\\"%*s\\\", 0x%x) = %i\\n\",\n\t\t dentry, name, (int) size, (char *) value, flags, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "ssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size);",
            "ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);",
            "int ovl_removexattr(struct dentry *dentry, const char *name);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size);\nssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);\nint ovl_removexattr(struct dentry *dentry, const char *name);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tint err = vfs_setxattr(dentry, name, value, size, flags);\n\tpr_debug(\"setxattr(%pd2, \\\"%s\\\", \\\"%*s\\\", 0x%x) = %i\\n\",\n\t\t dentry, name, (int) size, (char *) value, flags, err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}"
  },
  {
    "function_name": "ovl_create_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "72-117",
    "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!newdentry->d_inode"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_do_symlink",
          "args": [
            "dir",
            "newdentry",
            "link",
            "debug"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "84-91",
          "snippet": "static inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t const char *oldname, bool debug)\n{\n\tint err = vfs_symlink(dir, dentry, oldname);\n\tif (debug)\n\t\tpr_debug(\"symlink(\\\"%s\\\", %pd2) = %i\\n\", oldname, dentry, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t const char *oldname, bool debug)\n{\n\tint err = vfs_symlink(dir, dentry, oldname);\n\tif (debug)\n\t\tpr_debug(\"symlink(\\\"%s\\\", %pd2) = %i\\n\", oldname, dentry, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_mknod",
          "args": [
            "dir",
            "newdentry",
            "stat->mode",
            "stat->rdev",
            "debug"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "73-82",
          "snippet": "static inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, dev_t dev, bool debug)\n{\n\tint err = vfs_mknod(dir, dentry, mode, dev);\n\tif (debug) {\n\t\tpr_debug(\"mknod(%pd2, 0%o, 0%o) = %i\\n\",\n\t\t\t dentry, mode, dev, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, dev_t dev, bool debug)\n{\n\tint err = vfs_mknod(dir, dentry, mode, dev);\n\tif (debug) {\n\t\tpr_debug(\"mknod(%pd2, 0%o, 0%o) = %i\\n\",\n\t\t\t dentry, mode, dev, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_mkdir",
          "args": [
            "dir",
            "newdentry",
            "stat->mode",
            "debug"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "64-71",
          "snippet": "static inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, bool debug)\n{\n\tint err = vfs_mkdir(dir, dentry, mode);\n\tif (debug)\n\t\tpr_debug(\"mkdir(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, bool debug)\n{\n\tint err = vfs_mkdir(dir, dentry, mode);\n\tif (debug)\n\t\tpr_debug(\"mkdir(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_create",
          "args": [
            "dir",
            "newdentry",
            "stat->mode",
            "debug"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "55-62",
          "snippet": "static inline int ovl_do_create(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t mode, bool debug)\n{\n\tint err = vfs_create(dir, dentry, mode, true);\n\tif (debug)\n\t\tpr_debug(\"create(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_create(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t mode, bool debug)\n{\n\tint err = vfs_create(dir, dentry, mode, true);\n\tif (debug)\n\t\tpr_debug(\"create(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_link",
          "args": [
            "hardlink",
            "dir",
            "newdentry",
            "debug"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "44-53",
          "snippet": "static inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t      struct dentry *new_dentry, bool debug)\n{\n\tint err = vfs_link(old_dentry, dir, new_dentry, NULL);\n\tif (debug) {\n\t\tpr_debug(\"link(%pd2, %pd2) = %i\\n\",\n\t\t\t old_dentry, new_dentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,\n\t\t\t\tstruct kstat *stat, const char *link);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,\n\t\t\t\tstruct kstat *stat, const char *link);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t      struct dentry *new_dentry, bool debug)\n{\n\tint err = vfs_link(old_dentry, dir, new_dentry, NULL);\n\tif (debug) {\n\t\tpr_debug(\"link(%pd2, %pd2) = %i\\n\",\n\t\t\t old_dentry, new_dentry, err);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_whiteout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "52-70",
    "snippet": "static struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "whiteout"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_whiteout",
          "args": [
            "wdir",
            "whiteout"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "127-132",
          "snippet": "static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_whiteout(dir, dentry);\n\tpr_debug(\"whiteout(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_whiteout(dir, dentry);\n\tpr_debug(\"whiteout(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "whiteout"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lookup_temp",
          "args": [
            "workdir",
            "dentry"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lookup_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "34-49",
          "snippet": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_whiteout(struct dentry *workdir,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *whiteout;\n\tstruct inode *wdir = workdir->d_inode;\n\n\twhiteout = ovl_lookup_temp(workdir, dentry);\n\tif (IS_ERR(whiteout))\n\t\treturn whiteout;\n\n\terr = ovl_do_whiteout(wdir, whiteout);\n\tif (err) {\n\t\tdput(whiteout);\n\t\twhiteout = ERR_PTR(err);\n\t}\n\n\treturn whiteout;\n}"
  },
  {
    "function_name": "ovl_lookup_temp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "34-49",
    "snippet": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "temp"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: workdir/%s already exists\\n\"",
            "name"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "temp"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "workdir",
            "strlen(name)"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"#%lx\"",
            "(unsigned long) dentry"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}"
  },
  {
    "function_name": "ovl_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
    "lines": "17-32",
    "snippet": "void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: cleanup of '%pd2' failed (%i)\\n\"",
            "wdentry",
            "err"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "wdentry"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_unlink",
          "args": [
            "wdir",
            "wdentry"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "37-42",
          "snippet": "static inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_unlink(dir, dentry, NULL);\n\tpr_debug(\"unlink(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_unlink(dir, dentry, NULL);\n\tpr_debug(\"unlink(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_rmdir",
          "args": [
            "wdir",
            "wdentry"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "30-35",
          "snippet": "static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_rmdir(dir, dentry);\n\tpr_debug(\"rmdir(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_rmdir(dir, dentry);\n\tpr_debug(\"rmdir(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "wdentry"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "wdentry"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup(struct inode *wdir, struct dentry *wdentry)\n{\n\tint err;\n\n\tdget(wdentry);\n\tif (d_is_dir(wdentry))\n\t\terr = ovl_do_rmdir(wdir, wdentry);\n\telse\n\t\terr = ovl_do_unlink(wdir, wdentry);\n\tdput(wdentry);\n\n\tif (err) {\n\t\tpr_err(\"overlayfs: cleanup of '%pd2' failed (%i)\\n\",\n\t\t       wdentry, err);\n\t}\n}"
  }
]