[
  {
    "function_name": "xfs_buf_iodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "1132-1155",
    "snippet": "void\nxfs_buf_iodone(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\n\tASSERT(BUF_ITEM(lip)->bli_buf == bp);\n\n\txfs_buf_rele(bp);\n\n\t/*\n\t * If we are forcibly shutting down, this may well be\n\t * off the AIL already. That's because we simulate the\n\t * log-committed callbacks to unpin these buffers. Or we may never\n\t * have put this item on AIL because of the transaction was\n\t * aborted forcibly. xfs_trans_ail_delete() takes care of these.\n\t *\n\t * Either way, AIL is useless if we're forcing a shutdown.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_CORRUPT_INCORE);\n\txfs_buf_item_free(BUF_ITEM(lip));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_item_free",
          "args": [
            "BUF_ITEM(lip)"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "945-951",
          "snippet": "STATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_buf_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_buf_item_zone;\n\nSTATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "lip",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "BUF_ITEM(lip)->bli_buf == bp"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_iodone(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\n\tASSERT(BUF_ITEM(lip)->bli_buf == bp);\n\n\txfs_buf_rele(bp);\n\n\t/*\n\t * If we are forcibly shutting down, this may well be\n\t * off the AIL already. That's because we simulate the\n\t * log-committed callbacks to unpin these buffers. Or we may never\n\t * have put this item on AIL because of the transaction was\n\t * aborted forcibly. xfs_trans_ail_delete() takes care of these.\n\t *\n\t * Either way, AIL is useless if we're forcing a shutdown.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_CORRUPT_INCORE);\n\txfs_buf_item_free(BUF_ITEM(lip));\n}"
  },
  {
    "function_name": "xfs_buf_iodone_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "1050-1123",
    "snippet": "void\nxfs_buf_iodone_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip = bp->b_fspriv;\n\tstruct xfs_mount\t*mp = lip->li_mountp;\n\tstatic ulong\t\tlasttime;\n\tstatic xfs_buftarg_t\t*lasttarg;\n\n\tif (likely(!bp->b_error))\n\t\tgoto do_callbacks;\n\n\t/*\n\t * If we've already decided to shutdown the filesystem because of\n\t * I/O errors, there's no point in giving this a retry.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_stale(bp);\n\t\tXFS_BUF_DONE(bp);\n\t\ttrace_xfs_buf_item_iodone(bp, _RET_IP_);\n\t\tgoto do_callbacks;\n\t}\n\n\tif (bp->b_target != lasttarg ||\n\t    time_after(jiffies, (lasttime + 5*HZ))) {\n\t\tlasttime = jiffies;\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\t}\n\tlasttarg = bp->b_target;\n\n\t/*\n\t * If the write was asynchronous then no one will be looking for the\n\t * error.  Clear the error state and write the buffer out again.\n\t *\n\t * XXX: This helps against transient write errors, but we need to find\n\t * a way to shut the filesystem down if the writes keep failing.\n\t *\n\t * In practice we'll shut the filesystem down soon as non-transient\n\t * errors tend to affect the whole device and a failing log write\n\t * will make us give up.  But we really ought to do better here.\n\t */\n\tif (XFS_BUF_ISASYNC(bp)) {\n\t\tASSERT(bp->b_iodone != NULL);\n\n\t\ttrace_xfs_buf_item_iodone_async(bp, _RET_IP_);\n\n\t\txfs_buf_ioerror(bp, 0); /* errno of 0 unsets the flag */\n\n\t\tif (!(bp->b_flags & (XBF_STALE|XBF_WRITE_FAIL))) {\n\t\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC |\n\t\t\t\t       XBF_DONE | XBF_WRITE_FAIL;\n\t\t\txfs_buf_submit(bp);\n\t\t} else {\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If the write of the buffer was synchronous, we want to make\n\t * sure to return the error to the caller of xfs_bwrite().\n\t */\n\txfs_buf_stale(bp);\n\tXFS_BUF_DONE(bp);\n\n\ttrace_xfs_buf_error_relse(bp, _RET_IP_);\n\ndo_callbacks:\n\txfs_buf_do_callbacks(bp);\n\tbp->b_fspriv = NULL;\n\tbp->b_iodone = NULL;\n\txfs_buf_ioend(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);",
      "static DEFINE_RATELIMIT_STATE(xfs_buf_write_fail_rl_state, 30 * HZ, 10);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_do_callbacks",
          "args": [
            "bp"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_do_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "1023-1041",
          "snippet": "STATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_error_relse",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "bp"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit",
          "args": [
            "bp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "0"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_iodone_async",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_iodone != NULL"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISASYNC",
          "args": [
            "bp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "(lasttime + 5*HZ)"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_iodone",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "bp"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bp->b_error"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\nstatic DEFINE_RATELIMIT_STATE(xfs_buf_write_fail_rl_state, 30 * HZ, 10);\n\nvoid\nxfs_buf_iodone_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip = bp->b_fspriv;\n\tstruct xfs_mount\t*mp = lip->li_mountp;\n\tstatic ulong\t\tlasttime;\n\tstatic xfs_buftarg_t\t*lasttarg;\n\n\tif (likely(!bp->b_error))\n\t\tgoto do_callbacks;\n\n\t/*\n\t * If we've already decided to shutdown the filesystem because of\n\t * I/O errors, there's no point in giving this a retry.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_stale(bp);\n\t\tXFS_BUF_DONE(bp);\n\t\ttrace_xfs_buf_item_iodone(bp, _RET_IP_);\n\t\tgoto do_callbacks;\n\t}\n\n\tif (bp->b_target != lasttarg ||\n\t    time_after(jiffies, (lasttime + 5*HZ))) {\n\t\tlasttime = jiffies;\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\t}\n\tlasttarg = bp->b_target;\n\n\t/*\n\t * If the write was asynchronous then no one will be looking for the\n\t * error.  Clear the error state and write the buffer out again.\n\t *\n\t * XXX: This helps against transient write errors, but we need to find\n\t * a way to shut the filesystem down if the writes keep failing.\n\t *\n\t * In practice we'll shut the filesystem down soon as non-transient\n\t * errors tend to affect the whole device and a failing log write\n\t * will make us give up.  But we really ought to do better here.\n\t */\n\tif (XFS_BUF_ISASYNC(bp)) {\n\t\tASSERT(bp->b_iodone != NULL);\n\n\t\ttrace_xfs_buf_item_iodone_async(bp, _RET_IP_);\n\n\t\txfs_buf_ioerror(bp, 0); /* errno of 0 unsets the flag */\n\n\t\tif (!(bp->b_flags & (XBF_STALE|XBF_WRITE_FAIL))) {\n\t\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC |\n\t\t\t\t       XBF_DONE | XBF_WRITE_FAIL;\n\t\t\txfs_buf_submit(bp);\n\t\t} else {\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If the write of the buffer was synchronous, we want to make\n\t * sure to return the error to the caller of xfs_bwrite().\n\t */\n\txfs_buf_stale(bp);\n\tXFS_BUF_DONE(bp);\n\n\ttrace_xfs_buf_error_relse(bp, _RET_IP_);\n\ndo_callbacks:\n\txfs_buf_do_callbacks(bp);\n\tbp->b_fspriv = NULL;\n\tbp->b_iodone = NULL;\n\txfs_buf_ioend(bp);\n}"
  },
  {
    "function_name": "xfs_buf_do_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "1023-1041",
    "snippet": "STATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lip->li_cb",
          "args": [
            "bp",
            "lip"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lip->li_cb != NULL"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_attach_iodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "987-1009",
    "snippet": "void\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}"
  },
  {
    "function_name": "xfs_buf_item_relse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "960-975",
    "snippet": "void\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_item_free",
          "args": [
            "bip"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "945-951",
          "snippet": "STATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_buf_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_buf_item_zone;\n\nSTATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_item.li_flags & XFS_LI_IN_AIL)"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_relse",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}"
  },
  {
    "function_name": "xfs_buf_item_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "945-951",
    "snippet": "STATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_buf_item_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_buf_item_zone",
            "bip"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_free_format",
          "args": [
            "bip"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_free_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "736-744",
          "snippet": "STATIC void\nxfs_buf_item_free_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tif (bip->bli_formats != &bip->__bli_format) {\n\t\tkmem_free(bip->bli_formats);\n\t\tbip->bli_formats = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_item_free_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tif (bip->bli_formats != &bip->__bli_format) {\n\t\tkmem_free(bip->bli_formats);\n\t\tbip->bli_formats = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_buf_item_zone;\n\nSTATIC void\nxfs_buf_item_free(\n\txfs_buf_log_item_t\t*bip)\n{\n\txfs_buf_item_free_format(bip);\n\tkmem_zone_free(xfs_buf_item_zone, bip);\n}"
  },
  {
    "function_name": "xfs_buf_item_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "938-943",
    "snippet": "uint\nxfs_buf_item_dirty(\n\txfs_buf_log_item_t\t*bip)\n{\n\treturn (bip->bli_flags & XFS_BLI_DIRTY);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_buf_item_dirty(\n\txfs_buf_log_item_t\t*bip)\n{\n\treturn (bip->bli_flags & XFS_BLI_DIRTY);\n}"
  },
  {
    "function_name": "xfs_buf_item_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "898-931",
    "snippet": "void\nxfs_buf_item_log(\n\txfs_buf_log_item_t\t*bip,\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast)\n{\n\tint\t\t\ti;\n\tuint\t\t\tstart;\n\tuint\t\t\tend;\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\n\t/*\n\t * walk each buffer segment and mark them dirty appropriately.\n\t */\n\tstart = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (start > last)\n\t\t\tbreak;\n\t\tend = start + BBTOB(bp->b_maps[i].bm_len);\n\t\tif (first > end) {\n\t\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t\t\tcontinue;\n\t\t}\n\t\tif (first < start)\n\t\t\tfirst = start;\n\t\tif (end > last)\n\t\t\tend = last;\n\n\t\txfs_buf_item_log_segment(first, end,\n\t\t\t\t\t &bip->bli_formats[i].blf_data_map[0]);\n\n\t\tstart += bp->b_maps[i].bm_len;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_item_log_segment",
          "args": [
            "first",
            "end",
            "&bip->bli_formats[i].blf_data_map[0]"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_log_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "817-892",
          "snippet": "static void\nxfs_buf_item_log_segment(\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast,\n\tuint\t\t\t*map)\n{\n\tuint\t\tfirst_bit;\n\tuint\t\tlast_bit;\n\tuint\t\tbits_to_set;\n\tuint\t\tbits_set;\n\tuint\t\tword_num;\n\tuint\t\t*wordp;\n\tuint\t\tbit;\n\tuint\t\tend_bit;\n\tuint\t\tmask;\n\n\t/*\n\t * Convert byte offsets to bit numbers.\n\t */\n\tfirst_bit = first >> XFS_BLF_SHIFT;\n\tlast_bit = last >> XFS_BLF_SHIFT;\n\n\t/*\n\t * Calculate the total number of bits to be set.\n\t */\n\tbits_to_set = last_bit - first_bit + 1;\n\n\t/*\n\t * Get a pointer to the first word in the bitmap\n\t * to set a bit in.\n\t */\n\tword_num = first_bit >> BIT_TO_WORD_SHIFT;\n\twordp = &map[word_num];\n\n\t/*\n\t * Calculate the starting bit in the first word.\n\t */\n\tbit = first_bit & (uint)(NBWORD - 1);\n\n\t/*\n\t * First set any bits in the first word of our range.\n\t * If it starts at bit 0 of the word, it will be\n\t * set below rather than here.  That is what the variable\n\t * bit tells us. The variable bits_set tracks the number\n\t * of bits that have been set so far.  End_bit is the number\n\t * of the last bit to be set in this word plus one.\n\t */\n\tif (bit) {\n\t\tend_bit = MIN(bit + bits_to_set, (uint)NBWORD);\n\t\tmask = ((1 << (end_bit - bit)) - 1) << bit;\n\t\t*wordp |= mask;\n\t\twordp++;\n\t\tbits_set = end_bit - bit;\n\t} else {\n\t\tbits_set = 0;\n\t}\n\n\t/*\n\t * Now set bits a whole word at a time that are between\n\t * first_bit and last_bit.\n\t */\n\twhile ((bits_to_set - bits_set) >= NBWORD) {\n\t\t*wordp |= 0xffffffff;\n\t\tbits_set += NBWORD;\n\t\twordp++;\n\t}\n\n\t/*\n\t * Finally, set any bits left to be set in one last partial word.\n\t */\n\tend_bit = bits_to_set - bits_set;\n\tif (end_bit) {\n\t\tmask = (1 << end_bit) - 1;\n\t\t*wordp |= mask;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_item_log_segment(\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast,\n\tuint\t\t\t*map)\n{\n\tuint\t\tfirst_bit;\n\tuint\t\tlast_bit;\n\tuint\t\tbits_to_set;\n\tuint\t\tbits_set;\n\tuint\t\tword_num;\n\tuint\t\t*wordp;\n\tuint\t\tbit;\n\tuint\t\tend_bit;\n\tuint\t\tmask;\n\n\t/*\n\t * Convert byte offsets to bit numbers.\n\t */\n\tfirst_bit = first >> XFS_BLF_SHIFT;\n\tlast_bit = last >> XFS_BLF_SHIFT;\n\n\t/*\n\t * Calculate the total number of bits to be set.\n\t */\n\tbits_to_set = last_bit - first_bit + 1;\n\n\t/*\n\t * Get a pointer to the first word in the bitmap\n\t * to set a bit in.\n\t */\n\tword_num = first_bit >> BIT_TO_WORD_SHIFT;\n\twordp = &map[word_num];\n\n\t/*\n\t * Calculate the starting bit in the first word.\n\t */\n\tbit = first_bit & (uint)(NBWORD - 1);\n\n\t/*\n\t * First set any bits in the first word of our range.\n\t * If it starts at bit 0 of the word, it will be\n\t * set below rather than here.  That is what the variable\n\t * bit tells us. The variable bits_set tracks the number\n\t * of bits that have been set so far.  End_bit is the number\n\t * of the last bit to be set in this word plus one.\n\t */\n\tif (bit) {\n\t\tend_bit = MIN(bit + bits_to_set, (uint)NBWORD);\n\t\tmask = ((1 << (end_bit - bit)) - 1) << bit;\n\t\t*wordp |= mask;\n\t\twordp++;\n\t\tbits_set = end_bit - bit;\n\t} else {\n\t\tbits_set = 0;\n\t}\n\n\t/*\n\t * Now set bits a whole word at a time that are between\n\t * first_bit and last_bit.\n\t */\n\twhile ((bits_to_set - bits_set) >= NBWORD) {\n\t\t*wordp |= 0xffffffff;\n\t\tbits_set += NBWORD;\n\t\twordp++;\n\t}\n\n\t/*\n\t * Finally, set any bits left to be set in one last partial word.\n\t */\n\tend_bit = bits_to_set - bits_set;\n\tif (end_bit) {\n\t\tmask = (1 << end_bit) - 1;\n\t\t*wordp |= mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[i].bm_len"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[i].bm_len"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_log(\n\txfs_buf_log_item_t\t*bip,\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast)\n{\n\tint\t\t\ti;\n\tuint\t\t\tstart;\n\tuint\t\t\tend;\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\n\t/*\n\t * walk each buffer segment and mark them dirty appropriately.\n\t */\n\tstart = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (start > last)\n\t\t\tbreak;\n\t\tend = start + BBTOB(bp->b_maps[i].bm_len);\n\t\tif (first > end) {\n\t\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t\t\tcontinue;\n\t\t}\n\t\tif (first < start)\n\t\t\tfirst = start;\n\t\tif (end > last)\n\t\t\tend = last;\n\n\t\txfs_buf_item_log_segment(first, end,\n\t\t\t\t\t &bip->bli_formats[i].blf_data_map[0]);\n\n\t\tstart += bp->b_maps[i].bm_len;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_item_log_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "817-892",
    "snippet": "static void\nxfs_buf_item_log_segment(\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast,\n\tuint\t\t\t*map)\n{\n\tuint\t\tfirst_bit;\n\tuint\t\tlast_bit;\n\tuint\t\tbits_to_set;\n\tuint\t\tbits_set;\n\tuint\t\tword_num;\n\tuint\t\t*wordp;\n\tuint\t\tbit;\n\tuint\t\tend_bit;\n\tuint\t\tmask;\n\n\t/*\n\t * Convert byte offsets to bit numbers.\n\t */\n\tfirst_bit = first >> XFS_BLF_SHIFT;\n\tlast_bit = last >> XFS_BLF_SHIFT;\n\n\t/*\n\t * Calculate the total number of bits to be set.\n\t */\n\tbits_to_set = last_bit - first_bit + 1;\n\n\t/*\n\t * Get a pointer to the first word in the bitmap\n\t * to set a bit in.\n\t */\n\tword_num = first_bit >> BIT_TO_WORD_SHIFT;\n\twordp = &map[word_num];\n\n\t/*\n\t * Calculate the starting bit in the first word.\n\t */\n\tbit = first_bit & (uint)(NBWORD - 1);\n\n\t/*\n\t * First set any bits in the first word of our range.\n\t * If it starts at bit 0 of the word, it will be\n\t * set below rather than here.  That is what the variable\n\t * bit tells us. The variable bits_set tracks the number\n\t * of bits that have been set so far.  End_bit is the number\n\t * of the last bit to be set in this word plus one.\n\t */\n\tif (bit) {\n\t\tend_bit = MIN(bit + bits_to_set, (uint)NBWORD);\n\t\tmask = ((1 << (end_bit - bit)) - 1) << bit;\n\t\t*wordp |= mask;\n\t\twordp++;\n\t\tbits_set = end_bit - bit;\n\t} else {\n\t\tbits_set = 0;\n\t}\n\n\t/*\n\t * Now set bits a whole word at a time that are between\n\t * first_bit and last_bit.\n\t */\n\twhile ((bits_to_set - bits_set) >= NBWORD) {\n\t\t*wordp |= 0xffffffff;\n\t\tbits_set += NBWORD;\n\t\twordp++;\n\t}\n\n\t/*\n\t * Finally, set any bits left to be set in one last partial word.\n\t */\n\tend_bit = bits_to_set - bits_set;\n\tif (end_bit) {\n\t\tmask = (1 << end_bit) - 1;\n\t\t*wordp |= mask;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "bit + bits_to_set",
            "(uint)NBWORD"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "NBWORD - 1"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_item_log_segment(\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast,\n\tuint\t\t\t*map)\n{\n\tuint\t\tfirst_bit;\n\tuint\t\tlast_bit;\n\tuint\t\tbits_to_set;\n\tuint\t\tbits_set;\n\tuint\t\tword_num;\n\tuint\t\t*wordp;\n\tuint\t\tbit;\n\tuint\t\tend_bit;\n\tuint\t\tmask;\n\n\t/*\n\t * Convert byte offsets to bit numbers.\n\t */\n\tfirst_bit = first >> XFS_BLF_SHIFT;\n\tlast_bit = last >> XFS_BLF_SHIFT;\n\n\t/*\n\t * Calculate the total number of bits to be set.\n\t */\n\tbits_to_set = last_bit - first_bit + 1;\n\n\t/*\n\t * Get a pointer to the first word in the bitmap\n\t * to set a bit in.\n\t */\n\tword_num = first_bit >> BIT_TO_WORD_SHIFT;\n\twordp = &map[word_num];\n\n\t/*\n\t * Calculate the starting bit in the first word.\n\t */\n\tbit = first_bit & (uint)(NBWORD - 1);\n\n\t/*\n\t * First set any bits in the first word of our range.\n\t * If it starts at bit 0 of the word, it will be\n\t * set below rather than here.  That is what the variable\n\t * bit tells us. The variable bits_set tracks the number\n\t * of bits that have been set so far.  End_bit is the number\n\t * of the last bit to be set in this word plus one.\n\t */\n\tif (bit) {\n\t\tend_bit = MIN(bit + bits_to_set, (uint)NBWORD);\n\t\tmask = ((1 << (end_bit - bit)) - 1) << bit;\n\t\t*wordp |= mask;\n\t\twordp++;\n\t\tbits_set = end_bit - bit;\n\t} else {\n\t\tbits_set = 0;\n\t}\n\n\t/*\n\t * Now set bits a whole word at a time that are between\n\t * first_bit and last_bit.\n\t */\n\twhile ((bits_to_set - bits_set) >= NBWORD) {\n\t\t*wordp |= 0xffffffff;\n\t\tbits_set += NBWORD;\n\t\twordp++;\n\t}\n\n\t/*\n\t * Finally, set any bits left to be set in one last partial word.\n\t */\n\tend_bit = bits_to_set - bits_set;\n\tif (end_bit) {\n\t\tmask = (1 << end_bit) - 1;\n\t\t*wordp |= mask;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_item_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "753-810",
    "snippet": "void\nxfs_buf_item_init(\n\txfs_buf_t\t*bp,\n\txfs_mount_t\t*mp)\n{\n\txfs_log_item_t\t\t*lip = bp->b_fspriv;\n\txfs_buf_log_item_t\t*bip;\n\tint\t\t\tchunks;\n\tint\t\t\tmap_size;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/*\n\t * Check to see if there is already a buf log item for\n\t * this buffer.  If there is, it is guaranteed to be\n\t * the first.  If we do already have one, there is\n\t * nothing to do here so return.\n\t */\n\tASSERT(bp->b_target->bt_mount == mp);\n\tif (lip != NULL && lip->li_type == XFS_LI_BUF)\n\t\treturn;\n\n\tbip = kmem_zone_zalloc(xfs_buf_item_zone, KM_SLEEP);\n\txfs_log_item_init(mp, &bip->bli_item, XFS_LI_BUF, &xfs_buf_item_ops);\n\tbip->bli_buf = bp;\n\txfs_buf_hold(bp);\n\n\t/*\n\t * chunks is the number of XFS_BLF_CHUNK size pieces the buffer\n\t * can be divided into. Make sure not to truncate any pieces.\n\t * map_size is the size of the bitmap needed to describe the\n\t * chunks of the buffer.\n\t *\n\t * Discontiguous buffer support follows the layout of the underlying\n\t * buffer. This makes the implementation as simple as possible.\n\t */\n\terror = xfs_buf_item_get_format(bip, bp->b_map_count);\n\tASSERT(error == 0);\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tchunks = DIV_ROUND_UP(BBTOB(bp->b_maps[i].bm_len),\n\t\t\t\t      XFS_BLF_CHUNK);\n\t\tmap_size = DIV_ROUND_UP(chunks, NBWORD);\n\n\t\tbip->bli_formats[i].blf_type = XFS_LI_BUF;\n\t\tbip->bli_formats[i].blf_blkno = bp->b_maps[i].bm_bn;\n\t\tbip->bli_formats[i].blf_len = bp->b_maps[i].bm_len;\n\t\tbip->bli_formats[i].blf_map_size = map_size;\n\t}\n\n\t/*\n\t * Put the buf item into the list of items attached to the\n\t * buffer at the front.\n\t */\n\tif (bp->b_fspriv)\n\t\tbip->bli_item.li_bio_list = bp->b_fspriv;\n\tbp->b_fspriv = bip;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_buf_item_zone;",
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);",
      "static const struct xfs_item_ops xfs_buf_item_ops = {\n\t.iop_size\t= xfs_buf_item_size,\n\t.iop_format\t= xfs_buf_item_format,\n\t.iop_pin\t= xfs_buf_item_pin,\n\t.iop_unpin\t= xfs_buf_item_unpin,\n\t.iop_unlock\t= xfs_buf_item_unlock,\n\t.iop_committed\t= xfs_buf_item_committed,\n\t.iop_push\t= xfs_buf_item_push,\n\t.iop_committing = xfs_buf_item_committing\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "chunks",
            "NBWORD"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "BBTOB(bp->b_maps[i].bm_len)",
            "XFS_BLF_CHUNK"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[i].bm_len"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == 0"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_get_format",
          "args": [
            "bip",
            "bp->b_map_count"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_get_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "716-734",
          "snippet": "STATIC int\nxfs_buf_item_get_format(\n\tstruct xfs_buf_log_item\t*bip,\n\tint\t\t\tcount)\n{\n\tASSERT(bip->bli_formats == NULL);\n\tbip->bli_format_count = count;\n\n\tif (count == 1) {\n\t\tbip->bli_formats = &bip->__bli_format;\n\t\treturn 0;\n\t}\n\n\tbip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),\n\t\t\t\tKM_SLEEP);\n\tif (!bip->bli_formats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_buf_item_get_format(\n\tstruct xfs_buf_log_item\t*bip,\n\tint\t\t\tcount)\n{\n\tASSERT(bip->bli_formats == NULL);\n\tbip->bli_format_count = count;\n\n\tif (count == 1) {\n\t\tbip->bli_formats = &bip->__bli_format;\n\t\treturn 0;\n\t}\n\n\tbip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),\n\t\t\t\tKM_SLEEP);\n\tif (!bip->bli_formats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_item_init",
          "args": [
            "mp",
            "&bip->bli_item",
            "XFS_LI_BUF",
            "&xfs_buf_item_ops"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "961-976",
          "snippet": "void\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_buf_item_zone",
            "KM_SLEEP"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_target->bt_mount == mp"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_buf_item_zone;\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\nstatic const struct xfs_item_ops xfs_buf_item_ops = {\n\t.iop_size\t= xfs_buf_item_size,\n\t.iop_format\t= xfs_buf_item_format,\n\t.iop_pin\t= xfs_buf_item_pin,\n\t.iop_unpin\t= xfs_buf_item_unpin,\n\t.iop_unlock\t= xfs_buf_item_unlock,\n\t.iop_committed\t= xfs_buf_item_committed,\n\t.iop_push\t= xfs_buf_item_push,\n\t.iop_committing = xfs_buf_item_committing\n};\n\nvoid\nxfs_buf_item_init(\n\txfs_buf_t\t*bp,\n\txfs_mount_t\t*mp)\n{\n\txfs_log_item_t\t\t*lip = bp->b_fspriv;\n\txfs_buf_log_item_t\t*bip;\n\tint\t\t\tchunks;\n\tint\t\t\tmap_size;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/*\n\t * Check to see if there is already a buf log item for\n\t * this buffer.  If there is, it is guaranteed to be\n\t * the first.  If we do already have one, there is\n\t * nothing to do here so return.\n\t */\n\tASSERT(bp->b_target->bt_mount == mp);\n\tif (lip != NULL && lip->li_type == XFS_LI_BUF)\n\t\treturn;\n\n\tbip = kmem_zone_zalloc(xfs_buf_item_zone, KM_SLEEP);\n\txfs_log_item_init(mp, &bip->bli_item, XFS_LI_BUF, &xfs_buf_item_ops);\n\tbip->bli_buf = bp;\n\txfs_buf_hold(bp);\n\n\t/*\n\t * chunks is the number of XFS_BLF_CHUNK size pieces the buffer\n\t * can be divided into. Make sure not to truncate any pieces.\n\t * map_size is the size of the bitmap needed to describe the\n\t * chunks of the buffer.\n\t *\n\t * Discontiguous buffer support follows the layout of the underlying\n\t * buffer. This makes the implementation as simple as possible.\n\t */\n\terror = xfs_buf_item_get_format(bip, bp->b_map_count);\n\tASSERT(error == 0);\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tchunks = DIV_ROUND_UP(BBTOB(bp->b_maps[i].bm_len),\n\t\t\t\t      XFS_BLF_CHUNK);\n\t\tmap_size = DIV_ROUND_UP(chunks, NBWORD);\n\n\t\tbip->bli_formats[i].blf_type = XFS_LI_BUF;\n\t\tbip->bli_formats[i].blf_blkno = bp->b_maps[i].bm_bn;\n\t\tbip->bli_formats[i].blf_len = bp->b_maps[i].bm_len;\n\t\tbip->bli_formats[i].blf_map_size = map_size;\n\t}\n\n\t/*\n\t * Put the buf item into the list of items attached to the\n\t * buffer at the front.\n\t */\n\tif (bp->b_fspriv)\n\t\tbip->bli_item.li_bio_list = bp->b_fspriv;\n\tbp->b_fspriv = bip;\n}"
  },
  {
    "function_name": "xfs_buf_item_free_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "736-744",
    "snippet": "STATIC void\nxfs_buf_item_free_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tif (bip->bli_formats != &bip->__bli_format) {\n\t\tkmem_free(bip->bli_formats);\n\t\tbip->bli_formats = NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bip->bli_formats"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_item_free_format(\n\tstruct xfs_buf_log_item\t*bip)\n{\n\tif (bip->bli_formats != &bip->__bli_format) {\n\t\tkmem_free(bip->bli_formats);\n\t\tbip->bli_formats = NULL;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_item_get_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "716-734",
    "snippet": "STATIC int\nxfs_buf_item_get_format(\n\tstruct xfs_buf_log_item\t*bip,\n\tint\t\t\tcount)\n{\n\tASSERT(bip->bli_formats == NULL);\n\tbip->bli_format_count = count;\n\n\tif (count == 1) {\n\t\tbip->bli_formats = &bip->__bli_format;\n\t\treturn 0;\n\t}\n\n\tbip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),\n\t\t\t\tKM_SLEEP);\n\tif (!bip->bli_formats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "count * sizeof(struct xfs_buf_log_format)",
            "KM_SLEEP"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_formats == NULL"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_buf_item_get_format(\n\tstruct xfs_buf_log_item\t*bip,\n\tint\t\t\tcount)\n{\n\tASSERT(bip->bli_formats == NULL);\n\tbip->bli_format_count = count;\n\n\tif (count == 1) {\n\t\tbip->bli_formats = &bip->__bli_format;\n\t\treturn 0;\n\t}\n\n\tbip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),\n\t\t\t\tKM_SLEEP);\n\tif (!bip->bli_formats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_buf_item_committing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "695-700",
    "snippet": "STATIC void\nxfs_buf_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n}"
  },
  {
    "function_name": "xfs_buf_item_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "681-693",
    "snippet": "STATIC xfs_lsn_t\nxfs_buf_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\ttrace_xfs_buf_item_committed(bip);\n\n\tif ((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) && lip->li_lsn != 0)\n\t\treturn lip->li_lsn;\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_committed",
          "args": [
            "bip"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_lsn_t\nxfs_buf_item_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\ttrace_xfs_buf_item_committed(bip);\n\n\tif ((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) && lip->li_lsn != 0)\n\t\treturn lip->li_lsn;\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_buf_item_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "571-661",
    "snippet": "STATIC void\nxfs_buf_item_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tbool\t\t\tclean;\n\tbool\t\t\taborted;\n\tint\t\t\tflags;\n\n\t/* Clear the buffer's association with this transaction. */\n\tbp->b_transp = NULL;\n\n\t/*\n\t * If this is a transaction abort, don't return early.  Instead, allow\n\t * the brelse to happen.  Normally it would be done for stale\n\t * (cancelled) buffers at unpin time, but we'll never go through the\n\t * pin/unpin cycle if we abort inside commit.\n\t */\n\taborted = (lip->li_flags & XFS_LI_ABORTED) ? true : false;\n\t/*\n\t * Before possibly freeing the buf item, copy the per-transaction state\n\t * so we can reference it safely later after clearing it from the\n\t * buffer log item.\n\t */\n\tflags = bip->bli_flags;\n\tbip->bli_flags &= ~(XFS_BLI_LOGGED | XFS_BLI_HOLD | XFS_BLI_ORDERED);\n\n\t/*\n\t * If the buf item is marked stale, then don't do anything.  We'll\n\t * unlock the buffer and free the buf item when the buffer is unpinned\n\t * for the last time.\n\t */\n\tif (flags & XFS_BLI_STALE) {\n\t\ttrace_xfs_buf_item_unlock_stale(bip);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tif (!aborted) {\n\t\t\tatomic_dec(&bip->bli_refcount);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_xfs_buf_item_unlock(bip);\n\n\t/*\n\t * If the buf item isn't tracking any data, free it, otherwise drop the\n\t * reference we hold to it. If we are aborting the transaction, this may\n\t * be the only reference to the buf item, so we free it anyway\n\t * regardless of whether it is dirty or not. A dirty abort implies a\n\t * shutdown, anyway.\n\t *\n\t * Ordered buffers are dirty but may have no recorded changes, so ensure\n\t * we only release clean items here.\n\t */\n\tclean = (flags & XFS_BLI_DIRTY) ? false : true;\n\tif (clean) {\n\t\tint i;\n\t\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\t\tif (!xfs_bitmap_empty(bip->bli_formats[i].blf_data_map,\n\t\t\t\t     bip->bli_formats[i].blf_map_size)) {\n\t\t\t\tclean = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Clean buffers, by definition, cannot be in the AIL. However, aborted\n\t * buffers may be dirty and hence in the AIL. Therefore if we are\n\t * aborting a buffer and we've just taken the last refernce away, we\n\t * have to check if it is in the AIL before freeing it. We need to free\n\t * it in this case, because an aborted transaction has already shut the\n\t * filesystem down and this is the last chance we will have to do so.\n\t */\n\tif (atomic_dec_and_test(&bip->bli_refcount)) {\n\t\tif (clean)\n\t\t\txfs_buf_item_relse(bp);\n\t\telse if (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(lip->li_mountp));\n\t\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t\tspin_lock(&lip->li_ailp->xa_lock);\n\t\t\t\txfs_trans_ail_delete(lip->li_ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR);\n\t\t\t}\n\t\t\txfs_buf_item_relse(bp);\n\t\t}\n\t}\n\n\tif (!(flags & XFS_BLI_HOLD))\n\t\txfs_buf_relse(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_relse",
          "args": [
            "bp"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "960-975",
          "snippet": "void\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "lip->li_ailp",
            "lip",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(lip->li_mountp)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "lip->li_mountp"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bitmap_empty",
          "args": [
            "bip->bli_formats[i].blf_data_map",
            "bip->bli_formats[i].blf_map_size"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bitmap_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "31-42",
          "snippet": "int\nxfs_bitmap_empty(uint *map, uint size)\n{\n\tuint i;\n\tuint ret = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tret |= map[i];\n\t}\n\n\treturn (ret == 0);\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_bitmap_empty(uint *map, uint size)\n{\n\tuint i;\n\tuint ret = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tret |= map[i];\n\t}\n\n\treturn (ret == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_unlock",
          "args": [
            "bip"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->__bli_format.blf_flags & XFS_BLF_CANCEL"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_unlock_stale",
          "args": [
            "bip"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_item_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tbool\t\t\tclean;\n\tbool\t\t\taborted;\n\tint\t\t\tflags;\n\n\t/* Clear the buffer's association with this transaction. */\n\tbp->b_transp = NULL;\n\n\t/*\n\t * If this is a transaction abort, don't return early.  Instead, allow\n\t * the brelse to happen.  Normally it would be done for stale\n\t * (cancelled) buffers at unpin time, but we'll never go through the\n\t * pin/unpin cycle if we abort inside commit.\n\t */\n\taborted = (lip->li_flags & XFS_LI_ABORTED) ? true : false;\n\t/*\n\t * Before possibly freeing the buf item, copy the per-transaction state\n\t * so we can reference it safely later after clearing it from the\n\t * buffer log item.\n\t */\n\tflags = bip->bli_flags;\n\tbip->bli_flags &= ~(XFS_BLI_LOGGED | XFS_BLI_HOLD | XFS_BLI_ORDERED);\n\n\t/*\n\t * If the buf item is marked stale, then don't do anything.  We'll\n\t * unlock the buffer and free the buf item when the buffer is unpinned\n\t * for the last time.\n\t */\n\tif (flags & XFS_BLI_STALE) {\n\t\ttrace_xfs_buf_item_unlock_stale(bip);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tif (!aborted) {\n\t\t\tatomic_dec(&bip->bli_refcount);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_xfs_buf_item_unlock(bip);\n\n\t/*\n\t * If the buf item isn't tracking any data, free it, otherwise drop the\n\t * reference we hold to it. If we are aborting the transaction, this may\n\t * be the only reference to the buf item, so we free it anyway\n\t * regardless of whether it is dirty or not. A dirty abort implies a\n\t * shutdown, anyway.\n\t *\n\t * Ordered buffers are dirty but may have no recorded changes, so ensure\n\t * we only release clean items here.\n\t */\n\tclean = (flags & XFS_BLI_DIRTY) ? false : true;\n\tif (clean) {\n\t\tint i;\n\t\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\t\tif (!xfs_bitmap_empty(bip->bli_formats[i].blf_data_map,\n\t\t\t\t     bip->bli_formats[i].blf_map_size)) {\n\t\t\t\tclean = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Clean buffers, by definition, cannot be in the AIL. However, aborted\n\t * buffers may be dirty and hence in the AIL. Therefore if we are\n\t * aborting a buffer and we've just taken the last refernce away, we\n\t * have to check if it is in the AIL before freeing it. We need to free\n\t * it in this case, because an aborted transaction has already shut the\n\t * filesystem down and this is the last chance we will have to do so.\n\t */\n\tif (atomic_dec_and_test(&bip->bli_refcount)) {\n\t\tif (clean)\n\t\t\txfs_buf_item_relse(bp);\n\t\telse if (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(lip->li_mountp));\n\t\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t\tspin_lock(&lip->li_ailp->xa_lock);\n\t\t\t\txfs_trans_ail_delete(lip->li_ailp, lip,\n\t\t\t\t\t\t     SHUTDOWN_LOG_IO_ERROR);\n\t\t\t}\n\t\t\txfs_buf_item_relse(bp);\n\t\t}\n\t}\n\n\tif (!(flags & XFS_BLI_HOLD))\n\t\txfs_buf_relse(bp);\n}"
  },
  {
    "function_name": "xfs_buf_item_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "510-550",
    "snippet": "STATIC uint\nxfs_buf_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\n\tif (xfs_buf_ispinned(bp))\n\t\treturn XFS_ITEM_PINNED;\n\tif (!xfs_buf_trylock(bp)) {\n\t\t/*\n\t\t * If we have just raced with a buffer being pinned and it has\n\t\t * been marked stale, we could end up stalling until someone else\n\t\t * issues a log force to unpin the stale buffer. Check for the\n\t\t * race condition here so xfsaild recognizes the buffer is pinned\n\t\t * and queues a log force to move it along.\n\t\t */\n\t\tif (xfs_buf_ispinned(bp))\n\t\t\treturn XFS_ITEM_PINNED;\n\t\treturn XFS_ITEM_LOCKED;\n\t}\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_push(bip);\n\n\t/* has a previous flush failed due to IO errors? */\n\tif ((bp->b_flags & XBF_WRITE_FAIL) &&\n\t    ___ratelimit(&xfs_buf_write_fail_rl_state, \"XFS:\")) {\n\t\txfs_warn(bp->b_target->bt_mount,\n\"Detected failing async write on buffer block 0x%llx. Retrying async write.\",\n\t\t\t (long long)bp->b_bn);\n\t}\n\n\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\trval = XFS_ITEM_FLUSHING;\n\txfs_buf_unlock(bp);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "bp->b_target->bt_mount",
            "\"Detected failing async write on buffer block 0x%llx. Retrying async write.\"",
            "(long long)bp->b_bn"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___ratelimit",
          "args": [
            "&xfs_buf_write_fail_rl_state",
            "\"XFS:\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_push",
          "args": [
            "bip"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ispinned",
          "args": [
            "bp"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ispinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "356-359",
          "snippet": "static inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_trylock",
          "args": [
            "bp"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "934-946",
          "snippet": "int\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC uint\nxfs_buf_item_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\n\tif (xfs_buf_ispinned(bp))\n\t\treturn XFS_ITEM_PINNED;\n\tif (!xfs_buf_trylock(bp)) {\n\t\t/*\n\t\t * If we have just raced with a buffer being pinned and it has\n\t\t * been marked stale, we could end up stalling until someone else\n\t\t * issues a log force to unpin the stale buffer. Check for the\n\t\t * race condition here so xfsaild recognizes the buffer is pinned\n\t\t * and queues a log force to move it along.\n\t\t */\n\t\tif (xfs_buf_ispinned(bp))\n\t\t\treturn XFS_ITEM_PINNED;\n\t\treturn XFS_ITEM_LOCKED;\n\t}\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_push(bip);\n\n\t/* has a previous flush failed due to IO errors? */\n\tif ((bp->b_flags & XBF_WRITE_FAIL) &&\n\t    ___ratelimit(&xfs_buf_write_fail_rl_state, \"XFS:\")) {\n\t\txfs_warn(bp->b_target->bt_mount,\n\"Detected failing async write on buffer block 0x%llx. Retrying async write.\",\n\t\t\t (long long)bp->b_bn);\n\t}\n\n\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\trval = XFS_ITEM_FLUSHING;\n\txfs_buf_unlock(bp);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_buf_item_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "410-500",
    "snippet": "STATIC void\nxfs_buf_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\txfs_buf_t\t*bp = bip->bli_buf;\n\tstruct xfs_ail\t*ailp = lip->li_ailp;\n\tint\t\tstale = bip->bli_flags & XFS_BLI_STALE;\n\tint\t\tfreed;\n\n\tASSERT(bp->b_fspriv == bip);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_buf_item_unpin(bip);\n\n\tfreed = atomic_dec_and_test(&bip->bli_refcount);\n\n\tif (atomic_dec_and_test(&bp->b_pin_count))\n\t\twake_up_all(&bp->b_waiters);\n\n\tif (freed && stale) {\n\t\tASSERT(bip->bli_flags & XFS_BLI_STALE);\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\n\t\ttrace_xfs_buf_item_unpin_stale(bip);\n\n\t\tif (remove) {\n\t\t\t/*\n\t\t\t * If we are in a transaction context, we have to\n\t\t\t * remove the log item from the transaction as we are\n\t\t\t * about to release our reference to the buffer.  If we\n\t\t\t * don't, the unlock that occurs later in\n\t\t\t * xfs_trans_uncommit() will try to reference the\n\t\t\t * buffer which we no longer have a hold on.\n\t\t\t */\n\t\t\tif (lip->li_desc)\n\t\t\t\txfs_trans_del_item(lip);\n\n\t\t\t/*\n\t\t\t * Since the transaction no longer refers to the buffer,\n\t\t\t * the buffer should no longer refer to the transaction.\n\t\t\t */\n\t\t\tbp->b_transp = NULL;\n\t\t}\n\n\t\t/*\n\t\t * If we get called here because of an IO error, we may\n\t\t * or may not have the item on the AIL. xfs_trans_ail_delete()\n\t\t * will take care of that situation.\n\t\t * xfs_trans_ail_delete() drops the AIL lock.\n\t\t */\n\t\tif (bip->bli_flags & XFS_BLI_STALE_INODE) {\n\t\t\txfs_buf_do_callbacks(bp);\n\t\t\tbp->b_fspriv = NULL;\n\t\t\tbp->b_iodone = NULL;\n\t\t} else {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_LOG_IO_ERROR);\n\t\t\txfs_buf_item_relse(bp);\n\t\t\tASSERT(bp->b_fspriv == NULL);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t} else if (freed && remove) {\n\t\t/*\n\t\t * There are currently two references to the buffer - the active\n\t\t * LRU reference and the buf log item. What we are about to do\n\t\t * here - simulate a failed IO completion - requires 3\n\t\t * references.\n\t\t *\n\t\t * The LRU reference is removed by the xfs_buf_stale() call. The\n\t\t * buf item reference is removed by the xfs_buf_iodone()\n\t\t * callback that is run by xfs_buf_do_callbacks() during ioend\n\t\t * processing (via the bp->b_iodone callback), and then finally\n\t\t * the ioend processing will drop the IO reference if the buffer\n\t\t * is marked XBF_ASYNC.\n\t\t *\n\t\t * Hence we need to take an additional reference here so that IO\n\t\t * completion processing doesn't free the buffer prematurely.\n\t\t */\n\t\txfs_buf_lock(bp);\n\t\txfs_buf_hold(bp);\n\t\tbp->b_flags |= XBF_ASYNC;\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tXFS_BUF_UNDONE(bp);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_UNDONE",
          "args": [
            "bp"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_fspriv == NULL"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_relse",
          "args": [
            "bp"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "960-975",
          "snippet": "void\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "lip",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_do_callbacks",
          "args": [
            "bp"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_do_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "1023-1041",
          "snippet": "STATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_do_callbacks(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_log_item\t*lip;\n\n\twhile ((lip = bp->b_fspriv) != NULL) {\n\t\tbp->b_fspriv = lip->li_bio_list;\n\t\tASSERT(lip->li_cb != NULL);\n\t\t/*\n\t\t * Clear the next pointer so we don't have any\n\t\t * confusion if the item is added to another buf.\n\t\t * Don't touch the log item after calling its\n\t\t * callback, because it could have freed itself.\n\t\t */\n\t\tlip->li_bio_list = NULL;\n\t\tlip->li_cb(bp, lip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_del_item",
          "args": [
            "lip"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "681-687",
          "snippet": "void\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_unpin_stale",
          "args": [
            "bip"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->__bli_format.blf_flags & XFS_BLF_CANCEL"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ISSTALE(bp)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISSTALE",
          "args": [
            "bp"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_flags & XFS_BLI_STALE"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&bp->b_waiters"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bp->b_pin_count"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_unpin",
          "args": [
            "bip"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_fspriv == bip"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_item_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\txfs_buf_t\t*bp = bip->bli_buf;\n\tstruct xfs_ail\t*ailp = lip->li_ailp;\n\tint\t\tstale = bip->bli_flags & XFS_BLI_STALE;\n\tint\t\tfreed;\n\n\tASSERT(bp->b_fspriv == bip);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_buf_item_unpin(bip);\n\n\tfreed = atomic_dec_and_test(&bip->bli_refcount);\n\n\tif (atomic_dec_and_test(&bp->b_pin_count))\n\t\twake_up_all(&bp->b_waiters);\n\n\tif (freed && stale) {\n\t\tASSERT(bip->bli_flags & XFS_BLI_STALE);\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\n\t\ttrace_xfs_buf_item_unpin_stale(bip);\n\n\t\tif (remove) {\n\t\t\t/*\n\t\t\t * If we are in a transaction context, we have to\n\t\t\t * remove the log item from the transaction as we are\n\t\t\t * about to release our reference to the buffer.  If we\n\t\t\t * don't, the unlock that occurs later in\n\t\t\t * xfs_trans_uncommit() will try to reference the\n\t\t\t * buffer which we no longer have a hold on.\n\t\t\t */\n\t\t\tif (lip->li_desc)\n\t\t\t\txfs_trans_del_item(lip);\n\n\t\t\t/*\n\t\t\t * Since the transaction no longer refers to the buffer,\n\t\t\t * the buffer should no longer refer to the transaction.\n\t\t\t */\n\t\t\tbp->b_transp = NULL;\n\t\t}\n\n\t\t/*\n\t\t * If we get called here because of an IO error, we may\n\t\t * or may not have the item on the AIL. xfs_trans_ail_delete()\n\t\t * will take care of that situation.\n\t\t * xfs_trans_ail_delete() drops the AIL lock.\n\t\t */\n\t\tif (bip->bli_flags & XFS_BLI_STALE_INODE) {\n\t\t\txfs_buf_do_callbacks(bp);\n\t\t\tbp->b_fspriv = NULL;\n\t\t\tbp->b_iodone = NULL;\n\t\t} else {\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_LOG_IO_ERROR);\n\t\t\txfs_buf_item_relse(bp);\n\t\t\tASSERT(bp->b_fspriv == NULL);\n\t\t}\n\t\txfs_buf_relse(bp);\n\t} else if (freed && remove) {\n\t\t/*\n\t\t * There are currently two references to the buffer - the active\n\t\t * LRU reference and the buf log item. What we are about to do\n\t\t * here - simulate a failed IO completion - requires 3\n\t\t * references.\n\t\t *\n\t\t * The LRU reference is removed by the xfs_buf_stale() call. The\n\t\t * buf item reference is removed by the xfs_buf_iodone()\n\t\t * callback that is run by xfs_buf_do_callbacks() during ioend\n\t\t * processing (via the bp->b_iodone callback), and then finally\n\t\t * the ioend processing will drop the IO reference if the buffer\n\t\t * is marked XBF_ASYNC.\n\t\t *\n\t\t * Hence we need to take an additional reference here so that IO\n\t\t * completion processing doesn't free the buffer prematurely.\n\t\t */\n\t\txfs_buf_lock(bp);\n\t\txfs_buf_hold(bp);\n\t\tbp->b_flags |= XBF_ASYNC;\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tXFS_BUF_UNDONE(bp);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_item_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "380-395",
    "snippet": "STATIC void\nxfs_buf_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_ORDERED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_pin(bip);\n\n\tatomic_inc(&bip->bli_refcount);\n\tatomic_inc(&bip->bli_buf->b_pin_count);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bip->bli_buf->b_pin_count"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_pin",
          "args": [
            "bip"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_ORDERED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_item_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_ORDERED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\n\ttrace_xfs_buf_item_pin(bip);\n\n\tatomic_inc(&bip->bli_refcount);\n\tatomic_inc(&bip->bli_buf->b_pin_count);\n}"
  },
  {
    "function_name": "xfs_buf_item_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "308-369",
    "snippet": "STATIC void\nxfs_buf_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tuint\t\t\toffset = 0;\n\tint\t\t\ti;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\tASSERT((bip->bli_flags & XFS_BLI_STALE) ||\n\t       (xfs_blft_from_flags(&bip->__bli_format) > XFS_BLFT_UNKNOWN_BUF\n\t        && xfs_blft_from_flags(&bip->__bli_format) < XFS_BLFT_MAX_BUF));\n\n\n\t/*\n\t * If it is an inode buffer, transfer the in-memory state to the\n\t * format flags and clear the in-memory state.\n\t *\n\t * For buffer based inode allocation, we do not transfer\n\t * this state if the inode buffer allocation has not yet been committed\n\t * to the log as setting the XFS_BLI_INODE_BUF flag will prevent\n\t * correct replay of the inode allocation.\n\t *\n\t * For icreate item based inode allocation, the buffers aren't written\n\t * to the journal during allocation, and hence we should always tag the\n\t * buffer as an inode buffer so that the correct unlinked list replay\n\t * occurs during recovery.\n\t */\n\tif (bip->bli_flags & XFS_BLI_INODE_BUF) {\n\t\tif (xfs_sb_version_hascrc(&lip->li_mountp->m_sb) ||\n\t\t    !((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) &&\n\t\t      xfs_log_item_in_current_chkpt(lip)))\n\t\t\tbip->__bli_format.blf_flags |= XFS_BLF_INODE_BUF;\n\t\tbip->bli_flags &= ~XFS_BLI_INODE_BUF;\n\t}\n\n\tif ((bip->bli_flags & (XFS_BLI_ORDERED|XFS_BLI_STALE)) ==\n\t\t\t\t\t\t\tXFS_BLI_ORDERED) {\n\t\t/*\n\t\t * The buffer has been logged just to order it.  It is not being\n\t\t * included in the transaction commit, so don't format it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_ordered(bip);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_format_segment(bip, lv, &vecp, offset,\n\t\t\t\t\t    &bip->bli_formats[i]);\n\t\toffset += bp->b_maps[i].bm_len;\n\t}\n\n\t/*\n\t * Check to make sure everything is consistent.\n\t */\n\ttrace_xfs_buf_item_format(bip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_format",
          "args": [
            "bip"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_format_segment",
          "args": [
            "bip",
            "lv",
            "&vecp",
            "offset",
            "&bip->bli_formats[i]"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_format_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "212-300",
          "snippet": "static void\nxfs_buf_item_format_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tuint\t\t\toffset,\n\tstruct xfs_buf_log_format *blfp)\n{\n\tstruct xfs_buf\t*bp = bip->bli_buf;\n\tuint\t\tbase_size;\n\tint\t\tfirst_bit;\n\tint\t\tlast_bit;\n\tint\t\tnext_bit;\n\tuint\t\tnbits;\n\n\t/* copy the flags across from the base format item */\n\tblfp->blf_flags = bip->__bli_format.blf_flags;\n\n\t/*\n\t * Base size is the actual size of the ondisk structure - it reflects\n\t * the actual size of the dirty bitmap rather than the size of the in\n\t * memory structure.\n\t */\n\tbase_size = xfs_buf_log_format_size(blfp);\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (!(bip->bli_flags & XFS_BLI_STALE) && first_bit == -1) {\n\t\t/*\n\t\t * If the map is not be dirty in the transaction, mark\n\t\t * the size as zero and do not advance the vector pointer.\n\t\t */\n\t\treturn;\n\t}\n\n\tblfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);\n\tblfp->blf_size = 1;\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_stale(bip);\n\t\tASSERT(blfp->blf_flags & XFS_BLF_CANCEL);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Fill in an iovec for each set of contiguous chunks.\n\t */\n\tlast_bit = first_bit;\n\tnbits = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)last_bit + 1);\n\t\t/*\n\t\t * If we run out of bits fill in the last iovec and get out of\n\t\t * the loop.  Else if we start a new set of bits then fill in\n\t\t * the iovec for the series we were looking at and start\n\t\t * counting the bits in the new one.  Else we're still in the\n\t\t * same set of bits so just keep counting and scanning.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, next_bit, last_bit)) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tfirst_bit = next_bit;\n\t\t\tlast_bit = next_bit;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic void\nxfs_buf_item_format_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tuint\t\t\toffset,\n\tstruct xfs_buf_log_format *blfp)\n{\n\tstruct xfs_buf\t*bp = bip->bli_buf;\n\tuint\t\tbase_size;\n\tint\t\tfirst_bit;\n\tint\t\tlast_bit;\n\tint\t\tnext_bit;\n\tuint\t\tnbits;\n\n\t/* copy the flags across from the base format item */\n\tblfp->blf_flags = bip->__bli_format.blf_flags;\n\n\t/*\n\t * Base size is the actual size of the ondisk structure - it reflects\n\t * the actual size of the dirty bitmap rather than the size of the in\n\t * memory structure.\n\t */\n\tbase_size = xfs_buf_log_format_size(blfp);\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (!(bip->bli_flags & XFS_BLI_STALE) && first_bit == -1) {\n\t\t/*\n\t\t * If the map is not be dirty in the transaction, mark\n\t\t * the size as zero and do not advance the vector pointer.\n\t\t */\n\t\treturn;\n\t}\n\n\tblfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);\n\tblfp->blf_size = 1;\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_stale(bip);\n\t\tASSERT(blfp->blf_flags & XFS_BLF_CANCEL);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Fill in an iovec for each set of contiguous chunks.\n\t */\n\tlast_bit = first_bit;\n\tnbits = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)last_bit + 1);\n\t\t/*\n\t\t * If we run out of bits fill in the last iovec and get out of\n\t\t * the loop.  Else if we start a new set of bits then fill in\n\t\t * the iovec for the series we were looking at and start\n\t\t * counting the bits in the new one.  Else we're still in the\n\t\t * same set of bits so just keep counting and scanning.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, next_bit, last_bit)) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tfirst_bit = next_bit;\n\t\t\tlast_bit = next_bit;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_format_ordered",
          "args": [
            "bip"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_item_in_current_chkpt",
          "args": [
            "lip"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_in_current_chkpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "924-943",
          "snippet": "bool\nxfs_log_item_in_current_chkpt(\n\tstruct xfs_log_item *lip)\n{\n\tstruct xfs_cil_ctx *ctx;\n\n\tif (list_empty(&lip->li_cil))\n\t\treturn false;\n\n\tctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\n\n\t/*\n\t * li_seq is written on the first commit of a log item to record the\n\t * first checkpoint it is written to. Hence if it is different to the\n\t * current sequence, we're in a new checkpoint.\n\t */\n\tif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_log_item_in_current_chkpt(\n\tstruct xfs_log_item *lip)\n{\n\tstruct xfs_cil_ctx *ctx;\n\n\tif (list_empty(&lip->li_cil))\n\t\treturn false;\n\n\tctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\n\n\t/*\n\t * li_seq is written on the first commit of a log item to record the\n\t * first checkpoint it is written to. Hence if it is different to the\n\t * current sequence, we're in a new checkpoint.\n\t */\n\tif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&lip->li_mountp->m_sb"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(bip->bli_flags & XFS_BLI_STALE) ||\n\t       (xfs_blft_from_flags(&bip->__bli_format) > XFS_BLFT_UNKNOWN_BUF\n\t        && xfs_blft_from_flags(&bip->__bli_format) < XFS_BLFT_MAX_BUF)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_blft_from_flags",
          "args": [
            "&bip->__bli_format"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blft_from_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "509-513",
          "snippet": "static inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)",
            "#define XFS_BLFT_SHIFT\t11"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)\n#define XFS_BLFT_SHIFT\t11\n\nstatic inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_item_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tuint\t\t\toffset = 0;\n\tint\t\t\ti;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT((bip->bli_flags & XFS_BLI_LOGGED) ||\n\t       (bip->bli_flags & XFS_BLI_STALE));\n\tASSERT((bip->bli_flags & XFS_BLI_STALE) ||\n\t       (xfs_blft_from_flags(&bip->__bli_format) > XFS_BLFT_UNKNOWN_BUF\n\t        && xfs_blft_from_flags(&bip->__bli_format) < XFS_BLFT_MAX_BUF));\n\n\n\t/*\n\t * If it is an inode buffer, transfer the in-memory state to the\n\t * format flags and clear the in-memory state.\n\t *\n\t * For buffer based inode allocation, we do not transfer\n\t * this state if the inode buffer allocation has not yet been committed\n\t * to the log as setting the XFS_BLI_INODE_BUF flag will prevent\n\t * correct replay of the inode allocation.\n\t *\n\t * For icreate item based inode allocation, the buffers aren't written\n\t * to the journal during allocation, and hence we should always tag the\n\t * buffer as an inode buffer so that the correct unlinked list replay\n\t * occurs during recovery.\n\t */\n\tif (bip->bli_flags & XFS_BLI_INODE_BUF) {\n\t\tif (xfs_sb_version_hascrc(&lip->li_mountp->m_sb) ||\n\t\t    !((bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF) &&\n\t\t      xfs_log_item_in_current_chkpt(lip)))\n\t\t\tbip->__bli_format.blf_flags |= XFS_BLF_INODE_BUF;\n\t\tbip->bli_flags &= ~XFS_BLI_INODE_BUF;\n\t}\n\n\tif ((bip->bli_flags & (XFS_BLI_ORDERED|XFS_BLI_STALE)) ==\n\t\t\t\t\t\t\tXFS_BLI_ORDERED) {\n\t\t/*\n\t\t * The buffer has been logged just to order it.  It is not being\n\t\t * included in the transaction commit, so don't format it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_ordered(bip);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_format_segment(bip, lv, &vecp, offset,\n\t\t\t\t\t    &bip->bli_formats[i]);\n\t\toffset += bp->b_maps[i].bm_len;\n\t}\n\n\t/*\n\t * Check to make sure everything is consistent.\n\t */\n\ttrace_xfs_buf_item_format(bip);\n}"
  },
  {
    "function_name": "xfs_buf_item_format_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "212-300",
    "snippet": "static void\nxfs_buf_item_format_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tuint\t\t\toffset,\n\tstruct xfs_buf_log_format *blfp)\n{\n\tstruct xfs_buf\t*bp = bip->bli_buf;\n\tuint\t\tbase_size;\n\tint\t\tfirst_bit;\n\tint\t\tlast_bit;\n\tint\t\tnext_bit;\n\tuint\t\tnbits;\n\n\t/* copy the flags across from the base format item */\n\tblfp->blf_flags = bip->__bli_format.blf_flags;\n\n\t/*\n\t * Base size is the actual size of the ondisk structure - it reflects\n\t * the actual size of the dirty bitmap rather than the size of the in\n\t * memory structure.\n\t */\n\tbase_size = xfs_buf_log_format_size(blfp);\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (!(bip->bli_flags & XFS_BLI_STALE) && first_bit == -1) {\n\t\t/*\n\t\t * If the map is not be dirty in the transaction, mark\n\t\t * the size as zero and do not advance the vector pointer.\n\t\t */\n\t\treturn;\n\t}\n\n\tblfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);\n\tblfp->blf_size = 1;\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_stale(bip);\n\t\tASSERT(blfp->blf_flags & XFS_BLF_CANCEL);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Fill in an iovec for each set of contiguous chunks.\n\t */\n\tlast_bit = first_bit;\n\tnbits = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)last_bit + 1);\n\t\t/*\n\t\t * If we run out of bits fill in the last iovec and get out of\n\t\t * the loop.  Else if we start a new set of bits then fill in\n\t\t * the iovec for the series we were looking at and start\n\t\t * counting the bits in the new one.  Else we're still in the\n\t\t * same set of bits so just keep counting and scanning.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, next_bit, last_bit)) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tfirst_bit = next_bit;\n\t\t\tlast_bit = next_bit;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_item_copy_iovec",
          "args": [
            "lv",
            "vecp",
            "bp",
            "offset",
            "first_bit",
            "nbits"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "185-198",
          "snippet": "static inline void\nxfs_buf_item_copy_iovec(\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tuint\t\t\tnbits)\n{\n\toffset += first_bit * XFS_BLF_CHUNK;\n\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,\n\t\t\txfs_buf_offset(bp, offset),\n\t\t\tnbits * XFS_BLF_CHUNK);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic inline void\nxfs_buf_item_copy_iovec(\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tuint\t\t\tnbits)\n{\n\toffset += first_bit * XFS_BLF_CHUNK;\n\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,\n\t\t\txfs_buf_offset(bp, offset),\n\t\t\tnbits * XFS_BLF_CHUNK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_straddle",
          "args": [
            "bp",
            "offset",
            "next_bit",
            "last_bit"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_straddle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "200-210",
          "snippet": "static inline bool\nxfs_buf_item_straddle(\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tnext_bit,\n\tint\t\t\tlast_bit)\n{\n\treturn xfs_buf_offset(bp, offset + (next_bit << XFS_BLF_SHIFT)) !=\n\t\t(xfs_buf_offset(bp, offset + (last_bit << XFS_BLF_SHIFT)) +\n\t\t XFS_BLF_CHUNK);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic inline bool\nxfs_buf_item_straddle(\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tnext_bit,\n\tint\t\t\tlast_bit)\n{\n\treturn xfs_buf_offset(bp, offset + (next_bit << XFS_BLF_SHIFT)) !=\n\t\t(xfs_buf_offset(bp, offset + (last_bit << XFS_BLF_SHIFT)) +\n\t\t XFS_BLF_CHUNK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_next_bit",
          "args": [
            "blfp->blf_data_map",
            "blfp->blf_map_size",
            "(uint)last_bit + 1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "88-118",
          "snippet": "int xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blfp->blf_flags & XFS_BLF_CANCEL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_format_stale",
          "args": [
            "bip"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_BFORMAT",
            "blfp",
            "base_size"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_log_format_size",
          "args": [
            "blfp"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_log_format_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "43-49",
          "snippet": "static inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic void\nxfs_buf_item_format_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tuint\t\t\toffset,\n\tstruct xfs_buf_log_format *blfp)\n{\n\tstruct xfs_buf\t*bp = bip->bli_buf;\n\tuint\t\tbase_size;\n\tint\t\tfirst_bit;\n\tint\t\tlast_bit;\n\tint\t\tnext_bit;\n\tuint\t\tnbits;\n\n\t/* copy the flags across from the base format item */\n\tblfp->blf_flags = bip->__bli_format.blf_flags;\n\n\t/*\n\t * Base size is the actual size of the ondisk structure - it reflects\n\t * the actual size of the dirty bitmap rather than the size of the in\n\t * memory structure.\n\t */\n\tbase_size = xfs_buf_log_format_size(blfp);\n\n\tfirst_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (!(bip->bli_flags & XFS_BLI_STALE) && first_bit == -1) {\n\t\t/*\n\t\t * If the map is not be dirty in the transaction, mark\n\t\t * the size as zero and do not advance the vector pointer.\n\t\t */\n\t\treturn;\n\t}\n\n\tblfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);\n\tblfp->blf_size = 1;\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_format_stale(bip);\n\t\tASSERT(blfp->blf_flags & XFS_BLF_CANCEL);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Fill in an iovec for each set of contiguous chunks.\n\t */\n\tlast_bit = first_bit;\n\tnbits = 1;\n\tfor (;;) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\t(uint)last_bit + 1);\n\t\t/*\n\t\t * If we run out of bits fill in the last iovec and get out of\n\t\t * the loop.  Else if we start a new set of bits then fill in\n\t\t * the iovec for the series we were looking at and start\n\t\t * counting the bits in the new one.  Else we're still in the\n\t\t * same set of bits so just keep counting and scanning.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1 ||\n\t\t           xfs_buf_item_straddle(bp, offset, next_bit, last_bit)) {\n\t\t\txfs_buf_item_copy_iovec(lv, vecp, bp, offset,\n\t\t\t\t\t\tfirst_bit, nbits);\n\t\t\tblfp->blf_size++;\n\t\t\tfirst_bit = next_bit;\n\t\t\tlast_bit = next_bit;\n\t\t\tnbits = 1;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t\tnbits++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_item_straddle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "200-210",
    "snippet": "static inline bool\nxfs_buf_item_straddle(\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tnext_bit,\n\tint\t\t\tlast_bit)\n{\n\treturn xfs_buf_offset(bp, offset + (next_bit << XFS_BLF_SHIFT)) !=\n\t\t(xfs_buf_offset(bp, offset + (last_bit << XFS_BLF_SHIFT)) +\n\t\t XFS_BLF_CHUNK);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "offset + (last_bit << XFS_BLF_SHIFT)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic inline bool\nxfs_buf_item_straddle(\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tnext_bit,\n\tint\t\t\tlast_bit)\n{\n\treturn xfs_buf_offset(bp, offset + (next_bit << XFS_BLF_SHIFT)) !=\n\t\t(xfs_buf_offset(bp, offset + (last_bit << XFS_BLF_SHIFT)) +\n\t\t XFS_BLF_CHUNK);\n}"
  },
  {
    "function_name": "xfs_buf_item_copy_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "185-198",
    "snippet": "static inline void\nxfs_buf_item_copy_iovec(\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tuint\t\t\tnbits)\n{\n\toffset += first_bit * XFS_BLF_CHUNK;\n\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,\n\t\t\txfs_buf_offset(bp, offset),\n\t\t\tnbits * XFS_BLF_CHUNK);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "vecp",
            "XLOG_REG_TYPE_BCHUNK",
            "xfs_buf_offset(bp, offset)",
            "nbits * XFS_BLF_CHUNK"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "offset"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nstatic inline void\nxfs_buf_item_copy_iovec(\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_iovec\t**vecp,\n\tstruct xfs_buf\t\t*bp,\n\tuint\t\t\toffset,\n\tint\t\t\tfirst_bit,\n\tuint\t\t\tnbits)\n{\n\toffset += first_bit * XFS_BLF_CHUNK;\n\txlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,\n\t\t\txfs_buf_offset(bp, offset),\n\t\t\tnbits * XFS_BLF_CHUNK);\n}"
  },
  {
    "function_name": "xfs_buf_item_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "131-183",
    "snippet": "STATIC void\nxfs_buf_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tint\t\t\ti;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_size_stale(bip);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\t*nvecs += bip->bli_format_count;\n\t\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\t\t*nbytes += xfs_buf_log_format_size(&bip->bli_formats[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tASSERT(bip->bli_flags & XFS_BLI_LOGGED);\n\n\tif (bip->bli_flags & XFS_BLI_ORDERED) {\n\t\t/*\n\t\t * The buffer has been logged just to order it.\n\t\t * It is not being included in the transaction\n\t\t * commit, so no vectors are used at all.\n\t\t */\n\t\ttrace_xfs_buf_item_size_ordered(bip);\n\t\t*nvecs = XFS_LOG_VEC_ORDERED;\n\t\treturn;\n\t}\n\n\t/*\n\t * the vector count is based on the number of buffer vectors we have\n\t * dirty bits in. This will only be greater than one when we have a\n\t * compound buffer with more than one segment dirty. Hence for compound\n\t * buffers we need to track which segment the dirty bits correspond to,\n\t * and when we move from one segment to the next increment the vector\n\t * count for the extra buf log format structure that will need to be\n\t * written.\n\t */\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_size_segment(bip, &bip->bli_formats[i],\n\t\t\t\t\t  nvecs, nbytes);\n\t}\n\ttrace_xfs_buf_item_size(bip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_size",
          "args": [
            "bip"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_size_segment",
          "args": [
            "bip",
            "&bip->bli_formats[i]",
            "nvecs",
            "nbytes"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_size_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "61-112",
          "snippet": "STATIC void\nxfs_buf_item_size_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_buf_log_format *blfp,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\tnext_bit;\n\tint\t\t\tlast_bit;\n\n\tlast_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (last_bit == -1)\n\t\treturn;\n\n\t/*\n\t * initial count for a dirty buffer is 2 vectors - the format structure\n\t * and the first dirty region.\n\t */\n\t*nvecs += 2;\n\t*nbytes += xfs_buf_log_format_size(blfp) + XFS_BLF_CHUNK;\n\n\twhile (last_bit != -1) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\tlast_bit + 1);\n\t\t/*\n\t\t * If we run out of bits, leave the loop,\n\t\t * else if we find a new set of bits bump the number of vecs,\n\t\t * else keep scanning the current set of bits.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else if (xfs_buf_offset(bp, next_bit * XFS_BLF_CHUNK) !=\n\t\t\t   (xfs_buf_offset(bp, last_bit * XFS_BLF_CHUNK) +\n\t\t\t    XFS_BLF_CHUNK)) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t}\n\t\t*nbytes += XFS_BLF_CHUNK;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_item_size_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_buf_log_format *blfp,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\tnext_bit;\n\tint\t\t\tlast_bit;\n\n\tlast_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (last_bit == -1)\n\t\treturn;\n\n\t/*\n\t * initial count for a dirty buffer is 2 vectors - the format structure\n\t * and the first dirty region.\n\t */\n\t*nvecs += 2;\n\t*nbytes += xfs_buf_log_format_size(blfp) + XFS_BLF_CHUNK;\n\n\twhile (last_bit != -1) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\tlast_bit + 1);\n\t\t/*\n\t\t * If we run out of bits, leave the loop,\n\t\t * else if we find a new set of bits bump the number of vecs,\n\t\t * else keep scanning the current set of bits.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else if (xfs_buf_offset(bp, next_bit * XFS_BLF_CHUNK) !=\n\t\t\t   (xfs_buf_offset(bp, last_bit * XFS_BLF_CHUNK) +\n\t\t\t    XFS_BLF_CHUNK)) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t}\n\t\t*nbytes += XFS_BLF_CHUNK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_size_ordered",
          "args": [
            "bip"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_flags & XFS_BLI_LOGGED"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_log_format_size",
          "args": [
            "&bip->bli_formats[i]"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_log_format_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "43-49",
          "snippet": "static inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->__bli_format.blf_flags & XFS_BLF_CANCEL"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_size_stale",
          "args": [
            "bip"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUF_ITEM",
          "args": [
            "lip"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "BUF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "36-39",
          "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_item_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf_log_item\t*bip = BUF_ITEM(lip);\n\tint\t\t\ti;\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * The buffer is stale, so all we need to log\n\t\t * is the buf log format structure with the\n\t\t * cancel flag in it.\n\t\t */\n\t\ttrace_xfs_buf_item_size_stale(bip);\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\t*nvecs += bip->bli_format_count;\n\t\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\t\t*nbytes += xfs_buf_log_format_size(&bip->bli_formats[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tASSERT(bip->bli_flags & XFS_BLI_LOGGED);\n\n\tif (bip->bli_flags & XFS_BLI_ORDERED) {\n\t\t/*\n\t\t * The buffer has been logged just to order it.\n\t\t * It is not being included in the transaction\n\t\t * commit, so no vectors are used at all.\n\t\t */\n\t\ttrace_xfs_buf_item_size_ordered(bip);\n\t\t*nvecs = XFS_LOG_VEC_ORDERED;\n\t\treturn;\n\t}\n\n\t/*\n\t * the vector count is based on the number of buffer vectors we have\n\t * dirty bits in. This will only be greater than one when we have a\n\t * compound buffer with more than one segment dirty. Hence for compound\n\t * buffers we need to track which segment the dirty bits correspond to,\n\t * and when we move from one segment to the next increment the vector\n\t * count for the extra buf log format structure that will need to be\n\t * written.\n\t */\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\txfs_buf_item_size_segment(bip, &bip->bli_formats[i],\n\t\t\t\t\t  nvecs, nbytes);\n\t}\n\ttrace_xfs_buf_item_size(bip);\n}"
  },
  {
    "function_name": "xfs_buf_item_size_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "61-112",
    "snippet": "STATIC void\nxfs_buf_item_size_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_buf_log_format *blfp,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\tnext_bit;\n\tint\t\t\tlast_bit;\n\n\tlast_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (last_bit == -1)\n\t\treturn;\n\n\t/*\n\t * initial count for a dirty buffer is 2 vectors - the format structure\n\t * and the first dirty region.\n\t */\n\t*nvecs += 2;\n\t*nbytes += xfs_buf_log_format_size(blfp) + XFS_BLF_CHUNK;\n\n\twhile (last_bit != -1) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\tlast_bit + 1);\n\t\t/*\n\t\t * If we run out of bits, leave the loop,\n\t\t * else if we find a new set of bits bump the number of vecs,\n\t\t * else keep scanning the current set of bits.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else if (xfs_buf_offset(bp, next_bit * XFS_BLF_CHUNK) !=\n\t\t\t   (xfs_buf_offset(bp, last_bit * XFS_BLF_CHUNK) +\n\t\t\t    XFS_BLF_CHUNK)) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t}\n\t\t*nbytes += XFS_BLF_CHUNK;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_offset",
          "args": [
            "bp",
            "last_bit * XFS_BLF_CHUNK"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1422-1435",
          "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_next_bit",
          "args": [
            "blfp->blf_data_map",
            "blfp->blf_map_size",
            "last_bit + 1"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
          "lines": "88-118",
          "snippet": "int xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}",
          "includes": [
            "#include \"xfs_bit.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_log_format_size",
          "args": [
            "blfp"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_log_format_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "43-49",
          "snippet": "static inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nSTATIC void\nxfs_buf_item_size_segment(\n\tstruct xfs_buf_log_item\t*bip,\n\tstruct xfs_buf_log_format *blfp,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\tint\t\t\tnext_bit;\n\tint\t\t\tlast_bit;\n\n\tlast_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size, 0);\n\tif (last_bit == -1)\n\t\treturn;\n\n\t/*\n\t * initial count for a dirty buffer is 2 vectors - the format structure\n\t * and the first dirty region.\n\t */\n\t*nvecs += 2;\n\t*nbytes += xfs_buf_log_format_size(blfp) + XFS_BLF_CHUNK;\n\n\twhile (last_bit != -1) {\n\t\t/*\n\t\t * This takes the bit number to start looking from and\n\t\t * returns the next set bit from there.  It returns -1\n\t\t * if there are no more bits set or the start bit is\n\t\t * beyond the end of the bitmap.\n\t\t */\n\t\tnext_bit = xfs_next_bit(blfp->blf_data_map, blfp->blf_map_size,\n\t\t\t\t\tlast_bit + 1);\n\t\t/*\n\t\t * If we run out of bits, leave the loop,\n\t\t * else if we find a new set of bits bump the number of vecs,\n\t\t * else keep scanning the current set of bits.\n\t\t */\n\t\tif (next_bit == -1) {\n\t\t\tbreak;\n\t\t} else if (next_bit != last_bit + 1) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else if (xfs_buf_offset(bp, next_bit * XFS_BLF_CHUNK) !=\n\t\t\t   (xfs_buf_offset(bp, last_bit * XFS_BLF_CHUNK) +\n\t\t\t    XFS_BLF_CHUNK)) {\n\t\t\tlast_bit = next_bit;\n\t\t\t(*nvecs)++;\n\t\t} else {\n\t\t\tlast_bit++;\n\t\t}\n\t\t*nbytes += XFS_BLF_CHUNK;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_log_format_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "43-49",
    "snippet": "static inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_log_format_size(\n\tstruct xfs_buf_log_format *blfp)\n{\n\treturn offsetof(struct xfs_buf_log_format, blf_data_map) +\n\t\t\t(blfp->blf_map_size * sizeof(blfp->blf_data_map[0]));\n}"
  },
  {
    "function_name": "BUF_ITEM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
    "lines": "36-39",
    "snippet": "static inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lip",
            "structxfs_buf_log_item",
            "bli_item"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_buf_log_item *BUF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_buf_log_item, bli_item);\n}"
  }
]