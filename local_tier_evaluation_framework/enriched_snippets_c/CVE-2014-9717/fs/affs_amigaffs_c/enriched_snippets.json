[
  {
    "function_name": "affs_copy_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "507-515",
    "snippet": "int\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bstr",
            "dentry->d_name.name",
            "len"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "dentry->d_name.len",
            "AFFSNAMEMAX"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}"
  },
  {
    "function_name": "affs_check_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "481-498",
    "snippet": "int\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_nofilenametruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "471-477",
    "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
  },
  {
    "function_name": "affs_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "458-469",
    "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"(device %s): %s(): %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "affs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "442-456",
    "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Remounting filesystem read-only\\n\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"error (device %s): %s(): %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
  },
  {
    "function_name": "mode_to_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "414-440",
    "snippet": "void\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nvoid\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}"
  },
  {
    "function_name": "prot_to_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "387-412",
    "snippet": "umode_t\nprot_to_mode(u32 prot)\n{\n\tumode_t mode = 0;\n\n\tif (!(prot & FIBF_NOWRITE))\n\t\tmode |= S_IWUSR;\n\tif (!(prot & FIBF_NOREAD))\n\t\tmode |= S_IRUSR;\n\tif (!(prot & FIBF_NOEXECUTE))\n\t\tmode |= S_IXUSR;\n\tif (prot & FIBF_GRP_WRITE)\n\t\tmode |= S_IWGRP;\n\tif (prot & FIBF_GRP_READ)\n\t\tmode |= S_IRGRP;\n\tif (prot & FIBF_GRP_EXECUTE)\n\t\tmode |= S_IXGRP;\n\tif (prot & FIBF_OTR_WRITE)\n\t\tmode |= S_IWOTH;\n\tif (prot & FIBF_OTR_READ)\n\t\tmode |= S_IROTH;\n\tif (prot & FIBF_OTR_EXECUTE)\n\t\tmode |= S_IXOTH;\n\n\treturn mode;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"affs.h\"\n\numode_t\nprot_to_mode(u32 prot)\n{\n\tumode_t mode = 0;\n\n\tif (!(prot & FIBF_NOWRITE))\n\t\tmode |= S_IWUSR;\n\tif (!(prot & FIBF_NOREAD))\n\t\tmode |= S_IRUSR;\n\tif (!(prot & FIBF_NOEXECUTE))\n\t\tmode |= S_IXUSR;\n\tif (prot & FIBF_GRP_WRITE)\n\t\tmode |= S_IWGRP;\n\tif (prot & FIBF_GRP_READ)\n\t\tmode |= S_IRGRP;\n\tif (prot & FIBF_GRP_EXECUTE)\n\t\tmode |= S_IXGRP;\n\tif (prot & FIBF_OTR_WRITE)\n\t\tmode |= S_IWOTH;\n\tif (prot & FIBF_OTR_READ)\n\t\tmode |= S_IROTH;\n\tif (prot & FIBF_OTR_EXECUTE)\n\t\tmode |= S_IXOTH;\n\n\treturn mode;\n}"
  },
  {
    "function_name": "secs_to_datestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "368-385",
    "snippet": "void\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "secs * 50"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "minute"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "days"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nvoid\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}"
  },
  {
    "function_name": "affs_fix_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "353-366",
    "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "-checksum"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
  },
  {
    "function_name": "affs_checksum_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "335-346",
    "snippet": "u32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*ptr++"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nu32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}"
  },
  {
    "function_name": "affs_remove_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "263-326",
    "snippet": "int\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_unlock_link",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "286-290",
          "snippet": "static inline void\naffs_unlock_link(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_link_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_link(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_link_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "dir"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_remove_link",
          "args": [
            "dentry"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "138-227",
          "snippet": "static int\naffs_remove_link(struct dentry *dentry)\n{\n\tstruct inode *dir, *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL, *link_bh = NULL;\n\tu32 link_ino, ino;\n\tint retval;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tlink_ino = (u32)(long)dentry->d_fsdata;\n\tif (inode->i_ino == link_ino) {\n\t\t/* we can't remove the head of the link, as its blocknr is still used as ino,\n\t\t * so we remove the block of the first link instead.\n\t\t */ \n\t\tlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\n\t\tdir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\n\t\tif (IS_ERR(dir)) {\n\t\t\tretval = PTR_ERR(dir);\n\t\t\tgoto done;\n\t\t}\n\n\t\taffs_lock_dir(dir);\n\t\t/*\n\t\t * if there's a dentry for that block, make it\n\t\t * refer to inode itself.\n\t\t */\n\t\taffs_fix_dcache(inode, link_ino);\n\t\tretval = affs_remove_hash(dir, link_bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(link_bh, inode);\n\n\t\tmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\n\t\tretval = affs_insert_hash(dir, bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, inode);\n\n\t\taffs_unlock_dir(dir);\n\t\tiput(dir);\n\t} else {\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\t}\n\n\twhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\n\t\tif (ino == link_ino) {\n\t\t\t__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\n\t\t\tAFFS_TAIL(sb, bh)->link_chain = ino2;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t\tretval = 0;\n\t\t\t/* Fix the link count, if bh is a normal header block without links */\n\t\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\tcase ST_LINKDIR:\n\t\t\tcase ST_LINKFILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!AFFS_TAIL(sb, bh)->link_chain)\n\t\t\t\t\tset_nlink(inode, 1);\n\t\t\t}\n\t\t\taffs_free_block(sb, link_ino);\n\t\t\tgoto done;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, ino);\n\t\tif (!bh)\n\t\t\tgoto done;\n\t}\n\tretval = -ENOENT;\ndone:\n\taffs_brelse(link_bh);\n\taffs_brelse(bh);\n\treturn retval;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\naffs_remove_link(struct dentry *dentry)\n{\n\tstruct inode *dir, *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL, *link_bh = NULL;\n\tu32 link_ino, ino;\n\tint retval;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tlink_ino = (u32)(long)dentry->d_fsdata;\n\tif (inode->i_ino == link_ino) {\n\t\t/* we can't remove the head of the link, as its blocknr is still used as ino,\n\t\t * so we remove the block of the first link instead.\n\t\t */ \n\t\tlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\n\t\tdir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\n\t\tif (IS_ERR(dir)) {\n\t\t\tretval = PTR_ERR(dir);\n\t\t\tgoto done;\n\t\t}\n\n\t\taffs_lock_dir(dir);\n\t\t/*\n\t\t * if there's a dentry for that block, make it\n\t\t * refer to inode itself.\n\t\t */\n\t\taffs_fix_dcache(inode, link_ino);\n\t\tretval = affs_remove_hash(dir, link_bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(link_bh, inode);\n\n\t\tmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\n\t\tretval = affs_insert_hash(dir, bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, inode);\n\n\t\taffs_unlock_dir(dir);\n\t\tiput(dir);\n\t} else {\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\t}\n\n\twhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\n\t\tif (ino == link_ino) {\n\t\t\t__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\n\t\t\tAFFS_TAIL(sb, bh)->link_chain = ino2;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t\tretval = 0;\n\t\t\t/* Fix the link count, if bh is a normal header block without links */\n\t\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\tcase ST_LINKDIR:\n\t\t\tcase ST_LINKFILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!AFFS_TAIL(sb, bh)->link_chain)\n\t\t\t\t\tset_nlink(inode, 1);\n\t\t\t}\n\t\t\taffs_free_block(sb, link_ino);\n\t\t\tgoto done;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, ino);\n\t\tif (!bh)\n\t\t\tgoto done;\n\t}\n\tretval = -ENOENT;\ndone:\n\taffs_brelse(link_bh);\n\taffs_brelse(bh);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_remove_hash",
          "args": [
            "dir",
            "bh"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "71-119",
          "snippet": "int\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_empty_dir",
          "args": [
            "inode"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "affs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "230-251",
          "snippet": "static int\naffs_empty_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tint retval, size;\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tretval = -ENOTEMPTY;\n\tfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\n\t\tif (AFFS_HEAD(bh)->table[size])\n\t\t\tgoto not_empty;\n\tretval = 0;\nnot_empty:\n\taffs_brelse(bh);\ndone:\n\treturn retval;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\naffs_empty_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tint retval, size;\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tretval = -ENOTEMPTY;\n\tfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\n\t\tif (AFFS_HEAD(bh)->table[size])\n\t\t\tgoto not_empty;\n\tretval = 0;\nnot_empty:\n\taffs_brelse(bh);\ndone:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "inode"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->stype"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_lock_link",
          "args": [
            "inode"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "281-285",
          "snippet": "static inline void\naffs_lock_link(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_link_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_link(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_link_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "(u32)(long)dentry->d_fsdata"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(key=%ld)\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
  },
  {
    "function_name": "affs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "230-251",
    "snippet": "static int\naffs_empty_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tint retval, size;\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tretval = -ENOTEMPTY;\n\tfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\n\t\tif (AFFS_HEAD(bh)->table[size])\n\t\t\tgoto not_empty;\n\tretval = 0;\nnot_empty:\n\taffs_brelse(bh);\ndone:\n\treturn retval;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\naffs_empty_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tint retval, size;\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tretval = -ENOTEMPTY;\n\tfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\n\t\tif (AFFS_HEAD(bh)->table[size])\n\t\t\tgoto not_empty;\n\tretval = 0;\nnot_empty:\n\taffs_brelse(bh);\ndone:\n\treturn retval;\n}"
  },
  {
    "function_name": "affs_remove_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "138-227",
    "snippet": "static int\naffs_remove_link(struct dentry *dentry)\n{\n\tstruct inode *dir, *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL, *link_bh = NULL;\n\tu32 link_ino, ino;\n\tint retval;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tlink_ino = (u32)(long)dentry->d_fsdata;\n\tif (inode->i_ino == link_ino) {\n\t\t/* we can't remove the head of the link, as its blocknr is still used as ino,\n\t\t * so we remove the block of the first link instead.\n\t\t */ \n\t\tlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\n\t\tdir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\n\t\tif (IS_ERR(dir)) {\n\t\t\tretval = PTR_ERR(dir);\n\t\t\tgoto done;\n\t\t}\n\n\t\taffs_lock_dir(dir);\n\t\t/*\n\t\t * if there's a dentry for that block, make it\n\t\t * refer to inode itself.\n\t\t */\n\t\taffs_fix_dcache(inode, link_ino);\n\t\tretval = affs_remove_hash(dir, link_bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(link_bh, inode);\n\n\t\tmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\n\t\tretval = affs_insert_hash(dir, bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, inode);\n\n\t\taffs_unlock_dir(dir);\n\t\tiput(dir);\n\t} else {\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\t}\n\n\twhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\n\t\tif (ino == link_ino) {\n\t\t\t__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\n\t\t\tAFFS_TAIL(sb, bh)->link_chain = ino2;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t\tretval = 0;\n\t\t\t/* Fix the link count, if bh is a normal header block without links */\n\t\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\tcase ST_LINKDIR:\n\t\t\tcase ST_LINKFILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!AFFS_TAIL(sb, bh)->link_chain)\n\t\t\t\t\tset_nlink(inode, 1);\n\t\t\t}\n\t\t\taffs_free_block(sb, link_ino);\n\t\t\tgoto done;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, ino);\n\t\tif (!bh)\n\t\t\tgoto done;\n\t}\n\tretval = -ENOENT;\ndone:\n\taffs_brelse(link_bh);\n\taffs_brelse(bh);\n\treturn retval;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "ino"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "link_ino"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->stype"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "bh",
            "be32_to_cpu(ino2) - link_ino"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ino2"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "link_bh"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->link_chain"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "dir"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_insert_hash",
          "args": [
            "dir",
            "bh"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "affs_insert_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "22-65",
          "snippet": "int\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "AFFS_TAIL(sb, bh)->name",
            "AFFS_TAIL(sb, link_bh)->name",
            "32"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "link_bh"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_remove_hash",
          "args": [
            "dir",
            "link_bh"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "71-119",
          "snippet": "int\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_dcache",
          "args": [
            "inode",
            "link_ino"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_dcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "121-133",
          "snippet": "static void\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\n{\n\tstruct dentry *dentry;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n\t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic void\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\n{\n\tstruct dentry *dentry;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n\t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "dir"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_iget",
          "args": [
            "sb",
            "be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "affs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "16-162",
          "snippet": "struct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, link_bh)->parent"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "link_bh"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->link_chain"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(key=%ld)\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\naffs_remove_link(struct dentry *dentry)\n{\n\tstruct inode *dir, *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL, *link_bh = NULL;\n\tu32 link_ino, ino;\n\tint retval;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\tlink_ino = (u32)(long)dentry->d_fsdata;\n\tif (inode->i_ino == link_ino) {\n\t\t/* we can't remove the head of the link, as its blocknr is still used as ino,\n\t\t * so we remove the block of the first link instead.\n\t\t */ \n\t\tlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\n\t\tdir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\n\t\tif (IS_ERR(dir)) {\n\t\t\tretval = PTR_ERR(dir);\n\t\t\tgoto done;\n\t\t}\n\n\t\taffs_lock_dir(dir);\n\t\t/*\n\t\t * if there's a dentry for that block, make it\n\t\t * refer to inode itself.\n\t\t */\n\t\taffs_fix_dcache(inode, link_ino);\n\t\tretval = affs_remove_hash(dir, link_bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(link_bh, inode);\n\n\t\tmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\n\t\tretval = affs_insert_hash(dir, bh);\n\t\tif (retval) {\n\t\t\taffs_unlock_dir(dir);\n\t\t\tgoto done;\n\t\t}\n\t\tmark_buffer_dirty_inode(bh, inode);\n\n\t\taffs_unlock_dir(dir);\n\t\tiput(dir);\n\t} else {\n\t\tlink_bh = affs_bread(sb, link_ino);\n\t\tif (!link_bh)\n\t\t\tgoto done;\n\t}\n\n\twhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\n\t\tif (ino == link_ino) {\n\t\t\t__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\n\t\t\tAFFS_TAIL(sb, bh)->link_chain = ino2;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t\tretval = 0;\n\t\t\t/* Fix the link count, if bh is a normal header block without links */\n\t\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t\tcase ST_LINKDIR:\n\t\t\tcase ST_LINKFILE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!AFFS_TAIL(sb, bh)->link_chain)\n\t\t\t\t\tset_nlink(inode, 1);\n\t\t\t}\n\t\t\taffs_free_block(sb, link_ino);\n\t\t\tgoto done;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, ino);\n\t\tif (!bh)\n\t\t\tgoto done;\n\t}\n\tretval = -ENOENT;\ndone:\n\taffs_brelse(link_bh);\n\taffs_brelse(bh);\n\treturn retval;\n}"
  },
  {
    "function_name": "affs_fix_dcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "121-133",
    "snippet": "static void\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\n{\n\tstruct dentry *dentry;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n\t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "dentry",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic void\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\n{\n\tstruct dentry *dentry;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n\t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "affs_remove_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "71-119",
    "snippet": "int\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->hash_chain"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "hash_ino"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "rem_bh"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "dir"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "bh",
            "be32_to_cpu(ino) - hash_ino"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ino"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "rem_bh"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(bh)->table[offset]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(dir=%lu, ino=%d, hashval=%d)\\n\"",
            "__func__",
            "dir->i_ino",
            "rem_ino",
            "offset"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_hash_name",
          "args": [
            "sb",
            "AFFS_TAIL(sb, rem_bh)->name+1",
            "AFFS_TAIL(sb, rem_bh)->name[0]"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "affs_hash_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "173-184",
          "snippet": "int\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nint\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "rem_bh"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "rem_bh"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "affs_insert_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
    "lines": "22-65",
    "snippet": "int\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "dir_bh"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "dir_bh",
            "dir"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "dir_bh",
            "ino"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ino"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "dir_bh"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ino"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "dir_bh"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dir->i_ino"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, dir_bh)->hash_chain"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "dir_bh"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "hash_ino"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(dir_bh)->table[offset]"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "dir_bh"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(dir=%lu, ino=%d)\\n\"",
            "__func__",
            "dir->i_ino",
            "ino"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_hash_name",
          "args": [
            "sb",
            "AFFS_TAIL(sb, bh)->name + 1",
            "AFFS_TAIL(sb, bh)->name[0]"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "affs_hash_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "173-184",
          "snippet": "int\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nint\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
  }
]