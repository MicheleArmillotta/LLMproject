[
  {
    "function_name": "indirect2direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
    "lines": "201-317",
    "snippet": "int indirect2direct(struct reiserfs_transaction_handle *th,\n\t\t    struct inode *inode, struct page *page,\n\t\t    struct treepath *path,\t/* path to the indirect item. */\n\t\t    const struct cpu_key *item_key,\t/* Key to look for\n\t\t\t\t\t\t\t * unformatted node\n\t\t\t\t\t\t\t * pointer to be cut. */\n\t\t    loff_t n_new_file_size,\t/* New file size. */\n\t\t    char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head s_ih;\n\tunsigned long block_size = sb->s_blocksize;\n\tchar *tail;\n\tint tail_len, round_tail_len;\n\tloff_t pos, pos1;\t/* position of first byte of the tail */\n\tstruct cpu_key key;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_indirect2direct++;\n\n\t*mode = M_SKIP_BALANCING;\n\n\t/* store item head path points to. */\n\tcopy_item_head(&s_ih, tp_item_head(path));\n\n\ttail_len = (n_new_file_size & (block_size - 1));\n\tif (get_inode_sd_version(inode) == STAT_DATA_V2)\n\t\tround_tail_len = ROUND_UP(tail_len);\n\telse\n\t\tround_tail_len = tail_len;\n\n\tpos =\n\t    le_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t\t\t\t 1) * sb->s_blocksize;\n\tpos1 = pos;\n\n\t/*\n\t * we are protected by i_mutex. The tail can not disapper, not\n\t * append can be done either\n\t * we are in truncate or packing tail in file_release\n\t */\n\n\ttail = (char *)kmap(page);\t/* this can schedule */\n\n\tif (path_changed(&s_ih, path)) {\n\t\t/* re-search indirect item */\n\t\tif (search_for_position_by_key(sb, item_key, path)\n\t\t    == POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-5520\",\n\t\t\t\t       \"item to be converted %K does not exist\",\n\t\t\t\t       item_key);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n#ifdef CONFIG_REISERFS_CHECK\n\t\tpos = le_ih_k_offset(&s_ih) - 1 +\n\t\t    (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t     1) * sb->s_blocksize;\n\t\tif (pos != pos1)\n\t\t\treiserfs_panic(sb, \"vs-5530\", \"tail position \"\n\t\t\t\t       \"changed while we were reading it\");\n#endif\n\t}\n\n\t/* Set direct item header to insert. */\n\tmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\n\t\t\t  pos1 + 1, TYPE_DIRECT, round_tail_len,\n\t\t\t  0xffff /*ih_free_space */ );\n\n\t/*\n\t * we want a pointer to the first byte of the tail in the page.\n\t * the page was locked and this part of the page was up to date when\n\t * indirect2direct was called, so we know the bytes are still valid\n\t */\n\ttail = tail + (pos & (PAGE_CACHE_SIZE - 1));\n\n\tPATH_LAST_POSITION(path)++;\n\n\tkey = *item_key;\n\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\tkey.key_length = 4;\n\t/* Insert tail as new direct item in the tree */\n\tif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\n\t\t\t\t tail ? tail : NULL) < 0) {\n\t\t/*\n\t\t * No disk memory. So we can not convert last unformatted node\n\t\t * to the direct item.  In this case we used to adjust\n\t\t * indirect items's ih_free_space. Now ih_free_space is not\n\t\t * used, it would be ideal to write zeros to corresponding\n\t\t * unformatted node. For now i_size is considered as guard for\n\t\t * going out of file size\n\t\t */\n\t\tkunmap(page);\n\t\treturn block_size - round_tail_len;\n\t}\n\tkunmap(page);\n\n\t/* make sure to get the i_blocks changes from reiserfs_insert_item */\n\treiserfs_update_sd(th, inode);\n\n\t/*\n\t * note: we have now the same as in above direct2indirect\n\t * conversion: there are two keys which have matching first three\n\t * key components. They only differ by the fourth one.\n\t */\n\n\t/*\n\t * We have inserted new direct item and must remove last\n\t * unformatted node.\n\t */\n\t*mode = M_CUT;\n\n\t/* we store position of first direct item in the in-core inode */\n\t/* mark_file_with_tail (inode, pos1 + 1); */\n\tREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\n\n\treturn block_size - round_tail_len;\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "path",
            "&key",
            "&s_ih",
            "inode",
            "tail ? tail : NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_type",
          "args": [
            "&key",
            "TYPE_DIRECT"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1598-1601",
          "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "&s_ih",
            "NULL",
            "get_inode_item_key_version(inode)",
            "pos1 + 1",
            "TYPE_DIRECT",
            "round_tail_len",
            "0xffff/*ih_free_space */"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"vs-5530\"",
            "\"tail position \"\n\t\t\t\t       \"changed while we were reading it\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "&s_ih"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "&s_ih"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&s_ih",
            "tp_item_head(path)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"PAP-5520\"",
            "\"item to be converted %K does not exist\"",
            "item_key"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "sb",
            "item_key",
            "path"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_changed",
          "args": [
            "&s_ih",
            "path"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "&s_ih"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "tail_len"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nint indirect2direct(struct reiserfs_transaction_handle *th,\n\t\t    struct inode *inode, struct page *page,\n\t\t    struct treepath *path,\t/* path to the indirect item. */\n\t\t    const struct cpu_key *item_key,\t/* Key to look for\n\t\t\t\t\t\t\t * unformatted node\n\t\t\t\t\t\t\t * pointer to be cut. */\n\t\t    loff_t n_new_file_size,\t/* New file size. */\n\t\t    char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct item_head s_ih;\n\tunsigned long block_size = sb->s_blocksize;\n\tchar *tail;\n\tint tail_len, round_tail_len;\n\tloff_t pos, pos1;\t/* position of first byte of the tail */\n\tstruct cpu_key key;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_indirect2direct++;\n\n\t*mode = M_SKIP_BALANCING;\n\n\t/* store item head path points to. */\n\tcopy_item_head(&s_ih, tp_item_head(path));\n\n\ttail_len = (n_new_file_size & (block_size - 1));\n\tif (get_inode_sd_version(inode) == STAT_DATA_V2)\n\t\tround_tail_len = ROUND_UP(tail_len);\n\telse\n\t\tround_tail_len = tail_len;\n\n\tpos =\n\t    le_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t\t\t\t 1) * sb->s_blocksize;\n\tpos1 = pos;\n\n\t/*\n\t * we are protected by i_mutex. The tail can not disapper, not\n\t * append can be done either\n\t * we are in truncate or packing tail in file_release\n\t */\n\n\ttail = (char *)kmap(page);\t/* this can schedule */\n\n\tif (path_changed(&s_ih, path)) {\n\t\t/* re-search indirect item */\n\t\tif (search_for_position_by_key(sb, item_key, path)\n\t\t    == POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-5520\",\n\t\t\t\t       \"item to be converted %K does not exist\",\n\t\t\t\t       item_key);\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n#ifdef CONFIG_REISERFS_CHECK\n\t\tpos = le_ih_k_offset(&s_ih) - 1 +\n\t\t    (ih_item_len(&s_ih) / UNFM_P_SIZE -\n\t\t     1) * sb->s_blocksize;\n\t\tif (pos != pos1)\n\t\t\treiserfs_panic(sb, \"vs-5530\", \"tail position \"\n\t\t\t\t       \"changed while we were reading it\");\n#endif\n\t}\n\n\t/* Set direct item header to insert. */\n\tmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\n\t\t\t  pos1 + 1, TYPE_DIRECT, round_tail_len,\n\t\t\t  0xffff /*ih_free_space */ );\n\n\t/*\n\t * we want a pointer to the first byte of the tail in the page.\n\t * the page was locked and this part of the page was up to date when\n\t * indirect2direct was called, so we know the bytes are still valid\n\t */\n\ttail = tail + (pos & (PAGE_CACHE_SIZE - 1));\n\n\tPATH_LAST_POSITION(path)++;\n\n\tkey = *item_key;\n\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\tkey.key_length = 4;\n\t/* Insert tail as new direct item in the tree */\n\tif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\n\t\t\t\t tail ? tail : NULL) < 0) {\n\t\t/*\n\t\t * No disk memory. So we can not convert last unformatted node\n\t\t * to the direct item.  In this case we used to adjust\n\t\t * indirect items's ih_free_space. Now ih_free_space is not\n\t\t * used, it would be ideal to write zeros to corresponding\n\t\t * unformatted node. For now i_size is considered as guard for\n\t\t * going out of file size\n\t\t */\n\t\tkunmap(page);\n\t\treturn block_size - round_tail_len;\n\t}\n\tkunmap(page);\n\n\t/* make sure to get the i_blocks changes from reiserfs_insert_item */\n\treiserfs_update_sd(th, inode);\n\n\t/*\n\t * note: we have now the same as in above direct2indirect\n\t * conversion: there are two keys which have matching first three\n\t * key components. They only differ by the fourth one.\n\t */\n\n\t/*\n\t * We have inserted new direct item and must remove last\n\t * unformatted node.\n\t */\n\t*mode = M_CUT;\n\n\t/* we store position of first direct item in the in-core inode */\n\t/* mark_file_with_tail (inode, pos1 + 1); */\n\tREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\n\n\treturn block_size - round_tail_len;\n}"
  },
  {
    "function_name": "reiserfs_unmap_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
    "lines": "166-191",
    "snippet": "void reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_jh",
          "args": [
            "bh"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "731-746",
          "snippet": "void reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "direct2indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
    "lines": "24-163",
    "snippet": "int direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t    struct treepath *path, struct buffer_head *unbh,\n\t\t    loff_t tail_offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *up_to_date_bh;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tunsigned long total_tail = 0;\n\n\t/* Key to search for the last byte of the converted item. */\n\tstruct cpu_key end_key;\n\n\t/*\n\t * new indirect item to be inserted or key\n\t * of unfm pointer to be pasted\n\t */\n\tstruct item_head ind_ih;\n\tint blk_size;\n\t/* returned value for reiserfs_insert_item and clones */\n\tint  retval;\n\t/* Handle on an unformatted node that will be inserted in the tree. */\n\tunp_t unfm_ptr;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_direct2indirect++;\n\n\tblk_size = sb->s_blocksize;\n\n\t/*\n\t * and key to search for append or insert pointer to the new\n\t * unformatted node.\n\t */\n\tcopy_item_head(&ind_ih, p_le_ih);\n\tset_le_ih_k_offset(&ind_ih, tail_offset);\n\tset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\n\n\t/* Set the key to search for the place for new unfm pointer */\n\tmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\n\n\t/* FIXME: we could avoid this */\n\tif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\n\t\treiserfs_error(sb, \"PAP-14030\",\n\t\t\t       \"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\", &end_key);\n\t\tpathrelse(path);\n\t\treturn -EIO;\n\t}\n\n\tp_le_ih = tp_item_head(path);\n\n\tunfm_ptr = cpu_to_le32(unbh->b_blocknr);\n\n\tif (is_statdata_le_ih(p_le_ih)) {\n\t\t/* Insert new indirect item. */\n\t\tset_ih_free_space(&ind_ih, 0);\t/* delete at nearest future */\n\t\tput_ih_item_len(&ind_ih, UNFM_P_SIZE);\n\t\tPATH_LAST_POSITION(path)++;\n\t\tretval =\n\t\t    reiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\n\t\t\t\t\t (char *)&unfm_ptr);\n\t} else {\n\t\t/* Paste into last indirect item of an object. */\n\t\tretval = reiserfs_paste_into_item(th, path, &end_key, inode,\n\t\t\t\t\t\t    (char *)&unfm_ptr,\n\t\t\t\t\t\t    UNFM_P_SIZE);\n\t}\n\tif (retval) {\n\t\treturn retval;\n\t}\n\t/*\n\t * note: from here there are two keys which have matching first\n\t *  three key components. They only differ by the fourth one.\n\t */\n\n\t/* Set the key to search for the direct items of the file */\n\tmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\n\t\t     4);\n\n\t/*\n\t * Move bytes from the direct items to the new unformatted node\n\t * and delete them.\n\t */\n\twhile (1) {\n\t\tint tail_size;\n\n\t\t/*\n\t\t * end_key.k_offset is set so, that we will always have found\n\t\t * last item of the file\n\t\t */\n\t\tif (search_for_position_by_key(sb, &end_key, path) ==\n\t\t    POSITION_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-14050\",\n\t\t\t\t       \"direct item (%K) not found\", &end_key);\n\t\tp_le_ih = tp_item_head(path);\n\t\tRFALSE(!is_direct_le_ih(p_le_ih),\n\t\t       \"vs-14055: direct item expected(%K), found %h\",\n\t\t       &end_key, p_le_ih);\n\t\ttail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\n\t\t    + ih_item_len(p_le_ih) - 1;\n\n\t\t/*\n\t\t * we only send the unbh pointer if the buffer is not\n\t\t * up to date.  this avoids overwriting good data from\n\t\t * writepage() with old data from the disk or buffer cache\n\t\t * Special case: unbh->b_page will be NULL if we are coming\n\t\t * through DIRECT_IO handler here.\n\t\t */\n\t\tif (!unbh->b_page || buffer_uptodate(unbh)\n\t\t    || PageUptodate(unbh->b_page)) {\n\t\t\tup_to_date_bh = NULL;\n\t\t} else {\n\t\t\tup_to_date_bh = unbh;\n\t\t}\n\t\tretval = reiserfs_delete_item(th, path, &end_key, inode,\n\t\t\t\t\t\tup_to_date_bh);\n\n\t\ttotal_tail += retval;\n\n\t\t/* done: file does not have direct items anymore */\n\t\tif (tail_size == retval)\n\t\t\tbreak;\n\n\t}\n\t/*\n\t * if we've copied bytes from disk into the page, we need to zero\n\t * out the unused part of the block (it was not up to date before)\n\t */\n\tif (up_to_date_bh) {\n\t\tunsigned pgoff =\n\t\t    (tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tchar *kaddr = kmap_atomic(up_to_date_bh->b_page);\n\t\tmemset(kaddr + pgoff, 0, blk_size - total_tail);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pgoff",
            "0",
            "blk_size - total_tail"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "up_to_date_bh->b_page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_item",
          "args": [
            "th",
            "path",
            "&end_key",
            "inode",
            "up_to_date_bh"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_delete_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1233-2262",
          "snippet": "int reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n\tint iter = 0;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0 /*size is unknown */ );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\titer++;\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t/* file system changed, repeat search */\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t/* while (1) */\n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t/* reiserfs_delete_item returns item length when success */\n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t/*\n\t * hack so the quota code doesn't have to guess if the file has a\n\t * tail.  On tail insert, we allocate quota for 1 unformatted node.\n\t * We test the offset because the tail might have been\n\t * split into multiple items, and we only want to decrement for\n\t * the unfm node once\n\t */\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t/*\n\t\t * We are in direct2indirect conversion, so move tail contents\n\t\t * to the unformatted node\n\t\t */\n\t\t/*\n\t\t * note, we do the copy before preparing the buffer because we\n\t\t * don't care about the contents of the unformatted node yet.\n\t\t * the only thing we really care about is the direct item's\n\t\t * data is in the unformatted node.\n\t\t *\n\t\t * Otherwise, we would have to call\n\t\t * reiserfs_prepare_for_journal on the unformatted node,\n\t\t * which might schedule, meaning we'd have to loop all the\n\t\t * way back up to the start of the while loop.\n\t\t *\n\t\t * The unformatted node must be dirtied later on.  We can't be\n\t\t * sure here if the entire tail has been deleted yet.\n\t\t *\n\t\t * un_bh is from the page cache (all unformatted nodes are\n\t\t * from the page cache) and might be a highmem page.  So, we\n\t\t * can't use un_bh->b_data.\n\t\t * -clm\n\t\t */\n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t/* Perform balancing after all resources have been collected at once. */\n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t/* Return deleted body length */\n\treturn ret_value;\n}\n\n/*\n * Summary Of Mechanisms For Handling Collisions Between Processes:\n *\n *  deletion of the body of the object is performed by iput(), with the\n *  result that if multiple processes are operating on a file, the\n *  deletion of the body of the file is deferred until the last process\n *  that has an open inode performs its iput().\n *\n *  writes and truncates are protected from collisions by use of\n *  semaphores.\n *\n *  creates, linking, and mknod are protected from collisions with other\n *  processes by making the reiserfs_add_entry() the last step in the\n *  creation, and then rolling back all changes if there was a collision.\n *  - Hans\n*/\n\n/* this deletes item which never gets split */\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t/*\n\t\t\t * No need for a warning, if there is just no free\n\t\t\t * space to insert '..' item into the\n\t\t\t * newly-created subdir\n\t\t\t */\n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t/*\n\t\t\t * Should we count quota for item? (we don't\n\t\t\t * count quotas for save-links)\n\t\t\t */\n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IO_ERROR, NO_DISK_SPACE, etc */\n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t/* for directory this deletes item containing \".\" and \"..\" */\n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n/* USE_INODE_GENERATION_COUNTER */\n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_CACHE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t/*\n\t\t\t\t * we want to unmap the buffers that contain\n\t\t\t\t * the tail, and all the buffers after it\n\t\t\t\t * (since the tail must be at the end of the\n\t\t\t\t * file).  We don't want to unmap file data\n\t\t\t\t * before the tail, since it might be dirty\n\t\t\t\t * and waiting to reach disk\n\t\t\t\t */\n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t/*\n\t * the page being sent in could be NULL if there was an i/o error\n\t * reading in the last block.  The user will hit problems trying to\n\t * read the file, but for now we just skip the indirect2direct\n\t */\n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t/* leave tail in an unformatted node */\n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t/* Perform the conversion to a direct_item. */\n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n/*\n * we did indirect_to_direct conversion. And we have inserted direct\n * item successesfully, but there were no disk space to cut unfm\n * pointer being converted. Therefore we have to delete inserted\n * direct item(s)\n */\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t/* look for the last byte of the tail */\n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL /*unbh not needed */ );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t/*\n\t * Every function which is going to call do_balance must first\n\t * create a tree_balance structure.  Then it must fill up this\n\t * structure by using the init_tb_struct and fix_nodes functions.\n\t * After that we can make tree balancing.\n\t */\n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t/* Amount to be cut. */\n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t/* Number of the removed unformatted nodes. */\n\tint is_inode_locked = 0;\n\tchar mode;\t\t/* Mode of the balance. */\n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t/*\n\t * Repeat this loop until we either cut the item without needing\n\t * to balance, or we fix_nodes without schedule occurring\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Determine the balance mode, position of the first byte to\n\t\t * be cut, and size to be cut.  In case of the indirect item\n\t\t * free unformatted nodes which are pointed to by the cut\n\t\t * pointers.\n\t\t */\n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t/*\n\t\t\t * convert last unformatted node to direct item or\n\t\t\t * leave tail in the unformatted node\n\t\t\t */\n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t/* tail has been left in the unformatted node */\n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t/*\n\t\t\t * removing of last unformatted node will\n\t\t\t * change value we have to return to truncate.\n\t\t\t * Save it\n\t\t\t */\n\t\t\tretval2 = ret_value;\n\n\t\t\t/*\n\t\t\t * So, we have performed the first part of the\n\t\t\t * conversion:\n\t\t\t * inserting the new direct item.  Now we are\n\t\t\t * removing the last unformatted node pointer.\n\t\t\t * Set key to search for it.\n\t\t\t */\n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t/* while */\n\n\t/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */\n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t/*\n\t\t\t * FIXME: this seems to be not needed: we are always\n\t\t\t * able to cut item\n\t\t\t */\n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t/* go ahead and perform balancing */\n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t/* Calculate number of bytes that need to be cut from the item. */\n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t/*\n\t * For direct items, we only change the quota when deleting the last\n\t * item.\n\t */\n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t/* FIXME: this is to keep 3.5 happy */\n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t/*\n\t\t * we are going to complete indirect2direct conversion. Make\n\t\t * sure, that we exactly remove last unformatted node pointer\n\t\t * of the item\n\t\t */\n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t/*\n\t\t * it would be useful to make sure, that right neighboring\n\t\t * item is direct item of this file\n\t\t */\n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t/*\n\t\t * we've done an indirect->direct conversion.  when the\n\t\t * data block was freed, it was removed from the list of\n\t\t * blocks that must be flushed before the transaction\n\t\t * commits, make sure to unmap and invalidate it\n\t\t */\n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n/*\n * Truncate file to the new size. Note, this must be called with a\n * transaction already started\n */\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t/* ->i_size contains new size */\n\t\t\t struct page *page,\t/* up to date for last block */\n\t\t\t /*\n\t\t\t  * when it is called by file_release to convert\n\t\t\t  * the tail - no timestamps should be updated\n\t\t\t  */\n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t/* Path to the current object item. */\n\tstruct item_head *p_le_ih;\t/* Pointer to an item header. */\n\n\t/* Key to search for a previous file item. */\n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t/* Old file size. */\n\t new_file_size;\t/* New file size. */\n\tint deleted;\t\t/* Number of deleted or truncated bytes. */\n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t/* deletion of directory - no need to update timestamps */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t/* Get new file size. */\n\tnew_file_size = inode->i_size;\n\n\t/* FIXME: note, that key type is unimportant here */\n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t/* Get real file size (total length of all file items) */\n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t/*\n\t\t * this may mismatch with real file size: if last direct item\n\t\t * had no padding zeros and last unformatted node had no free\n\t\t * space, this file would have this file size\n\t\t */\n\t\tfile_size = offset + bytes - 1;\n\t}\n\t/*\n\t * are we doing a full truncate or delete, if so\n\t * kick in the reada code\n\t */\n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t/* Update key to search for the last file item. */\n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t/* Cut or delete file item. */\n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t/* Change key to search the last file item. */\n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t/*\n\t\t * While there are bytes to truncate and previous\n\t\t * file item is presented in the tree.\n\t\t */\n\n\t\t/*\n\t\t * This loop could take a really long time, and could log\n\t\t * many more blocks than a transaction can hold.  So, we do\n\t\t * a polite journal end here, and if the transaction needs\n\t\t * ending, we make sure the file is consistent before ending\n\t\t * the current trans and starting a new one\n\t\t */\n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t/* this is truncate, not file closing */\n\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n/* this makes sure, that we __append__, not overwrite or add holes */\nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t/* config reiserfs check */\n\n/*\n * Paste bytes to the existing item.\n * Returns bytes number pasted into the item.\n */\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     /* Path to the pasted item. */\n\t\t\t     struct treepath *search_path,\n\t\t\t     /* Key to search for the needed item. */\n\t\t\t     const struct cpu_key *key,\n\t\t\t     /* Inode item belongs to */\n\t\t\t     struct inode *inode,\n\t\t\t     /* Pointer to the bytes to paste. */\n\t\t\t     const char *body,\n\t\t\t     /* Size of pasted bytes. */\n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t/* DQUOT_* can schedule, must check before the fix_nodes */\n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t/*\n\t * Perform balancing after all resources are collected by fix_nodes,\n\t * and accessing them will not risk triggering schedule.\n\t */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* this also releases the path */\n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n/*\n * Insert new item into the buffer at the path.\n * th   - active transaction handle\n * path - path to the inserted item\n * ih   - pointer to the item header to insert\n * body - pointer to the bytes to insert\n */\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t/* Do we count quotas for item? */\n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t/*\n\t\t * hack so the quota code doesn't have to guess\n\t\t * if the file has a tail, links are always tails,\n\t\t * so there's no guessing needed\n\t\t */\n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t/*\n\t\t * We can't dirty inode here. It would be immediately\n\t\t * written but appropriate stat item isn't inserted yet...\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t/*\n\t * DQUOT_* can schedule, must check to be sure calling\n\t * fix_nodes is safe\n\t */\n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/* make balancing after all resources will be collected at a time */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* also releases the path */\n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)\n\nint reiserfs_delete_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *item_key,\n\t\t\t struct inode *inode, struct buffer_head *un_bh)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_del_balance;\n\tstruct item_head s_ih;\n\tstruct item_head *q_ih;\n\tint quota_cut_bytes;\n\tint ret_value, del_size, removed;\n\tint depth;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tchar mode;\n\tint iter = 0;\n#endif\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_del_balance, sb, path,\n\t\t       0 /*size is unknown */ );\n\n\twhile (1) {\n\t\tremoved = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\titer++;\n\t\tmode =\n#endif\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &del_size,\n\t\t\t\t\t      max_reiserfs_offset(inode));\n\n\t\tRFALSE(mode != M_DELETE, \"PAP-5320: mode must be M_DELETE\");\n\n\t\tcopy_item_head(&s_ih, tp_item_head(path));\n\t\ts_del_balance.insert_size[0] = del_size;\n\n\t\tret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, delete_item_restarted);\n\n\t\t/* file system changed, repeat search */\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == IO_ERROR)\n\t\t\tbreak;\n\t\tif (ret_value == FILE_NOT_FOUND) {\n\t\t\treiserfs_warning(sb, \"vs-5340\",\n\t\t\t\t\t \"no items of the file %K found\",\n\t\t\t\t\t item_key);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t/* while (1) */\n\n\tif (ret_value != CARRY_ON) {\n\t\tunfix_nodes(&s_del_balance);\n\t\treturn 0;\n\t}\n\n\t/* reiserfs_delete_item returns item length when success */\n\tret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);\n\tq_ih = tp_item_head(path);\n\tquota_cut_bytes = ih_item_len(q_ih);\n\n\t/*\n\t * hack so the quota code doesn't have to guess if the file has a\n\t * tail.  On tail insert, we allocate quota for 1 unformatted node.\n\t * We test the offset because the tail might have been\n\t * split into multiple items, and we only want to decrement for\n\t * the unfm node once\n\t */\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {\n\t\tif ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n\n\tif (un_bh) {\n\t\tint off;\n\t\tchar *data;\n\n\t\t/*\n\t\t * We are in direct2indirect conversion, so move tail contents\n\t\t * to the unformatted node\n\t\t */\n\t\t/*\n\t\t * note, we do the copy before preparing the buffer because we\n\t\t * don't care about the contents of the unformatted node yet.\n\t\t * the only thing we really care about is the direct item's\n\t\t * data is in the unformatted node.\n\t\t *\n\t\t * Otherwise, we would have to call\n\t\t * reiserfs_prepare_for_journal on the unformatted node,\n\t\t * which might schedule, meaning we'd have to loop all the\n\t\t * way back up to the start of the while loop.\n\t\t *\n\t\t * The unformatted node must be dirtied later on.  We can't be\n\t\t * sure here if the entire tail has been deleted yet.\n\t\t *\n\t\t * un_bh is from the page cache (all unformatted nodes are\n\t\t * from the page cache) and might be a highmem page.  So, we\n\t\t * can't use un_bh->b_data.\n\t\t * -clm\n\t\t */\n\n\t\tdata = kmap_atomic(un_bh->b_page);\n\t\toff = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));\n\t\tmemcpy(data + off,\n\t\t       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),\n\t\t       ret_value);\n\t\tkunmap_atomic(data);\n\t}\n\n\t/* Perform balancing after all resources have been collected at once. */\n\tdo_balance(&s_del_balance, NULL, NULL, M_DELETE);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota delete_item(): freeing %u, id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, head2type(&s_ih));\n#endif\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t/* Return deleted body length */\n\treturn ret_value;\n}\n\n/*\n * Summary Of Mechanisms For Handling Collisions Between Processes:\n *\n *  deletion of the body of the object is performed by iput(), with the\n *  result that if multiple processes are operating on a file, the\n *  deletion of the body of the file is deferred until the last process\n *  that has an open inode performs its iput().\n *\n *  writes and truncates are protected from collisions by use of\n *  semaphores.\n *\n *  creates, linking, and mknod are protected from collisions with other\n *  processes by making the reiserfs_add_entry() the last step in the\n *  creation, and then rolling back all changes if there was a collision.\n *  - Hans\n*/\n\n/* this deletes item which never gets split */\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct tree_balance tb;\n\tINITIALIZE_PATH(path);\n\tint item_len = 0;\n\tint tb_init = 0;\n\tstruct cpu_key cpu_key;\n\tint retval;\n\tint quota_cut_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tle_key2cpu_key(&cpu_key, key);\n\n\twhile (1) {\n\t\tretval = search_item(th->t_super, &cpu_key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(th->t_super, \"vs-5350\",\n\t\t\t\t       \"i/o failure occurred trying \"\n\t\t\t\t       \"to delete %K\", &cpu_key);\n\t\t\tbreak;\n\t\t}\n\t\tif (retval != ITEM_FOUND) {\n\t\t\tpathrelse(&path);\n\t\t\t/*\n\t\t\t * No need for a warning, if there is just no free\n\t\t\t * space to insert '..' item into the\n\t\t\t * newly-created subdir\n\t\t\t */\n\t\t\tif (!\n\t\t\t    ((unsigned long long)\n\t\t\t     GET_HASH_VALUE(le_key_k_offset\n\t\t\t\t\t    (le_key_version(key), key)) == 0\n\t\t\t     && (unsigned long long)\n\t\t\t     GET_GENERATION_NUMBER(le_key_k_offset\n\t\t\t\t\t\t   (le_key_version(key),\n\t\t\t\t\t\t    key)) == 1))\n\t\t\t\treiserfs_warning(th->t_super, \"vs-5355\",\n\t\t\t\t\t\t \"%k not found\", key);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tb_init) {\n\t\t\ttb_init = 1;\n\t\t\titem_len = ih_item_len(tp_item_head(&path));\n\t\t\tinit_tb_struct(th, &tb, th->t_super, &path,\n\t\t\t\t       -(IH_SIZE + item_len));\n\t\t}\n\t\tquota_cut_bytes = ih_item_len(tp_item_head(&path));\n\n\t\tretval = fix_nodes(M_DELETE, &tb, NULL, NULL);\n\t\tif (retval == REPEAT_SEARCH) {\n\t\t\tPROC_INFO_INC(th->t_super, delete_solid_item_restarted);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retval == CARRY_ON) {\n\t\t\tdo_balance(&tb, NULL, NULL, M_DELETE);\n\t\t\t/*\n\t\t\t * Should we count quota for item? (we don't\n\t\t\t * count quotas for save-links)\n\t\t\t */\n\t\t\tif (inode) {\n\t\t\t\tint depth;\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota delete_solid_item(): freeing %u id=%u type=%c\",\n\t\t\t\t\t       quota_cut_bytes, inode->i_uid,\n\t\t\t\t\t       key2type(key));\n#endif\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t\t\t quota_cut_bytes);\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IO_ERROR, NO_DISK_SPACE, etc */\n\t\treiserfs_warning(th->t_super, \"vs-5360\",\n\t\t\t\t \"could not delete %K due to fix_nodes failure\",\n\t\t\t\t &cpu_key);\n\t\tunfix_nodes(&tb);\n\t\tbreak;\n\t}\n\n\treiserfs_check_path(&path);\n}\n\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode)\n{\n\tint err;\n\tinode->i_size = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\t/* for directory this deletes item containing \".\" and \"..\" */\n\terr =\n\t    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );\n\tif (err)\n\t\treturn err;\n\n#if defined( USE_INODE_GENERATION_COUNTER )\n\tif (!old_format_only(th->t_super)) {\n\t\t__le32 *inode_generation;\n\n\t\tinode_generation =\n\t\t    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;\n\t\tle32_add_cpu(inode_generation, 1);\n\t}\n/* USE_INODE_GENERATION_COUNTER */\n#endif\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\n\treturn err;\n}\n\nstatic void unmap_buffers(struct page *page, loff_t pos)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct buffer_head *next;\n\tunsigned long tail_index;\n\tunsigned long cur_index;\n\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\ttail_index = pos & (PAGE_CACHE_SIZE - 1);\n\t\t\tcur_index = 0;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tnext = bh->b_this_page;\n\n\t\t\t\t/*\n\t\t\t\t * we want to unmap the buffers that contain\n\t\t\t\t * the tail, and all the buffers after it\n\t\t\t\t * (since the tail must be at the end of the\n\t\t\t\t * file).  We don't want to unmap file data\n\t\t\t\t * before the tail, since it might be dirty\n\t\t\t\t * and waiting to reach disk\n\t\t\t\t */\n\t\t\t\tcur_index += bh->b_size;\n\t\t\t\tif (cur_index > tail_index) {\n\t\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t\t}\n\t\t\t\tbh = next;\n\t\t\t} while (bh != head);\n\t\t}\n\t}\n}\n\nstatic int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    struct treepath *path,\n\t\t\t\t    const struct cpu_key *item_key,\n\t\t\t\t    loff_t new_file_size, char *mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint block_size = sb->s_blocksize;\n\tint cut_bytes;\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(new_file_size != inode->i_size);\n\n\t/*\n\t * the page being sent in could be NULL if there was an i/o error\n\t * reading in the last block.  The user will hit problems trying to\n\t * read the file, but for now we just skip the indirect2direct\n\t */\n\tif (atomic_read(&inode->i_count) > 1 ||\n\t    !tail_has_to_be_packed(inode) ||\n\t    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\t/* leave tail in an unformatted node */\n\t\t*mode = M_SKIP_BALANCING;\n\t\tcut_bytes =\n\t\t    block_size - (new_file_size & (block_size - 1));\n\t\tpathrelse(path);\n\t\treturn cut_bytes;\n\t}\n\n\t/* Perform the conversion to a direct_item. */\n\treturn indirect2direct(th, inode, page, path, item_key,\n\t\t\t       new_file_size, mode);\n}\n\n/*\n * we did indirect_to_direct conversion. And we have inserted direct\n * item successesfully, but there were no disk space to cut unfm\n * pointer being converted. Therefore we have to delete inserted\n * direct item(s)\n */\nstatic void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, struct treepath *path)\n{\n\tstruct cpu_key tail_key;\n\tint tail_len;\n\tint removed;\n\tBUG_ON(!th->t_trans_id);\n\n\tmake_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);\n\ttail_key.key_length = 4;\n\n\ttail_len =\n\t    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;\n\twhile (tail_len) {\n\t\t/* look for the last byte of the tail */\n\t\tif (search_for_position_by_key(inode->i_sb, &tail_key, path) ==\n\t\t    POSITION_NOT_FOUND)\n\t\t\treiserfs_panic(inode->i_sb, \"vs-5615\",\n\t\t\t\t       \"found invalid item\");\n\t\tRFALSE(path->pos_in_item !=\n\t\t       ih_item_len(tp_item_head(path)) - 1,\n\t\t       \"vs-5616: appended bytes found\");\n\t\tPATH_LAST_POSITION(path)--;\n\n\t\tremoved =\n\t\t    reiserfs_delete_item(th, path, &tail_key, inode,\n\t\t\t\t\t NULL /*unbh not needed */ );\n\t\tRFALSE(removed <= 0\n\t\t       || removed > tail_len,\n\t\t       \"vs-5617: there was tail %d bytes, removed item length %d bytes\",\n\t\t       tail_len, removed);\n\t\ttail_len -= removed;\n\t\tset_cpu_key_k_offset(&tail_key,\n\t\t\t\t     cpu_key_k_offset(&tail_key) - removed);\n\t}\n\treiserfs_warning(inode->i_sb, \"reiserfs-5091\", \"indirect_to_direct \"\n\t\t\t \"conversion has been rolled back due to \"\n\t\t\t \"lack of disk space\");\n\tmark_inode_dirty(inode);\n}\n\n/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */\nint reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,\n\t\t\t   struct treepath *path,\n\t\t\t   struct cpu_key *item_key,\n\t\t\t   struct inode *inode,\n\t\t\t   struct page *page, loff_t new_file_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\t/*\n\t * Every function which is going to call do_balance must first\n\t * create a tree_balance structure.  Then it must fill up this\n\t * structure by using the init_tb_struct and fix_nodes functions.\n\t * After that we can make tree balancing.\n\t */\n\tstruct tree_balance s_cut_balance;\n\tstruct item_head *p_le_ih;\n\tint cut_size = 0;\t/* Amount to be cut. */\n\tint ret_value = CARRY_ON;\n\tint removed = 0;\t/* Number of the removed unformatted nodes. */\n\tint is_inode_locked = 0;\n\tchar mode;\t\t/* Mode of the balance. */\n\tint retval2 = -1;\n\tint quota_cut_bytes;\n\tloff_t tail_pos = 0;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tinit_tb_struct(th, &s_cut_balance, inode->i_sb, path,\n\t\t       cut_size);\n\n\t/*\n\t * Repeat this loop until we either cut the item without needing\n\t * to balance, or we fix_nodes without schedule occurring\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Determine the balance mode, position of the first byte to\n\t\t * be cut, and size to be cut.  In case of the indirect item\n\t\t * free unformatted nodes which are pointed to by the cut\n\t\t * pointers.\n\t\t */\n\n\t\tmode =\n\t\t    prepare_for_delete_or_cut(th, inode, path,\n\t\t\t\t\t      item_key, &removed,\n\t\t\t\t\t      &cut_size, new_file_size);\n\t\tif (mode == M_CONVERT) {\n\t\t\t/*\n\t\t\t * convert last unformatted node to direct item or\n\t\t\t * leave tail in the unformatted node\n\t\t\t */\n\t\t\tRFALSE(ret_value != CARRY_ON,\n\t\t\t       \"PAP-5570: can not convert twice\");\n\n\t\t\tret_value =\n\t\t\t    maybe_indirect_to_direct(th, inode, page,\n\t\t\t\t\t\t     path, item_key,\n\t\t\t\t\t\t     new_file_size, &mode);\n\t\t\tif (mode == M_SKIP_BALANCING)\n\t\t\t\t/* tail has been left in the unformatted node */\n\t\t\t\treturn ret_value;\n\n\t\t\tis_inode_locked = 1;\n\n\t\t\t/*\n\t\t\t * removing of last unformatted node will\n\t\t\t * change value we have to return to truncate.\n\t\t\t * Save it\n\t\t\t */\n\t\t\tretval2 = ret_value;\n\n\t\t\t/*\n\t\t\t * So, we have performed the first part of the\n\t\t\t * conversion:\n\t\t\t * inserting the new direct item.  Now we are\n\t\t\t * removing the last unformatted node pointer.\n\t\t\t * Set key to search for it.\n\t\t\t */\n\t\t\tset_cpu_key_k_type(item_key, TYPE_INDIRECT);\n\t\t\titem_key->key_length = 4;\n\t\t\tnew_file_size -=\n\t\t\t    (new_file_size & (sb->s_blocksize - 1));\n\t\t\ttail_pos = new_file_size;\n\t\t\tset_cpu_key_k_offset(item_key, new_file_size + 1);\n\t\t\tif (search_for_position_by_key\n\t\t\t    (sb, item_key,\n\t\t\t     path) == POSITION_NOT_FOUND) {\n\t\t\t\tprint_block(PATH_PLAST_BUFFER(path), 3,\n\t\t\t\t\t    PATH_LAST_POSITION(path) - 1,\n\t\t\t\t\t    PATH_LAST_POSITION(path) + 1);\n\t\t\t\treiserfs_panic(sb, \"PAP-5580\", \"item to \"\n\t\t\t\t\t       \"convert does not exist (%K)\",\n\t\t\t\t\t       item_key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (cut_size == 0) {\n\t\t\tpathrelse(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\ts_cut_balance.insert_size[0] = cut_size;\n\n\t\tret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);\n\t\tif (ret_value != REPEAT_SEARCH)\n\t\t\tbreak;\n\n\t\tPROC_INFO_INC(sb, cut_from_item_restarted);\n\n\t\tret_value =\n\t\t    search_for_position_by_key(sb, item_key, path);\n\t\tif (ret_value == POSITION_FOUND)\n\t\t\tcontinue;\n\n\t\treiserfs_warning(sb, \"PAP-5610\", \"item %K not found\",\n\t\t\t\t item_key);\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn (ret_value == IO_ERROR) ? -EIO : -ENOENT;\n\t}\t\t\t/* while */\n\n\t/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */\n\tif (ret_value != CARRY_ON) {\n\t\tif (is_inode_locked) {\n\t\t\t/*\n\t\t\t * FIXME: this seems to be not needed: we are always\n\t\t\t * able to cut item\n\t\t\t */\n\t\t\tindirect_to_direct_roll_back(th, inode, path);\n\t\t}\n\t\tif (ret_value == NO_DISK_SPACE)\n\t\t\treiserfs_warning(sb, \"reiserfs-5092\",\n\t\t\t\t\t \"NO_DISK_SPACE\");\n\t\tunfix_nodes(&s_cut_balance);\n\t\treturn -EIO;\n\t}\n\n\t/* go ahead and perform balancing */\n\n\tRFALSE(mode == M_PASTE || mode == M_INSERT, \"invalid mode\");\n\n\t/* Calculate number of bytes that need to be cut from the item. */\n\tquota_cut_bytes =\n\t    (mode ==\n\t     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.\n\t    insert_size[0];\n\tif (retval2 == -1)\n\t\tret_value = calc_deleted_bytes_number(&s_cut_balance, mode);\n\telse\n\t\tret_value = retval2;\n\n\t/*\n\t * For direct items, we only change the quota when deleting the last\n\t * item.\n\t */\n\tp_le_ih = tp_item_head(s_cut_balance.tb_path);\n\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {\n\t\tif (mode == M_DELETE &&\n\t\t    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==\n\t\t    1) {\n\t\t\t/* FIXME: this is to keep 3.5 happy */\n\t\t\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\t\t\tquota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;\n\t\t} else {\n\t\t\tquota_cut_bytes = 0;\n\t\t}\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (is_inode_locked) {\n\t\tstruct item_head *le_ih =\n\t\t    tp_item_head(s_cut_balance.tb_path);\n\t\t/*\n\t\t * we are going to complete indirect2direct conversion. Make\n\t\t * sure, that we exactly remove last unformatted node pointer\n\t\t * of the item\n\t\t */\n\t\tif (!is_indirect_le_ih(le_ih))\n\t\t\treiserfs_panic(sb, \"vs-5652\",\n\t\t\t\t       \"item must be indirect %h\", le_ih);\n\n\t\tif (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)\n\t\t\treiserfs_panic(sb, \"vs-5653\", \"completing \"\n\t\t\t\t       \"indirect2direct conversion indirect \"\n\t\t\t\t       \"item %h being deleted must be of \"\n\t\t\t\t       \"4 byte long\", le_ih);\n\n\t\tif (mode == M_CUT\n\t\t    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {\n\t\t\treiserfs_panic(sb, \"vs-5654\", \"can not complete \"\n\t\t\t\t       \"indirect2direct conversion of %h \"\n\t\t\t\t       \"(CUT, insert_size==%d)\",\n\t\t\t\t       le_ih, s_cut_balance.insert_size[0]);\n\t\t}\n\t\t/*\n\t\t * it would be useful to make sure, that right neighboring\n\t\t * item is direct item of this file\n\t\t */\n\t}\n#endif\n\n\tdo_balance(&s_cut_balance, NULL, NULL, mode);\n\tif (is_inode_locked) {\n\t\t/*\n\t\t * we've done an indirect->direct conversion.  when the\n\t\t * data block was freed, it was removed from the list of\n\t\t * blocks that must be flushed before the transaction\n\t\t * commits, make sure to unmap and invalidate it\n\t\t */\n\t\tunmap_buffers(page, tail_pos);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\t}\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota cut_from_item(): freeing %u id=%u type=%c\",\n\t\t       quota_cut_bytes, inode->i_uid, '?');\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, quota_cut_bytes);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn ret_value;\n}\n\nstatic void truncate_directory(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tBUG_ON(!th->t_trans_id);\n\tif (inode->i_nlink)\n\t\treiserfs_error(inode->i_sb, \"vs-5655\", \"link count != 0\");\n\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);\n\treiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));\n\treiserfs_update_sd(th, inode);\n\tset_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);\n\tset_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);\n}\n\n/*\n * Truncate file to the new size. Note, this must be called with a\n * transaction already started\n */\nint reiserfs_do_truncate(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode,\t/* ->i_size contains new size */\n\t\t\t struct page *page,\t/* up to date for last block */\n\t\t\t /*\n\t\t\t  * when it is called by file_release to convert\n\t\t\t  * the tail - no timestamps should be updated\n\t\t\t  */\n\t\t\t int update_timestamps\n    )\n{\n\tINITIALIZE_PATH(s_search_path);\t/* Path to the current object item. */\n\tstruct item_head *p_le_ih;\t/* Pointer to an item header. */\n\n\t/* Key to search for a previous file item. */\n\tstruct cpu_key s_item_key;\n\tloff_t file_size,\t/* Old file size. */\n\t new_file_size;\t/* New file size. */\n\tint deleted;\t\t/* Number of deleted or truncated bytes. */\n\tint retval;\n\tint err = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\tif (!\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t     || S_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\t/* deletion of directory - no need to update timestamps */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\ttruncate_directory(th, inode);\n\t\treturn 0;\n\t}\n\n\t/* Get new file size. */\n\tnew_file_size = inode->i_size;\n\n\t/* FIXME: note, that key type is unimportant here */\n\tmake_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),\n\t\t     TYPE_DIRECT, 3);\n\n\tretval =\n\t    search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t       &s_search_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-5657\",\n\t\t\t       \"i/o failure occurred trying to truncate %K\",\n\t\t\t       &s_item_key);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tif (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {\n\t\treiserfs_error(inode->i_sb, \"PAP-5660\",\n\t\t\t       \"wrong result %d of search for %K\", retval,\n\t\t\t       &s_item_key);\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ts_search_path.pos_in_item--;\n\n\t/* Get real file size (total length of all file items) */\n\tp_le_ih = tp_item_head(&s_search_path);\n\tif (is_statdata_le_ih(p_le_ih))\n\t\tfile_size = 0;\n\telse {\n\t\tloff_t offset = le_ih_k_offset(p_le_ih);\n\t\tint bytes =\n\t\t    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);\n\n\t\t/*\n\t\t * this may mismatch with real file size: if last direct item\n\t\t * had no padding zeros and last unformatted node had no free\n\t\t * space, this file would have this file size\n\t\t */\n\t\tfile_size = offset + bytes - 1;\n\t}\n\t/*\n\t * are we doing a full truncate or delete, if so\n\t * kick in the reada code\n\t */\n\tif (new_file_size == 0)\n\t\ts_search_path.reada = PATH_READA | PATH_READA_BACK;\n\n\tif (file_size == 0 || file_size < new_file_size) {\n\t\tgoto update_and_out;\n\t}\n\n\t/* Update key to search for the last file item. */\n\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\tdo {\n\t\t/* Cut or delete file item. */\n\t\tdeleted =\n\t\t    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,\n\t\t\t\t\t   inode, page, new_file_size);\n\t\tif (deleted < 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-5665\",\n\t\t\t\t\t \"reiserfs_cut_from_item failed\");\n\t\t\treiserfs_check_path(&s_search_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tRFALSE(deleted > file_size,\n\t\t       \"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K\",\n\t\t       deleted, file_size, &s_item_key);\n\n\t\t/* Change key to search the last file item. */\n\t\tfile_size -= deleted;\n\n\t\tset_cpu_key_k_offset(&s_item_key, file_size);\n\n\t\t/*\n\t\t * While there are bytes to truncate and previous\n\t\t * file item is presented in the tree.\n\t\t */\n\n\t\t/*\n\t\t * This loop could take a really long time, and could log\n\t\t * many more blocks than a transaction can hold.  So, we do\n\t\t * a polite journal end here, and if the transaction needs\n\t\t * ending, we make sure the file is consistent before ending\n\t\t * the current trans and starting a new one\n\t\t */\n\t\tif (journal_transaction_should_end(th, 0) ||\n\t\t    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {\n\t\t\tpathrelse(&s_search_path);\n\n\t\t\tif (update_timestamps) {\n\t\t\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t}\n\t\t\treiserfs_update_sd(th, inode);\n\n\t\t\terr = journal_end(th);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = journal_begin(th, inode->i_sb,\n\t\t\t\t\t    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t}\n\t} while (file_size > ROUND_UP(new_file_size) &&\n\t\t search_for_position_by_key(inode->i_sb, &s_item_key,\n\t\t\t\t\t    &s_search_path) == POSITION_FOUND);\n\n\tRFALSE(file_size > ROUND_UP(new_file_size),\n\t       \"PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d\",\n\t       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);\n\nupdate_and_out:\n\tif (update_timestamps) {\n\t\t/* this is truncate, not file closing */\n\t\tinode->i_mtime = CURRENT_TIME_SEC;\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t}\n\treiserfs_update_sd(th, inode);\n\nout:\n\tpathrelse(&s_search_path);\n\treturn err;\n}\n\n#ifdef CONFIG_REISERFS_CHECK\n/* this makes sure, that we __append__, not overwrite or add holes */\nstatic void check_research_for_paste(struct treepath *path,\n\t\t\t\t     const struct cpu_key *key)\n{\n\tstruct item_head *found_ih = tp_item_head(path);\n\n\tif (is_direct_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || op_bytes_number(found_ih,\n\t\t\t\t       get_last_bh(path)->b_size) !=\n\t\t    pos_in_item(path))\n\t\t\treiserfs_panic(NULL, \"PAP-5720\", \"found direct item \"\n\t\t\t\t       \"%h or position (%d) does not match \"\n\t\t\t\t       \"to key %K\", found_ih,\n\t\t\t\t       pos_in_item(path), key);\n\t}\n\tif (is_indirect_le_ih(found_ih)) {\n\t\tif (le_ih_k_offset(found_ih) +\n\t\t    op_bytes_number(found_ih,\n\t\t\t\t    get_last_bh(path)->b_size) !=\n\t\t    cpu_key_k_offset(key)\n\t\t    || I_UNFM_NUM(found_ih) != pos_in_item(path)\n\t\t    || get_ih_free_space(found_ih) != 0)\n\t\t\treiserfs_panic(NULL, \"PAP-5730\", \"found indirect \"\n\t\t\t\t       \"item (%h) or position (%d) does not \"\n\t\t\t\t       \"match to key (%K)\",\n\t\t\t\t       found_ih, pos_in_item(path), key);\n\t}\n}\n#endif\t\t\t\t/* config reiserfs check */\n\n/*\n * Paste bytes to the existing item.\n * Returns bytes number pasted into the item.\n */\nint reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,\n\t\t\t     /* Path to the pasted item. */\n\t\t\t     struct treepath *search_path,\n\t\t\t     /* Key to search for the needed item. */\n\t\t\t     const struct cpu_key *key,\n\t\t\t     /* Inode item belongs to */\n\t\t\t     struct inode *inode,\n\t\t\t     /* Pointer to the bytes to paste. */\n\t\t\t     const char *body,\n\t\t\t     /* Size of pasted bytes. */\n\t\t\t     int pasted_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct tree_balance s_paste_balance;\n\tint retval;\n\tint fs_gen;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tfs_gen = get_generation(inode->i_sb);\n\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): allocating %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tretval = dquot_alloc_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (retval) {\n\t\tpathrelse(search_path);\n\t\treturn retval;\n\t}\n\tinit_tb_struct(th, &s_paste_balance, th->t_super, search_path,\n\t\t       pasted_size);\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_paste_balance.key = key->on_disk_key;\n#endif\n\n\t/* DQUOT_* can schedule, must check before the fix_nodes */\n\tif (fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_PASTE, &s_paste_balance, NULL,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, paste_into_item_restarted);\n\t\tretval =\n\t\t    search_for_position_by_key(th->t_super, key,\n\t\t\t\t\t       search_path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"PAP-5710\",\n\t\t\t\t\t \"entry or pasted byte (%K) exists\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t\tcheck_research_for_paste(search_path, key);\n#endif\n\t}\n\n\t/*\n\t * Perform balancing after all resources are collected by fix_nodes,\n\t * and accessing them will not risk triggering schedule.\n\t */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);\n\t\treturn 0;\n\t}\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* this also releases the path */\n\tunfix_nodes(&s_paste_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota paste_into_item(): freeing %u id=%u type=%c\",\n\t\t       pasted_size, inode->i_uid,\n\t\t       key2type(&key->on_disk_key));\n#endif\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tdquot_free_space_nodirty(inode, pasted_size);\n\treiserfs_write_lock_nested(sb, depth);\n\treturn retval;\n}\n\n/*\n * Insert new item into the buffer at the path.\n * th   - active transaction handle\n * path - path to the inserted item\n * ih   - pointer to the item header to insert\n * body - pointer to the bytes to insert\n */\nint reiserfs_insert_item(struct reiserfs_transaction_handle *th,\n\t\t\t struct treepath *path, const struct cpu_key *key,\n\t\t\t struct item_head *ih, struct inode *inode,\n\t\t\t const char *body)\n{\n\tstruct tree_balance s_ins_balance;\n\tint retval;\n\tint fs_gen = 0;\n\tint quota_bytes = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (inode) {\t\t/* Do we count quotas for item? */\n\t\tint depth;\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tquota_bytes = ih_item_len(ih);\n\n\t\t/*\n\t\t * hack so the quota code doesn't have to guess\n\t\t * if the file has a tail, links are always tails,\n\t\t * so there's no guessing needed\n\t\t */\n\t\tif (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))\n\t\t\tquota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota insert_item(): allocating %u id=%u type=%c\",\n\t\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\t\t/*\n\t\t * We can't dirty inode here. It would be immediately\n\t\t * written but appropriate stat item isn't inserted yet...\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tretval = dquot_alloc_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\tif (retval) {\n\t\t\tpathrelse(path);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tinit_tb_struct(th, &s_ins_balance, th->t_super, path,\n\t\t       IH_SIZE + ih_item_len(ih));\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\ts_ins_balance.key = key->on_disk_key;\n#endif\n\t/*\n\t * DQUOT_* can schedule, must check to be sure calling\n\t * fix_nodes is safe\n\t */\n\tif (inode && fs_changed(fs_gen, inode->i_sb)) {\n\t\tgoto search_again;\n\t}\n\n\twhile ((retval =\n\t\tfix_nodes(M_INSERT, &s_ins_balance, ih,\n\t\t\t  body)) == REPEAT_SEARCH) {\nsearch_again:\n\t\t/* file system changed while we were in the fix_nodes */\n\t\tPROC_INFO_INC(th->t_super, insert_item_restarted);\n\t\tretval = search_item(th->t_super, key, path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tif (retval == ITEM_FOUND) {\n\t\t\treiserfs_warning(th->t_super, \"PAP-5760\",\n\t\t\t\t\t \"key %K already exists in the tree\",\n\t\t\t\t\t key);\n\t\t\tretval = -EEXIST;\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/* make balancing after all resources will be collected at a time */\n\tif (retval == CARRY_ON) {\n\t\tdo_balance(&s_ins_balance, ih, body, M_INSERT);\n\t\treturn 0;\n\t}\n\n\tretval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;\nerror_out:\n\t/* also releases the path */\n\tunfix_nodes(&s_ins_balance);\n#ifdef REISERQUOTA_DEBUG\n\treiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,\n\t\t       \"reiserquota insert_item(): freeing %u id=%u type=%c\",\n\t\t       quota_bytes, inode->i_uid, head2type(ih));\n#endif\n\tif (inode) {\n\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_free_space_nodirty(inode, quota_bytes);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "unbh->b_page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "unbh"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "p_le_ih"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "p_le_ih"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!is_direct_le_ih(p_le_ih)",
            "\"vs-14055: direct item expected(%K), found %h\"",
            "&end_key",
            "p_le_ih"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"PAP-14050\"",
            "\"direct item (%K) not found\"",
            "&end_key"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "sb",
            "&end_key",
            "path"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&end_key",
            "inode",
            "max_reiserfs_offset(inode)",
            "TYPE_DIRECT",
            "4"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_reiserfs_offset",
          "args": [
            "inode"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "max_reiserfs_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2280-2286",
          "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_paste_into_item",
          "args": [
            "th",
            "path",
            "&end_key",
            "inode",
            "(char *)&unfm_ptr",
            "UNFM_P_SIZE"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "path",
            "&end_key",
            "&ind_ih",
            "inode",
            "(char *)&unfm_ptr"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "&ind_ih",
            "UNFM_P_SIZE"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "&ind_ih",
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "p_le_ih"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "unbh->b_blocknr"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"PAP-14030\"",
            "\"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\"",
            "&end_key"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_type",
          "args": [
            "&ind_ih",
            "TYPE_INDIRECT"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1536-1539",
          "snippet": "static inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "&ind_ih",
            "tail_offset"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&ind_ih",
            "p_le_ih"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t    struct treepath *path, struct buffer_head *unbh,\n\t\t    loff_t tail_offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *up_to_date_bh;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tunsigned long total_tail = 0;\n\n\t/* Key to search for the last byte of the converted item. */\n\tstruct cpu_key end_key;\n\n\t/*\n\t * new indirect item to be inserted or key\n\t * of unfm pointer to be pasted\n\t */\n\tstruct item_head ind_ih;\n\tint blk_size;\n\t/* returned value for reiserfs_insert_item and clones */\n\tint  retval;\n\t/* Handle on an unformatted node that will be inserted in the tree. */\n\tunp_t unfm_ptr;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_direct2indirect++;\n\n\tblk_size = sb->s_blocksize;\n\n\t/*\n\t * and key to search for append or insert pointer to the new\n\t * unformatted node.\n\t */\n\tcopy_item_head(&ind_ih, p_le_ih);\n\tset_le_ih_k_offset(&ind_ih, tail_offset);\n\tset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\n\n\t/* Set the key to search for the place for new unfm pointer */\n\tmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\n\n\t/* FIXME: we could avoid this */\n\tif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\n\t\treiserfs_error(sb, \"PAP-14030\",\n\t\t\t       \"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\", &end_key);\n\t\tpathrelse(path);\n\t\treturn -EIO;\n\t}\n\n\tp_le_ih = tp_item_head(path);\n\n\tunfm_ptr = cpu_to_le32(unbh->b_blocknr);\n\n\tif (is_statdata_le_ih(p_le_ih)) {\n\t\t/* Insert new indirect item. */\n\t\tset_ih_free_space(&ind_ih, 0);\t/* delete at nearest future */\n\t\tput_ih_item_len(&ind_ih, UNFM_P_SIZE);\n\t\tPATH_LAST_POSITION(path)++;\n\t\tretval =\n\t\t    reiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\n\t\t\t\t\t (char *)&unfm_ptr);\n\t} else {\n\t\t/* Paste into last indirect item of an object. */\n\t\tretval = reiserfs_paste_into_item(th, path, &end_key, inode,\n\t\t\t\t\t\t    (char *)&unfm_ptr,\n\t\t\t\t\t\t    UNFM_P_SIZE);\n\t}\n\tif (retval) {\n\t\treturn retval;\n\t}\n\t/*\n\t * note: from here there are two keys which have matching first\n\t *  three key components. They only differ by the fourth one.\n\t */\n\n\t/* Set the key to search for the direct items of the file */\n\tmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\n\t\t     4);\n\n\t/*\n\t * Move bytes from the direct items to the new unformatted node\n\t * and delete them.\n\t */\n\twhile (1) {\n\t\tint tail_size;\n\n\t\t/*\n\t\t * end_key.k_offset is set so, that we will always have found\n\t\t * last item of the file\n\t\t */\n\t\tif (search_for_position_by_key(sb, &end_key, path) ==\n\t\t    POSITION_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-14050\",\n\t\t\t\t       \"direct item (%K) not found\", &end_key);\n\t\tp_le_ih = tp_item_head(path);\n\t\tRFALSE(!is_direct_le_ih(p_le_ih),\n\t\t       \"vs-14055: direct item expected(%K), found %h\",\n\t\t       &end_key, p_le_ih);\n\t\ttail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\n\t\t    + ih_item_len(p_le_ih) - 1;\n\n\t\t/*\n\t\t * we only send the unbh pointer if the buffer is not\n\t\t * up to date.  this avoids overwriting good data from\n\t\t * writepage() with old data from the disk or buffer cache\n\t\t * Special case: unbh->b_page will be NULL if we are coming\n\t\t * through DIRECT_IO handler here.\n\t\t */\n\t\tif (!unbh->b_page || buffer_uptodate(unbh)\n\t\t    || PageUptodate(unbh->b_page)) {\n\t\t\tup_to_date_bh = NULL;\n\t\t} else {\n\t\t\tup_to_date_bh = unbh;\n\t\t}\n\t\tretval = reiserfs_delete_item(th, path, &end_key, inode,\n\t\t\t\t\t\tup_to_date_bh);\n\n\t\ttotal_tail += retval;\n\n\t\t/* done: file does not have direct items anymore */\n\t\tif (tail_size == retval)\n\t\t\tbreak;\n\n\t}\n\t/*\n\t * if we've copied bytes from disk into the page, we need to zero\n\t * out the unused part of the block (it was not up to date before)\n\t */\n\tif (up_to_date_bh) {\n\t\tunsigned pgoff =\n\t\t    (tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tchar *kaddr = kmap_atomic(up_to_date_bh->b_page);\n\t\tmemset(kaddr + pgoff, 0, blk_size - total_tail);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\n\treturn 0;\n}"
  }
]