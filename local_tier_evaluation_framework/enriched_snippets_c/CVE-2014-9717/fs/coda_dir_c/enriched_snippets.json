[
  {
    "function_name": "coda_revalidate_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "508-550",
    "snippet": "int coda_revalidate_inode(struct inode *inode)\n{\n\tstruct coda_vattr attr;\n\tint error;\n\tint old_mode;\n\tino_t old_ino;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tif (!cii->c_flags)\n\t\treturn 0;\n\n\tif (cii->c_flags & (C_VATTR | C_PURGE | C_FLUSH)) {\n\t\terror = venus_getattr(inode->i_sb, &(cii->c_fid), &attr);\n\t\tif (error)\n\t\t\treturn -EIO;\n\n\t\t/* this inode may be lost if:\n\t\t   - it's ino changed \n\t\t   - type changes must be permitted for repair and\n\t\t   missing mount points.\n\t\t*/\n\t\told_mode = inode->i_mode;\n\t\told_ino = inode->i_ino;\n\t\tcoda_vattr_to_iattr(inode, &attr);\n\n\t\tif ((old_mode & S_IFMT) != (inode->i_mode & S_IFMT)) {\n\t\t\tpr_warn(\"inode %ld, fid %s changed type!\\n\",\n\t\t\t\tinode->i_ino, coda_f2s(&(cii->c_fid)));\n\t\t}\n\n\t\t/* the following can happen when a local fid is replaced \n\t\t   with a global one, here we lose and declare the inode bad */\n\t\tif (inode->i_ino != old_ino)\n\t\t\treturn -EIO;\n\t\t\n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\t\tspin_lock(&cii->c_lock);\n\t\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\t\tspin_unlock(&cii->c_lock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_flag_inode_children",
          "args": [
            "inode",
            "C_FLUSH"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"inode %ld, fid %s changed type!\\n\"",
            "inode->i_ino",
            "coda_f2s(&(cii->c_fid))"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_f2s",
          "args": [
            "&(cii->c_fid)"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "coda_f2s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "27-34",
          "snippet": "char * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nchar * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vattr_to_iattr",
          "args": [
            "inode",
            "&attr"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "coda_vattr_to_iattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "70-112",
          "snippet": "void coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_getattr",
          "args": [
            "inode->i_sb",
            "&(cii->c_fid)",
            "&attr"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "venus_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "91-108",
          "snippet": "int venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_revalidate_inode(struct inode *inode)\n{\n\tstruct coda_vattr attr;\n\tint error;\n\tint old_mode;\n\tino_t old_ino;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tif (!cii->c_flags)\n\t\treturn 0;\n\n\tif (cii->c_flags & (C_VATTR | C_PURGE | C_FLUSH)) {\n\t\terror = venus_getattr(inode->i_sb, &(cii->c_fid), &attr);\n\t\tif (error)\n\t\t\treturn -EIO;\n\n\t\t/* this inode may be lost if:\n\t\t   - it's ino changed \n\t\t   - type changes must be permitted for repair and\n\t\t   missing mount points.\n\t\t*/\n\t\told_mode = inode->i_mode;\n\t\told_ino = inode->i_ino;\n\t\tcoda_vattr_to_iattr(inode, &attr);\n\n\t\tif ((old_mode & S_IFMT) != (inode->i_mode & S_IFMT)) {\n\t\t\tpr_warn(\"inode %ld, fid %s changed type!\\n\",\n\t\t\t\tinode->i_ino, coda_f2s(&(cii->c_fid)));\n\t\t}\n\n\t\t/* the following can happen when a local fid is replaced \n\t\t   with a global one, here we lose and declare the inode bad */\n\t\tif (inode->i_ino != old_ino)\n\t\t\treturn -EIO;\n\t\t\n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\t\tspin_lock(&cii->c_lock);\n\t\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\t\tspin_unlock(&cii->c_lock);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_dentry_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "486-498",
    "snippet": "static int coda_dentry_delete(const struct dentry * dentry)\n{\n\tint flags;\n\n\tif (!dentry->d_inode) \n\t\treturn 0;\n\n\tflags = (ITOC(dentry->d_inode)->c_flags) & C_PURGE;\n\tif (is_bad_inode(dentry->d_inode) || flags) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "dentry->d_inode"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "dentry->d_inode"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_dentry_delete(const struct dentry * dentry)\n{\n\tint flags;\n\n\tif (!dentry->d_inode) \n\t\treturn 0;\n\n\tflags = (ITOC(dentry->d_inode)->c_flags) & C_PURGE;\n\tif (is_bad_inode(dentry->d_inode) || flags) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_dentry_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "444-480",
    "snippet": "static int coda_dentry_revalidate(struct dentry *de, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = de->d_inode;\n\tif (!inode || is_root_inode(inode))\n\t\tgoto out;\n\tif (is_bad_inode(inode))\n\t\tgoto bad;\n\n\tcii = ITOC(de->d_inode);\n\tif (!(cii->c_flags & (C_PURGE | C_FLUSH)))\n\t\tgoto out;\n\n\tshrink_dcache_parent(de);\n\n\t/* propagate for a flush */\n\tif (cii->c_flags & C_FLUSH) \n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\tif (d_count(de) > 1)\n\t\t/* pretend it's valid, but don't change the flags */\n\t\tgoto out;\n\n\t/* clear the flags. */\n\tspin_lock(&cii->c_lock);\n\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\tspin_unlock(&cii->c_lock);\nbad:\n\treturn 0;\nout:\n\treturn 1;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "de"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_flag_inode_children",
          "args": [
            "inode",
            "C_FLUSH"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "de"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "de->d_inode"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "inode"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_dentry_revalidate(struct dentry *de, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = de->d_inode;\n\tif (!inode || is_root_inode(inode))\n\t\tgoto out;\n\tif (is_bad_inode(inode))\n\t\tgoto bad;\n\n\tcii = ITOC(de->d_inode);\n\tif (!(cii->c_flags & (C_PURGE | C_FLUSH)))\n\t\tgoto out;\n\n\tshrink_dcache_parent(de);\n\n\t/* propagate for a flush */\n\tif (cii->c_flags & C_FLUSH) \n\t\tcoda_flag_inode_children(inode, C_FLUSH);\n\n\tif (d_count(de) > 1)\n\t\t/* pretend it's valid, but don't change the flags */\n\t\tgoto out;\n\n\t/* clear the flags. */\n\tspin_lock(&cii->c_lock);\n\tcii->c_flags &= ~(C_VATTR | C_PURGE | C_FLUSH);\n\tspin_unlock(&cii->c_lock);\nbad:\n\treturn 0;\nout:\n\treturn 1;\n}"
  },
  {
    "function_name": "coda_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "417-441",
    "snippet": "static int coda_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (host_file->f_op->iterate) {\n\t\tstruct inode *host_inode = file_inode(host_file);\n\n\t\tmutex_lock(&host_inode->i_mutex);\n\t\tret = -ENOENT;\n\t\tif (!IS_DEADDIR(host_inode)) {\n\t\t\tret = host_file->f_op->iterate(host_file, ctx);\n\t\t\tfile_accessed(host_file);\n\t\t}\n\t\tmutex_unlock(&host_inode->i_mutex);\n\t\treturn ret;\n\t}\n\t/* Venus: we must read Venus dirents from a file */\n\treturn coda_venus_readdir(coda_file, ctx);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_venus_readdir",
          "args": [
            "coda_file",
            "ctx"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "coda_venus_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "342-414",
          "snippet": "static int coda_venus_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct venus_dirent *vdir;\n\tunsigned long vdir_size = offsetof(struct venus_dirent, d_name);\n\tunsigned int type;\n\tstruct qstr name;\n\tino_t ino;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tcii = ITOC(file_inode(coda_file));\n\n\tvdir = kmalloc(sizeof(*vdir), GFP_KERNEL);\n\tif (!vdir) return -ENOMEM;\n\n\tif (!dir_emit_dots(coda_file, ctx))\n\t\tgoto out;\n\n\twhile (1) {\n\t\t/* read entries from the directory file */\n\t\tret = kernel_read(host_file, ctx->pos - 2, (char *)vdir,\n\t\t\t\t  sizeof(*vdir));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: read dir %s failed %d\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid), ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) break; /* end of directory file reached */\n\n\t\t/* catch truncated reads */\n\t\tif (ret < vdir_size || ret < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: short read on %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\t/* validate whether the directory file actually makes sense */\n\t\tif (vdir->d_reclen < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: invalid dir %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\tname.len = vdir->d_namlen;\n\t\tname.name = vdir->d_name;\n\n\t\t/* Make sure we skip '.' and '..', we already got those */\n\t\tif (name.name[0] == '.' && (name.len == 1 ||\n\t\t    (name.name[1] == '.' && name.len == 2)))\n\t\t\tvdir->d_fileno = name.len = 0;\n\n\t\t/* skip null entries */\n\t\tif (vdir->d_fileno && name.len) {\n\t\t\tino = vdir->d_fileno;\n\t\t\ttype = CDT2DT(vdir->d_type);\n\t\t\tif (!dir_emit(ctx, name.name, name.len, ino, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* we'll always have progress because d_reclen is unsigned and\n\t\t * we've already established it is non-zero. */\n\t\tctx->pos += vdir->d_reclen;\n\t}\nout:\n\tkfree(vdir);\n\treturn 0;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_venus_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct venus_dirent *vdir;\n\tunsigned long vdir_size = offsetof(struct venus_dirent, d_name);\n\tunsigned int type;\n\tstruct qstr name;\n\tino_t ino;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tcii = ITOC(file_inode(coda_file));\n\n\tvdir = kmalloc(sizeof(*vdir), GFP_KERNEL);\n\tif (!vdir) return -ENOMEM;\n\n\tif (!dir_emit_dots(coda_file, ctx))\n\t\tgoto out;\n\n\twhile (1) {\n\t\t/* read entries from the directory file */\n\t\tret = kernel_read(host_file, ctx->pos - 2, (char *)vdir,\n\t\t\t\t  sizeof(*vdir));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: read dir %s failed %d\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid), ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) break; /* end of directory file reached */\n\n\t\t/* catch truncated reads */\n\t\tif (ret < vdir_size || ret < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: short read on %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\t/* validate whether the directory file actually makes sense */\n\t\tif (vdir->d_reclen < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: invalid dir %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\tname.len = vdir->d_namlen;\n\t\tname.name = vdir->d_name;\n\n\t\t/* Make sure we skip '.' and '..', we already got those */\n\t\tif (name.name[0] == '.' && (name.len == 1 ||\n\t\t    (name.name[1] == '.' && name.len == 2)))\n\t\t\tvdir->d_fileno = name.len = 0;\n\n\t\t/* skip null entries */\n\t\tif (vdir->d_fileno && name.len) {\n\t\t\tino = vdir->d_fileno;\n\t\t\ttype = CDT2DT(vdir->d_type);\n\t\t\tif (!dir_emit(ctx, name.name, name.len, ino, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* we'll always have progress because d_reclen is unsigned and\n\t\t * we've already established it is non-zero. */\n\t\tctx->pos += vdir->d_reclen;\n\t}\nout:\n\tkfree(vdir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&host_inode->i_mutex"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "host_file"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_file->f_op->iterate",
          "args": [
            "host_file",
            "ctx"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "host_inode"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&host_inode->i_mutex"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "host_file"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (host_file->f_op->iterate) {\n\t\tstruct inode *host_inode = file_inode(host_file);\n\n\t\tmutex_lock(&host_inode->i_mutex);\n\t\tret = -ENOENT;\n\t\tif (!IS_DEADDIR(host_inode)) {\n\t\t\tret = host_file->f_op->iterate(host_file, ctx);\n\t\t\tfile_accessed(host_file);\n\t\t}\n\t\tmutex_unlock(&host_inode->i_mutex);\n\t\treturn ret;\n\t}\n\t/* Venus: we must read Venus dirents from a file */\n\treturn coda_venus_readdir(coda_file, ctx);\n}"
  },
  {
    "function_name": "coda_venus_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "342-414",
    "snippet": "static int coda_venus_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct venus_dirent *vdir;\n\tunsigned long vdir_size = offsetof(struct venus_dirent, d_name);\n\tunsigned int type;\n\tstruct qstr name;\n\tino_t ino;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tcii = ITOC(file_inode(coda_file));\n\n\tvdir = kmalloc(sizeof(*vdir), GFP_KERNEL);\n\tif (!vdir) return -ENOMEM;\n\n\tif (!dir_emit_dots(coda_file, ctx))\n\t\tgoto out;\n\n\twhile (1) {\n\t\t/* read entries from the directory file */\n\t\tret = kernel_read(host_file, ctx->pos - 2, (char *)vdir,\n\t\t\t\t  sizeof(*vdir));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: read dir %s failed %d\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid), ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) break; /* end of directory file reached */\n\n\t\t/* catch truncated reads */\n\t\tif (ret < vdir_size || ret < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: short read on %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\t/* validate whether the directory file actually makes sense */\n\t\tif (vdir->d_reclen < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: invalid dir %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\tname.len = vdir->d_namlen;\n\t\tname.name = vdir->d_name;\n\n\t\t/* Make sure we skip '.' and '..', we already got those */\n\t\tif (name.name[0] == '.' && (name.len == 1 ||\n\t\t    (name.name[1] == '.' && name.len == 2)))\n\t\t\tvdir->d_fileno = name.len = 0;\n\n\t\t/* skip null entries */\n\t\tif (vdir->d_fileno && name.len) {\n\t\t\tino = vdir->d_fileno;\n\t\t\ttype = CDT2DT(vdir->d_type);\n\t\t\tif (!dir_emit(ctx, name.name, name.len, ino, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* we'll always have progress because d_reclen is unsigned and\n\t\t * we've already established it is non-zero. */\n\t\tctx->pos += vdir->d_reclen;\n\t}\nout:\n\tkfree(vdir);\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vdir"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name.name",
            "name.len",
            "ino",
            "type"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CDT2DT",
          "args": [
            "vdir->d_type"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "CDT2DT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "322-339",
          "snippet": "static inline unsigned int CDT2DT(unsigned char cdt)\n{\n\tunsigned int dt;\n\n\tswitch(cdt) {\n\tcase CDT_UNKNOWN: dt = DT_UNKNOWN; break;\n\tcase CDT_FIFO:\t  dt = DT_FIFO;    break;\n\tcase CDT_CHR:\t  dt = DT_CHR;     break;\n\tcase CDT_DIR:\t  dt = DT_DIR;     break;\n\tcase CDT_BLK:\t  dt = DT_BLK;     break;\n\tcase CDT_REG:\t  dt = DT_REG;     break;\n\tcase CDT_LNK:\t  dt = DT_LNK;     break;\n\tcase CDT_SOCK:\t  dt = DT_SOCK;    break;\n\tcase CDT_WHT:\t  dt = DT_WHT;     break;\n\tdefault:\t  dt = DT_UNKNOWN; break;\n\t}\n\treturn dt;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline unsigned int CDT2DT(unsigned char cdt)\n{\n\tunsigned int dt;\n\n\tswitch(cdt) {\n\tcase CDT_UNKNOWN: dt = DT_UNKNOWN; break;\n\tcase CDT_FIFO:\t  dt = DT_FIFO;    break;\n\tcase CDT_CHR:\t  dt = DT_CHR;     break;\n\tcase CDT_DIR:\t  dt = DT_DIR;     break;\n\tcase CDT_BLK:\t  dt = DT_BLK;     break;\n\tcase CDT_REG:\t  dt = DT_REG;     break;\n\tcase CDT_LNK:\t  dt = DT_LNK;     break;\n\tcase CDT_SOCK:\t  dt = DT_SOCK;    break;\n\tcase CDT_WHT:\t  dt = DT_WHT;     break;\n\tdefault:\t  dt = DT_UNKNOWN; break;\n\t}\n\treturn dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: invalid dir %s\\n\"",
            "__func__",
            "coda_f2s(&cii->c_fid)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_f2s",
          "args": [
            "&cii->c_fid"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "coda_f2s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "27-34",
          "snippet": "char * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nchar * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: short read on %s\\n\"",
            "__func__",
            "coda_f2s(&cii->c_fid)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: read dir %s failed %d\\n\"",
            "__func__",
            "coda_f2s(&cii->c_fid)",
            "ret"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "host_file",
            "ctx->pos - 2",
            "(char *)vdir",
            "sizeof(*vdir)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "coda_file",
            "ctx"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*vdir)",
            "GFP_KERNEL"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "file_inode(coda_file)"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "coda_file"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_venus_readdir(struct file *coda_file, struct dir_context *ctx)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct venus_dirent *vdir;\n\tunsigned long vdir_size = offsetof(struct venus_dirent, d_name);\n\tunsigned int type;\n\tstruct qstr name;\n\tino_t ino;\n\tint ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tcii = ITOC(file_inode(coda_file));\n\n\tvdir = kmalloc(sizeof(*vdir), GFP_KERNEL);\n\tif (!vdir) return -ENOMEM;\n\n\tif (!dir_emit_dots(coda_file, ctx))\n\t\tgoto out;\n\n\twhile (1) {\n\t\t/* read entries from the directory file */\n\t\tret = kernel_read(host_file, ctx->pos - 2, (char *)vdir,\n\t\t\t\t  sizeof(*vdir));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: read dir %s failed %d\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid), ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) break; /* end of directory file reached */\n\n\t\t/* catch truncated reads */\n\t\tif (ret < vdir_size || ret < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: short read on %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\t/* validate whether the directory file actually makes sense */\n\t\tif (vdir->d_reclen < vdir_size + vdir->d_namlen) {\n\t\t\tpr_err(\"%s: invalid dir %s\\n\",\n\t\t\t       __func__, coda_f2s(&cii->c_fid));\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\n\t\tname.len = vdir->d_namlen;\n\t\tname.name = vdir->d_name;\n\n\t\t/* Make sure we skip '.' and '..', we already got those */\n\t\tif (name.name[0] == '.' && (name.len == 1 ||\n\t\t    (name.name[1] == '.' && name.len == 2)))\n\t\t\tvdir->d_fileno = name.len = 0;\n\n\t\t/* skip null entries */\n\t\tif (vdir->d_fileno && name.len) {\n\t\t\tino = vdir->d_fileno;\n\t\t\ttype = CDT2DT(vdir->d_type);\n\t\t\tif (!dir_emit(ctx, name.name, name.len, ino, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* we'll always have progress because d_reclen is unsigned and\n\t\t * we've already established it is non-zero. */\n\t\tctx->pos += vdir->d_reclen;\n\t}\nout:\n\tkfree(vdir);\n\treturn 0;\n}"
  },
  {
    "function_name": "CDT2DT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "322-339",
    "snippet": "static inline unsigned int CDT2DT(unsigned char cdt)\n{\n\tunsigned int dt;\n\n\tswitch(cdt) {\n\tcase CDT_UNKNOWN: dt = DT_UNKNOWN; break;\n\tcase CDT_FIFO:\t  dt = DT_FIFO;    break;\n\tcase CDT_CHR:\t  dt = DT_CHR;     break;\n\tcase CDT_DIR:\t  dt = DT_DIR;     break;\n\tcase CDT_BLK:\t  dt = DT_BLK;     break;\n\tcase CDT_REG:\t  dt = DT_REG;     break;\n\tcase CDT_LNK:\t  dt = DT_LNK;     break;\n\tcase CDT_SOCK:\t  dt = DT_SOCK;    break;\n\tcase CDT_WHT:\t  dt = DT_WHT;     break;\n\tdefault:\t  dt = DT_UNKNOWN; break;\n\t}\n\treturn dt;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline unsigned int CDT2DT(unsigned char cdt)\n{\n\tunsigned int dt;\n\n\tswitch(cdt) {\n\tcase CDT_UNKNOWN: dt = DT_UNKNOWN; break;\n\tcase CDT_FIFO:\t  dt = DT_FIFO;    break;\n\tcase CDT_CHR:\t  dt = DT_CHR;     break;\n\tcase CDT_DIR:\t  dt = DT_DIR;     break;\n\tcase CDT_BLK:\t  dt = DT_BLK;     break;\n\tcase CDT_REG:\t  dt = DT_REG;     break;\n\tcase CDT_LNK:\t  dt = DT_LNK;     break;\n\tcase CDT_SOCK:\t  dt = DT_SOCK;    break;\n\tcase CDT_WHT:\t  dt = DT_WHT;     break;\n\tdefault:\t  dt = DT_UNKNOWN; break;\n\t}\n\treturn dt;\n}"
  },
  {
    "function_name": "coda_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "293-320",
    "snippet": "static int coda_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tconst char *old_name = old_dentry->d_name.name;\n\tconst char *new_name = new_dentry->d_name.name;\n\tint old_length = old_dentry->d_name.len;\n\tint new_length = new_dentry->d_name.len;\n\tint error;\n\n\terror = venus_rename(old_dir->i_sb, coda_i2f(old_dir),\n\t\t\t     coda_i2f(new_dir), old_length, new_length,\n\t\t\t     (const char *) old_name, (const char *)new_name);\n\tif (!error) {\n\t\tif (new_dentry->d_inode) {\n\t\t\tif (d_is_dir(new_dentry)) {\n\t\t\t\tcoda_dir_drop_nlink(old_dir);\n\t\t\t\tcoda_dir_inc_nlink(new_dir);\n\t\t\t}\n\t\t\tcoda_dir_update_mtime(old_dir);\n\t\t\tcoda_dir_update_mtime(new_dir);\n\t\t\tcoda_flag_inode(new_dentry->d_inode, C_VATTR);\n\t\t} else {\n\t\t\tcoda_flag_inode(old_dir, C_VATTR);\n\t\t\tcoda_flag_inode(new_dir, C_VATTR);\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_flag_inode",
          "args": [
            "new_dir",
            "C_VATTR"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "new_dir"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "new_dentry"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "venus_rename",
          "args": [
            "old_dir->i_sb",
            "coda_i2f(old_dir)",
            "coda_i2f(new_dir)",
            "old_length",
            "new_length",
            "(const char *) old_name",
            "(const char *)new_name"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "venus_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "231-266",
          "snippet": "int venus_rename(struct super_block *sb, struct CodaFid *old_fid, \n\t\t struct CodaFid *new_fid, size_t old_length, \n\t\t size_t new_length, const char *old_name, \n\t\t const char *new_name)\n{\n\tunion inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error; \n\tint offset, s;\n\t\n\toffset = INSIZE(rename);\n\tinsize = max_t(unsigned int, offset + new_length + old_length + 8,\n\t\t     OUTSIZE(rename)); \n \tUPARG(CODA_RENAME);\n\n        inp->coda_rename.sourceFid = *old_fid;\n        inp->coda_rename.destFid =  *new_fid;\n        inp->coda_rename.srcname = offset;\n\n        /* Venus must receive an null terminated string */\n        s = ( old_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, old_name, old_length);\n        *((char *)inp + offset + old_length) = '\\0';\n\n        /* another null terminated string for Venus */\n        offset += s;\n        inp->coda_rename.destname = offset;\n        s = ( new_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, new_name, new_length);\n        *((char *)inp + offset + new_length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_rename(struct super_block *sb, struct CodaFid *old_fid, \n\t\t struct CodaFid *new_fid, size_t old_length, \n\t\t size_t new_length, const char *old_name, \n\t\t const char *new_name)\n{\n\tunion inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error; \n\tint offset, s;\n\t\n\toffset = INSIZE(rename);\n\tinsize = max_t(unsigned int, offset + new_length + old_length + 8,\n\t\t     OUTSIZE(rename)); \n \tUPARG(CODA_RENAME);\n\n        inp->coda_rename.sourceFid = *old_fid;\n        inp->coda_rename.destFid =  *new_fid;\n        inp->coda_rename.srcname = offset;\n\n        /* Venus must receive an null terminated string */\n        s = ( old_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, old_name, old_length);\n        *((char *)inp + offset + old_length) = '\\0';\n\n        /* another null terminated string for Venus */\n        offset += s;\n        inp->coda_rename.destname = offset;\n        s = ( new_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, new_name, new_length);\n        *((char *)inp + offset + new_length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "new_dir"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tconst char *old_name = old_dentry->d_name.name;\n\tconst char *new_name = new_dentry->d_name.name;\n\tint old_length = old_dentry->d_name.len;\n\tint new_length = new_dentry->d_name.len;\n\tint error;\n\n\terror = venus_rename(old_dir->i_sb, coda_i2f(old_dir),\n\t\t\t     coda_i2f(new_dir), old_length, new_length,\n\t\t\t     (const char *) old_name, (const char *)new_name);\n\tif (!error) {\n\t\tif (new_dentry->d_inode) {\n\t\t\tif (d_is_dir(new_dentry)) {\n\t\t\t\tcoda_dir_drop_nlink(old_dir);\n\t\t\t\tcoda_dir_inc_nlink(new_dir);\n\t\t\t}\n\t\t\tcoda_dir_update_mtime(old_dir);\n\t\t\tcoda_dir_update_mtime(new_dir);\n\t\t\tcoda_flag_inode(new_dentry->d_inode, C_VATTR);\n\t\t} else {\n\t\t\tcoda_flag_inode(old_dir, C_VATTR);\n\t\t\tcoda_flag_inode(new_dir, C_VATTR);\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "coda_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "273-290",
    "snippet": "static int coda_rmdir(struct inode *dir, struct dentry *de)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\terror = venus_rmdir(dir->i_sb, coda_i2f(dir), name, len);\n\tif (!error) {\n\t\t/* VFS may delete the child */\n\t\tif (de->d_inode)\n\t\t\tclear_nlink(de->d_inode);\n\n\t\t/* fix the link count of the parent */\n\t\tcoda_dir_drop_nlink(dir);\n\t\tcoda_dir_update_mtime(dir);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_drop_nlink",
          "args": [
            "dir"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "de->d_inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_rmdir",
          "args": [
            "dir->i_sb",
            "coda_i2f(dir)",
            "name",
            "len"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "venus_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "301-322",
          "snippet": "int venus_rmdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(rmdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\n\tUPARG(CODA_RMDIR);\n\n        inp->coda_rmdir.VFid = *dirfid;\n        inp->coda_rmdir.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_rmdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(rmdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\n\tUPARG(CODA_RMDIR);\n\n        inp->coda_rmdir.VFid = *dirfid;\n        inp->coda_rmdir.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_rmdir(struct inode *dir, struct dentry *de)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\terror = venus_rmdir(dir->i_sb, coda_i2f(dir), name, len);\n\tif (!error) {\n\t\t/* VFS may delete the child */\n\t\tif (de->d_inode)\n\t\t\tclear_nlink(de->d_inode);\n\n\t\t/* fix the link count of the parent */\n\t\tcoda_dir_drop_nlink(dir);\n\t\tcoda_dir_update_mtime(dir);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "coda_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "258-271",
    "snippet": "static int coda_unlink(struct inode *dir, struct dentry *de)\n{\n        int error;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\n\terror = venus_remove(dir->i_sb, coda_i2f(dir), name, len);\n\tif (error)\n\t\treturn error;\n\n\tcoda_dir_update_mtime(dir);\n\tdrop_nlink(de->d_inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "de->d_inode"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_remove",
          "args": [
            "dir->i_sb",
            "coda_i2f(dir)",
            "name",
            "len"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "venus_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "324-344",
          "snippet": "int venus_remove(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int error=0, insize, outsize, offset;\n\n        offset = INSIZE(remove);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\n\tUPARG(CODA_REMOVE);\n\n        inp->coda_remove.VFid = *dirfid;\n        inp->coda_remove.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_remove(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int error=0, insize, outsize, offset;\n\n        offset = INSIZE(remove);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\n\tUPARG(CODA_REMOVE);\n\n        inp->coda_remove.VFid = *dirfid;\n        inp->coda_remove.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_unlink(struct inode *dir, struct dentry *de)\n{\n        int error;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\n\terror = venus_remove(dir->i_sb, coda_i2f(dir), name, len);\n\tif (error)\n\t\treturn error;\n\n\tcoda_dir_update_mtime(dir);\n\tdrop_nlink(de->d_inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "227-255",
    "snippet": "static int coda_symlink(struct inode *dir_inode, struct dentry *de,\n\t\t\tconst char *symname)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint symlen;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tsymlen = strlen(symname);\n\tif (symlen > CODA_MAXPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\t/*\n\t * This entry is now negative. Since we do not create\n\t * an inode for the entry we have to drop it.\n\t */\n\td_drop(de);\n\terror = venus_symlink(dir_inode->i_sb, coda_i2f(dir_inode), name, len,\n\t\t\t      symname, symlen);\n\n\t/* mtime is no good anymore */\n\tif (!error)\n\t\tcoda_dir_update_mtime(dir_inode);\n\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir_inode"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_symlink",
          "args": [
            "dir_inode->i_sb",
            "coda_i2f(dir_inode)",
            "name",
            "len",
            "symname",
            "symlen"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "venus_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "404-437",
          "snippet": "int venus_symlink(struct super_block *sb, struct CodaFid *fid,\n\t\t     const char *name, int len,\n\t\t     const char *symname, int symlen)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset, s;\n\n        offset = INSIZE(symlink);\n\tinsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\n\tUPARG(CODA_SYMLINK);\n        \n        /*        inp->coda_symlink.attr = *tva; XXXXXX */ \n        inp->coda_symlink.VFid = *fid;\n\n\t/* Round up to word boundary and null terminate */\n        inp->coda_symlink.srcname = offset;\n        s = ( symlen  & ~0x3 ) + 4; \n        memcpy((char *)(inp) + offset, symname, symlen);\n        *((char *)inp + offset + symlen) = '\\0';\n        \n\t/* Round up to word boundary and null terminate */\n        offset += s;\n        inp->coda_symlink.tname = offset;\n        s = (len & ~0x3) + 4;\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_symlink(struct super_block *sb, struct CodaFid *fid,\n\t\t     const char *name, int len,\n\t\t     const char *symname, int symlen)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset, s;\n\n        offset = INSIZE(symlink);\n\tinsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\n\tUPARG(CODA_SYMLINK);\n        \n        /*        inp->coda_symlink.attr = *tva; XXXXXX */ \n        inp->coda_symlink.VFid = *fid;\n\n\t/* Round up to word boundary and null terminate */\n        inp->coda_symlink.srcname = offset;\n        s = ( symlen  & ~0x3 ) + 4; \n        memcpy((char *)(inp) + offset, symname, symlen);\n        *((char *)inp + offset + symlen) = '\\0';\n        \n\t/* Round up to word boundary and null terminate */\n        offset += s;\n        inp->coda_symlink.tname = offset;\n        s = (len & ~0x3) + 4;\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir_inode"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "de"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_iscontrol",
          "args": [
            "name",
            "len"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iscontrol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "37-41",
          "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "dir_inode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_symlink(struct inode *dir_inode, struct dentry *de,\n\t\t\tconst char *symname)\n{\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint symlen;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tsymlen = strlen(symname);\n\tif (symlen > CODA_MAXPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\t/*\n\t * This entry is now negative. Since we do not create\n\t * an inode for the entry we have to drop it.\n\t */\n\td_drop(de);\n\terror = venus_symlink(dir_inode->i_sb, coda_i2f(dir_inode), name, len,\n\t\t\t      symname, symlen);\n\n\t/* mtime is no good anymore */\n\tif (!error)\n\t\tcoda_dir_update_mtime(dir_inode);\n\n\treturn error;\n}"
  },
  {
    "function_name": "coda_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "201-224",
    "snippet": "static int coda_link(struct dentry *source_de, struct inode *dir_inode, \n\t  struct dentry *de)\n{\n\tstruct inode *inode = source_de->d_inode;\n        const char * name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\terror = venus_link(dir_inode->i_sb, coda_i2f(inode),\n\t\t\t   coda_i2f(dir_inode), (const char *)name, len);\n\tif (error) {\n\t\td_drop(de);\n\t\treturn error;\n\t}\n\n\tcoda_dir_update_mtime(dir_inode);\n\tihold(inode);\n\td_instantiate(de, inode);\n\tinc_nlink(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "de",
            "inode"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir_inode"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "de"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_link",
          "args": [
            "dir_inode->i_sb",
            "coda_i2f(inode)",
            "coda_i2f(dir_inode)",
            "(const char *)name",
            "len"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "venus_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "378-402",
          "snippet": "int venus_link(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct CodaFid *dirfid, const char *name, int len )\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(link);\n\tinsize = max_t(unsigned int, offset  + len + 1, OUTSIZE(link));\n        UPARG(CODA_LINK);\n\n        inp->coda_link.sourceFid = *fid;\n        inp->coda_link.destFid = *dirfid;\n        inp->coda_link.tname = offset;\n\n        /* make sure strings are null terminated */\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_link(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct CodaFid *dirfid, const char *name, int len )\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(link);\n\tinsize = max_t(unsigned int, offset  + len + 1, OUTSIZE(link));\n        UPARG(CODA_LINK);\n\n        inp->coda_link.sourceFid = *fid;\n        inp->coda_link.destFid = *dirfid;\n        inp->coda_link.tname = offset;\n\n        /* make sure strings are null terminated */\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir_inode"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_iscontrol",
          "args": [
            "name",
            "len"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iscontrol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "37-41",
          "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "dir_inode"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_link(struct dentry *source_de, struct inode *dir_inode, \n\t  struct dentry *de)\n{\n\tstruct inode *inode = source_de->d_inode;\n        const char * name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\n\tif (is_root_inode(dir_inode) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\terror = venus_link(dir_inode->i_sb, coda_i2f(inode),\n\t\t\t   coda_i2f(dir_inode), (const char *)name, len);\n\tif (error) {\n\t\td_drop(de);\n\t\treturn error;\n\t}\n\n\tcoda_dir_update_mtime(dir_inode);\n\tihold(inode);\n\td_instantiate(de, inode);\n\tinc_nlink(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "166-198",
    "snippet": "static int coda_mkdir(struct inode *dir, struct dentry *de, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct coda_vattr attrs;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\tstruct CodaFid newfid;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tattrs.va_mode = mode;\n\terror = venus_mkdir(dir->i_sb, coda_i2f(dir), \n\t\t\t       name, len, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n         \n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t/* invalidate the directory cnode's attributes */\n\tcoda_dir_inc_nlink(dir);\n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "de"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "de",
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_inc_nlink",
          "args": [
            "dir"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_iget",
          "args": [
            "dir->i_sb",
            "&newfid",
            "&attrs"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "59-83",
          "snippet": "struct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_mkdir",
          "args": [
            "dir->i_sb",
            "coda_i2f(dir)",
            "name",
            "len",
            "&newfid",
            "&attrs"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "venus_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "200-228",
          "snippet": "int venus_mkdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t   const char *name, int length, \n\t\t   struct CodaFid *newfid, struct coda_vattr *attrs)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(mkdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\n\tUPARG(CODA_MKDIR);\n\n        inp->coda_mkdir.VFid = *dirfid;\n        inp->coda_mkdir.attr = *attrs;\n\tinp->coda_mkdir.name = offset;\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_mkdir.attr;\n\t\t*newfid = outp->coda_mkdir.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_mkdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t   const char *name, int length, \n\t\t   struct CodaFid *newfid, struct coda_vattr *attrs)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(mkdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\n\tUPARG(CODA_MKDIR);\n\n        inp->coda_mkdir.VFid = *dirfid;\n        inp->coda_mkdir.attr = *attrs;\n\tinp->coda_mkdir.name = offset;\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_mkdir.attr;\n\t\t*newfid = outp->coda_mkdir.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_iscontrol",
          "args": [
            "name",
            "len"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iscontrol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "37-41",
          "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "dir"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_mkdir(struct inode *dir, struct dentry *de, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct coda_vattr attrs;\n\tconst char *name = de->d_name.name;\n\tint len = de->d_name.len;\n\tint error;\n\tstruct CodaFid newfid;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, len))\n\t\treturn -EPERM;\n\n\tattrs.va_mode = mode;\n\terror = venus_mkdir(dir->i_sb, coda_i2f(dir), \n\t\t\t       name, len, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n         \n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t/* invalidate the directory cnode's attributes */\n\tcoda_dir_inc_nlink(dir);\n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}"
  },
  {
    "function_name": "coda_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "134-164",
    "snippet": "static int coda_create(struct inode *dir, struct dentry *de, umode_t mode, bool excl)\n{\n\tint error;\n\tconst char *name=de->d_name.name;\n\tint length=de->d_name.len;\n\tstruct inode *inode;\n\tstruct CodaFid newfid;\n\tstruct coda_vattr attrs;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, length))\n\t\treturn -EPERM;\n\n\terror = venus_create(dir->i_sb, coda_i2f(dir), name, length, \n\t\t\t\t0, mode, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n\n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t/* invalidate the directory cnode's attributes */\n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "de"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "de",
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_dir_update_mtime",
          "args": [
            "dir"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "102-114",
          "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_iget",
          "args": [
            "dir->i_sb",
            "&newfid",
            "&attrs"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "59-83",
          "snippet": "struct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_create",
          "args": [
            "dir->i_sb",
            "coda_i2f(dir)",
            "name",
            "length",
            "0",
            "mode",
            "&newfid",
            "&attrs"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "venus_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "268-299",
          "snippet": "int venus_create(struct super_block *sb, struct CodaFid *dirfid, \n\t\t const char *name, int length, int excl, int mode,\n\t\t struct CodaFid *newfid, struct coda_vattr *attrs) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(create);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\n\tUPARG(CODA_CREATE);\n\n        inp->coda_create.VFid = *dirfid;\n        inp->coda_create.attr.va_mode = mode;\n\tinp->coda_create.excl = excl;\n        inp->coda_create.mode = mode;\n        inp->coda_create.name = offset;\n\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_create.attr;\n\t\t*newfid = outp->coda_create.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_create(struct super_block *sb, struct CodaFid *dirfid, \n\t\t const char *name, int length, int excl, int mode,\n\t\t struct CodaFid *newfid, struct coda_vattr *attrs) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(create);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\n\tUPARG(CODA_CREATE);\n\n        inp->coda_create.VFid = *dirfid;\n        inp->coda_create.attr.va_mode = mode;\n\tinp->coda_create.excl = excl;\n        inp->coda_create.mode = mode;\n        inp->coda_create.name = offset;\n\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_create.attr;\n\t\t*newfid = outp->coda_create.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_iscontrol",
          "args": [
            "name",
            "length"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iscontrol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "37-41",
          "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "dir"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_create(struct inode *dir, struct dentry *de, umode_t mode, bool excl)\n{\n\tint error;\n\tconst char *name=de->d_name.name;\n\tint length=de->d_name.len;\n\tstruct inode *inode;\n\tstruct CodaFid newfid;\n\tstruct coda_vattr attrs;\n\n\tif (is_root_inode(dir) && coda_iscontrol(name, length))\n\t\treturn -EPERM;\n\n\terror = venus_create(dir->i_sb, coda_i2f(dir), name, length, \n\t\t\t\t0, mode, &newfid, &attrs);\n\tif (error)\n\t\tgoto err_out;\n\n\tinode = coda_iget(dir->i_sb, &newfid, &attrs);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tgoto err_out;\n\t}\n\n\t/* invalidate the directory cnode's attributes */\n\tcoda_dir_update_mtime(dir);\n\td_instantiate(de, inode);\n\treturn 0;\nerr_out:\n\td_drop(de);\n\treturn error;\n}"
  },
  {
    "function_name": "coda_dir_drop_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "127-131",
    "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
  },
  {
    "function_name": "coda_dir_inc_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "121-125",
    "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
  },
  {
    "function_name": "coda_dir_update_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "102-114",
    "snippet": "static inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_flag_inode",
          "args": [
            "dir",
            "C_VATTR"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_update_mtime(struct inode *dir)\n{\n#ifdef REQUERY_VENUS_FOR_MTIME\n\t/* invalidate the directory cnode's attributes so we refetch the\n\t * attributes from venus next time the inode is referenced */\n\tcoda_flag_inode(dir, C_VATTR);\n#else\n\t/* optimistically we can also act as if our nose bleeds. The\n\t * granularity of the mtime is coarse anyways so we might actually be\n\t * right most of the time. Note: we only do this for directories. */\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n#endif\n}"
  },
  {
    "function_name": "coda_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "75-99",
    "snippet": "int coda_permission(struct inode *inode, int mask)\n{\n\tint error;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \n\tif (!mask)\n\t\treturn 0;\n\n\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\treturn -EACCES;\n\n\tif (coda_cache_check(inode, mask))\n\t\treturn 0;\n\n\terror = venus_access(inode->i_sb, coda_i2f(inode), mask);\n    \n\tif (!error)\n\t\tcoda_cache_enter(inode, mask);\n\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_cache_enter",
          "args": [
            "inode",
            "mask"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_access",
          "args": [
            "inode->i_sb",
            "coda_i2f(inode)",
            "mask"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "venus_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "456-472",
          "snippet": "int venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\n\tinsize = SIZE(access);\n\tUPARG(CODA_ACCESS);\n\n        inp->coda_access.VFid = *fid;\n        inp->coda_access.flags = mask;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\n\tinsize = SIZE(access);\n\tUPARG(CODA_ACCESS);\n\n        inp->coda_access.VFid = *fid;\n        inp->coda_access.flags = mask;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_cache_check",
          "args": [
            "inode",
            "mask"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "61-73",
          "snippet": "int coda_cache_check(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tint hit;\n\t\n\tspin_lock(&cii->c_lock);\n\thit = (mask & cii->c_cached_perm) == mask &&\n\t    uid_eq(cii->c_uid, current_fsuid()) &&\n\t    cii->c_cached_epoch == atomic_read(&permission_epoch);\n\tspin_unlock(&cii->c_lock);\n\n\treturn hit;\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nint coda_cache_check(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tint hit;\n\t\n\tspin_lock(&cii->c_lock);\n\thit = (mask & cii->c_cached_perm) == mask &&\n\t    uid_eq(cii->c_uid, current_fsuid()) &&\n\t    cii->c_cached_epoch == atomic_read(&permission_epoch);\n\tspin_unlock(&cii->c_lock);\n\n\treturn hit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute_ok",
          "args": [
            "inode"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_permission(struct inode *inode, int mask)\n{\n\tint error;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \n\tif (!mask)\n\t\treturn 0;\n\n\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\treturn -EACCES;\n\n\tif (coda_cache_check(inode, mask))\n\t\treturn 0;\n\n\terror = venus_access(inode->i_sb, coda_i2f(inode), mask);\n    \n\tif (!error)\n\t\tcoda_cache_enter(inode, mask);\n\n\treturn error;\n}"
  },
  {
    "function_name": "coda_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "40-72",
    "snippet": "static struct dentry *coda_lookup(struct inode *dir, struct dentry *entry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst char *name = entry->d_name.name;\n\tsize_t length = entry->d_name.len;\n\tstruct inode *inode;\n\tint type = 0;\n\n\tif (length > CODA_MAXNAMLEN) {\n\t\tpr_err(\"name too long: lookup, %s (%*s)\\n\",\n\t\t       coda_i2s(dir), (int)length, name);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* control object, create inode on the fly */\n\tif (is_root_inode(dir) && coda_iscontrol(name, length)) {\n\t\tinode = coda_cnode_makectl(sb);\n\t\ttype = CODA_NOCACHE;\n\t} else {\n\t\tstruct CodaFid fid = { { 0, } };\n\t\tint error = venus_lookup(sb, coda_i2f(dir), name, length,\n\t\t\t\t     &type, &fid);\n\t\tinode = !error ? coda_cnode_make(&fid, sb) : ERR_PTR(error);\n\t}\n\n\tif (!IS_ERR(inode) && (type & CODA_NOCACHE))\n\t\tcoda_flag_inode(inode, C_VATTR | C_PURGE);\n\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = NULL;\n\n\treturn d_splice_alias(inode, entry);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "entry"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_flag_inode",
          "args": [
            "inode",
            "C_VATTR | C_PURGE"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_cnode_make",
          "args": [
            "&fid",
            "sb"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cnode_make",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "91-106",
          "snippet": "struct inode *coda_cnode_make(struct CodaFid *fid, struct super_block *sb)\n{\n        struct coda_vattr attr;\n\tstruct inode *inode;\n        int error;\n        \n\t/* We get inode numbers from Venus -- see venus source */\n\terror = venus_getattr(sb, fid, &attr);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = coda_iget(sb, fid, &attr);\n\tif (IS_ERR(inode))\n\t\tpr_warn(\"%s: coda_iget failed\\n\", __func__);\n\treturn inode;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_cnode_make(struct CodaFid *fid, struct super_block *sb)\n{\n        struct coda_vattr attr;\n\tstruct inode *inode;\n        int error;\n        \n\t/* We get inode numbers from Venus -- see venus source */\n\terror = venus_getattr(sb, fid, &attr);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = coda_iget(sb, fid, &attr);\n\tif (IS_ERR(inode))\n\t\tpr_warn(\"%s: coda_iget failed\\n\", __func__);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_lookup",
          "args": [
            "sb",
            "coda_i2f(dir)",
            "name",
            "length",
            "&type",
            "&fid"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "venus_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "129-157",
          "snippet": "int venus_lookup(struct super_block *sb, struct CodaFid *fid, \n\t\t    const char *name, int length, int * type, \n\t\t    struct CodaFid *resfid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\tint offset;\n\n\toffset = INSIZE(lookup);\n        insize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\n\tUPARG(CODA_LOOKUP);\n\n        inp->coda_lookup.VFid = *fid;\n\tinp->coda_lookup.name = offset;\n\tinp->coda_lookup.flags = CLU_CASE_SENSITIVE;\n        /* send Venus a null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*resfid = outp->coda_lookup.VFid;\n\t\t*type = outp->coda_lookup.vtype;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_lookup(struct super_block *sb, struct CodaFid *fid, \n\t\t    const char *name, int length, int * type, \n\t\t    struct CodaFid *resfid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\tint offset;\n\n\toffset = INSIZE(lookup);\n        insize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\n\tUPARG(CODA_LOOKUP);\n\n        inp->coda_lookup.VFid = *fid;\n\tinp->coda_lookup.name = offset;\n\tinp->coda_lookup.flags = CLU_CASE_SENSITIVE;\n        /* send Venus a null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*resfid = outp->coda_lookup.VFid;\n\t\t*type = outp->coda_lookup.vtype;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "dir"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_cnode_makectl",
          "args": [
            "sb"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cnode_makectl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "156-167",
          "snippet": "struct inode *coda_cnode_makectl(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = CTL_INO;\n\t\tinode->i_op = &coda_ioctl_inode_operations;\n\t\tinode->i_fop = &coda_ioctl_operations;\n\t\tinode->i_mode = 0444;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_cnode_makectl(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = CTL_INO;\n\t\tinode->i_op = &coda_ioctl_inode_operations;\n\t\tinode->i_fop = &coda_ioctl_operations;\n\t\tinode->i_mode = 0444;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_iscontrol",
          "args": [
            "name",
            "length"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iscontrol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "37-41",
          "snippet": "int coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_iscontrol(const char *name, size_t length)\n{\n\treturn ((CODA_CONTROLLEN == length) && \n                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "dir"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"name too long: lookup, %s (%*s)\\n\"",
            "coda_i2s(dir)",
            "(int)length",
            "name"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_i2s",
          "args": [
            "dir"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "90-93",
          "snippet": "static __inline__ char *coda_i2s(struct inode *inode)\n{\n\treturn coda_f2s(&(ITOC(inode)->c_fid));\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ char *coda_i2s(struct inode *inode)\n{\n\treturn coda_f2s(&(ITOC(inode)->c_fid));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct dentry *coda_lookup(struct inode *dir, struct dentry *entry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst char *name = entry->d_name.name;\n\tsize_t length = entry->d_name.len;\n\tstruct inode *inode;\n\tint type = 0;\n\n\tif (length > CODA_MAXNAMLEN) {\n\t\tpr_err(\"name too long: lookup, %s (%*s)\\n\",\n\t\t       coda_i2s(dir), (int)length, name);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* control object, create inode on the fly */\n\tif (is_root_inode(dir) && coda_iscontrol(name, length)) {\n\t\tinode = coda_cnode_makectl(sb);\n\t\ttype = CODA_NOCACHE;\n\t} else {\n\t\tstruct CodaFid fid = { { 0, } };\n\t\tint error = venus_lookup(sb, coda_i2f(dir), name, length,\n\t\t\t\t     &type, &fid);\n\t\tinode = !error ? coda_cnode_make(&fid, sb) : ERR_PTR(error);\n\t}\n\n\tif (!IS_ERR(inode) && (type & CODA_NOCACHE))\n\t\tcoda_flag_inode(inode, C_VATTR | C_PURGE);\n\n\tif (inode == ERR_PTR(-ENOENT))\n\t\tinode = NULL;\n\n\treturn d_splice_alias(inode, entry);\n}"
  },
  {
    "function_name": "coda_return_EIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
    "lines": "32-35",
    "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
  }
]