[
  {
    "function_name": "__fscache_unregister_netfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
    "lines": "88-103",
    "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Netfs '%s' unregistered from caching\\n\"",
            "netfs->name"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "netfs->primary_index",
            "0"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&netfs->link"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s.%u}\"",
            "netfs->name",
            "netfs->version"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_register_netfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
    "lines": "22-81",
    "snippet": "int __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fscache_netfs_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_cookie_put",
          "args": [
            "netfs->primary_index"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_cookie_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "624-646",
          "snippet": "void __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Netfs '%s' registered for caching\\n\"",
            "netfs->name"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&netfs->link",
            "&fscache_netfs_list"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr->name",
            "netfs->name"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ptr",
            "&fscache_netfs_list",
            "link"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&netfs->primary_index->backing_objects"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&netfs->primary_index->lock"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&netfs->primary_index->parent->n_children"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&netfs->primary_index->parent->usage"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&netfs->primary_index->n_active",
            "1"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&netfs->primary_index->n_children",
            "0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&netfs->primary_index->usage",
            "1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "fscache_cookie_jar",
            "GFP_KERNEL"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&netfs->link"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s}\"",
            "netfs->name"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_netfs_list);\n\nint __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  }
]