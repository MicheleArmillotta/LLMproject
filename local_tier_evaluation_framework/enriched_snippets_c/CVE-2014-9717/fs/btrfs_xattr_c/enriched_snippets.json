[
  {
    "function_name": "btrfs_xattr_security_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "486-492",
    "snippet": "int btrfs_xattr_security_init(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, struct inode *dir,\n\t\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &btrfs_initxattrs, trans);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&btrfs_initxattrs",
            "trans"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint btrfs_xattr_security_init(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, struct inode *dir,\n\t\t\t      const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &btrfs_initxattrs, trans);\n}"
  },
  {
    "function_name": "btrfs_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "460-484",
    "snippet": "static int btrfs_initxattrs(struct inode *inode,\n\t\t\t    const struct xattr *xattr_array, void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tstruct btrfs_trans_handle *trans = fs_info;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\terr = __btrfs_setxattr(trans, inode, name,\n\t\t\t\t       xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_setxattr",
          "args": [
            "trans",
            "inode",
            "name",
            "xattr->value",
            "xattr->value_len",
            "0"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "233-259",
          "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "name + XATTR_SECURITY_PREFIX_LEN",
            "xattr->name"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1",
            "GFP_NOFS"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xattr->name"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int btrfs_initxattrs(struct inode *inode,\n\t\t\t    const struct xattr *xattr_array, void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tstruct btrfs_trans_handle *trans = fs_info;\n\tchar *name;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\tname = kmalloc(XATTR_SECURITY_PREFIX_LEN +\n\t\t\t       strlen(xattr->name) + 1, GFP_NOFS);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(name + XATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\terr = __btrfs_setxattr(trans, inode, name,\n\t\t\t\t       xattr->value, xattr->value_len, 0);\n\t\tkfree(name);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "430-458",
    "snippet": "int btrfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;\n\n\t/*\n\t * The permission on security.* and system.* is not checked\n\t * in permission().\n\t */\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))\n\t\treturn btrfs_set_prop(dentry->d_inode, name,\n\t\t\t\t      NULL, 0, XATTR_REPLACE);\n\n\treturn __btrfs_setxattr(NULL, dentry->d_inode, name, NULL, 0,\n\t\t\t\tXATTR_REPLACE);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_setxattr",
          "args": [
            "NULL",
            "dentry->d_inode",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "233-259",
          "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_prop",
          "args": [
            "dentry->d_inode",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "150-157",
          "snippet": "int btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_BTRFS_PREFIX",
            "XATTR_BTRFS_PREFIX_LEN"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "370-378",
          "snippet": "static bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "generic_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "777-787",
          "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint btrfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;\n\n\t/*\n\t * The permission on security.* and system.* is not checked\n\t * in permission().\n\t */\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))\n\t\treturn btrfs_set_prop(dentry->d_inode, name,\n\t\t\t\t      NULL, 0, XATTR_REPLACE);\n\n\treturn __btrfs_setxattr(NULL, dentry->d_inode, name, NULL, 0,\n\t\t\t\tXATTR_REPLACE);\n}"
  },
  {
    "function_name": "btrfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "396-428",
    "snippet": "int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t   size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;\n\n\t/*\n\t * The permission on security.* and system.* is not checked\n\t * in permission().\n\t */\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))\n\t\treturn btrfs_set_prop(dentry->d_inode, name,\n\t\t\t\t      value, size, flags);\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\n\treturn __btrfs_setxattr(NULL, dentry->d_inode, name, value, size,\n\t\t\t\tflags);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_setxattr",
          "args": [
            "NULL",
            "dentry->d_inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "233-259",
          "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_prop",
          "args": [
            "dentry->d_inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "150-157",
          "snippet": "int btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_BTRFS_PREFIX",
            "XATTR_BTRFS_PREFIX_LEN"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "370-378",
          "snippet": "static bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "760-771",
          "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t   size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;\n\n\t/*\n\t * The permission on security.* and system.* is not checked\n\t * in permission().\n\t */\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))\n\t\treturn btrfs_set_prop(dentry->d_inode, name,\n\t\t\t\t      value, size, flags);\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\n\treturn __btrfs_setxattr(NULL, dentry->d_inode, name, value, size,\n\t\t\t\tflags);\n}"
  },
  {
    "function_name": "btrfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "380-394",
    "snippet": "ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t size)\n{\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, buffer, size);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __btrfs_getxattr(dentry->d_inode, name, buffer, size);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_getxattr",
          "args": [
            "dentry->d_inode",
            "name",
            "buffer",
            "size"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "35-89",
          "snippet": "ssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "370-378",
          "snippet": "static bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_getxattr",
          "args": [
            "dentry",
            "name",
            "buffer",
            "size"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "generic_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "715-724",
          "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t btrfs_getxattr(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t size)\n{\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, buffer, size);\n\n\tif (!btrfs_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\treturn __btrfs_getxattr(dentry->d_inode, name, buffer, size);\n}"
  },
  {
    "function_name": "btrfs_is_valid_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "370-378",
    "snippet": "static bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_BTRFS_PREFIX",
            "XATTR_BTRFS_PREFIX_LEN"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic bool btrfs_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||\n\t\t!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);\n}"
  },
  {
    "function_name": "btrfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "261-350",
    "snippet": "ssize_t btrfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct btrfs_key key, found_key;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tint ret = 0, slot;\n\tsize_t total_size = 0, size_left = size;\n\tunsigned long name_ptr;\n\tsize_t name_len;\n\n\t/*\n\t * ok we want all objects associated with this id.\n\t * NOTE: we set key.offset = 0; because we want to start with the\n\t * first xattr that we find and walk forward\n\t */\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\t/* search for our xattrs */\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\t/* this is where we start walking through the path */\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * if we've reached the last slot in this leaf we need\n\t\t\t * to go to the next leaf and reset everything\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/* check to make sure this item is what we want */\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tif (verify_dir_item(root, leaf, di))\n\t\t\tgoto next;\n\n\t\tname_len = btrfs_dir_name_len(leaf, di);\n\t\ttotal_size += name_len + 1;\n\n\t\t/* we are just looking for how big our buffer needs to be */\n\t\tif (!size)\n\t\t\tgoto next;\n\n\t\tif (!buffer || (name_len + 1) > size_left) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto err;\n\t\t}\n\n\t\tname_ptr = (unsigned long)(di + 1);\n\t\tread_extent_buffer(leaf, buffer, name_ptr, name_len);\n\t\tbuffer[name_len] = '\\0';\n\n\t\tsize_left -= name_len + 1;\n\t\tbuffer += name_len + 1;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = total_size;\n\nerr:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "buffer",
            "name_ptr",
            "name_len"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_dir_item",
          "args": [
            "root",
            "leaf",
            "di"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "450-482",
          "snippet": "int verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_dir_item"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t btrfs_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct btrfs_key key, found_key;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tint ret = 0, slot;\n\tsize_t total_size = 0, size_left = size;\n\tunsigned long name_ptr;\n\tsize_t name_len;\n\n\t/*\n\t * ok we want all objects associated with this id.\n\t * NOTE: we set key.offset = 0; because we want to start with the\n\t * first xattr that we find and walk forward\n\t */\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\t/* search for our xattrs */\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\t/* this is where we start walking through the path */\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * if we've reached the last slot in this leaf we need\n\t\t\t * to go to the next leaf and reset everything\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/* check to make sure this item is what we want */\n\t\tif (found_key.objectid != key.objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\n\t\tif (verify_dir_item(root, leaf, di))\n\t\t\tgoto next;\n\n\t\tname_len = btrfs_dir_name_len(leaf, di);\n\t\ttotal_size += name_len + 1;\n\n\t\t/* we are just looking for how big our buffer needs to be */\n\t\tif (!size)\n\t\t\tgoto next;\n\n\t\tif (!buffer || (name_len + 1) > size_left) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto err;\n\t\t}\n\n\t\tname_ptr = (unsigned long)(di + 1);\n\t\tread_extent_buffer(leaf, buffer, name_ptr, name_len);\n\t\tbuffer[name_len] = '\\0';\n\n\t\tsize_left -= name_len + 1;\n\t\tbuffer += name_len + 1;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = total_size;\n\nerr:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "233-259",
    "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_COPY_EVERYTHING",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_setxattr",
          "args": [
            "trans",
            "inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "do_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "91-228",
          "snippet": "static int do_setxattr(struct btrfs_trans_handle *trans,\n\t\t       struct inode *inode, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\tstruct btrfs_dir_item *di = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_release_on_error = 1;\n\n\tif (!value) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, -1);\n\t\tif (!di && (flags & XATTR_REPLACE))\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\telse if (di)\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a replace we can't just do the insert blindly.\n\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n\t * doesn't exist. If it exists, fall down below to the insert/replace\n\t * path - we can't race with a concurrent xattr delete, because the VFS\n\t * locks the inode's i_mutex before calling setxattr or removexattr.\n\t */\n\tif (flags & XATTR_REPLACE) {\n\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, 0);\n\t\tif (!di)\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tdi = NULL;\n\t}\n\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n\t\t\t\t      name, name_len, value, size);\n\tif (ret == -EOVERFLOW) {\n\t\t/*\n\t\t * We have an existing item in a leaf, split_leaf couldn't\n\t\t * expand it. That item might have or not a dir_item that\n\t\t * matches our target xattr, so lets check.\n\t\t */\n\t\tret = 0;\n\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tif (!di && !(flags & XATTR_REPLACE)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tASSERT(di); /* logic error */\n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\n\tif (di && (flags & XATTR_CREATE)) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (di) {\n\t\t/*\n\t\t * We're doing a replace, and it must be atomic, that is, at\n\t\t * any point in time we have either the old or the new xattr\n\t\t * value in the tree. We don't want readers (getxattr and\n\t\t * listxattrs) to miss a value, this is specially important\n\t\t * for ACLs.\n\t\t */\n\t\tconst int slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n\t\tstruct btrfs_item *item;\n\t\tunsigned long data_ptr;\n\t\tchar *ptr;\n\n\t\tif (size > old_data_len) {\n\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t    (size - old_data_len)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n\t\t\t/* No other xattrs packed in the same leaf item. */\n\t\t\tif (size > old_data_len)\n\t\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t\t  size - old_data_len);\n\t\t\telse if (size < old_data_len)\n\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n\t\t} else {\n\t\t\t/* There are other xattrs packed in the same item. */\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbtrfs_extend_item(root, path, data_size);\n\t\t}\n\n\t\titem = btrfs_item_nr(slot);\n\t\tptr = btrfs_item_ptr(leaf, slot, char);\n\t\tptr += btrfs_item_size(leaf, item) - data_size;\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tbtrfs_set_dir_data_len(leaf, di, size);\n\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\t/*\n\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n\t\t * filled it.\n\t\t */\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int do_setxattr(struct btrfs_trans_handle *trans,\n\t\t       struct inode *inode, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\tstruct btrfs_dir_item *di = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_release_on_error = 1;\n\n\tif (!value) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, -1);\n\t\tif (!di && (flags & XATTR_REPLACE))\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\telse if (di)\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a replace we can't just do the insert blindly.\n\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n\t * doesn't exist. If it exists, fall down below to the insert/replace\n\t * path - we can't race with a concurrent xattr delete, because the VFS\n\t * locks the inode's i_mutex before calling setxattr or removexattr.\n\t */\n\tif (flags & XATTR_REPLACE) {\n\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, 0);\n\t\tif (!di)\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tdi = NULL;\n\t}\n\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n\t\t\t\t      name, name_len, value, size);\n\tif (ret == -EOVERFLOW) {\n\t\t/*\n\t\t * We have an existing item in a leaf, split_leaf couldn't\n\t\t * expand it. That item might have or not a dir_item that\n\t\t * matches our target xattr, so lets check.\n\t\t */\n\t\tret = 0;\n\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tif (!di && !(flags & XATTR_REPLACE)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tASSERT(di); /* logic error */\n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\n\tif (di && (flags & XATTR_CREATE)) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (di) {\n\t\t/*\n\t\t * We're doing a replace, and it must be atomic, that is, at\n\t\t * any point in time we have either the old or the new xattr\n\t\t * value in the tree. We don't want readers (getxattr and\n\t\t * listxattrs) to miss a value, this is specially important\n\t\t * for ACLs.\n\t\t */\n\t\tconst int slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n\t\tstruct btrfs_item *item;\n\t\tunsigned long data_ptr;\n\t\tchar *ptr;\n\n\t\tif (size > old_data_len) {\n\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t    (size - old_data_len)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n\t\t\t/* No other xattrs packed in the same leaf item. */\n\t\t\tif (size > old_data_len)\n\t\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t\t  size - old_data_len);\n\t\t\telse if (size < old_data_len)\n\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n\t\t} else {\n\t\t\t/* There are other xattrs packed in the same item. */\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbtrfs_extend_item(root, path, data_size);\n\t\t}\n\n\t\titem = btrfs_item_nr(slot);\n\t\tptr = btrfs_item_ptr(leaf, slot, char);\n\t\tptr += btrfs_item_size(leaf, item) - data_size;\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tbtrfs_set_dir_data_len(leaf, di, size);\n\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\t/*\n\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n\t\t * filled it.\n\t\t */\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "2"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "91-228",
    "snippet": "static int do_setxattr(struct btrfs_trans_handle *trans,\n\t\t       struct inode *inode, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\tstruct btrfs_dir_item *di = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_release_on_error = 1;\n\n\tif (!value) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, -1);\n\t\tif (!di && (flags & XATTR_REPLACE))\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\telse if (di)\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a replace we can't just do the insert blindly.\n\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n\t * doesn't exist. If it exists, fall down below to the insert/replace\n\t * path - we can't race with a concurrent xattr delete, because the VFS\n\t * locks the inode's i_mutex before calling setxattr or removexattr.\n\t */\n\tif (flags & XATTR_REPLACE) {\n\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, 0);\n\t\tif (!di)\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tdi = NULL;\n\t}\n\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n\t\t\t\t      name, name_len, value, size);\n\tif (ret == -EOVERFLOW) {\n\t\t/*\n\t\t * We have an existing item in a leaf, split_leaf couldn't\n\t\t * expand it. That item might have or not a dir_item that\n\t\t * matches our target xattr, so lets check.\n\t\t */\n\t\tret = 0;\n\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tif (!di && !(flags & XATTR_REPLACE)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tASSERT(di); /* logic error */\n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\n\tif (di && (flags & XATTR_CREATE)) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (di) {\n\t\t/*\n\t\t * We're doing a replace, and it must be atomic, that is, at\n\t\t * any point in time we have either the old or the new xattr\n\t\t * value in the tree. We don't want readers (getxattr and\n\t\t * listxattrs) to miss a value, this is specially important\n\t\t * for ACLs.\n\t\t */\n\t\tconst int slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n\t\tstruct btrfs_item *item;\n\t\tunsigned long data_ptr;\n\t\tchar *ptr;\n\n\t\tif (size > old_data_len) {\n\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t    (size - old_data_len)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n\t\t\t/* No other xattrs packed in the same leaf item. */\n\t\t\tif (size > old_data_len)\n\t\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t\t  size - old_data_len);\n\t\t\telse if (size < old_data_len)\n\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n\t\t} else {\n\t\t\t/* There are other xattrs packed in the same item. */\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbtrfs_extend_item(root, path, data_size);\n\t\t}\n\n\t\titem = btrfs_item_nr(slot);\n\t\tptr = btrfs_item_ptr(leaf, slot, char);\n\t\tptr += btrfs_item_size(leaf, item) - data_size;\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tbtrfs_set_dir_data_len(leaf, di, size);\n\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\t/*\n\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n\t\t * filled it.\n\t\t */\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "value",
            "data_ptr",
            "size"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dir_data_len",
          "args": [
            "leaf",
            "di",
            "size"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "leaf",
            "item"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "char"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extend_item",
          "args": [
            "root",
            "path",
            "data_size"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4634-4697",
          "snippet": "void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delete_one_dir_name",
          "args": [
            "trans",
            "root",
            "path",
            "di"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delete_one_dir_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "420-448",
          "snippet": "int btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct btrfs_dir_item *di)\n{\n\n\tstruct extent_buffer *leaf;\n\tu32 sub_item_len;\n\tu32 item_len;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\n\t\tbtrfs_dir_data_len(leaf, di);\n\titem_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (sub_item_len == item_len) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t} else {\n\t\t/* MARKER */\n\t\tunsigned long ptr = (unsigned long)di;\n\t\tunsigned long start;\n\n\t\tstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\titem_len - (ptr + sub_item_len - start));\n\t\tbtrfs_truncate_item(root, path, item_len - sub_item_len, 1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct btrfs_dir_item *di)\n{\n\n\tstruct extent_buffer *leaf;\n\tu32 sub_item_len;\n\tu32 item_len;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\n\t\tbtrfs_dir_data_len(leaf, di);\n\titem_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (sub_item_len == item_len) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t} else {\n\t\t/* MARKER */\n\t\tunsigned long ptr = (unsigned long)di;\n\t\tunsigned long start;\n\n\t\tstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\titem_len - (ptr + sub_item_len - start));\n\t\tbtrfs_truncate_item(root, path, item_len - sub_item_len, 1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_item",
          "args": [
            "root",
            "path",
            "data_size",
            "1"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4535-4629",
          "snippet": "void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "di"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_match_dir_item_name",
          "args": [
            "root",
            "path",
            "name",
            "name_len"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_match_dir_item_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "382-414",
          "snippet": "struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "path->nodes[0]"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_xattr_item",
          "args": [
            "trans",
            "root",
            "path",
            "btrfs_ino(inode)",
            "name",
            "name_len",
            "value",
            "size"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_xattr_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "68-110",
          "snippet": "int btrfs_insert_xattr_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 objectid,\n\t\t\t    const char *name, u16 name_len,\n\t\t\t    const void *data, u16 data_len)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr, data_ptr;\n\tstruct btrfs_key key, location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tu32 data_size;\n\n\tBUG_ON(name_len + data_len > BTRFS_MAX_XATTR_SIZE(root));\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tdata_size = sizeof(*dir_item) + name_len + data_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item))\n\t\treturn PTR_ERR(dir_item);\n\tmemset(&location, 0, sizeof(location));\n\n\tleaf = path->nodes[0];\n\tbtrfs_cpu_key_to_disk(&disk_key, &location);\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, BTRFS_FT_XATTR);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tbtrfs_set_dir_data_len(leaf, dir_item, data_len);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\tdata_ptr = (unsigned long)((char *)name_ptr + name_len);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\twrite_extent_buffer(leaf, data, data_ptr, data_len);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_xattr_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 objectid,\n\t\t\t    const char *name, u16 name_len,\n\t\t\t    const void *data, u16 data_len)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr, data_ptr;\n\tstruct btrfs_key key, location;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tu32 data_size;\n\n\tBUG_ON(name_len + data_len > BTRFS_MAX_XATTR_SIZE(root));\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tdata_size = sizeof(*dir_item) + name_len + data_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item))\n\t\treturn PTR_ERR(dir_item);\n\tmemset(&location, 0, sizeof(location));\n\n\tleaf = path->nodes[0];\n\tbtrfs_cpu_key_to_disk(&disk_key, &location);\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, BTRFS_FT_XATTR);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tbtrfs_set_dir_data_len(leaf, dir_item, data_len);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\tdata_ptr = (unsigned long)((char *)name_ptr + name_len);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\twrite_extent_buffer(leaf, data, data_ptr, data_len);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_xattr",
          "args": [
            "NULL",
            "root",
            "path",
            "btrfs_ino(inode)",
            "name",
            "name_len",
            "0"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "354-375",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, u64 dir,\n\t\t\t\t\t  const char *name, u16 name_len,\n\t\t\t\t\t  int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, u64 dir,\n\t\t\t\t\t  const char *name, u16 name_len,\n\t\t\t\t\t  int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_MAX_XATTR_SIZE",
          "args": [
            "root"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int do_setxattr(struct btrfs_trans_handle *trans,\n\t\t       struct inode *inode, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\tstruct btrfs_dir_item *di = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_release_on_error = 1;\n\n\tif (!value) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, -1);\n\t\tif (!di && (flags & XATTR_REPLACE))\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\telse if (di)\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a replace we can't just do the insert blindly.\n\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n\t * doesn't exist. If it exists, fall down below to the insert/replace\n\t * path - we can't race with a concurrent xattr delete, because the VFS\n\t * locks the inode's i_mutex before calling setxattr or removexattr.\n\t */\n\tif (flags & XATTR_REPLACE) {\n\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, 0);\n\t\tif (!di)\n\t\t\tret = -ENODATA;\n\t\telse if (IS_ERR(di))\n\t\t\tret = PTR_ERR(di);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tdi = NULL;\n\t}\n\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n\t\t\t\t      name, name_len, value, size);\n\tif (ret == -EOVERFLOW) {\n\t\t/*\n\t\t * We have an existing item in a leaf, split_leaf couldn't\n\t\t * expand it. That item might have or not a dir_item that\n\t\t * matches our target xattr, so lets check.\n\t\t */\n\t\tret = 0;\n\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tif (!di && !(flags & XATTR_REPLACE)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\t\tASSERT(di); /* logic error */\n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\n\tif (di && (flags & XATTR_CREATE)) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (di) {\n\t\t/*\n\t\t * We're doing a replace, and it must be atomic, that is, at\n\t\t * any point in time we have either the old or the new xattr\n\t\t * value in the tree. We don't want readers (getxattr and\n\t\t * listxattrs) to miss a value, this is specially important\n\t\t * for ACLs.\n\t\t */\n\t\tconst int slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n\t\tstruct btrfs_item *item;\n\t\tunsigned long data_ptr;\n\t\tchar *ptr;\n\n\t\tif (size > old_data_len) {\n\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t    (size - old_data_len)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n\t\t\t/* No other xattrs packed in the same leaf item. */\n\t\t\tif (size > old_data_len)\n\t\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t\t  size - old_data_len);\n\t\t\telse if (size < old_data_len)\n\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n\t\t} else {\n\t\t\t/* There are other xattrs packed in the same item. */\n\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbtrfs_extend_item(root, path, data_size);\n\t\t}\n\n\t\titem = btrfs_item_nr(slot);\n\t\tptr = btrfs_item_ptr(leaf, slot, char);\n\t\tptr += btrfs_item_size(leaf, item) - data_size;\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tbtrfs_set_dir_data_len(leaf, di, size);\n\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\t/*\n\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n\t\t * filled it.\n\t\t */\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
    "lines": "35-89",
    "snippet": "ssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"props.h\"",
      "#include \"disk-io.h\"",
      "#include \"xattr.h\"",
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "buffer",
            "data_ptr",
            "btrfs_dir_data_len(leaf, di)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_xattr",
          "args": [
            "NULL",
            "root",
            "path",
            "btrfs_ino(inode)",
            "name",
            "strlen(name)",
            "0"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "354-375",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, u64 dir,\n\t\t\t\t\t  const char *name, u16 name_len,\n\t\t\t\t\t  int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, u64 dir,\n\t\t\t\t\t  const char *name, u16 name_len,\n\t\t\t\t\t  int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  }
]