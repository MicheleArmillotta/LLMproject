[
  {
    "function_name": "gfs2_diradd_alloc_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "2058-2089",
    "snippet": "int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "name->len"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "inode",
            "name",
            "gfs2_dirent_find_space",
            "&bh"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dir_exhash_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "2002-2047",
    "snippet": "int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tu32 hsize, len;\n\tu32 index = 0, next_index;\n\t__be64 *lp;\n\tu64 leaf_no;\n\tint error = 0, last;\n\n\thsize = 1 << dip->i_depth;\n\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\twhile (index < hsize) {\n\t\tleaf_no = be64_to_cpu(lp[index]);\n\t\tif (leaf_no) {\n\t\t\terror = get_leaf(dip, leaf_no, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tlen = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));\n\n\t\t\tnext_index = (index & ~(len - 1)) + len;\n\t\t\tlast = ((next_index >= hsize) ? 1 : 0);\n\t\t\terror = leaf_dealloc(dip, index, len, leaf_no, bh,\n\t\t\t\t\t     last);\n\t\t\tbrelse(bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tindex = next_index;\n\t\t} else\n\t\t\tindex++;\n\t}\n\n\tif (index != hsize) {\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t}\n\nout:\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_dealloc",
          "args": [
            "dip",
            "index",
            "len",
            "leaf_no",
            "bh",
            "last"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1877-1990",
          "snippet": "static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,\n\t\t\tu64 leaf_no, struct buffer_head *leaf_bh,\n\t\t\tint last_dealloc)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,\n\t\t\t       PAGE_KERNEL);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t/*  Count the number of leaves  */\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_free_meta(dip, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t/* On the last dealloc, make this a regular file in case we crash.\n\t   (We don't want to free these blocks a second time.)  */\n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\n\tgfs2_quota_unhold(dip);\nout:\n\tkvfree(ht);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,\n\t\t\tu64 leaf_no, struct buffer_head *leaf_bh,\n\t\t\tint last_dealloc)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,\n\t\t\t       PAGE_KERNEL);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t/*  Count the number of leaves  */\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_free_meta(dip, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t/* On the last dealloc, make this a regular file in case we crash.\n\t   (We don't want to free these blocks a second time.)  */\n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\n\tgfs2_quota_unhold(dip);\nout:\n\tkvfree(ht);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "leaf->lf_depth"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "dip",
            "leaf_no",
            "&bh"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lp[index]"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lp"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lp"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_hash_table",
          "args": [
            "dip"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "339-381",
          "snippet": "static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tu32 hsize, len;\n\tu32 index = 0, next_index;\n\t__be64 *lp;\n\tu64 leaf_no;\n\tint error = 0, last;\n\n\thsize = 1 << dip->i_depth;\n\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\twhile (index < hsize) {\n\t\tleaf_no = be64_to_cpu(lp[index]);\n\t\tif (leaf_no) {\n\t\t\terror = get_leaf(dip, leaf_no, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tlen = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));\n\n\t\t\tnext_index = (index & ~(len - 1)) + len;\n\t\t\tlast = ((next_index >= hsize) ? 1 : 0);\n\t\t\terror = leaf_dealloc(dip, index, len, leaf_no, bh,\n\t\t\t\t\t     last);\n\t\t\tbrelse(bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tindex = next_index;\n\t\t} else\n\t\t\tindex++;\n\t}\n\n\tif (index != hsize) {\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t}\n\nout:\n\n\treturn error;\n}"
  },
  {
    "function_name": "leaf_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1877-1990",
    "snippet": "static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,\n\t\t\tu64 leaf_no, struct buffer_head *leaf_bh,\n\t\t\tint last_dealloc)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,\n\t\t\t       PAGE_KERNEL);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t/*  Count the number of leaves  */\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_free_meta(dip, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t/* On the last dealloc, make this a regular file in case we crash.\n\t   (We don't want to free these blocks a second time.)  */\n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\n\tgfs2_quota_unhold(dip);\nout:\n\tkvfree(ht);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "ht"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "dip"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_free",
          "args": [
            "&rlist"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2600-2612",
          "snippet": "void gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1245-1249",
          "snippet": "void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "dip",
            "dibh->b_data"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "dip->i_gl",
            "dibh"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&dibh"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_write_data",
          "args": [
            "dip",
            "ht",
            "index * sizeof(u64)",
            "size"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "155-245",
          "snippet": "static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&dip->i_inode",
            "-1"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_free_meta",
          "args": [
            "dip",
            "blk",
            "1"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2424-2431",
          "snippet": "void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "tmp_leaf->lf_next"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "dip",
            "blk",
            "&bh"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA",
            "l_blocks"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "size",
            "sdp->sd_jbsize"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1210-1236",
          "snippet": "int gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_alloc",
          "args": [
            "&rlist",
            "LM_ST_EXCLUSIVE"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2582-2592",
          "snippet": "void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_add",
          "args": [
            "dip",
            "&rlist",
            "blk"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2527-2570",
          "snippet": "void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "tmp_leaf->lf_next"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_quota_hold",
          "args": [
            "dip",
            "NO_UID_QUOTA_CHANGE",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "530-585",
          "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "GFP_NOFS | __GFP_NOWARN | __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rlist",
            "0",
            "sizeof(struct gfs2_rgrp_list)"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,\n\t\t\tu64 leaf_no, struct buffer_head *leaf_bh,\n\t\t\tint last_dealloc)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,\n\t\t\t       PAGE_KERNEL);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t/*  Count the number of leaves  */\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_free_meta(dip, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t/* On the last dealloc, make this a regular file in case we crash.\n\t   (We don't want to free these blocks a second time.)  */\n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\n\tgfs2_quota_unhold(dip);\nout:\n\tkvfree(ht);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_dir_mvino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1832-1863",
    "snippet": "int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,\n\t\t   const struct gfs2_inode *nip, unsigned int new_type)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint error;\n\n\tdent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\tgfs2_inum_out(nip, dent);\n\tdent->de_type = cpu_to_be16(new_type);\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tbrelse(bh);\n\t\terror = gfs2_meta_inode_buffer(dip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_meta(dip->i_gl, bh);\n\t}\n\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(dip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "dip",
            "bh->b_data"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "dip->i_gl",
            "bh"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&bh"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "new_type"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inum_out",
          "args": [
            "nip",
            "dent"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inum_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "75-80",
          "snippet": "static inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "&dip->i_inode",
            "filename",
            "gfs2_dirent_find",
            "&bh"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,\n\t\t   const struct gfs2_inode *nip, unsigned int new_type)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint error;\n\n\tdent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\tgfs2_inum_out(nip, dent);\n\tdent->de_type = cpu_to_be16(new_type);\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tbrelse(bh);\n\t\terror = gfs2_meta_inode_buffer(dip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_meta(dip->i_gl, bh);\n\t}\n\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(dip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dir_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1772-1817",
    "snippet": "int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "&dip->i_inode"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "&dip->i_inode"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "tv.tv_sec"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tv.tv_nsec"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "--entries"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "leaf->lf_entries"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirent_del",
          "args": [
            "dip",
            "bh",
            "prev",
            "dent"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "dirent_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "644-678",
          "snippet": "static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "prev->de_rec_len"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_find",
          "args": [
            "dent",
            "name",
            "NULL"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_find_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "441-454",
          "snippet": "static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *opaque)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (totlen - actual >= required)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *opaque)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (totlen - actual >= required)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "&dip->i_inode",
            "name",
            "gfs2_dirent_prev",
            "&bh"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dir_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1693-1761",
    "snippet": "int gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_new_leaf",
          "args": [
            "inode",
            "name"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "dir_new_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1621-1667",
          "snippet": "static int dir_new_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct buffer_head *bh, *obh;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_leaf *leaf, *oleaf;\n\tu32 dist = 1;\n\tint error;\n\tu32 index;\n\tu64 bn;\n\n\tindex = name->hash >> (32 - ip->i_depth);\n\terror = get_first_leaf(ip, index, &obh);\n\tif (error)\n\t\treturn error;\n\tdo {\n\t\tdist++;\n\t\toleaf = (struct gfs2_leaf *)obh->b_data;\n\t\tbn = be64_to_cpu(oleaf->lf_next);\n\t\tif (!bn)\n\t\t\tbreak;\n\t\tbrelse(obh);\n\t\terror = get_leaf(ip, bn, &obh);\n\t\tif (error)\n\t\t\treturn error;\n\t} while(1);\n\n\tgfs2_trans_add_meta(ip->i_gl, obh);\n\n\tleaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));\n\tif (!leaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tleaf->lf_dist = cpu_to_be32(dist);\n\toleaf->lf_next = cpu_to_be64(bh->b_blocknr);\n\tbrelse(bh);\n\tbrelse(obh);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_new_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct buffer_head *bh, *obh;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_leaf *leaf, *oleaf;\n\tu32 dist = 1;\n\tint error;\n\tu32 index;\n\tu64 bn;\n\n\tindex = name->hash >> (32 - ip->i_depth);\n\terror = get_first_leaf(ip, index, &obh);\n\tif (error)\n\t\treturn error;\n\tdo {\n\t\tdist++;\n\t\toleaf = (struct gfs2_leaf *)obh->b_data;\n\t\tbn = be64_to_cpu(oleaf->lf_next);\n\t\tif (!bn)\n\t\t\tbreak;\n\t\tbrelse(obh);\n\t\terror = get_leaf(ip, bn, &obh);\n\t\tif (error)\n\t\t\treturn error;\n\t} while(1);\n\n\tgfs2_trans_add_meta(ip->i_gl, obh);\n\n\tleaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));\n\tif (!leaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tleaf->lf_dist = cpu_to_be32(dist);\n\toleaf->lf_next = cpu_to_be64(bh->b_blocknr);\n\tbrelse(bh);\n\tbrelse(obh);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_split_leaf",
          "args": [
            "inode",
            "name"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "dir_split_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "959-1100",
          "snippet": "static int dir_split_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x, moved = 0;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t/*  Get the old leaf block  */\n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1; /* can't split */\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t/*  Compute the start and len of leaf pointers in the hash table.  */\n\tlen = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tpr_warn(\"i_depth %u lf_depth %u index %u\\n\",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t/* Change the pointers.\n\t   Don't bother distinguishing stuffed from non-stuffed.\n\t   This code is complicated enough already. */\n\tlp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t/*  Change the pointers  */\n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t/*  Compute the divider  */\n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t/*  Copy the entries  */\n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n\n\tdo {\n\t\tnext = dent;\n\t\tif (dirent_next(dip, obh, &next))\n\t\t\tnext = NULL;\n\n\t\tif (!gfs2_dirent_sentinel(dent) &&\n\t\t    be32_to_cpu(dent->de_hash) < divider) {\n\t\t\tstruct qstr str;\n\t\t\tstr.name = (char*)(dent+1);\n\t\t\tstr.len = be16_to_cpu(dent->de_name_len);\n\t\t\tstr.hash = be32_to_cpu(dent->de_hash);\n\t\t\tnew = gfs2_dirent_alloc(inode, nbh, &str);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terror = PTR_ERR(new);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew->de_inum = dent->de_inum; /* No endian worries */\n\t\t\tnew->de_type = dent->de_type; /* No endian worries */\n\t\t\tbe16_add_cpu(&nleaf->lf_entries, 1);\n\n\t\t\tdirent_del(dip, obh, prev, dent);\n\n\t\t\tif (!oleaf->lf_entries)\n\t\t\t\tgfs2_consist_inode(dip);\n\t\t\tbe16_add_cpu(&oleaf->lf_entries, -1);\n\n\t\t\tif (!prev)\n\t\t\t\tprev = dent;\n\n\t\t\tmoved = 1;\n\t\t} else {\n\t\t\tprev = dent;\n\t\t}\n\t\tdent = next;\n\t} while (dent);\n\n\toleaf->lf_depth = nleaf->lf_depth;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {\n\t\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\t\tgfs2_dinode_out(dip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tbrelse(obh);\n\tbrelse(nbh);\n\n\treturn error;\n\nfail_lpfree:\n\tkfree(lp);\n\nfail_brelse:\n\tbrelse(obh);\n\tbrelse(nbh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_split_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x, moved = 0;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t/*  Get the old leaf block  */\n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1; /* can't split */\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t/*  Compute the start and len of leaf pointers in the hash table.  */\n\tlen = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tpr_warn(\"i_depth %u lf_depth %u index %u\\n\",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t/* Change the pointers.\n\t   Don't bother distinguishing stuffed from non-stuffed.\n\t   This code is complicated enough already. */\n\tlp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t/*  Change the pointers  */\n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t/*  Compute the divider  */\n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t/*  Copy the entries  */\n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n\n\tdo {\n\t\tnext = dent;\n\t\tif (dirent_next(dip, obh, &next))\n\t\t\tnext = NULL;\n\n\t\tif (!gfs2_dirent_sentinel(dent) &&\n\t\t    be32_to_cpu(dent->de_hash) < divider) {\n\t\t\tstruct qstr str;\n\t\t\tstr.name = (char*)(dent+1);\n\t\t\tstr.len = be16_to_cpu(dent->de_name_len);\n\t\t\tstr.hash = be32_to_cpu(dent->de_hash);\n\t\t\tnew = gfs2_dirent_alloc(inode, nbh, &str);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terror = PTR_ERR(new);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew->de_inum = dent->de_inum; /* No endian worries */\n\t\t\tnew->de_type = dent->de_type; /* No endian worries */\n\t\t\tbe16_add_cpu(&nleaf->lf_entries, 1);\n\n\t\t\tdirent_del(dip, obh, prev, dent);\n\n\t\t\tif (!oleaf->lf_entries)\n\t\t\t\tgfs2_consist_inode(dip);\n\t\t\tbe16_add_cpu(&oleaf->lf_entries, -1);\n\n\t\t\tif (!prev)\n\t\t\t\tprev = dent;\n\n\t\t\tmoved = 1;\n\t\t} else {\n\t\t\tprev = dent;\n\t\t}\n\t\tdent = next;\n\t} while (dent);\n\n\toleaf->lf_depth = nleaf->lf_depth;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {\n\t\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\t\tgfs2_dinode_out(dip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tbrelse(obh);\n\tbrelse(nbh);\n\n\treturn error;\n\nfail_lpfree:\n\tkfree(lp);\n\nfail_brelse:\n\tbrelse(obh);\n\tbrelse(nbh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_double_exhash",
          "args": [
            "ip"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "dir_double_exhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1109-1164",
          "snippet": "static int dir_double_exhash(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *dibh;\n\tu32 hsize;\n\tu32 hsize_bytes;\n\t__be64 *hc;\n\t__be64 *hc2, *h;\n\tint x;\n\tint error = 0;\n\n\thsize = 1 << dip->i_depth;\n\thsize_bytes = hsize * sizeof(__be64);\n\n\thc = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hc))\n\t\treturn PTR_ERR(hc);\n\n\thc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);\n\tif (hc2 == NULL)\n\t\thc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);\n\n\tif (!hc2)\n\t\treturn -ENOMEM;\n\n\th = hc2;\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tfor (x = 0; x < hsize; x++) {\n\t\t*h++ = *hc;\n\t\t*h++ = *hc;\n\t\thc++;\n\t}\n\n\terror = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);\n\tif (error != (hsize_bytes * 2))\n\t\tgoto fail;\n\n\tgfs2_dir_hash_inval(dip);\n\tdip->i_hash_cache = hc2;\n\tdip->i_depth++;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\treturn 0;\n\nfail:\n\t/* Replace original hash table & size */\n\tgfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);\n\ti_size_write(&dip->i_inode, hsize_bytes);\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\nout_kfree:\n\tkvfree(hc2);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_double_exhash(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *dibh;\n\tu32 hsize;\n\tu32 hsize_bytes;\n\t__be64 *hc;\n\t__be64 *hc2, *h;\n\tint x;\n\tint error = 0;\n\n\thsize = 1 << dip->i_depth;\n\thsize_bytes = hsize * sizeof(__be64);\n\n\thc = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hc))\n\t\treturn PTR_ERR(hc);\n\n\thc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);\n\tif (hc2 == NULL)\n\t\thc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);\n\n\tif (!hc2)\n\t\treturn -ENOMEM;\n\n\th = hc2;\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tfor (x = 0; x < hsize; x++) {\n\t\t*h++ = *hc;\n\t\t*h++ = *hc;\n\t\thc++;\n\t}\n\n\terror = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);\n\tif (error != (hsize_bytes * 2))\n\t\tgoto fail;\n\n\tgfs2_dir_hash_inval(dip);\n\tdip->i_hash_cache = hc2;\n\tdip->i_depth++;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\treturn 0;\n\nfail:\n\t/* Replace original hash table & size */\n\tgfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);\n\ti_size_write(&dip->i_inode, hsize_bytes);\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\nout_kfree:\n\tkvfree(hc2);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_make_exhash",
          "args": [
            "inode"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "dir_make_exhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "864-948",
          "snippet": "static int dir_make_exhash(struct inode *inode)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_dirent *dent;\n\tstruct qstr args;\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_leaf *leaf;\n\tint y;\n\tu32 x;\n\t__be64 *lp;\n\tu64 bn;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\t/*  Turn over a new leaf  */\n\n\tleaf = new_leaf(inode, &bh, 0);\n\tif (!leaf)\n\t\treturn -ENOSPC;\n\tbn = bh->b_blocknr;\n\n\tgfs2_assert(sdp, dip->i_entries < (1 << 16));\n\tleaf->lf_entries = cpu_to_be16(dip->i_entries);\n\n\t/*  Copy dirents  */\n\n\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,\n\t\t\t     sizeof(struct gfs2_dinode));\n\n\t/*  Find last entry  */\n\n\tx = 0;\n\targs.len = bh->b_size - sizeof(struct gfs2_dinode) +\n\t\t   sizeof(struct gfs2_leaf);\n\targs.name = bh->b_data;\n\tdent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_last, &args, NULL);\n\tif (!dent) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn PTR_ERR(dent);\n\t}\n\n\t/*  Adjust the last dirent's record length\n\t   (Remember that dent still points to the last entry.)  */\n\n\tdent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf));\n\n\tbrelse(bh);\n\n\t/*  We're done with the new leaf block, now setup the new\n\t    hash table.  */\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tlp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));\n\n\tfor (x = sdp->sd_hash_ptrs; x--; lp++)\n\t\t*lp = cpu_to_be64(bn);\n\n\ti_size_write(inode, sdp->sd_sb.sb_bsize / 2);\n\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\tdip->i_diskflags |= GFS2_DIF_EXHASH;\n\n\tfor (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;\n\tdip->i_depth = y;\n\n\tgfs2_dinode_out(dip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_make_exhash(struct inode *inode)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_dirent *dent;\n\tstruct qstr args;\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_leaf *leaf;\n\tint y;\n\tu32 x;\n\t__be64 *lp;\n\tu64 bn;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\t/*  Turn over a new leaf  */\n\n\tleaf = new_leaf(inode, &bh, 0);\n\tif (!leaf)\n\t\treturn -ENOSPC;\n\tbn = bh->b_blocknr;\n\n\tgfs2_assert(sdp, dip->i_entries < (1 << 16));\n\tleaf->lf_entries = cpu_to_be16(dip->i_entries);\n\n\t/*  Copy dirents  */\n\n\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,\n\t\t\t     sizeof(struct gfs2_dinode));\n\n\t/*  Find last entry  */\n\n\tx = 0;\n\targs.len = bh->b_size - sizeof(struct gfs2_dinode) +\n\t\t   sizeof(struct gfs2_leaf);\n\targs.name = bh->b_data;\n\tdent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_last, &args, NULL);\n\tif (!dent) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn PTR_ERR(dent);\n\t}\n\n\t/*  Adjust the last dirent's record length\n\t   (Remember that dent still points to the last entry.)  */\n\n\tdent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf));\n\n\tbrelse(bh);\n\n\t/*  We're done with the new leaf block, now setup the new\n\t    hash table.  */\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tlp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));\n\n\tfor (x = sdp->sd_hash_ptrs; x--; lp++)\n\t\t*lp = cpu_to_be64(bn);\n\n\ti_size_write(inode, sdp->sd_sb.sb_bsize / 2);\n\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\tdip->i_diskflags |= GFS2_DIF_EXHASH;\n\n\tfor (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;\n\tdip->i_depth = y;\n\n\tgfs2_dinode_out(dip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "nip->i_inode.i_mode"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "tv.tv_sec"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tv.tv_nsec"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&leaf->lf_entries",
            "1"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "gfs2_inode_ra_len(nip)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inode_ra_len",
          "args": [
            "nip"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_ra_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1669-1675",
          "snippet": "static u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)\n{\n\tu64 where = ip->i_no_addr + 1;\n\tif (ip->i_eattr == where)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)\n{\n\tu64 where = ip->i_no_addr + 1;\n\tif (ip->i_eattr == where)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "IF2DT(nip->i_inode.i_mode)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF2DT",
          "args": [
            "nip->i_inode.i_mode"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inum_out",
          "args": [
            "nip",
            "dent"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inum_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "75-80",
          "snippet": "static inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_init_dirent",
          "args": [
            "inode",
            "dent",
            "name",
            "bh"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_init_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "684-702",
          "snippet": "static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "inode",
            "name",
            "gfs2_dirent_find_space",
            "&bh"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_inode_ra_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1669-1675",
    "snippet": "static u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)\n{\n\tu64 where = ip->i_no_addr + 1;\n\tif (ip->i_eattr == where)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)\n{\n\tu64 where = ip->i_no_addr + 1;\n\tif (ip->i_eattr == where)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dir_new_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1621-1667",
    "snippet": "static int dir_new_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct buffer_head *bh, *obh;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_leaf *leaf, *oleaf;\n\tu32 dist = 1;\n\tint error;\n\tu32 index;\n\tu64 bn;\n\n\tindex = name->hash >> (32 - ip->i_depth);\n\terror = get_first_leaf(ip, index, &obh);\n\tif (error)\n\t\treturn error;\n\tdo {\n\t\tdist++;\n\t\toleaf = (struct gfs2_leaf *)obh->b_data;\n\t\tbn = be64_to_cpu(oleaf->lf_next);\n\t\tif (!bn)\n\t\t\tbreak;\n\t\tbrelse(obh);\n\t\terror = get_leaf(ip, bn, &obh);\n\t\tif (error)\n\t\t\treturn error;\n\t} while(1);\n\n\tgfs2_trans_add_meta(ip->i_gl, obh);\n\n\tleaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));\n\tif (!leaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tleaf->lf_dist = cpu_to_be32(dist);\n\toleaf->lf_next = cpu_to_be64(bh->b_blocknr);\n\tbrelse(bh);\n\tbrelse(obh);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "bh->b_data"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "1"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&bh"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dist"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_leaf",
          "args": [
            "inode",
            "&bh",
            "be16_to_cpu(oleaf->lf_depth)"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "new_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "819-855",
          "snippet": "static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oleaf->lf_depth"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "ip",
            "bn",
            "&obh"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oleaf->lf_next"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_leaf",
          "args": [
            "ip",
            "index",
            "&obh"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "751-762",
          "snippet": "static int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_new_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct buffer_head *bh, *obh;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_leaf *leaf, *oleaf;\n\tu32 dist = 1;\n\tint error;\n\tu32 index;\n\tu64 bn;\n\n\tindex = name->hash >> (32 - ip->i_depth);\n\terror = get_first_leaf(ip, index, &obh);\n\tif (error)\n\t\treturn error;\n\tdo {\n\t\tdist++;\n\t\toleaf = (struct gfs2_leaf *)obh->b_data;\n\t\tbn = be64_to_cpu(oleaf->lf_next);\n\t\tif (!bn)\n\t\t\tbreak;\n\t\tbrelse(obh);\n\t\terror = get_leaf(ip, bn, &obh);\n\t\tif (error)\n\t\t\treturn error;\n\t} while(1);\n\n\tgfs2_trans_add_meta(ip->i_gl, obh);\n\n\tleaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));\n\tif (!leaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tleaf->lf_dist = cpu_to_be32(dist);\n\toleaf->lf_next = cpu_to_be64(bh->b_blocknr);\n\tbrelse(bh);\n\tbrelse(obh);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dir_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1571-1600",
    "snippet": "int gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "GFS2_I(dir)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dir"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_type"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF2DT",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dent->de_inum.no_formal_ino"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dent->de_inum.no_addr"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "dir",
            "name",
            "gfs2_dirent_find",
            "&bh"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_dir_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1548-1569",
    "snippet": "struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inode_lookup",
          "args": [
            "dir->i_sb",
            "dtype",
            "addr",
            "formal_ino",
            "0"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "140-204",
          "snippet": "struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dent->de_inum.no_formal_ino"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dent->de_inum.no_addr"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_type"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "dent"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_search",
          "args": [
            "dir",
            "name",
            "gfs2_dirent_find",
            "&bh"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "764-817",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}"
  },
  {
    "function_name": "gfs2_dir_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1475-1534",
    "snippet": "int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,\n\t\t  struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t/* 96 is max number of dirents which can be stuffed into an inode */\n\tdarr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\tif (IS_ERR(dent)) {\n\t\t\terror = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dip->i_entries != g.offset) {\n\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\",\n\t\t\t\t(unsigned long long)dip->i_no_addr,\n\t\t\t\tdip->i_entries,\n\t\t\t\tg.offset);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\terror = do_filldir_main(dip, ctx, darr,\n\t\t\t\t\tdip->i_entries, &copied);\nout:\n\t\tkfree(darr);\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\tbrelse(dibh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "darr"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_filldir_main",
          "args": [
            "dip",
            "ctx",
            "darr",
            "dip->i_entries",
            "&copied"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "do_filldir_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1224-1280",
          "snippet": "static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\"",
            "(unsigned long long)dip->i_no_addr",
            "dip->i_entries",
            "g.offset"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_scan",
          "args": [
            "inode",
            "dibh->b_data",
            "dibh->b_size",
            "gfs2_dirent_gather",
            "NULL",
            "&g"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "531-580",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "96 * sizeof(struct gfs2_dirent *)",
            "GFP_NOFS"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&dibh"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "dip"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_e_read",
          "args": [
            "inode",
            "ctx",
            "f_ra"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "dir_e_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1436-1473",
          "snippet": "static int dir_e_read(struct inode *inode, struct dir_context *ctx,\n\t\t      struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = 1 << dip->i_depth;\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n\t\terror = gfs2_dir_read_leaf(inode, ctx,\n\t\t\t\t\t   &copied, &depth,\n\t\t\t\t\t   be64_to_cpu(lp[index]));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tlen = 1 << (dip->i_depth - depth);\n\t\tindex = (index & ~(len - 1)) + len;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_e_read(struct inode *inode, struct dir_context *ctx,\n\t\t      struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = 1 << dip->i_depth;\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n\t\terror = gfs2_dir_read_leaf(inode, ctx,\n\t\t\t\t\t   &copied, &depth,\n\t\t\t\t\t   be64_to_cpu(lp[index]));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tlen = 1 << (dip->i_depth - depth);\n\t\tindex = (index & ~(len - 1)) + len;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_read(struct inode *inode, struct dir_context *ctx,\n\t\t  struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t/* 96 is max number of dirents which can be stuffed into an inode */\n\tdarr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\tif (IS_ERR(dent)) {\n\t\t\terror = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dip->i_entries != g.offset) {\n\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\",\n\t\t\t\t(unsigned long long)dip->i_no_addr,\n\t\t\t\tdip->i_entries,\n\t\t\t\tg.offset);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\terror = do_filldir_main(dip, ctx, darr,\n\t\t\t\t\tdip->i_entries, &copied);\nout:\n\t\tkfree(darr);\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\tbrelse(dibh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "dir_e_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1436-1473",
    "snippet": "static int dir_e_read(struct inode *inode, struct dir_context *ctx,\n\t\t      struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = 1 << dip->i_depth;\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n\t\terror = gfs2_dir_read_leaf(inode, ctx,\n\t\t\t\t\t   &copied, &depth,\n\t\t\t\t\t   be64_to_cpu(lp[index]));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tlen = 1 << (dip->i_depth - depth);\n\t\tindex = (index & ~(len - 1)) + len;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_dir_read_leaf",
          "args": [
            "inode",
            "ctx",
            "&copied",
            "&depth",
            "be64_to_cpu(lp[index])"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_read_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1293-1379",
          "snippet": "static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,\n\t\t\t      int *copied, unsigned *depth,\n\t\t\t      u64 leaf_no)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *lf;\n\tunsigned entries = 0, entries2 = 0;\n\tunsigned leaves = 0;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct dirent_gather g;\n\tstruct buffer_head **larr;\n\tint leaf = 0;\n\tint error, i;\n\tu64 lfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tif (leaves == 0)\n\t\t\t*depth = be16_to_cpu(lf->lf_depth);\n\t\tentries += be16_to_cpu(lf->lf_entries);\n\t\tleaves++;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tbrelse(bh);\n\t} while(lfn);\n\n\tif (!entries)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\t/*\n\t * The extra 99 entries are not normally used, but are a buffer\n\t * zone in case the number of entries in the leaf is corrupt.\n\t * 99 is the maximum number of entries that can fit in a single\n\t * leaf block.\n\t */\n\tlarr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));\n\tif (!larr)\n\t\tgoto out;\n\tdarr = (const struct gfs2_dirent **)(larr + leaves);\n\tg.pdent = darr;\n\tg.offset = 0;\n\tlfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out_free;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tif (lf->lf_entries) {\n\t\t\tentries2 += be16_to_cpu(lf->lf_entries);\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\t\terror = PTR_ERR(dent);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto out_free;\n\t\t\tif (entries2 != g.offset) {\n\t\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\",\n\t\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\t\tentries2, g.offset);\n\t\t\t\t\t\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = 0;\n\t\t\tlarr[leaf++] = bh;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t} while(lfn);\n\n\tBUG_ON(entries2 != entries);\n\terror = do_filldir_main(ip, ctx, darr, entries, copied);\nout_free:\n\tfor(i = 0; i < leaf; i++)\n\t\tbrelse(larr[i]);\n\tkvfree(larr);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,\n\t\t\t      int *copied, unsigned *depth,\n\t\t\t      u64 leaf_no)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *lf;\n\tunsigned entries = 0, entries2 = 0;\n\tunsigned leaves = 0;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct dirent_gather g;\n\tstruct buffer_head **larr;\n\tint leaf = 0;\n\tint error, i;\n\tu64 lfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tif (leaves == 0)\n\t\t\t*depth = be16_to_cpu(lf->lf_depth);\n\t\tentries += be16_to_cpu(lf->lf_entries);\n\t\tleaves++;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tbrelse(bh);\n\t} while(lfn);\n\n\tif (!entries)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\t/*\n\t * The extra 99 entries are not normally used, but are a buffer\n\t * zone in case the number of entries in the leaf is corrupt.\n\t * 99 is the maximum number of entries that can fit in a single\n\t * leaf block.\n\t */\n\tlarr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));\n\tif (!larr)\n\t\tgoto out;\n\tdarr = (const struct gfs2_dirent **)(larr + leaves);\n\tg.pdent = darr;\n\tg.offset = 0;\n\tlfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out_free;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tif (lf->lf_entries) {\n\t\t\tentries2 += be16_to_cpu(lf->lf_entries);\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\t\terror = PTR_ERR(dent);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto out_free;\n\t\t\tif (entries2 != g.offset) {\n\t\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\",\n\t\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\t\tentries2, g.offset);\n\t\t\t\t\t\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = 0;\n\t\t\tlarr[leaf++] = bh;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t} while(lfn);\n\n\tBUG_ON(entries2 != entries);\n\terror = do_filldir_main(ip, ctx, darr, entries, copied);\nout_free:\n\tfor(i = 0; i < leaf; i++)\n\t\tbrelse(larr[i]);\n\tkvfree(larr);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lp[index]"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_readahead",
          "args": [
            "inode",
            "hsize",
            "index",
            "f_ra"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1389-1426",
          "snippet": "static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,\n\t\t\t       struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tu64 blocknr = 0, last;\n\tunsigned count;\n\n\t/* First check if we've already read-ahead for the whole range. */\n\tif (index + MAX_RA_BLOCKS < f_ra->start)\n\t\treturn;\n\n\tf_ra->start = max((pgoff_t)index, f_ra->start);\n\tfor (count = 0; count < MAX_RA_BLOCKS; count++) {\n\t\tif (f_ra->start >= hsize) /* if exceeded the hash table */\n\t\t\tbreak;\n\n\t\tlast = blocknr;\n\t\tblocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);\n\t\tf_ra->start++;\n\t\tif (blocknr == last)\n\t\t\tcontinue;\n\n\t\tbh = gfs2_getbuf(gl, blocknr, 1);\n\t\tif (trylock_buffer(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READA | REQ_META, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define MAX_RA_BLOCKS 32 /* max read-ahead blocks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define MAX_RA_BLOCKS 32 /* max read-ahead blocks */\n\nstatic void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,\n\t\t\t       struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tu64 blocknr = 0, last;\n\tunsigned count;\n\n\t/* First check if we've already read-ahead for the whole range. */\n\tif (index + MAX_RA_BLOCKS < f_ra->start)\n\t\treturn;\n\n\tf_ra->start = max((pgoff_t)index, f_ra->start);\n\tfor (count = 0; count < MAX_RA_BLOCKS; count++) {\n\t\tif (f_ra->start >= hsize) /* if exceeded the hash table */\n\t\t\tbreak;\n\n\t\tlast = blocknr;\n\t\tblocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);\n\t\tf_ra->start++;\n\t\tif (blocknr == last)\n\t\t\tcontinue;\n\n\t\tbh = gfs2_getbuf(gl, blocknr, 1);\n\t\tif (trylock_buffer(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READA | REQ_META, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lp"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lp"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_hash_table",
          "args": [
            "dip"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "339-381",
          "snippet": "static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_offset2hash",
          "args": [
            "ctx->pos"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_e_read(struct inode *inode, struct dir_context *ctx,\n\t\t      struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = 1 << dip->i_depth;\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n\t\terror = gfs2_dir_read_leaf(inode, ctx,\n\t\t\t\t\t   &copied, &depth,\n\t\t\t\t\t   be64_to_cpu(lp[index]));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tlen = 1 << (dip->i_depth - depth);\n\t\tindex = (index & ~(len - 1)) + len;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_dir_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1389-1426",
    "snippet": "static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,\n\t\t\t       struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tu64 blocknr = 0, last;\n\tunsigned count;\n\n\t/* First check if we've already read-ahead for the whole range. */\n\tif (index + MAX_RA_BLOCKS < f_ra->start)\n\t\treturn;\n\n\tf_ra->start = max((pgoff_t)index, f_ra->start);\n\tfor (count = 0; count < MAX_RA_BLOCKS; count++) {\n\t\tif (f_ra->start >= hsize) /* if exceeded the hash table */\n\t\t\tbreak;\n\n\t\tlast = blocknr;\n\t\tblocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);\n\t\tf_ra->start++;\n\t\tif (blocknr == last)\n\t\t\tcontinue;\n\n\t\tbh = gfs2_getbuf(gl, blocknr, 1);\n\t\tif (trylock_buffer(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READA | REQ_META, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bh);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define MAX_RA_BLOCKS 32 /* max read-ahead blocks */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READA | REQ_META",
            "bh"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_getbuf",
          "args": [
            "gl",
            "blocknr",
            "1"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_getbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "114-160",
          "snippet": "struct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\n{\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift;\n\tunsigned long index;\n\tunsigned int bufnum;\n\n\tif (mapping == NULL)\n\t\tmapping = &sdp->sd_aspace;\n\n\tshift = PAGE_CACHE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tindex = blkno >> shift;             /* convert block to page */\n\tbufnum = blkno - (index << shift);  /* block buf index within page */\n\n\tif (create) {\n\t\tfor (;;) {\n\t\t\tpage = grab_cache_page(mapping, index);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tyield();\n\t\t}\n\t} else {\n\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\tFGP_LOCK|FGP_ACCESSED);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\n\n\t/* Locate header for our buffer within our page */\n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t/* Do nothing */;\n\tget_bh(bh);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, sdp->sd_vfs, blkno);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\n{\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift;\n\tunsigned long index;\n\tunsigned int bufnum;\n\n\tif (mapping == NULL)\n\t\tmapping = &sdp->sd_aspace;\n\n\tshift = PAGE_CACHE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tindex = blkno >> shift;             /* convert block to page */\n\tbufnum = blkno - (index << shift);  /* block buf index within page */\n\n\tif (create) {\n\t\tfor (;;) {\n\t\t\tpage = grab_cache_page(mapping, index);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tyield();\n\t\t}\n\t} else {\n\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\tFGP_LOCK|FGP_ACCESSED);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t}\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\n\n\t/* Locate header for our buffer within our page */\n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t/* Do nothing */;\n\tget_bh(bh);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, sdp->sd_vfs, blkno);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ip->i_hash_cache[f_ra->start]"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(pgoff_t)index",
            "f_ra->start"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_max_rec_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1212-1238",
          "snippet": "static int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define MAX_RA_BLOCKS 32 /* max read-ahead blocks */\n\nstatic void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,\n\t\t\t       struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tu64 blocknr = 0, last;\n\tunsigned count;\n\n\t/* First check if we've already read-ahead for the whole range. */\n\tif (index + MAX_RA_BLOCKS < f_ra->start)\n\t\treturn;\n\n\tf_ra->start = max((pgoff_t)index, f_ra->start);\n\tfor (count = 0; count < MAX_RA_BLOCKS; count++) {\n\t\tif (f_ra->start >= hsize) /* if exceeded the hash table */\n\t\t\tbreak;\n\n\t\tlast = blocknr;\n\t\tblocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);\n\t\tf_ra->start++;\n\t\tif (blocknr == last)\n\t\t\tcontinue;\n\n\t\tbh = gfs2_getbuf(gl, blocknr, 1);\n\t\tif (trylock_buffer(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READA | REQ_META, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bh);\n\t}\n}"
  },
  {
    "function_name": "gfs2_dir_read_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1293-1379",
    "snippet": "static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,\n\t\t\t      int *copied, unsigned *depth,\n\t\t\t      u64 leaf_no)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *lf;\n\tunsigned entries = 0, entries2 = 0;\n\tunsigned leaves = 0;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct dirent_gather g;\n\tstruct buffer_head **larr;\n\tint leaf = 0;\n\tint error, i;\n\tu64 lfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tif (leaves == 0)\n\t\t\t*depth = be16_to_cpu(lf->lf_depth);\n\t\tentries += be16_to_cpu(lf->lf_entries);\n\t\tleaves++;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tbrelse(bh);\n\t} while(lfn);\n\n\tif (!entries)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\t/*\n\t * The extra 99 entries are not normally used, but are a buffer\n\t * zone in case the number of entries in the leaf is corrupt.\n\t * 99 is the maximum number of entries that can fit in a single\n\t * leaf block.\n\t */\n\tlarr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));\n\tif (!larr)\n\t\tgoto out;\n\tdarr = (const struct gfs2_dirent **)(larr + leaves);\n\tg.pdent = darr;\n\tg.offset = 0;\n\tlfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out_free;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tif (lf->lf_entries) {\n\t\t\tentries2 += be16_to_cpu(lf->lf_entries);\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\t\terror = PTR_ERR(dent);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto out_free;\n\t\t\tif (entries2 != g.offset) {\n\t\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\",\n\t\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\t\tentries2, g.offset);\n\t\t\t\t\t\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = 0;\n\t\t\tlarr[leaf++] = bh;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t} while(lfn);\n\n\tBUG_ON(entries2 != entries);\n\terror = do_filldir_main(ip, ctx, darr, entries, copied);\nout_free:\n\tfor(i = 0; i < leaf; i++)\n\t\tbrelse(larr[i]);\n\tkvfree(larr);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "larr"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "larr[i]"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_filldir_main",
          "args": [
            "ip",
            "ctx",
            "darr",
            "entries",
            "copied"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "do_filldir_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1224-1280",
          "snippet": "static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "entries2 != entries"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "entries2",
            "g.offset"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_scan",
          "args": [
            "inode",
            "bh->b_data",
            "bh->b_size",
            "gfs2_dirent_gather",
            "NULL",
            "&g"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "531-580",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lf->lf_entries"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lf->lf_next"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "ip",
            "lfn",
            "&bh"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_sort_buffer",
          "args": [
            "(leaves + entries + 99) * sizeof(void *)"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_sort_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1282-1291",
          "snippet": "static void *gfs2_alloc_sort_buffer(unsigned size)\n{\n\tvoid *ptr = NULL;\n\n\tif (size < KMALLOC_MAX_SIZE)\n\t\tptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (!ptr)\n\t\tptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);\n\treturn ptr;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void *gfs2_alloc_sort_buffer(unsigned size)\n{\n\tvoid *ptr = NULL;\n\n\tif (size < KMALLOC_MAX_SIZE)\n\t\tptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (!ptr)\n\t\tptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lf->lf_next"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lf->lf_entries"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lf->lf_depth"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,\n\t\t\t      int *copied, unsigned *depth,\n\t\t\t      u64 leaf_no)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *lf;\n\tunsigned entries = 0, entries2 = 0;\n\tunsigned leaves = 0;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct dirent_gather g;\n\tstruct buffer_head **larr;\n\tint leaf = 0;\n\tint error, i;\n\tu64 lfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tif (leaves == 0)\n\t\t\t*depth = be16_to_cpu(lf->lf_depth);\n\t\tentries += be16_to_cpu(lf->lf_entries);\n\t\tleaves++;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tbrelse(bh);\n\t} while(lfn);\n\n\tif (!entries)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\t/*\n\t * The extra 99 entries are not normally used, but are a buffer\n\t * zone in case the number of entries in the leaf is corrupt.\n\t * 99 is the maximum number of entries that can fit in a single\n\t * leaf block.\n\t */\n\tlarr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));\n\tif (!larr)\n\t\tgoto out;\n\tdarr = (const struct gfs2_dirent **)(larr + leaves);\n\tg.pdent = darr;\n\tg.offset = 0;\n\tlfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out_free;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tif (lf->lf_entries) {\n\t\t\tentries2 += be16_to_cpu(lf->lf_entries);\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\t\terror = PTR_ERR(dent);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto out_free;\n\t\t\tif (entries2 != g.offset) {\n\t\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\",\n\t\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\t\tentries2, g.offset);\n\t\t\t\t\t\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = 0;\n\t\t\tlarr[leaf++] = bh;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t} while(lfn);\n\n\tBUG_ON(entries2 != entries);\n\terror = do_filldir_main(ip, ctx, darr, entries, copied);\nout_free:\n\tfor(i = 0; i < leaf; i++)\n\t\tbrelse(larr[i]);\n\tkvfree(larr);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_alloc_sort_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1282-1291",
    "snippet": "static void *gfs2_alloc_sort_buffer(unsigned size)\n{\n\tvoid *ptr = NULL;\n\n\tif (size < KMALLOC_MAX_SIZE)\n\t\tptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (!ptr)\n\t\tptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);\n\treturn ptr;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "GFP_NOFS",
            "PAGE_KERNEL"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void *gfs2_alloc_sort_buffer(unsigned size)\n{\n\tvoid *ptr = NULL;\n\n\tif (size < KMALLOC_MAX_SIZE)\n\t\tptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (!ptr)\n\t\tptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);\n\treturn ptr;\n}"
  },
  {
    "function_name": "do_filldir_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1224-1280",
    "snippet": "static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "(const char *)(dent + 1)",
            "be16_to_cpu(dent->de_name_len)",
            "be64_to_cpu(dent->de_inum.no_addr)",
            "be16_to_cpu(dent->de_type)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_type"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dent->de_inum.no_addr"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_disk_hash2offset",
          "args": [
            "off_next"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent_next->de_hash"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_disk_hash2offset",
          "args": [
            "off_next"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent_next->de_hash"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "darr",
            "entries",
            "sizeof(struct gfs2_dirent *)",
            "compare_dents",
            "NULL"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   const struct gfs2_dirent **darr, u32 entries,\n\t\t\t   int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tsort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = be32_to_cpu(dent_next->de_hash);\n\toff_next = gfs2_disk_hash2offset(off_next);\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = be32_to_cpu(dent_next->de_hash);\n\t\t\toff_next = gfs2_disk_hash2offset(off_next);\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t/* Increment the ctx->pos by one, so the next time we come into the\n\t   do_filldir fxn, we get the next entry instead of the last one in the\n\t   current leaf */\n\n\tctx->pos++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "compare_dents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1177-1206",
    "snippet": "static int compare_dents(const void *a, const void *b)\n{\n\tconst struct gfs2_dirent *dent_a, *dent_b;\n\tu32 hash_a, hash_b;\n\tint ret = 0;\n\n\tdent_a = *(const struct gfs2_dirent **)a;\n\thash_a = be32_to_cpu(dent_a->de_hash);\n\n\tdent_b = *(const struct gfs2_dirent **)b;\n\thash_b = be32_to_cpu(dent_b->de_hash);\n\n\tif (hash_a > hash_b)\n\t\tret = 1;\n\telse if (hash_a < hash_b)\n\t\tret = -1;\n\telse {\n\t\tunsigned int len_a = be16_to_cpu(dent_a->de_name_len);\n\t\tunsigned int len_b = be16_to_cpu(dent_b->de_name_len);\n\n\t\tif (len_a > len_b)\n\t\t\tret = 1;\n\t\telse if (len_a < len_b)\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = memcmp(dent_a + 1, dent_b + 1, len_a);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dent_a + 1",
            "dent_b + 1",
            "len_a"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent_b->de_name_len"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent_a->de_name_len"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent_b->de_hash"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent_a->de_hash"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int compare_dents(const void *a, const void *b)\n{\n\tconst struct gfs2_dirent *dent_a, *dent_b;\n\tu32 hash_a, hash_b;\n\tint ret = 0;\n\n\tdent_a = *(const struct gfs2_dirent **)a;\n\thash_a = be32_to_cpu(dent_a->de_hash);\n\n\tdent_b = *(const struct gfs2_dirent **)b;\n\thash_b = be32_to_cpu(dent_b->de_hash);\n\n\tif (hash_a > hash_b)\n\t\tret = 1;\n\telse if (hash_a < hash_b)\n\t\tret = -1;\n\telse {\n\t\tunsigned int len_a = be16_to_cpu(dent_a->de_name_len);\n\t\tunsigned int len_b = be16_to_cpu(dent_b->de_name_len);\n\n\t\tif (len_a > len_b)\n\t\t\tret = 1;\n\t\telse if (len_a < len_b)\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = memcmp(dent_a + 1, dent_b + 1, len_a);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dir_double_exhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "1109-1164",
    "snippet": "static int dir_double_exhash(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *dibh;\n\tu32 hsize;\n\tu32 hsize_bytes;\n\t__be64 *hc;\n\t__be64 *hc2, *h;\n\tint x;\n\tint error = 0;\n\n\thsize = 1 << dip->i_depth;\n\thsize_bytes = hsize * sizeof(__be64);\n\n\thc = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hc))\n\t\treturn PTR_ERR(hc);\n\n\thc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);\n\tif (hc2 == NULL)\n\t\thc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);\n\n\tif (!hc2)\n\t\treturn -ENOMEM;\n\n\th = hc2;\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tfor (x = 0; x < hsize; x++) {\n\t\t*h++ = *hc;\n\t\t*h++ = *hc;\n\t\thc++;\n\t}\n\n\terror = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);\n\tif (error != (hsize_bytes * 2))\n\t\tgoto fail;\n\n\tgfs2_dir_hash_inval(dip);\n\tdip->i_hash_cache = hc2;\n\tdip->i_depth++;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\treturn 0;\n\nfail:\n\t/* Replace original hash table & size */\n\tgfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);\n\ti_size_write(&dip->i_inode, hsize_bytes);\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\nout_kfree:\n\tkvfree(hc2);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "hc2"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "dip",
            "dibh->b_data"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&dip->i_inode",
            "hsize_bytes"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_write_data",
          "args": [
            "dip",
            "(char *)hc",
            "0",
            "hsize_bytes"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "155-245",
          "snippet": "static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_hash_inval",
          "args": [
            "dip"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_hash_inval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "389-394",
          "snippet": "void gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&dibh"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "hsize_bytes * 2",
            "GFP_NOFS",
            "PAGE_KERNEL"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hsize_bytes * 2",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hc"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hc"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_hash_table",
          "args": [
            "dip"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "339-381",
          "snippet": "static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_double_exhash(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *dibh;\n\tu32 hsize;\n\tu32 hsize_bytes;\n\t__be64 *hc;\n\t__be64 *hc2, *h;\n\tint x;\n\tint error = 0;\n\n\thsize = 1 << dip->i_depth;\n\thsize_bytes = hsize * sizeof(__be64);\n\n\thc = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hc))\n\t\treturn PTR_ERR(hc);\n\n\thc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);\n\tif (hc2 == NULL)\n\t\thc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);\n\n\tif (!hc2)\n\t\treturn -ENOMEM;\n\n\th = hc2;\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tfor (x = 0; x < hsize; x++) {\n\t\t*h++ = *hc;\n\t\t*h++ = *hc;\n\t\thc++;\n\t}\n\n\terror = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);\n\tif (error != (hsize_bytes * 2))\n\t\tgoto fail;\n\n\tgfs2_dir_hash_inval(dip);\n\tdip->i_hash_cache = hc2;\n\tdip->i_depth++;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\treturn 0;\n\nfail:\n\t/* Replace original hash table & size */\n\tgfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);\n\ti_size_write(&dip->i_inode, hsize_bytes);\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\nout_kfree:\n\tkvfree(hc2);\n\treturn error;\n}"
  },
  {
    "function_name": "dir_split_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "959-1100",
    "snippet": "static int dir_split_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x, moved = 0;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t/*  Get the old leaf block  */\n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1; /* can't split */\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t/*  Compute the start and len of leaf pointers in the hash table.  */\n\tlen = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tpr_warn(\"i_depth %u lf_depth %u index %u\\n\",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t/* Change the pointers.\n\t   Don't bother distinguishing stuffed from non-stuffed.\n\t   This code is complicated enough already. */\n\tlp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t/*  Change the pointers  */\n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t/*  Compute the divider  */\n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t/*  Copy the entries  */\n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n\n\tdo {\n\t\tnext = dent;\n\t\tif (dirent_next(dip, obh, &next))\n\t\t\tnext = NULL;\n\n\t\tif (!gfs2_dirent_sentinel(dent) &&\n\t\t    be32_to_cpu(dent->de_hash) < divider) {\n\t\t\tstruct qstr str;\n\t\t\tstr.name = (char*)(dent+1);\n\t\t\tstr.len = be16_to_cpu(dent->de_name_len);\n\t\t\tstr.hash = be32_to_cpu(dent->de_hash);\n\t\t\tnew = gfs2_dirent_alloc(inode, nbh, &str);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terror = PTR_ERR(new);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew->de_inum = dent->de_inum; /* No endian worries */\n\t\t\tnew->de_type = dent->de_type; /* No endian worries */\n\t\t\tbe16_add_cpu(&nleaf->lf_entries, 1);\n\n\t\t\tdirent_del(dip, obh, prev, dent);\n\n\t\t\tif (!oleaf->lf_entries)\n\t\t\t\tgfs2_consist_inode(dip);\n\t\t\tbe16_add_cpu(&oleaf->lf_entries, -1);\n\n\t\t\tif (!prev)\n\t\t\t\tprev = dent;\n\n\t\t\tmoved = 1;\n\t\t} else {\n\t\t\tprev = dent;\n\t\t}\n\t\tdent = next;\n\t} while (dent);\n\n\toleaf->lf_depth = nleaf->lf_depth;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {\n\t\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\t\tgfs2_dinode_out(dip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tbrelse(obh);\n\tbrelse(nbh);\n\n\treturn error;\n\nfail_lpfree:\n\tkfree(lp);\n\nfail_brelse:\n\tbrelse(obh);\n\tbrelse(nbh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nbh"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lp"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "dip",
            "dibh->b_data"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&dip->i_inode",
            "1"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "dip->i_gl",
            "dibh"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "GFS2_SB(&dip->i_inode)",
            "!error"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&dibh"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&oleaf->lf_entries",
            "-1"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirent_del",
          "args": [
            "dip",
            "obh",
            "prev",
            "dent"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "dirent_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "644-678",
          "snippet": "static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&nleaf->lf_entries",
            "1"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_alloc",
          "args": [
            "inode",
            "nbh",
            "&str"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "704-714",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     const struct qstr *name)\n{\n\tstruct gfs2_dirent *dent;\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_find_space, name, NULL);\n\tif (!dent || IS_ERR(dent))\n\t\treturn dent;\n\treturn gfs2_init_dirent(inode, dent, name, bh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     const struct qstr *name)\n{\n\tstruct gfs2_dirent *dent;\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_find_space, name, NULL);\n\tif (!dent || IS_ERR(dent))\n\t\treturn dent;\n\treturn gfs2_init_dirent(inode, dent, name, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent->de_hash"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent->de_hash"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirent_next",
          "args": [
            "dip",
            "obh",
            "&next"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "dirent_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "609-633",
          "snippet": "static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent **dent)\n{\n\tstruct gfs2_dirent *cur = *dent, *tmp;\n\tchar *bh_end = bh->b_data + bh->b_size;\n\tint ret;\n\n\tret = dirent_check_reclen(dip, cur, bh_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = (void *)cur + ret;\n\tret = dirent_check_reclen(dip, tmp, bh_end);\n\tif (ret == -EIO)\n\t\treturn ret;\n\n        /* Only the first dent could ever have de_inum.no_addr == 0 */\n\tif (gfs2_dirent_sentinel(tmp)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\t*dent = tmp;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent **dent)\n{\n\tstruct gfs2_dirent *cur = *dent, *tmp;\n\tchar *bh_end = bh->b_data + bh->b_size;\n\tint ret;\n\n\tret = dirent_check_reclen(dip, cur, bh_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = (void *)cur + ret;\n\tret = dirent_check_reclen(dip, tmp, bh_end);\n\tif (ret == -EIO)\n\t\treturn ret;\n\n        /* Only the first dent could ever have de_inum.no_addr == 0 */\n\tif (gfs2_dirent_sentinel(tmp)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\t*dent = tmp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lp"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_write_data",
          "args": [
            "dip",
            "(char *)lp",
            "start * sizeof(u64)",
            "half_len * sizeof(u64)"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "155-245",
          "snippet": "static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_hash_inval",
          "args": [
            "dip"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_hash_inval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "389-394",
          "snippet": "void gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bn"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "half_len * sizeof(__be64)",
            "GFP_NOFS"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"i_depth %u lf_depth %u index %u\\n\"",
            "dip->i_depth",
            "be16_to_cpu(oleaf->lf_depth)",
            "index"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oleaf->lf_depth"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oleaf->lf_depth"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_leaf",
          "args": [
            "inode",
            "&nbh",
            "be16_to_cpu(oleaf->lf_depth) + 1"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "new_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "819-855",
          "snippet": "static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oleaf->lf_depth"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oleaf->lf_depth"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "dip",
            "leaf_no",
            "&obh"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_split_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x, moved = 0;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t/*  Get the old leaf block  */\n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1; /* can't split */\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t/*  Compute the start and len of leaf pointers in the hash table.  */\n\tlen = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tpr_warn(\"i_depth %u lf_depth %u index %u\\n\",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t/* Change the pointers.\n\t   Don't bother distinguishing stuffed from non-stuffed.\n\t   This code is complicated enough already. */\n\tlp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t/*  Change the pointers  */\n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t/*  Compute the divider  */\n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t/*  Copy the entries  */\n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n\n\tdo {\n\t\tnext = dent;\n\t\tif (dirent_next(dip, obh, &next))\n\t\t\tnext = NULL;\n\n\t\tif (!gfs2_dirent_sentinel(dent) &&\n\t\t    be32_to_cpu(dent->de_hash) < divider) {\n\t\t\tstruct qstr str;\n\t\t\tstr.name = (char*)(dent+1);\n\t\t\tstr.len = be16_to_cpu(dent->de_name_len);\n\t\t\tstr.hash = be32_to_cpu(dent->de_hash);\n\t\t\tnew = gfs2_dirent_alloc(inode, nbh, &str);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terror = PTR_ERR(new);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew->de_inum = dent->de_inum; /* No endian worries */\n\t\t\tnew->de_type = dent->de_type; /* No endian worries */\n\t\t\tbe16_add_cpu(&nleaf->lf_entries, 1);\n\n\t\t\tdirent_del(dip, obh, prev, dent);\n\n\t\t\tif (!oleaf->lf_entries)\n\t\t\t\tgfs2_consist_inode(dip);\n\t\t\tbe16_add_cpu(&oleaf->lf_entries, -1);\n\n\t\t\tif (!prev)\n\t\t\t\tprev = dent;\n\n\t\t\tmoved = 1;\n\t\t} else {\n\t\t\tprev = dent;\n\t\t}\n\t\tdent = next;\n\t} while (dent);\n\n\toleaf->lf_depth = nleaf->lf_depth;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {\n\t\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\t\tgfs2_dinode_out(dip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tbrelse(obh);\n\tbrelse(nbh);\n\n\treturn error;\n\nfail_lpfree:\n\tkfree(lp);\n\nfail_brelse:\n\tbrelse(obh);\n\tbrelse(nbh);\n\treturn error;\n}"
  },
  {
    "function_name": "dir_make_exhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "864-948",
    "snippet": "static int dir_make_exhash(struct inode *inode)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_dirent *dent;\n\tstruct qstr args;\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_leaf *leaf;\n\tint y;\n\tu32 x;\n\t__be64 *lp;\n\tu64 bn;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\t/*  Turn over a new leaf  */\n\n\tleaf = new_leaf(inode, &bh, 0);\n\tif (!leaf)\n\t\treturn -ENOSPC;\n\tbn = bh->b_blocknr;\n\n\tgfs2_assert(sdp, dip->i_entries < (1 << 16));\n\tleaf->lf_entries = cpu_to_be16(dip->i_entries);\n\n\t/*  Copy dirents  */\n\n\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,\n\t\t\t     sizeof(struct gfs2_dinode));\n\n\t/*  Find last entry  */\n\n\tx = 0;\n\targs.len = bh->b_size - sizeof(struct gfs2_dinode) +\n\t\t   sizeof(struct gfs2_leaf);\n\targs.name = bh->b_data;\n\tdent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_last, &args, NULL);\n\tif (!dent) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn PTR_ERR(dent);\n\t}\n\n\t/*  Adjust the last dirent's record length\n\t   (Remember that dent still points to the last entry.)  */\n\n\tdent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf));\n\n\tbrelse(bh);\n\n\t/*  We're done with the new leaf block, now setup the new\n\t    hash table.  */\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tlp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));\n\n\tfor (x = sdp->sd_hash_ptrs; x--; lp++)\n\t\t*lp = cpu_to_be64(bn);\n\n\ti_size_write(inode, sdp->sd_sb.sb_bsize / 2);\n\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\tdip->i_diskflags |= GFS2_DIF_EXHASH;\n\n\tfor (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;\n\tdip->i_depth = y;\n\n\tgfs2_dinode_out(dip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "dip",
            "dibh->b_data"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&dip->i_inode",
            "1"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "sdp->sd_sb.sb_bsize / 2"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bn"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "dip->i_gl",
            "dibh"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_scan",
          "args": [
            "&dip->i_inode",
            "bh->b_data",
            "bh->b_size",
            "gfs2_dirent_last",
            "&args",
            "NULL"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "531-580",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_copy_tail",
          "args": [
            "bh",
            "sizeof(struct gfs2_leaf)",
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_copy_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "28-38",
          "snippet": "static inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_copy_tail(struct buffer_head *to_bh,\n\t\t\t\t\t int to_head,\n\t\t\t\t\t struct buffer_head *from_bh,\n\t\t\t\t\t int from_head)\n{\n\tBUG_ON(from_head < to_head);\n\tmemcpy(to_bh->b_data + to_head, from_bh->b_data + from_head,\n\t       from_bh->b_size - from_head);\n\tmemset(to_bh->b_data + to_bh->b_size + to_head - from_head,\n\t       0, from_head - to_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "dip->i_entries"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "dip->i_entries < (1 << 16)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_leaf",
          "args": [
            "inode",
            "&bh",
            "0"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "new_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "819-855",
          "snippet": "static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "dip",
            "&dibh"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dir_make_exhash(struct inode *inode)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_dirent *dent;\n\tstruct qstr args;\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_leaf *leaf;\n\tint y;\n\tu32 x;\n\t__be64 *lp;\n\tu64 bn;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\t/*  Turn over a new leaf  */\n\n\tleaf = new_leaf(inode, &bh, 0);\n\tif (!leaf)\n\t\treturn -ENOSPC;\n\tbn = bh->b_blocknr;\n\n\tgfs2_assert(sdp, dip->i_entries < (1 << 16));\n\tleaf->lf_entries = cpu_to_be16(dip->i_entries);\n\n\t/*  Copy dirents  */\n\n\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,\n\t\t\t     sizeof(struct gfs2_dinode));\n\n\t/*  Find last entry  */\n\n\tx = 0;\n\targs.len = bh->b_size - sizeof(struct gfs2_dinode) +\n\t\t   sizeof(struct gfs2_leaf);\n\targs.name = bh->b_data;\n\tdent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_last, &args, NULL);\n\tif (!dent) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn PTR_ERR(dent);\n\t}\n\n\t/*  Adjust the last dirent's record length\n\t   (Remember that dent still points to the last entry.)  */\n\n\tdent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf));\n\n\tbrelse(bh);\n\n\t/*  We're done with the new leaf block, now setup the new\n\t    hash table.  */\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tlp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));\n\n\tfor (x = sdp->sd_hash_ptrs; x--; lp++)\n\t\t*lp = cpu_to_be64(bn);\n\n\ti_size_write(inode, sdp->sd_sb.sb_bsize / 2);\n\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\tdip->i_diskflags |= GFS2_DIF_EXHASH;\n\n\tfor (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;\n\tdip->i_depth = y;\n\n\tgfs2_dinode_out(dip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "new_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "819-855",
    "snippet": "static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_qstr2dirent",
          "args": [
            "&name",
            "bh->b_size - sizeof(struct gfs2_leaf)",
            "dent"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qstr2dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "71-81",
          "snippet": "static inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "leaf->lf_reserved2",
            "0",
            "sizeof(leaf->lf_reserved2)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "tv.tv_sec"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tv.tv_nsec"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ip->i_no_addr"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_FORMAT_DE"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "depth"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "bh",
            "GFS2_METATYPE_LF",
            "GFS2_FORMAT_LF"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "GFS2_SB(inode)",
            "bn",
            "1"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "bn"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&bn",
            "&n",
            "0",
            "NULL"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct qstr name = { .name = \"\" };\n\tstruct timespec tv = CURRENT_TIME;\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}"
  },
  {
    "function_name": "gfs2_dirent_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "764-817",
    "snippet": "static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dent == NULL || IS_ERR(dent)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_scan",
          "args": [
            "inode",
            "bh->b_data",
            "bh->b_size",
            "scan",
            "name",
            "NULL"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "531-580",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&bh"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "ip",
            "ln",
            "&bh"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "leaf->lf_next"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_leaf",
          "args": [
            "ip",
            "index",
            "&bh"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "751-762",
          "snippet": "static int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned hsize = 1 << ip->i_depth;\n\t\tunsigned index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (unlikely(dent == NULL || IS_ERR(dent))) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}"
  },
  {
    "function_name": "get_first_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "751-762",
    "snippet": "static int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_leaf",
          "args": [
            "dip",
            "leaf_no",
            "bh_out"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "get_leaf_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "739-749",
          "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}"
  },
  {
    "function_name": "get_leaf_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "739-749",
    "snippet": "static int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*(hash + index)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hash"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hash"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_hash_table",
          "args": [
            "dip"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "339-381",
          "snippet": "static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index,\n\t\t       u64 *leaf_out)\n{\n\t__be64 *hash;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hash))\n\t\treturn PTR_ERR(hash);\n\t*leaf_out = be64_to_cpu(*(hash + index));\n\treturn 0;\n}"
  },
  {
    "function_name": "get_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "716-728",
    "snippet": "static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,\n\t\t    struct buffer_head **bhp)\n{\n\tint error;\n\n\terror = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);\n\tif (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {\n\t\t/* pr_info(\"block num=%llu\\n\", leaf_no); */\n\t\terror = -EIO;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "GFS2_SB(&dip->i_inode)",
            "*bhp",
            "GFS2_METATYPE_LF"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "dip->i_gl",
            "leaf_no",
            "DIO_WAIT",
            "bhp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int get_leaf(struct gfs2_inode *dip, u64 leaf_no,\n\t\t    struct buffer_head **bhp)\n{\n\tint error;\n\n\terror = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);\n\tif (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {\n\t\t/* pr_info(\"block num=%llu\\n\", leaf_no); */\n\t\terror = -EIO;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_dirent_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "704-714",
    "snippet": "static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     const struct qstr *name)\n{\n\tstruct gfs2_dirent *dent;\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_find_space, name, NULL);\n\tif (!dent || IS_ERR(dent))\n\t\treturn dent;\n\treturn gfs2_init_dirent(inode, dent, name, bh);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_init_dirent",
          "args": [
            "inode",
            "dent",
            "name",
            "bh"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_init_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "684-702",
          "snippet": "static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_scan",
          "args": [
            "inode",
            "bh->b_data",
            "bh->b_size",
            "gfs2_dirent_find_space",
            "name",
            "NULL"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "531-580",
          "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     const struct qstr *name)\n{\n\tstruct gfs2_dirent *dent;\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_find_space, name, NULL);\n\tif (!dent || IS_ERR(dent))\n\t\treturn dent;\n\treturn gfs2_init_dirent(inode, dent, name, bh);\n}"
  },
  {
    "function_name": "gfs2_init_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "684-702",
    "snippet": "static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_qstr2dirent",
          "args": [
            "name",
            "totlen - offset",
            "ndent"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qstr2dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "71-81",
          "snippet": "static inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "offset"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset + name->len > totlen"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "be16_to_cpu(dent->de_name_len)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned offset = 0, totlen;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}"
  },
  {
    "function_name": "dirent_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "644-678",
    "snippet": "static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "prev_rec_len"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "cur->de_rec_len"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "prev->de_rec_len"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "dip->i_gl",
            "bh"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "cur"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t/* If there is no prev entry, this is the first entry in the block.\n\t   The de_rec_len is already as big as it needs to be.  Just zero\n\t   out the inode number and return.  */\n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t/*  Combine this dentry with the previous one.  */\n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}"
  },
  {
    "function_name": "dirent_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "609-633",
    "snippet": "static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent **dent)\n{\n\tstruct gfs2_dirent *cur = *dent, *tmp;\n\tchar *bh_end = bh->b_data + bh->b_size;\n\tint ret;\n\n\tret = dirent_check_reclen(dip, cur, bh_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = (void *)cur + ret;\n\tret = dirent_check_reclen(dip, tmp, bh_end);\n\tif (ret == -EIO)\n\t\treturn ret;\n\n        /* Only the first dent could ever have de_inum.no_addr == 0 */\n\tif (gfs2_dirent_sentinel(tmp)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\t*dent = tmp;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "tmp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirent_check_reclen",
          "args": [
            "dip",
            "tmp",
            "bh_end"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "dirent_check_reclen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "582-598",
          "snippet": "static int dirent_check_reclen(struct gfs2_inode *dip,\n\t\t\t       const struct gfs2_dirent *d, const void *end_p)\n{\n\tconst void *ptr = d;\n\tu16 rec_len = be16_to_cpu(d->de_rec_len);\n\n\tif (unlikely(rec_len < sizeof(struct gfs2_dirent)))\n\t\tgoto broken;\n\tptr += rec_len;\n\tif (ptr < end_p)\n\t\treturn rec_len;\n\tif (ptr == end_p)\n\t\treturn -ENOENT;\nbroken:\n\tgfs2_consist_inode(dip);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dirent_check_reclen(struct gfs2_inode *dip,\n\t\t\t       const struct gfs2_dirent *d, const void *end_p)\n{\n\tconst void *ptr = d;\n\tu16 rec_len = be16_to_cpu(d->de_rec_len);\n\n\tif (unlikely(rec_len < sizeof(struct gfs2_dirent)))\n\t\tgoto broken;\n\tptr += rec_len;\n\tif (ptr < end_p)\n\t\treturn rec_len;\n\tif (ptr == end_p)\n\t\treturn -ENOENT;\nbroken:\n\tgfs2_consist_inode(dip);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent **dent)\n{\n\tstruct gfs2_dirent *cur = *dent, *tmp;\n\tchar *bh_end = bh->b_data + bh->b_size;\n\tint ret;\n\n\tret = dirent_check_reclen(dip, cur, bh_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = (void *)cur + ret;\n\tret = dirent_check_reclen(dip, tmp, bh_end);\n\tif (ret == -EIO)\n\t\treturn ret;\n\n        /* Only the first dent could ever have de_inum.no_addr == 0 */\n\tif (gfs2_dirent_sentinel(tmp)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\t*dent = tmp;\n\treturn 0;\n}"
  },
  {
    "function_name": "dirent_check_reclen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "582-598",
    "snippet": "static int dirent_check_reclen(struct gfs2_inode *dip,\n\t\t\t       const struct gfs2_dirent *d, const void *end_p)\n{\n\tconst void *ptr = d;\n\tu16 rec_len = be16_to_cpu(d->de_rec_len);\n\n\tif (unlikely(rec_len < sizeof(struct gfs2_dirent)))\n\t\tgoto broken;\n\tptr += rec_len;\n\tif (ptr < end_p)\n\t\treturn rec_len;\n\tif (ptr == end_p)\n\t\treturn -ENOENT;\nbroken:\n\tgfs2_consist_inode(dip);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "dip"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rec_len < sizeof(struct gfs2_dirent)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "d->de_rec_len"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int dirent_check_reclen(struct gfs2_inode *dip,\n\t\t\t       const struct gfs2_dirent *d, const void *end_p)\n{\n\tconst void *ptr = d;\n\tu16 rec_len = be16_to_cpu(d->de_rec_len);\n\n\tif (unlikely(rec_len < sizeof(struct gfs2_dirent)))\n\t\tgoto broken;\n\tptr += rec_len;\n\tif (ptr < end_p)\n\t\treturn rec_len;\n\tif (ptr == end_p)\n\t\treturn -ENOENT;\nbroken:\n\tgfs2_consist_inode(dip);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "gfs2_dirent_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "531-580",
    "snippet": "static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "GFS2_I(inode)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 0"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_check_dirent",
          "args": [
            "dent",
            "offset",
            "size",
            "len",
            "0"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_check_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "481-506",
          "snippet": "static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,\n\t\t\t     unsigned int size, unsigned int len, int first)\n{\n\tconst char *msg = \"gfs2_dirent too small\";\n\tif (unlikely(size < sizeof(struct gfs2_dirent)))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent misaligned\";\n\tif (unlikely(offset & 0x7))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent points beyond end of block\";\n\tif (unlikely(offset + size > len))\n\t\tgoto error;\n\tmsg = \"zero inode number\";\n\tif (unlikely(!first && gfs2_dirent_sentinel(dent)))\n\t\tgoto error;\n\tmsg = \"name length is greater than space in dirent\";\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size))\n\t\tgoto error;\n\treturn 0;\nerror:\n\tpr_warn(\"%s: %s (%s)\\n\",\n\t\t__func__, msg, first ? \"first in block\" : \"not first in block\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,\n\t\t\t     unsigned int size, unsigned int len, int first)\n{\n\tconst char *msg = \"gfs2_dirent too small\";\n\tif (unlikely(size < sizeof(struct gfs2_dirent)))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent misaligned\";\n\tif (unlikely(offset & 0x7))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent points beyond end of block\";\n\tif (unlikely(offset + size > len))\n\t\tgoto error;\n\tmsg = \"zero inode number\";\n\tif (unlikely(!first && gfs2_dirent_sentinel(dent)))\n\t\tgoto error;\n\tmsg = \"name length is greater than space in dirent\";\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size))\n\t\tgoto error;\n\treturn 0;\nerror:\n\tpr_warn(\"%s: %s (%s)\\n\",\n\t\t__func__, msg, first ? \"first in block\" : \"not first in block\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan",
          "args": [
            "dent",
            "name",
            "opaque"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_offset",
          "args": [
            "buf"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "508-529",
          "snippet": "static int gfs2_dirent_offset(const void *buf)\n{\n\tconst struct gfs2_meta_header *h = buf;\n\tint offset;\n\n\tBUG_ON(buf == NULL);\n\n\tswitch(be32_to_cpu(h->mh_type)) {\n\tcase GFS2_METATYPE_LF:\n\t\toffset = sizeof(struct gfs2_leaf);\n\t\tbreak;\n\tcase GFS2_METATYPE_DI:\n\t\toffset = sizeof(struct gfs2_dinode);\n\t\tbreak;\n\tdefault:\n\t\tgoto wrong_type;\n\t}\n\treturn offset;\nwrong_type:\n\tpr_warn(\"%s: wrong block type %u\\n\", __func__, be32_to_cpu(h->mh_type));\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_offset(const void *buf)\n{\n\tconst struct gfs2_meta_header *h = buf;\n\tint offset;\n\n\tBUG_ON(buf == NULL);\n\n\tswitch(be32_to_cpu(h->mh_type)) {\n\tcase GFS2_METATYPE_LF:\n\t\toffset = sizeof(struct gfs2_leaf);\n\t\tbreak;\n\tcase GFS2_METATYPE_DI:\n\t\toffset = sizeof(struct gfs2_dinode);\n\t\tbreak;\n\tdefault:\n\t\tgoto wrong_type;\n\t}\n\treturn offset;\nwrong_type:\n\tpr_warn(\"%s: wrong block type %u\\n\", __func__, be32_to_cpu(h->mh_type));\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(dent, offset, size, len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "gfs2_dirent_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "508-529",
    "snippet": "static int gfs2_dirent_offset(const void *buf)\n{\n\tconst struct gfs2_meta_header *h = buf;\n\tint offset;\n\n\tBUG_ON(buf == NULL);\n\n\tswitch(be32_to_cpu(h->mh_type)) {\n\tcase GFS2_METATYPE_LF:\n\t\toffset = sizeof(struct gfs2_leaf);\n\t\tbreak;\n\tcase GFS2_METATYPE_DI:\n\t\toffset = sizeof(struct gfs2_dinode);\n\t\tbreak;\n\tdefault:\n\t\tgoto wrong_type;\n\t}\n\treturn offset;\nwrong_type:\n\tpr_warn(\"%s: wrong block type %u\\n\", __func__, be32_to_cpu(h->mh_type));\n\treturn -1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: wrong block type %u\\n\"",
            "__func__",
            "be32_to_cpu(h->mh_type)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "h->mh_type"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "h->mh_type"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buf == NULL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_offset(const void *buf)\n{\n\tconst struct gfs2_meta_header *h = buf;\n\tint offset;\n\n\tBUG_ON(buf == NULL);\n\n\tswitch(be32_to_cpu(h->mh_type)) {\n\tcase GFS2_METATYPE_LF:\n\t\toffset = sizeof(struct gfs2_leaf);\n\t\tbreak;\n\tcase GFS2_METATYPE_DI:\n\t\toffset = sizeof(struct gfs2_dinode);\n\t\tbreak;\n\tdefault:\n\t\tgoto wrong_type;\n\t}\n\treturn offset;\nwrong_type:\n\tpr_warn(\"%s: wrong block type %u\\n\", __func__, be32_to_cpu(h->mh_type));\n\treturn -1;\n}"
  },
  {
    "function_name": "gfs2_check_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "481-506",
    "snippet": "static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,\n\t\t\t     unsigned int size, unsigned int len, int first)\n{\n\tconst char *msg = \"gfs2_dirent too small\";\n\tif (unlikely(size < sizeof(struct gfs2_dirent)))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent misaligned\";\n\tif (unlikely(offset & 0x7))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent points beyond end of block\";\n\tif (unlikely(offset + size > len))\n\t\tgoto error;\n\tmsg = \"zero inode number\";\n\tif (unlikely(!first && gfs2_dirent_sentinel(dent)))\n\t\tgoto error;\n\tmsg = \"name length is greater than space in dirent\";\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size))\n\t\tgoto error;\n\treturn 0;\nerror:\n\tpr_warn(\"%s: %s (%s)\\n\",\n\t\t__func__, msg, first ? \"first in block\" : \"not first in block\");\n\treturn -EIO;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: %s (%s)\\n\"",
            "__func__",
            "msg",
            "first ? \"first in block\" : \"not first in block\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!first && gfs2_dirent_sentinel(dent)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset + size > len"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset & 0x7"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size < sizeof(struct gfs2_dirent)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,\n\t\t\t     unsigned int size, unsigned int len, int first)\n{\n\tconst char *msg = \"gfs2_dirent too small\";\n\tif (unlikely(size < sizeof(struct gfs2_dirent)))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent misaligned\";\n\tif (unlikely(offset & 0x7))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent points beyond end of block\";\n\tif (unlikely(offset + size > len))\n\t\tgoto error;\n\tmsg = \"zero inode number\";\n\tif (unlikely(!first && gfs2_dirent_sentinel(dent)))\n\t\tgoto error;\n\tmsg = \"name length is greater than space in dirent\";\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size))\n\t\tgoto error;\n\treturn 0;\nerror:\n\tpr_warn(\"%s: %s (%s)\\n\",\n\t\t__func__, msg, first ? \"first in block\" : \"not first in block\");\n\treturn -EIO;\n}"
  },
  {
    "function_name": "gfs2_dirent_gather",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "461-470",
    "snippet": "static int gfs2_dirent_gather(const struct gfs2_dirent *dent,\n\t\t\t      const struct qstr *name,\n\t\t\t      void *opaque)\n{\n\tstruct dirent_gather *g = opaque;\n\tif (!gfs2_dirent_sentinel(dent)) {\n\t\tg->pdent[g->offset++] = dent;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_gather(const struct gfs2_dirent *dent,\n\t\t\t      const struct qstr *name,\n\t\t\t      void *opaque)\n{\n\tstruct dirent_gather *g = opaque;\n\tif (!gfs2_dirent_sentinel(dent)) {\n\t\tg->pdent[g->offset++] = dent;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dirent_find_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "441-454",
    "snippet": "static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *opaque)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (totlen - actual >= required)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "be16_to_cpu(dent->de_name_len)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "name->len"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *opaque)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (totlen - actual >= required)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dirent_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "430-439",
    "snippet": "static int gfs2_dirent_last(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\tconst char *start = name->name;\n\tconst char *end = (const char *)dent + be16_to_cpu(dent->de_rec_len);\n\tif (name->len == (end - start))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_rec_len"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_last(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\tconst char *start = name->name;\n\tconst char *end = (const char *)dent + be16_to_cpu(dent->de_rec_len);\n\tif (name->len == (end - start))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dirent_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "419-424",
    "snippet": "static int gfs2_dirent_prev(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 2);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfs2_dirent_find",
          "args": [
            "dent",
            "name",
            "2"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_dirent_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "401-410",
          "snippet": "static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_prev(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 2);\n}"
  },
  {
    "function_name": "gfs2_dirent_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "412-417",
    "snippet": "static int gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfs2_dirent_find",
          "args": [
            "dent",
            "name",
            "1"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_dirent_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "401-410",
          "snippet": "static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 1);\n}"
  },
  {
    "function_name": "__gfs2_dirent_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "401-410",
    "snippet": "static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dent+1",
            "name->name",
            "name->len"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dent->de_name_len"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dent->de_hash"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dirent_sentinel",
          "args": [
            "dent"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dirent_sentinel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "396-399",
          "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dirent_sentinel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "396-399",
    "snippet": "static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}"
  },
  {
    "function_name": "gfs2_dir_hash_inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "389-394",
    "snippet": "void gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "hc"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}"
  },
  {
    "function_name": "gfs2_dir_get_hash_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "339-381",
    "snippet": "static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "hc"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ip->i_hash_cache"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "hc"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_read_data",
          "args": [
            "ip",
            "hc",
            "hsize"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "271-330",
          "snippet": "static int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t      unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\t\tint new;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\t\tdblock++;\n\t\textlen--;\n\t\tmemcpy(buf, bh->b_data + o, amount);\n\t\tbrelse(bh);\n\t\tbuf += (amount/sizeof(__be64));\n\t\tcopied += amount;\n\t\tlblock++;\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\n\treturn copied;\nfail:\n\treturn (copied) ? copied : error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t      unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\t\tint new;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\t\tdblock++;\n\t\textlen--;\n\t\tmemcpy(buf, bh->b_data + o, amount);\n\t\tbrelse(bh);\n\t\tbuf += (amount/sizeof(__be64));\n\t\tcopied += amount;\n\t\tlblock++;\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\n\treturn copied;\nfail:\n\treturn (copied) ? copied : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "hsize",
            "GFP_NOFS",
            "PAGE_KERNEL"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hsize",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(ip->i_diskflags & GFS2_DIF_EXHASH)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = 1 << ip->i_depth;\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}"
  },
  {
    "function_name": "gfs2_dir_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "271-330",
    "snippet": "static int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t      unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\t\tint new;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\t\tdblock++;\n\t\textlen--;\n\t\tmemcpy(buf, bh->b_data + o, amount);\n\t\tbrelse(bh);\n\t\tbuf += (amount/sizeof(__be64));\n\t\tcopied += amount;\n\t\tlblock++;\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\n\treturn copied;\nfail:\n\treturn (copied) ? copied : error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "bh->b_data + o",
            "amount"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bh",
            "GFS2_METATYPE_JD"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "dblock",
            "DIO_WAIT",
            "&bh"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_ra",
          "args": [
            "ip->i_gl",
            "dblock",
            "extlen"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "363-402",
          "snippet": "struct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "extlen < 1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_extent_map",
          "args": [
            "&ip->i_inode",
            "lblock",
            "&new",
            "&dblock",
            "&extlen"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "682-701",
          "snippet": "int gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "lblock",
            "sdp->sd_jbsize"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "gfs2_is_jdata(ip)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_read_stuffed",
          "args": [
            "ip",
            "buf",
            "size"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_read_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "247-260",
          "snippet": "static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t\t unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\t\tbrelse(dibh);\n\t}\n\n\treturn (error) ? error : size;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t\t unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\t\tbrelse(dibh);\n\t}\n\n\treturn (error) ? error : size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t      unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\t\tint new;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\t\tdblock++;\n\t\textlen--;\n\t\tmemcpy(buf, bh->b_data + o, amount);\n\t\tbrelse(bh);\n\t\tbuf += (amount/sizeof(__be64));\n\t\tcopied += amount;\n\t\tlblock++;\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\n\treturn copied;\nfail:\n\treturn (copied) ? copied : error;\n}"
  },
  {
    "function_name": "gfs2_dir_read_stuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "247-260",
    "snippet": "static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t\t unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\t\tbrelse(dibh);\n\t}\n\n\treturn (error) ? error : size;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "dibh->b_data + sizeof(struct gfs2_dinode)",
            "size"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t\t unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\t\tbrelse(dibh);\n\t}\n\n\treturn (error) ? error : size;\n}"
  },
  {
    "function_name": "gfs2_dir_write_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "155-245",
    "snippet": "static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&ip->i_inode",
            "offset + copied"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + o",
            "buf",
            "amount"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_existing_buffer",
          "args": [
            "ip",
            "dblock",
            "&bh"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_existing_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "105-120",
          "snippet": "static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_get_new_buffer",
          "args": [
            "ip",
            "dblock",
            "&bh"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_get_new_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "92-103",
          "snippet": "int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "dblock"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_extent_map",
          "args": [
            "&ip->i_inode",
            "lblock",
            "&new",
            "&dblock",
            "&extlen"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "682-701",
          "snippet": "int gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "lblock",
            "sdp->sd_jbsize"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "gfs2_is_jdata(ip)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_write_stuffed",
          "args": [
            "ip",
            "buf",
            "(unsigned int)offset",
            "size"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_write_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "122-142",
          "snippet": "static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,\n\t\t\t\t  unsigned int offset, unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);\n\tif (ip->i_inode.i_size < offset + size)\n\t\ti_size_write(&ip->i_inode, offset + size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn size;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,\n\t\t\t\t  unsigned int offset, unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);\n\tif (ip->i_inode.i_size < offset + size)\n\t\ti_size_write(&ip->i_inode, offset + size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tint new = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) &&\n\t    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\tnew = 1;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, lblock, &new,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_dir_write_stuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "122-142",
    "snippet": "static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,\n\t\t\t\t  unsigned int offset, unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);\n\tif (ip->i_inode.i_size < offset + size)\n\t\ti_size_write(&ip->i_inode, offset + size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn size;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&ip->i_inode",
            "offset + size"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dibh->b_data + offset + sizeof(struct gfs2_dinode)",
            "buf",
            "size"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,\n\t\t\t\t  unsigned int offset, unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);\n\tif (ip->i_inode.i_size < offset + size)\n\t\ti_size_write(&ip->i_inode, offset + size);\n\tip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn size;\n}"
  },
  {
    "function_name": "gfs2_dir_get_existing_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "105-120",
    "snippet": "static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t*bhp = bh;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "bh",
            "GFS2_METATYPE_JD"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "block",
            "DIO_WAIT",
            "&bh"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t*bhp = bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_dir_get_new_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
    "lines": "92-103",
    "snippet": "int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"bmap.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "bh",
            "sizeof(struct gfs2_meta_header)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "bh",
            "GFS2_METATYPE_JD",
            "GFS2_FORMAT_JD"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "block"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}"
  }
]