[
  {
    "function_name": "dlm_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2361-2368",
    "snippet": "static void __exit dlm_exit (void)\n{\n\tdlm_destroy_debugfs_root();\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_destroy_mle_cache",
          "args": [],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_mle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "415-419",
          "snippet": "void dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_mle_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\n\nvoid dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_master_caches",
          "args": [],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_master_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "473-484",
          "snippet": "void dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nvoid dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_lock_cache",
          "args": [],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_lock_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "78-82",
          "snippet": "void dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nvoid dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unregister_net_handlers",
          "args": [],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_net_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2218-2221",
          "snippet": "static void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_join_handlers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_debugfs_root",
          "args": [],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_debugfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "76-78",
          "snippet": "static inline void dlm_destroy_debugfs_root(void)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dlm_destroy_debugfs_root(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void __exit dlm_exit (void)\n{\n\tdlm_destroy_debugfs_root();\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n}"
  },
  {
    "function_name": "dlm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2319-2359",
    "snippet": "static int __init dlm_init(void)\n{\n\tint status;\n\n\tstatus = dlm_init_mle_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_mle slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_master_caches();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_lockres and \"\n\t\t     \"o2dlm_lockname slabcaches\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_lock_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Count not create o2dlm_lock slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_register_net_handlers();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to register network handlers\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_create_debugfs_root();\n\tif (status)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n\treturn -1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_destroy_mle_cache",
          "args": [],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_mle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "415-419",
          "snippet": "void dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_mle_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\n\nvoid dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_master_caches",
          "args": [],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_master_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "473-484",
          "snippet": "void dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nvoid dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_lock_cache",
          "args": [],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_lock_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "78-82",
          "snippet": "void dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nvoid dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unregister_net_handlers",
          "args": [],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_net_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2218-2221",
          "snippet": "static void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_join_handlers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_create_debugfs_root",
          "args": [],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_create_debugfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "72-75",
          "snippet": "static inline int dlm_create_debugfs_root(void)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int dlm_create_debugfs_root(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to register network handlers\\n\""
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_register_net_handlers",
          "args": [],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_register_net_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2223-2265",
          "snippet": "static int dlm_register_net_handlers(void)\n{\n\tint status = 0;\n\n\tstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_join_request),\n\t\t\t\t\tdlm_query_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_assert_joined),\n\t\t\t\t\tdlm_assert_joined_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_cancel_join),\n\t\t\t\t\tdlm_cancel_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_region),\n\t\t\t\t\tdlm_query_region_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\tdlm_query_nodeinfo_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\nbail:\n\tif (status < 0)\n\t\tdlm_unregister_net_handlers();\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_join_handlers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic int dlm_register_net_handlers(void)\n{\n\tint status = 0;\n\n\tstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_join_request),\n\t\t\t\t\tdlm_query_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_assert_joined),\n\t\t\t\t\tdlm_assert_joined_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_cancel_join),\n\t\t\t\t\tdlm_cancel_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_region),\n\t\t\t\t\tdlm_query_region_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\tdlm_query_nodeinfo_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\nbail:\n\tif (status < 0)\n\t\tdlm_unregister_net_handlers();\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_lock_cache",
          "args": [],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_lock_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "68-76",
          "snippet": "int dlm_init_lock_cache(void)\n{\n\tdlm_lock_cache = kmem_cache_create(\"o2dlm_lock\",\n\t\t\t\t\t   sizeof(struct dlm_lock),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dlm_lock_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nint dlm_init_lock_cache(void)\n{\n\tdlm_lock_cache = kmem_cache_create(\"o2dlm_lock\",\n\t\t\t\t\t   sizeof(struct dlm_lock),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dlm_lock_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_master_caches",
          "args": [],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_master_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "453-471",
          "snippet": "int dlm_init_master_caches(void)\n{\n\tdlm_lockres_cache = kmem_cache_create(\"o2dlm_lockres\",\n\t\t\t\t\t      sizeof(struct dlm_lock_resource),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockres_cache)\n\t\tgoto bail;\n\n\tdlm_lockname_cache = kmem_cache_create(\"o2dlm_lockname\",\n\t\t\t\t\t       DLM_LOCKID_NAME_MAX, 0,\n\t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockname_cache)\n\t\tgoto bail;\n\n\treturn 0;\nbail:\n\tdlm_destroy_master_caches();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nint dlm_init_master_caches(void)\n{\n\tdlm_lockres_cache = kmem_cache_create(\"o2dlm_lockres\",\n\t\t\t\t\t      sizeof(struct dlm_lock_resource),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockres_cache)\n\t\tgoto bail;\n\n\tdlm_lockname_cache = kmem_cache_create(\"o2dlm_lockname\",\n\t\t\t\t\t       DLM_LOCKID_NAME_MAX, 0,\n\t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockname_cache)\n\t\tgoto bail;\n\n\treturn 0;\nbail:\n\tdlm_destroy_master_caches();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_mle_cache",
          "args": [],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_mle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "404-413",
          "snippet": "int dlm_init_mle_cache(void)\n{\n\tdlm_mle_cache = kmem_cache_create(\"o2dlm_mle\",\n\t\t\t\t\t  sizeof(struct dlm_master_list_entry),\n\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t  NULL);\n\tif (dlm_mle_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_mle_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\n\nint dlm_init_mle_cache(void)\n{\n\tdlm_mle_cache = kmem_cache_create(\"o2dlm_mle\",\n\t\t\t\t\t  sizeof(struct dlm_master_list_entry),\n\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t  NULL);\n\tif (dlm_mle_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int __init dlm_init(void)\n{\n\tint status;\n\n\tstatus = dlm_init_mle_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_mle slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_master_caches();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Could not create o2dlm_lockres and \"\n\t\t     \"o2dlm_lockname slabcaches\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_init_lock_cache();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Count not create o2dlm_lock slabcache\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_register_net_handlers();\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to register network handlers\\n\");\n\t\tgoto error;\n\t}\n\n\tstatus = dlm_create_debugfs_root();\n\tif (status)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tdlm_unregister_net_handlers();\n\tdlm_destroy_lock_cache();\n\tdlm_destroy_master_caches();\n\tdlm_destroy_mle_cache();\n\treturn -1;\n}"
  },
  {
    "function_name": "dlm_unregister_eviction_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2311-2316",
    "snippet": "void dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_del_init(&cb->ec_item);\n\tup_write(&dlm_callback_sem);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(dlm_callback_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cb->ec_item"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_del_init(&cb->ec_item);\n\tup_write(&dlm_callback_sem);\n}"
  },
  {
    "function_name": "dlm_register_eviction_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2302-2308",
    "snippet": "void dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\n\tup_write(&dlm_callback_sem);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);",
      "static DECLARE_RWSEM(dlm_callback_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cb->ec_item",
            "&dlm->dlm_eviction_callbacks"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_register_eviction_cb(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_eviction_cb *cb)\n{\n\tdown_write(&dlm_callback_sem);\n\tlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\n\tup_write(&dlm_callback_sem);\n}"
  },
  {
    "function_name": "dlm_setup_eviction_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2292-2299",
    "snippet": "void dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data)\n{\n\tINIT_LIST_HEAD(&cb->ec_item);\n\tcb->ec_func = f;\n\tcb->ec_data = data;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cb->ec_item"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nvoid dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\n\t\t\t   dlm_eviction_func *f,\n\t\t\t   void *data)\n{\n\tINIT_LIST_HEAD(&cb->ec_item);\n\tcb->ec_func = f;\n\tcb->ec_data = data;\n}"
  },
  {
    "function_name": "dlm_fire_domain_eviction_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2280-2290",
    "snippet": "void dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);",
      "static DECLARE_RWSEM(dlm_callback_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb->ec_func",
          "args": [
            "node_num",
            "cb->ec_data"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cb",
            "&dlm->dlm_eviction_callbacks",
            "ec_item"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&dlm_callback_sem"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}"
  },
  {
    "function_name": "dlm_register_net_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2223-2265",
    "snippet": "static int dlm_register_net_handlers(void)\n{\n\tint status = 0;\n\n\tstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_join_request),\n\t\t\t\t\tdlm_query_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_assert_joined),\n\t\t\t\t\tdlm_assert_joined_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_cancel_join),\n\t\t\t\t\tdlm_cancel_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_region),\n\t\t\t\t\tdlm_query_region_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\tdlm_query_nodeinfo_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\nbail:\n\tif (status < 0)\n\t\tdlm_unregister_net_handlers();\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_join_handlers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unregister_net_handlers",
          "args": [],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_net_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2218-2221",
          "snippet": "static void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dlm_join_handlers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_register_handler",
          "args": [
            "DLM_QUERY_NODEINFO",
            "DLM_MOD_KEY",
            "sizeof(struct dlm_query_nodeinfo)",
            "dlm_query_nodeinfo_handler",
            "NULL",
            "NULL",
            "&dlm_join_handlers"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_register_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "812-883",
          "snippet": "int o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(o2net_handler_lock);",
            "static struct rb_root o2net_handler_tree = RB_ROOT;",
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic int dlm_register_net_handlers(void)\n{\n\tint status = 0;\n\n\tstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_join_request),\n\t\t\t\t\tdlm_query_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_assert_joined),\n\t\t\t\t\tdlm_assert_joined_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_cancel_join),\n\t\t\t\t\tdlm_cancel_join_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_region),\n\t\t\t\t\tdlm_query_region_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\n\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\tsizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\tdlm_query_nodeinfo_handler,\n\t\t\t\t\tNULL, NULL, &dlm_join_handlers);\nbail:\n\tif (status < 0)\n\t\tdlm_unregister_net_handlers();\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_unregister_net_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2218-2221",
    "snippet": "static void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dlm_join_handlers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_unregister_handler_list",
          "args": [
            "&dlm_join_handlers"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_handler_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "886-899",
          "snippet": "void o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(o2net_handler_lock);",
            "static struct rb_root o2net_handler_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nvoid o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(dlm_join_handlers);\n\nstatic void dlm_unregister_net_handlers(void)\n{\n\to2net_unregister_handler_list(&dlm_join_handlers);\n}"
  },
  {
    "function_name": "dlm_register_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2109-2213",
    "snippet": "struct dlm_ctxt * dlm_register_domain(const char *domain,\n\t\t\t       u32 key,\n\t\t\t       struct dlm_protocol_version *fs_proto)\n{\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\tstruct dlm_ctxt *new_ctxt = NULL;\n\n\tif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tmlog(ML_ERROR, \"domain name length too long\\n\");\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"register called for domain \\\"%s\\\"\\n\", domain);\n\nretry:\n\tdlm = NULL;\n\tif (signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&dlm_domain_lock);\n\n\tdlm = __dlm_lookup_domain(domain);\n\tif (dlm) {\n\t\tif (dlm->dlm_state != DLM_CTXT_JOINED) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\n\t\t\tmlog(0, \"This ctxt is not joined yet!\\n\");\n\t\t\twait_event_interruptible(dlm_domain_events,\n\t\t\t\t\t\t dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain));\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\", domain);\n\t\t\tret = -EPROTO;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t__dlm_get(dlm);\n\t\tdlm->num_joins++;\n\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\t/* doesn't exist */\n\tif (!new_ctxt) {\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tnew_ctxt = dlm_alloc_ctxt(domain, key);\n\t\tif (new_ctxt)\n\t\t\tgoto retry;\n\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\t/* a little variable switch-a-roo here... */\n\tdlm = new_ctxt;\n\tnew_ctxt = NULL;\n\n\t/* add the new domain */\n\tlist_add_tail(&dlm->list, &dlm_domains);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/*\n\t * Pass the locking protocol version into the join.  If the join\n\t * succeeds, it will have the negotiated protocol set.\n\t */\n\tdlm->dlm_locking_proto = dlm_protocol;\n\tdlm->fs_locking_proto = *fs_proto;\n\n\tret = dlm_join_domain(dlm);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tdlm_put(dlm);\n\t\tgoto leave;\n\t}\n\n\t/* Tell the caller what locking protocol we negotiated */\n\t*fs_proto = dlm->fs_locking_proto;\n\n\tret = 0;\nleave:\n\tif (new_ctxt)\n\t\tdlm_free_ctxt_mem(new_ctxt);\n\n\tif (ret < 0)\n\t\tdlm = ERR_PTR(ret);\n\n\treturn dlm;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
      "static const struct dlm_protocol_version dlm_protocol = {\n\t.pv_major = 1,\n\t.pv_minor = 2,\n};",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_free_ctxt_mem",
          "args": [
            "new_ctxt"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_ctxt_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "305-317",
          "snippet": "static void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "345-350",
          "snippet": "void dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_join_domain",
          "args": [
            "dlm"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_join_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1858-1953",
          "snippet": "static int dlm_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status;\n\tunsigned int backoff;\n\tunsigned int total_backoff = 0;\n\n\tBUG_ON(!dlm);\n\n\tmlog(0, \"Join domain %s\\n\", dlm->name);\n\n\tstatus = dlm_register_domain_handlers(dlm);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_recovery_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_debug_init(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdlm->dlm_worker = create_singlethread_workqueue(\"dlm_wq\");\n\tif (!dlm->dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdo {\n\t\tstatus = dlm_try_to_join_domain(dlm);\n\n\t\t/* If we're racing another node to the join, then we\n\t\t * need to back off temporarily and let them\n\t\t * complete. */\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n\t\tif (status == -EAGAIN) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (total_backoff > DLM_JOIN_TIMEOUT_MSECS) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tmlog(ML_NOTICE, \"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\", dlm->name,\n\t\t\t\t     total_backoff);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * <chip> After you!\n\t\t\t * <dale> No, after you!\n\t\t\t * <chip> I insist!\n\t\t\t * <dale> But you first!\n\t\t\t * ...\n\t\t\t */\n\t\t\tbackoff = (unsigned int)(jiffies & 0x3);\n\t\t\tbackoff *= DLM_DOMAIN_BACKOFF_MS;\n\t\t\ttotal_backoff += backoff;\n\t\t\tmlog(0, \"backoff %d\\n\", backoff);\n\t\t\tmsleep(backoff);\n\t\t}\n\t} while (status == -EAGAIN);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\twake_up(&dlm_domain_events);\n\n\tif (status) {\n\t\tdlm_unregister_domain_handlers(dlm);\n\t\tdlm_debug_shutdown(dlm);\n\t\tdlm_complete_thread(dlm);\n\t\tdlm_complete_recovery_thread(dlm);\n\t\tdlm_destroy_dlm_worker(dlm);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define\tDLM_JOIN_TIMEOUT_MSECS\t90000",
            "#define DLM_DOMAIN_BACKOFF_MS 200"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status;\n\tunsigned int backoff;\n\tunsigned int total_backoff = 0;\n\n\tBUG_ON(!dlm);\n\n\tmlog(0, \"Join domain %s\\n\", dlm->name);\n\n\tstatus = dlm_register_domain_handlers(dlm);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_recovery_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_debug_init(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdlm->dlm_worker = create_singlethread_workqueue(\"dlm_wq\");\n\tif (!dlm->dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdo {\n\t\tstatus = dlm_try_to_join_domain(dlm);\n\n\t\t/* If we're racing another node to the join, then we\n\t\t * need to back off temporarily and let them\n\t\t * complete. */\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n\t\tif (status == -EAGAIN) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (total_backoff > DLM_JOIN_TIMEOUT_MSECS) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tmlog(ML_NOTICE, \"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\", dlm->name,\n\t\t\t\t     total_backoff);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * <chip> After you!\n\t\t\t * <dale> No, after you!\n\t\t\t * <chip> I insist!\n\t\t\t * <dale> But you first!\n\t\t\t * ...\n\t\t\t */\n\t\t\tbackoff = (unsigned int)(jiffies & 0x3);\n\t\t\tbackoff *= DLM_DOMAIN_BACKOFF_MS;\n\t\t\ttotal_backoff += backoff;\n\t\t\tmlog(0, \"backoff %d\\n\", backoff);\n\t\t\tmsleep(backoff);\n\t\t}\n\t} while (status == -EAGAIN);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\twake_up(&dlm_domain_events);\n\n\tif (status) {\n\t\tdlm_unregister_domain_handlers(dlm);\n\t\tdlm_debug_shutdown(dlm);\n\t\tdlm_complete_thread(dlm);\n\t\tdlm_complete_recovery_thread(dlm);\n\t\tdlm_destroy_dlm_worker(dlm);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dlm->list",
            "&dlm_domains"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_alloc_ctxt",
          "args": [
            "domain",
            "key"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1955-2077",
          "snippet": "static struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\n\t\t\t\tu32 key)\n{\n\tint i;\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tdlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->name = kstrdup(domain, GFP_KERNEL);\n\tif (dlm->name == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->lockres_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\n\n\tdlm->master_hash = (struct hlist_head **)\n\t\t\t\tdlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->master_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\n\n\tdlm->key = key;\n\tdlm->node_num = o2nm_this_node();\n\n\tret = dlm_create_debugfs_subroot(dlm);\n\tif (ret < 0)\n\t\tgoto leave;\n\n\tspin_lock_init(&dlm->spinlock);\n\tspin_lock_init(&dlm->master_lock);\n\tspin_lock_init(&dlm->ast_lock);\n\tspin_lock_init(&dlm->track_lock);\n\tINIT_LIST_HEAD(&dlm->list);\n\tINIT_LIST_HEAD(&dlm->dirty_list);\n\tINIT_LIST_HEAD(&dlm->reco.resources);\n\tINIT_LIST_HEAD(&dlm->reco.node_data);\n\tINIT_LIST_HEAD(&dlm->purge_list);\n\tINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\n\tINIT_LIST_HEAD(&dlm->tracking_list);\n\tdlm->reco.state = 0;\n\n\tINIT_LIST_HEAD(&dlm->pending_asts);\n\tINIT_LIST_HEAD(&dlm->pending_basts);\n\n\tmlog(0, \"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\",\n\t\t  dlm->recovery_map, &(dlm->recovery_map[0]));\n\n\tmemset(dlm->recovery_map, 0, sizeof(dlm->recovery_map));\n\tmemset(dlm->live_nodes_map, 0, sizeof(dlm->live_nodes_map));\n\tmemset(dlm->domain_map, 0, sizeof(dlm->domain_map));\n\n\tdlm->dlm_thread_task = NULL;\n\tdlm->dlm_reco_thread_task = NULL;\n\tdlm->dlm_worker = NULL;\n\tinit_waitqueue_head(&dlm->dlm_thread_wq);\n\tinit_waitqueue_head(&dlm->dlm_reco_thread_wq);\n\tinit_waitqueue_head(&dlm->reco.event);\n\tinit_waitqueue_head(&dlm->ast_wq);\n\tinit_waitqueue_head(&dlm->migration_wq);\n\tINIT_LIST_HEAD(&dlm->mle_hb_events);\n\n\tdlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tinit_waitqueue_head(&dlm->dlm_join_events);\n\n\tdlm->reco.new_master = O2NM_INVALID_NODE_NUM;\n\tdlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\n\n\tatomic_set(&dlm->res_tot_count, 0);\n\tatomic_set(&dlm->res_cur_count, 0);\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\n\t\tatomic_set(&dlm->mle_tot_count[i], 0);\n\t\tatomic_set(&dlm->mle_cur_count[i], 0);\n\t}\n\n\tspin_lock_init(&dlm->work_lock);\n\tINIT_LIST_HEAD(&dlm->work_list);\n\tINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\n\n\tkref_init(&dlm->dlm_refs);\n\tdlm->dlm_state = DLM_CTXT_NEW;\n\n\tINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\n\n\tmlog(0, \"context init: refcount %u\\n\",\n\t\t  atomic_read(&dlm->dlm_refs.refcount));\n\nleave:\n\tif (ret < 0 && dlm) {\n\t\tif (dlm->master_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->master_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tif (dlm->lockres_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->lockres_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tkfree(dlm->name);\n\t\tkfree(dlm);\n\t\tdlm = NULL;\n\t}\n\treturn dlm;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\n\t\t\t\tu32 key)\n{\n\tint i;\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tdlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->name = kstrdup(domain, GFP_KERNEL);\n\tif (dlm->name == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->lockres_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\n\n\tdlm->master_hash = (struct hlist_head **)\n\t\t\t\tdlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->master_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\n\n\tdlm->key = key;\n\tdlm->node_num = o2nm_this_node();\n\n\tret = dlm_create_debugfs_subroot(dlm);\n\tif (ret < 0)\n\t\tgoto leave;\n\n\tspin_lock_init(&dlm->spinlock);\n\tspin_lock_init(&dlm->master_lock);\n\tspin_lock_init(&dlm->ast_lock);\n\tspin_lock_init(&dlm->track_lock);\n\tINIT_LIST_HEAD(&dlm->list);\n\tINIT_LIST_HEAD(&dlm->dirty_list);\n\tINIT_LIST_HEAD(&dlm->reco.resources);\n\tINIT_LIST_HEAD(&dlm->reco.node_data);\n\tINIT_LIST_HEAD(&dlm->purge_list);\n\tINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\n\tINIT_LIST_HEAD(&dlm->tracking_list);\n\tdlm->reco.state = 0;\n\n\tINIT_LIST_HEAD(&dlm->pending_asts);\n\tINIT_LIST_HEAD(&dlm->pending_basts);\n\n\tmlog(0, \"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\",\n\t\t  dlm->recovery_map, &(dlm->recovery_map[0]));\n\n\tmemset(dlm->recovery_map, 0, sizeof(dlm->recovery_map));\n\tmemset(dlm->live_nodes_map, 0, sizeof(dlm->live_nodes_map));\n\tmemset(dlm->domain_map, 0, sizeof(dlm->domain_map));\n\n\tdlm->dlm_thread_task = NULL;\n\tdlm->dlm_reco_thread_task = NULL;\n\tdlm->dlm_worker = NULL;\n\tinit_waitqueue_head(&dlm->dlm_thread_wq);\n\tinit_waitqueue_head(&dlm->dlm_reco_thread_wq);\n\tinit_waitqueue_head(&dlm->reco.event);\n\tinit_waitqueue_head(&dlm->ast_wq);\n\tinit_waitqueue_head(&dlm->migration_wq);\n\tINIT_LIST_HEAD(&dlm->mle_hb_events);\n\n\tdlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tinit_waitqueue_head(&dlm->dlm_join_events);\n\n\tdlm->reco.new_master = O2NM_INVALID_NODE_NUM;\n\tdlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\n\n\tatomic_set(&dlm->res_tot_count, 0);\n\tatomic_set(&dlm->res_cur_count, 0);\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\n\t\tatomic_set(&dlm->mle_tot_count[i], 0);\n\t\tatomic_set(&dlm->mle_cur_count[i], 0);\n\t}\n\n\tspin_lock_init(&dlm->work_lock);\n\tINIT_LIST_HEAD(&dlm->work_list);\n\tINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\n\n\tkref_init(&dlm->dlm_refs);\n\tdlm->dlm_state = DLM_CTXT_NEW;\n\n\tINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\n\n\tmlog(0, \"context init: refcount %u\\n\",\n\t\t  atomic_read(&dlm->dlm_refs.refcount));\n\nleave:\n\tif (ret < 0 && dlm) {\n\t\tif (dlm->master_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->master_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tif (dlm->lockres_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->lockres_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tkfree(dlm->name);\n\t\tkfree(dlm);\n\t\tdlm = NULL;\n\t}\n\treturn dlm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_get",
          "args": [
            "dlm"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "352-355",
          "snippet": "static void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\"",
            "domain"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_protocol_compare",
          "args": [
            "&dlm->fs_locking_proto",
            "fs_proto"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_protocol_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2087-2100",
          "snippet": "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "dlm_domain_events",
            "dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain)"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_wait_on_domain_helper",
          "args": [
            "domain"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_on_domain_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "288-303",
          "snippet": "static int dlm_wait_on_domain_helper(const char *domain)\n{\n\tint ret = 0;\n\tstruct dlm_ctxt *tmp = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\ttmp = __dlm_lookup_domain(domain);\n\tif (!tmp)\n\t\tret = 1;\n\telse if (tmp->dlm_state == DLM_CTXT_JOINED)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_wait_on_domain_helper(const char *domain)\n{\n\tint ret = 0;\n\tstruct dlm_ctxt *tmp = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\ttmp = __dlm_lookup_domain(domain);\n\tif (!tmp)\n\t\tret = 1;\n\telse if (tmp->dlm_state == DLM_CTXT_JOINED)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"This ctxt is not joined yet!\\n\""
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain",
          "args": [
            "domain"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "277-282",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic const struct dlm_protocol_version dlm_protocol = {\n\t.pv_major = 1,\n\t.pv_minor = 2,\n};\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt * dlm_register_domain(const char *domain,\n\t\t\t       u32 key,\n\t\t\t       struct dlm_protocol_version *fs_proto)\n{\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\tstruct dlm_ctxt *new_ctxt = NULL;\n\n\tif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tmlog(ML_ERROR, \"domain name length too long\\n\");\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"register called for domain \\\"%s\\\"\\n\", domain);\n\nretry:\n\tdlm = NULL;\n\tif (signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&dlm_domain_lock);\n\n\tdlm = __dlm_lookup_domain(domain);\n\tif (dlm) {\n\t\tif (dlm->dlm_state != DLM_CTXT_JOINED) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\n\t\t\tmlog(0, \"This ctxt is not joined yet!\\n\");\n\t\t\twait_event_interruptible(dlm_domain_events,\n\t\t\t\t\t\t dlm_wait_on_domain_helper(\n\t\t\t\t\t\t\t domain));\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Requested locking protocol version is not \"\n\t\t\t     \"compatible with already registered domain \"\n\t\t\t     \"\\\"%s\\\"\\n\", domain);\n\t\t\tret = -EPROTO;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t__dlm_get(dlm);\n\t\tdlm->num_joins++;\n\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\t/* doesn't exist */\n\tif (!new_ctxt) {\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\tnew_ctxt = dlm_alloc_ctxt(domain, key);\n\t\tif (new_ctxt)\n\t\t\tgoto retry;\n\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\t/* a little variable switch-a-roo here... */\n\tdlm = new_ctxt;\n\tnew_ctxt = NULL;\n\n\t/* add the new domain */\n\tlist_add_tail(&dlm->list, &dlm_domains);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/*\n\t * Pass the locking protocol version into the join.  If the join\n\t * succeeds, it will have the negotiated protocol set.\n\t */\n\tdlm->dlm_locking_proto = dlm_protocol;\n\tdlm->fs_locking_proto = *fs_proto;\n\n\tret = dlm_join_domain(dlm);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tdlm_put(dlm);\n\t\tgoto leave;\n\t}\n\n\t/* Tell the caller what locking protocol we negotiated */\n\t*fs_proto = dlm->fs_locking_proto;\n\n\tret = 0;\nleave:\n\tif (new_ctxt)\n\t\tdlm_free_ctxt_mem(new_ctxt);\n\n\tif (ret < 0)\n\t\tdlm = ERR_PTR(ret);\n\n\treturn dlm;\n}"
  },
  {
    "function_name": "dlm_protocol_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "2087-2100",
    "snippet": "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_alloc_ctxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1955-2077",
    "snippet": "static struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\n\t\t\t\tu32 key)\n{\n\tint i;\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tdlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->name = kstrdup(domain, GFP_KERNEL);\n\tif (dlm->name == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->lockres_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\n\n\tdlm->master_hash = (struct hlist_head **)\n\t\t\t\tdlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->master_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\n\n\tdlm->key = key;\n\tdlm->node_num = o2nm_this_node();\n\n\tret = dlm_create_debugfs_subroot(dlm);\n\tif (ret < 0)\n\t\tgoto leave;\n\n\tspin_lock_init(&dlm->spinlock);\n\tspin_lock_init(&dlm->master_lock);\n\tspin_lock_init(&dlm->ast_lock);\n\tspin_lock_init(&dlm->track_lock);\n\tINIT_LIST_HEAD(&dlm->list);\n\tINIT_LIST_HEAD(&dlm->dirty_list);\n\tINIT_LIST_HEAD(&dlm->reco.resources);\n\tINIT_LIST_HEAD(&dlm->reco.node_data);\n\tINIT_LIST_HEAD(&dlm->purge_list);\n\tINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\n\tINIT_LIST_HEAD(&dlm->tracking_list);\n\tdlm->reco.state = 0;\n\n\tINIT_LIST_HEAD(&dlm->pending_asts);\n\tINIT_LIST_HEAD(&dlm->pending_basts);\n\n\tmlog(0, \"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\",\n\t\t  dlm->recovery_map, &(dlm->recovery_map[0]));\n\n\tmemset(dlm->recovery_map, 0, sizeof(dlm->recovery_map));\n\tmemset(dlm->live_nodes_map, 0, sizeof(dlm->live_nodes_map));\n\tmemset(dlm->domain_map, 0, sizeof(dlm->domain_map));\n\n\tdlm->dlm_thread_task = NULL;\n\tdlm->dlm_reco_thread_task = NULL;\n\tdlm->dlm_worker = NULL;\n\tinit_waitqueue_head(&dlm->dlm_thread_wq);\n\tinit_waitqueue_head(&dlm->dlm_reco_thread_wq);\n\tinit_waitqueue_head(&dlm->reco.event);\n\tinit_waitqueue_head(&dlm->ast_wq);\n\tinit_waitqueue_head(&dlm->migration_wq);\n\tINIT_LIST_HEAD(&dlm->mle_hb_events);\n\n\tdlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tinit_waitqueue_head(&dlm->dlm_join_events);\n\n\tdlm->reco.new_master = O2NM_INVALID_NODE_NUM;\n\tdlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\n\n\tatomic_set(&dlm->res_tot_count, 0);\n\tatomic_set(&dlm->res_cur_count, 0);\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\n\t\tatomic_set(&dlm->mle_tot_count[i], 0);\n\t\tatomic_set(&dlm->mle_cur_count[i], 0);\n\t}\n\n\tspin_lock_init(&dlm->work_lock);\n\tINIT_LIST_HEAD(&dlm->work_list);\n\tINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\n\n\tkref_init(&dlm->dlm_refs);\n\tdlm->dlm_state = DLM_CTXT_NEW;\n\n\tINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\n\n\tmlog(0, \"context init: refcount %u\\n\",\n\t\t  atomic_read(&dlm->dlm_refs.refcount));\n\nleave:\n\tif (ret < 0 && dlm) {\n\t\tif (dlm->master_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->master_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tif (dlm->lockres_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->lockres_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tkfree(dlm->name);\n\t\tkfree(dlm);\n\t\tdlm = NULL;\n\t}\n\treturn dlm;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dlm"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dlm->name"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_free_pagevec",
          "args": [
            "(void **)dlm->lockres_hash",
            "DLM_HASH_PAGES"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "79-84",
          "snippet": "static void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"context init: refcount %u\\n\"",
            "atomic_read(&dlm->dlm_refs.refcount)"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dlm->dlm_refs.refcount"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->dlm_eviction_callbacks"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&dlm->dlm_refs"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&dlm->dispatched_work",
            "dlm_dispatch_work"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->work_list"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dlm->mle_cur_count[i]",
            "0"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dlm->mle_tot_count[i]",
            "0"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dlm->res_cur_count",
            "0"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dlm->res_tot_count",
            "0"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->dlm_join_events"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->mle_hb_events"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->migration_wq"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->ast_wq"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->reco.event"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->dlm_reco_thread_wq"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dlm->dlm_thread_wq"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dlm->domain_map",
            "0",
            "sizeof(dlm->domain_map)"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dlm->live_nodes_map",
            "0",
            "sizeof(dlm->live_nodes_map)"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dlm->recovery_map",
            "0",
            "sizeof(dlm->recovery_map)"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\"",
            "dlm->recovery_map",
            "&(dlm->recovery_map[0])"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->pending_basts"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->pending_asts"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->tracking_list"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->dlm_domain_handlers"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->purge_list"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->reco.node_data"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->reco.resources"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->dirty_list"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm->list"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dlm->track_lock"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_create_debugfs_subroot",
          "args": [
            "dlm"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_create_debugfs_subroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "65-68",
          "snippet": "static inline int dlm_create_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int dlm_create_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "dlm_master_hash(dlm, i)"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "195-200",
          "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_alloc_pagevec",
          "args": [
            "DLM_HASH_PAGES"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "dlm_lockres_hash(dlm, i)"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "domain",
            "GFP_KERNEL"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dlm)",
            "GFP_KERNEL"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\n\t\t\t\tu32 key)\n{\n\tint i;\n\tint ret;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tdlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->name = kstrdup(domain, GFP_KERNEL);\n\tif (dlm->name == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tdlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->lockres_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\n\n\tdlm->master_hash = (struct hlist_head **)\n\t\t\t\tdlm_alloc_pagevec(DLM_HASH_PAGES);\n\tif (!dlm->master_hash) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\n\n\tdlm->key = key;\n\tdlm->node_num = o2nm_this_node();\n\n\tret = dlm_create_debugfs_subroot(dlm);\n\tif (ret < 0)\n\t\tgoto leave;\n\n\tspin_lock_init(&dlm->spinlock);\n\tspin_lock_init(&dlm->master_lock);\n\tspin_lock_init(&dlm->ast_lock);\n\tspin_lock_init(&dlm->track_lock);\n\tINIT_LIST_HEAD(&dlm->list);\n\tINIT_LIST_HEAD(&dlm->dirty_list);\n\tINIT_LIST_HEAD(&dlm->reco.resources);\n\tINIT_LIST_HEAD(&dlm->reco.node_data);\n\tINIT_LIST_HEAD(&dlm->purge_list);\n\tINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\n\tINIT_LIST_HEAD(&dlm->tracking_list);\n\tdlm->reco.state = 0;\n\n\tINIT_LIST_HEAD(&dlm->pending_asts);\n\tINIT_LIST_HEAD(&dlm->pending_basts);\n\n\tmlog(0, \"dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\\n\",\n\t\t  dlm->recovery_map, &(dlm->recovery_map[0]));\n\n\tmemset(dlm->recovery_map, 0, sizeof(dlm->recovery_map));\n\tmemset(dlm->live_nodes_map, 0, sizeof(dlm->live_nodes_map));\n\tmemset(dlm->domain_map, 0, sizeof(dlm->domain_map));\n\n\tdlm->dlm_thread_task = NULL;\n\tdlm->dlm_reco_thread_task = NULL;\n\tdlm->dlm_worker = NULL;\n\tinit_waitqueue_head(&dlm->dlm_thread_wq);\n\tinit_waitqueue_head(&dlm->dlm_reco_thread_wq);\n\tinit_waitqueue_head(&dlm->reco.event);\n\tinit_waitqueue_head(&dlm->ast_wq);\n\tinit_waitqueue_head(&dlm->migration_wq);\n\tINIT_LIST_HEAD(&dlm->mle_hb_events);\n\n\tdlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tinit_waitqueue_head(&dlm->dlm_join_events);\n\n\tdlm->reco.new_master = O2NM_INVALID_NODE_NUM;\n\tdlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\n\n\tatomic_set(&dlm->res_tot_count, 0);\n\tatomic_set(&dlm->res_cur_count, 0);\n\tfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\n\t\tatomic_set(&dlm->mle_tot_count[i], 0);\n\t\tatomic_set(&dlm->mle_cur_count[i], 0);\n\t}\n\n\tspin_lock_init(&dlm->work_lock);\n\tINIT_LIST_HEAD(&dlm->work_list);\n\tINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\n\n\tkref_init(&dlm->dlm_refs);\n\tdlm->dlm_state = DLM_CTXT_NEW;\n\n\tINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\n\n\tmlog(0, \"context init: refcount %u\\n\",\n\t\t  atomic_read(&dlm->dlm_refs.refcount));\n\nleave:\n\tif (ret < 0 && dlm) {\n\t\tif (dlm->master_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->master_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tif (dlm->lockres_hash)\n\t\t\tdlm_free_pagevec((void **)dlm->lockres_hash,\n\t\t\t\t\tDLM_HASH_PAGES);\n\n\t\tkfree(dlm->name);\n\t\tkfree(dlm);\n\t\tdlm = NULL;\n\t}\n\treturn dlm;\n}"
  },
  {
    "function_name": "dlm_join_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1858-1953",
    "snippet": "static int dlm_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status;\n\tunsigned int backoff;\n\tunsigned int total_backoff = 0;\n\n\tBUG_ON(!dlm);\n\n\tmlog(0, \"Join domain %s\\n\", dlm->name);\n\n\tstatus = dlm_register_domain_handlers(dlm);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_recovery_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_debug_init(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdlm->dlm_worker = create_singlethread_workqueue(\"dlm_wq\");\n\tif (!dlm->dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdo {\n\t\tstatus = dlm_try_to_join_domain(dlm);\n\n\t\t/* If we're racing another node to the join, then we\n\t\t * need to back off temporarily and let them\n\t\t * complete. */\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n\t\tif (status == -EAGAIN) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (total_backoff > DLM_JOIN_TIMEOUT_MSECS) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tmlog(ML_NOTICE, \"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\", dlm->name,\n\t\t\t\t     total_backoff);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * <chip> After you!\n\t\t\t * <dale> No, after you!\n\t\t\t * <chip> I insist!\n\t\t\t * <dale> But you first!\n\t\t\t * ...\n\t\t\t */\n\t\t\tbackoff = (unsigned int)(jiffies & 0x3);\n\t\t\tbackoff *= DLM_DOMAIN_BACKOFF_MS;\n\t\t\ttotal_backoff += backoff;\n\t\t\tmlog(0, \"backoff %d\\n\", backoff);\n\t\t\tmsleep(backoff);\n\t\t}\n\t} while (status == -EAGAIN);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\twake_up(&dlm_domain_events);\n\n\tif (status) {\n\t\tdlm_unregister_domain_handlers(dlm);\n\t\tdlm_debug_shutdown(dlm);\n\t\tdlm_complete_thread(dlm);\n\t\tdlm_complete_recovery_thread(dlm);\n\t\tdlm_destroy_dlm_worker(dlm);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define\tDLM_JOIN_TIMEOUT_MSECS\t90000",
      "#define DLM_DOMAIN_BACKOFF_MS 200"
    ],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_destroy_dlm_worker",
          "args": [
            "dlm"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_dlm_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "392-399",
          "snippet": "static void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_complete_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_complete_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "218-225",
          "snippet": "void dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_complete_thread",
          "args": [
            "dlm"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_complete_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "496-503",
          "snippet": "void dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_debug_shutdown",
          "args": [
            "dlm"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_debug_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "62-64",
          "snippet": "static inline void dlm_debug_shutdown(struct dlm_ctxt *dlm)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dlm_debug_shutdown(struct dlm_ctxt *dlm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unregister_domain_handlers",
          "args": [
            "dlm"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_domain_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1713-1718",
          "snippet": "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm_domain_events"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "backoff"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"backoff %d\\n\"",
            "backoff"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\"",
            "dlm->name",
            "total_backoff"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_try_to_join_domain",
          "args": [
            "dlm"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_try_to_join_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1600-1711",
          "snippet": "static int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status = 0, tmpstat, node;\n\tstruct domain_join_ctxt *ctxt;\n\tenum dlm_query_join_response_code response = JOIN_DISALLOW;\n\n\tmlog(0, \"%p\", dlm);\n\n\tctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\n\tif (!ctxt) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* group sem locking should work for us here -- we're already\n\t * registered for heartbeat events so filling this should be\n\t * atomic wrt getting those handlers called. */\n\to2hb_fill_node_map(dlm->live_nodes_map, sizeof(dlm->live_nodes_map));\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(ctxt->live_map, dlm->live_nodes_map, sizeof(ctxt->live_map));\n\n\t__dlm_set_joining_node(dlm, dlm->node_num);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tnode = -1;\n\twhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tstatus = dlm_request_join(dlm, node, &response);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Ok, either we got a response or the node doesn't have a\n\t\t * dlm up. */\n\t\tif (response == JOIN_OK)\n\t\t\tset_bit(node, ctxt->yes_resp_map);\n\n\t\tif (dlm_should_restart_join(dlm, ctxt, response)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tmlog(0, \"Yay, done querying nodes!\\n\");\n\n\t/* Yay, everyone agree's we can join the domain. My domain is\n\t * comprised of all nodes who were put in the\n\t * yes_resp_map. Copy that into our domain map and send a join\n\t * assert message to clean up everyone elses state. */\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->domain_map, ctxt->yes_resp_map,\n\t       sizeof(ctxt->yes_resp_map));\n\tset_bit(dlm->node_num, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* Support for global heartbeat and node info was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major > 1 ||\n\t    dlm->dlm_locking_proto.pv_minor > 0) {\n\t\tstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdlm_send_join_asserts(dlm, ctxt->yes_resp_map);\n\n\t/* Joined state *must* be set before the joining node\n\t * information, otherwise the query_join handler may read no\n\t * current joiner but a state of NEW and tell joining nodes\n\t * we're not in the domain. */\n\tspin_lock(&dlm_domain_lock);\n\tdlm->dlm_state = DLM_CTXT_JOINED;\n\tdlm->num_joins++;\n\tspin_unlock(&dlm_domain_lock);\n\nbail:\n\tspin_lock(&dlm->spinlock);\n\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tif (!status) {\n\t\tprintk(KERN_NOTICE \"o2dlm: Joining domain %s \", dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ctxt) {\n\t\t/* Do we need to send a cancel message to any nodes? */\n\t\tif (status < 0) {\n\t\t\ttmpstat = dlm_send_join_cancels(dlm,\n\t\t\t\t\t\t\tctxt->yes_resp_map,\n\t\t\t\t\t\t\tsizeof(ctxt->yes_resp_map));\n\t\t\tif (tmpstat < 0)\n\t\t\t\tmlog_errno(tmpstat);\n\t\t}\n\t\tkfree(ctxt);\n\t}\n\n\tmlog(0, \"returning %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status = 0, tmpstat, node;\n\tstruct domain_join_ctxt *ctxt;\n\tenum dlm_query_join_response_code response = JOIN_DISALLOW;\n\n\tmlog(0, \"%p\", dlm);\n\n\tctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\n\tif (!ctxt) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* group sem locking should work for us here -- we're already\n\t * registered for heartbeat events so filling this should be\n\t * atomic wrt getting those handlers called. */\n\to2hb_fill_node_map(dlm->live_nodes_map, sizeof(dlm->live_nodes_map));\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(ctxt->live_map, dlm->live_nodes_map, sizeof(ctxt->live_map));\n\n\t__dlm_set_joining_node(dlm, dlm->node_num);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tnode = -1;\n\twhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tstatus = dlm_request_join(dlm, node, &response);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Ok, either we got a response or the node doesn't have a\n\t\t * dlm up. */\n\t\tif (response == JOIN_OK)\n\t\t\tset_bit(node, ctxt->yes_resp_map);\n\n\t\tif (dlm_should_restart_join(dlm, ctxt, response)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tmlog(0, \"Yay, done querying nodes!\\n\");\n\n\t/* Yay, everyone agree's we can join the domain. My domain is\n\t * comprised of all nodes who were put in the\n\t * yes_resp_map. Copy that into our domain map and send a join\n\t * assert message to clean up everyone elses state. */\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->domain_map, ctxt->yes_resp_map,\n\t       sizeof(ctxt->yes_resp_map));\n\tset_bit(dlm->node_num, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* Support for global heartbeat and node info was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major > 1 ||\n\t    dlm->dlm_locking_proto.pv_minor > 0) {\n\t\tstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdlm_send_join_asserts(dlm, ctxt->yes_resp_map);\n\n\t/* Joined state *must* be set before the joining node\n\t * information, otherwise the query_join handler may read no\n\t * current joiner but a state of NEW and tell joining nodes\n\t * we're not in the domain. */\n\tspin_lock(&dlm_domain_lock);\n\tdlm->dlm_state = DLM_CTXT_JOINED;\n\tdlm->num_joins++;\n\tspin_unlock(&dlm_domain_lock);\n\nbail:\n\tspin_lock(&dlm->spinlock);\n\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tif (!status) {\n\t\tprintk(KERN_NOTICE \"o2dlm: Joining domain %s \", dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ctxt) {\n\t\t/* Do we need to send a cancel message to any nodes? */\n\t\tif (status < 0) {\n\t\t\ttmpstat = dlm_send_join_cancels(dlm,\n\t\t\t\t\t\t\tctxt->yes_resp_map,\n\t\t\t\t\t\t\tsizeof(ctxt->yes_resp_map));\n\t\t\tif (tmpstat < 0)\n\t\t\t\tmlog_errno(tmpstat);\n\t\t}\n\t\tkfree(ctxt);\n\t}\n\n\tmlog(0, \"returning %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"dlm_wq\""
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_debug_init",
          "args": [
            "dlm"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_debug_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "58-61",
          "snippet": "static inline int dlm_debug_init(struct dlm_ctxt *dlm)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int dlm_debug_init(struct dlm_ctxt *dlm)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_launch_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_launch_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "203-216",
          "snippet": "int dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"starting dlm recovery thread...\\n\");\n\n\tdlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\n\t\t\t\t\t\t\"dlm_reco_thread\");\n\tif (IS_ERR(dlm->dlm_reco_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"starting dlm recovery thread...\\n\");\n\n\tdlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\n\t\t\t\t\t\t\"dlm_reco_thread\");\n\tif (IS_ERR(dlm->dlm_reco_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_launch_thread",
          "args": [
            "dlm"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_launch_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "482-494",
          "snippet": "int dlm_launch_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"Starting dlm_thread...\\n\");\n\n\tdlm->dlm_thread_task = kthread_run(dlm_thread, dlm, \"dlm_thread\");\n\tif (IS_ERR(dlm->dlm_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_thread_task));\n\t\tdlm->dlm_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nint dlm_launch_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"Starting dlm_thread...\\n\");\n\n\tdlm->dlm_thread_task = kthread_run(dlm_thread, dlm, \"dlm_thread\");\n\tif (IS_ERR(dlm->dlm_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_thread_task));\n\t\tdlm->dlm_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_register_domain_handlers",
          "args": [
            "dlm"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_register_domain_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1720-1856",
          "snippet": "static int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\n{\n\tint status;\n\n\tmlog(0, \"registering handlers.\\n\");\n\n\to2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    dlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\n\tif (status)\n\t\tgoto bail;\n\n\to2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    dlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_request),\n\t\t\t\t\tdlm_master_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_assert_master),\n\t\t\t\t\tdlm_assert_master_handler,\n\t\t\t\t\tdlm, dlm_assert_master_post_handler,\n\t\t\t\t\t&dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_create_lock),\n\t\t\t\t\tdlm_create_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_CONVERT_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_convert_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_UNLOCK_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_unlock_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\n\t\t\t\t\tDLM_PROXY_AST_MAX_LEN,\n\t\t\t\t\tdlm_proxy_ast_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres),\n\t\t\t\t\tdlm_deref_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_migrate_request),\n\t\t\t\t\tdlm_migrate_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tDLM_MIG_LOCKRES_MAX_LEN,\n\t\t\t\t\tdlm_mig_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_requery),\n\t\t\t\t\tdlm_master_requery_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_lock_request),\n\t\t\t\t\tdlm_request_all_locks_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_reco_data_done),\n\t\t\t\t\tdlm_reco_data_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_begin_reco),\n\t\t\t\t\tdlm_begin_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_finalize_reco),\n\t\t\t\t\tdlm_finalize_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_begin_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\nbail:\n\tif (status)\n\t\tdlm_unregister_domain_handlers(dlm);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\n{\n\tint status;\n\n\tmlog(0, \"registering handlers.\\n\");\n\n\to2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    dlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\n\tif (status)\n\t\tgoto bail;\n\n\to2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    dlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_request),\n\t\t\t\t\tdlm_master_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_assert_master),\n\t\t\t\t\tdlm_assert_master_handler,\n\t\t\t\t\tdlm, dlm_assert_master_post_handler,\n\t\t\t\t\t&dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_create_lock),\n\t\t\t\t\tdlm_create_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_CONVERT_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_convert_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_UNLOCK_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_unlock_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\n\t\t\t\t\tDLM_PROXY_AST_MAX_LEN,\n\t\t\t\t\tdlm_proxy_ast_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres),\n\t\t\t\t\tdlm_deref_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_migrate_request),\n\t\t\t\t\tdlm_migrate_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tDLM_MIG_LOCKRES_MAX_LEN,\n\t\t\t\t\tdlm_mig_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_requery),\n\t\t\t\t\tdlm_master_requery_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_lock_request),\n\t\t\t\t\tdlm_request_all_locks_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_reco_data_done),\n\t\t\t\t\tdlm_reco_data_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_begin_reco),\n\t\t\t\t\tdlm_begin_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_finalize_reco),\n\t\t\t\t\tdlm_finalize_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_begin_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\nbail:\n\tif (status)\n\t\tdlm_unregister_domain_handlers(dlm);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status;\n\tunsigned int backoff;\n\tunsigned int total_backoff = 0;\n\n\tBUG_ON(!dlm);\n\n\tmlog(0, \"Join domain %s\\n\", dlm->name);\n\n\tstatus = dlm_register_domain_handlers(dlm);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_launch_recovery_thread(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_debug_init(dlm);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdlm->dlm_worker = create_singlethread_workqueue(\"dlm_wq\");\n\tif (!dlm->dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdo {\n\t\tstatus = dlm_try_to_join_domain(dlm);\n\n\t\t/* If we're racing another node to the join, then we\n\t\t * need to back off temporarily and let them\n\t\t * complete. */\n#define\tDLM_JOIN_TIMEOUT_MSECS\t90000\n\t\tif (status == -EAGAIN) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (total_backoff > DLM_JOIN_TIMEOUT_MSECS) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t\tmlog(ML_NOTICE, \"Timed out joining dlm domain \"\n\t\t\t\t     \"%s after %u msecs\\n\", dlm->name,\n\t\t\t\t     total_backoff);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * <chip> After you!\n\t\t\t * <dale> No, after you!\n\t\t\t * <chip> I insist!\n\t\t\t * <dale> But you first!\n\t\t\t * ...\n\t\t\t */\n\t\t\tbackoff = (unsigned int)(jiffies & 0x3);\n\t\t\tbackoff *= DLM_DOMAIN_BACKOFF_MS;\n\t\t\ttotal_backoff += backoff;\n\t\t\tmlog(0, \"backoff %d\\n\", backoff);\n\t\t\tmsleep(backoff);\n\t\t}\n\t} while (status == -EAGAIN);\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\twake_up(&dlm_domain_events);\n\n\tif (status) {\n\t\tdlm_unregister_domain_handlers(dlm);\n\t\tdlm_debug_shutdown(dlm);\n\t\tdlm_complete_thread(dlm);\n\t\tdlm_complete_recovery_thread(dlm);\n\t\tdlm_destroy_dlm_worker(dlm);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_register_domain_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1720-1856",
    "snippet": "static int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\n{\n\tint status;\n\n\tmlog(0, \"registering handlers.\\n\");\n\n\to2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    dlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\n\tif (status)\n\t\tgoto bail;\n\n\to2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    dlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_request),\n\t\t\t\t\tdlm_master_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_assert_master),\n\t\t\t\t\tdlm_assert_master_handler,\n\t\t\t\t\tdlm, dlm_assert_master_post_handler,\n\t\t\t\t\t&dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_create_lock),\n\t\t\t\t\tdlm_create_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_CONVERT_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_convert_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_UNLOCK_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_unlock_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\n\t\t\t\t\tDLM_PROXY_AST_MAX_LEN,\n\t\t\t\t\tdlm_proxy_ast_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres),\n\t\t\t\t\tdlm_deref_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_migrate_request),\n\t\t\t\t\tdlm_migrate_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tDLM_MIG_LOCKRES_MAX_LEN,\n\t\t\t\t\tdlm_mig_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_requery),\n\t\t\t\t\tdlm_master_requery_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_lock_request),\n\t\t\t\t\tdlm_request_all_locks_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_reco_data_done),\n\t\t\t\t\tdlm_reco_data_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_begin_reco),\n\t\t\t\t\tdlm_begin_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_finalize_reco),\n\t\t\t\t\tdlm_finalize_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_begin_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\nbail:\n\tif (status)\n\t\tdlm_unregister_domain_handlers(dlm);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unregister_domain_handlers",
          "args": [
            "dlm"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_domain_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1713-1718",
          "snippet": "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_register_handler",
          "args": [
            "DLM_BEGIN_EXIT_DOMAIN_MSG",
            "dlm->key",
            "sizeof(struct dlm_exit_domain)",
            "dlm_begin_exit_domain_handler",
            "dlm",
            "NULL",
            "&dlm->dlm_domain_handlers"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_register_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "812-883",
          "snippet": "int o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(o2net_handler_lock);",
            "static struct rb_root o2net_handler_tree = RB_ROOT;",
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_register_callback",
          "args": [
            "dlm->name",
            "&dlm->dlm_hb_up"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_register_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2492-2533",
          "snippet": "int o2hb_register_callback(const char *region_uuid,\n\t\t\t   struct o2hb_callback_func *hc)\n{\n\tstruct o2hb_callback_func *f;\n\tstruct o2hb_callback *hbcall;\n\tint ret;\n\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\tBUG_ON(!list_empty(&hc->hc_item));\n\n\thbcall = hbcall_from_type(hc->hc_type);\n\tif (IS_ERR(hbcall)) {\n\t\tret = PTR_ERR(hbcall);\n\t\tgoto out;\n\t}\n\n\tif (region_uuid) {\n\t\tret = o2hb_region_inc_user(region_uuid);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tif (hc->hc_priority < f->hc_priority) {\n\t\t\tlist_add_tail(&hc->hc_item, &f->hc_item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&hc->hc_item))\n\t\tlist_add_tail(&hc->hc_item, &hbcall->list);\n\n\tup_write(&o2hb_callback_sem);\n\tret = 0;\nout:\n\tmlog(ML_CLUSTER, \"returning %d on behalf of %p for funcs %p\\n\",\n\t     ret, __builtin_return_address(0), hc);\n\treturn ret;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static int o2hb_region_pin(const char *region_uuid);",
            "static void o2hb_region_unpin(const char *region_uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic int o2hb_region_pin(const char *region_uuid);\nstatic void o2hb_region_unpin(const char *region_uuid);\n\nint o2hb_register_callback(const char *region_uuid,\n\t\t\t   struct o2hb_callback_func *hc)\n{\n\tstruct o2hb_callback_func *f;\n\tstruct o2hb_callback *hbcall;\n\tint ret;\n\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\tBUG_ON(!list_empty(&hc->hc_item));\n\n\thbcall = hbcall_from_type(hc->hc_type);\n\tif (IS_ERR(hbcall)) {\n\t\tret = PTR_ERR(hbcall);\n\t\tgoto out;\n\t}\n\n\tif (region_uuid) {\n\t\tret = o2hb_region_inc_user(region_uuid);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tif (hc->hc_priority < f->hc_priority) {\n\t\t\tlist_add_tail(&hc->hc_item, &f->hc_item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&hc->hc_item))\n\t\tlist_add_tail(&hc->hc_item, &hbcall->list);\n\n\tup_write(&o2hb_callback_sem);\n\tret = 0;\nout:\n\tmlog(ML_CLUSTER, \"returning %d on behalf of %p for funcs %p\\n\",\n\t     ret, __builtin_return_address(0), hc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_setup_callback",
          "args": [
            "&dlm->dlm_hb_up",
            "O2HB_NODE_UP_CB",
            "dlm_hb_node_up_cb",
            "dlm",
            "DLM_HB_NODE_UP_PRI"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_setup_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2337-2349",
          "snippet": "void o2hb_setup_callback(struct o2hb_callback_func *hc,\n\t\t\t enum o2hb_callback_type type,\n\t\t\t o2hb_cb_func *func,\n\t\t\t void *data,\n\t\t\t int priority)\n{\n\tINIT_LIST_HEAD(&hc->hc_item);\n\thc->hc_func = func;\n\thc->hc_data = data;\n\thc->hc_priority = priority;\n\thc->hc_type = type;\n\thc->hc_magic = O2HB_CB_MAGIC;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type);\n\nvoid o2hb_setup_callback(struct o2hb_callback_func *hc,\n\t\t\t enum o2hb_callback_type type,\n\t\t\t o2hb_cb_func *func,\n\t\t\t void *data,\n\t\t\t int priority)\n{\n\tINIT_LIST_HEAD(&hc->hc_item);\n\thc->hc_func = func;\n\thc->hc_data = data;\n\thc->hc_priority = priority;\n\thc->hc_type = type;\n\thc->hc_magic = O2HB_CB_MAGIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"registering handlers.\\n\""
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\n{\n\tint status;\n\n\tmlog(0, \"registering handlers.\\n\");\n\n\to2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    dlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\n\tif (status)\n\t\tgoto bail;\n\n\to2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    dlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\n\tstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_request),\n\t\t\t\t\tdlm_master_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_assert_master),\n\t\t\t\t\tdlm_assert_master_handler,\n\t\t\t\t\tdlm, dlm_assert_master_post_handler,\n\t\t\t\t\t&dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_create_lock),\n\t\t\t\t\tdlm_create_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_CONVERT_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_convert_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\n\t\t\t\t\tDLM_UNLOCK_LOCK_MAX_LEN,\n\t\t\t\t\tdlm_unlock_lock_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\n\t\t\t\t\tDLM_PROXY_AST_MAX_LEN,\n\t\t\t\t\tdlm_proxy_ast_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_deref_lockres),\n\t\t\t\t\tdlm_deref_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_migrate_request),\n\t\t\t\t\tdlm_migrate_request_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\n\t\t\t\t\tDLM_MIG_LOCKRES_MAX_LEN,\n\t\t\t\t\tdlm_mig_lockres_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_master_requery),\n\t\t\t\t\tdlm_master_requery_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_lock_request),\n\t\t\t\t\tdlm_request_all_locks_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_reco_data_done),\n\t\t\t\t\tdlm_reco_data_done_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_begin_reco),\n\t\t\t\t\tdlm_begin_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_finalize_reco),\n\t\t\t\t\tdlm_finalize_reco_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\n\tstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\n\t\t\t\t\tsizeof(struct dlm_exit_domain),\n\t\t\t\t\tdlm_begin_exit_domain_handler,\n\t\t\t\t\tdlm, NULL, &dlm->dlm_domain_handlers);\n\tif (status)\n\t\tgoto bail;\n\nbail:\n\tif (status)\n\t\tdlm_unregister_domain_handlers(dlm);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_unregister_domain_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1713-1718",
    "snippet": "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_unregister_handler_list",
          "args": [
            "&dlm->dlm_domain_handlers"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_handler_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "886-899",
          "snippet": "void o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(o2net_handler_lock);",
            "static struct rb_root o2net_handler_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nvoid o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_unregister_callback",
          "args": [
            "dlm->name",
            "&dlm->dlm_hb_down"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_unregister_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2536-2556",
          "snippet": "void o2hb_unregister_callback(const char *region_uuid,\n\t\t\t      struct o2hb_callback_func *hc)\n{\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\n\tmlog(ML_CLUSTER, \"on behalf of %p for funcs %p\\n\",\n\t     __builtin_return_address(0), hc);\n\n\t/* XXX Can this happen _with_ a region reference? */\n\tif (list_empty(&hc->hc_item))\n\t\treturn;\n\n\tif (region_uuid)\n\t\to2hb_region_dec_user(region_uuid);\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_del_init(&hc->hc_item);\n\n\tup_write(&o2hb_callback_sem);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static int o2hb_region_pin(const char *region_uuid);",
            "static void o2hb_region_unpin(const char *region_uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic int o2hb_region_pin(const char *region_uuid);\nstatic void o2hb_region_unpin(const char *region_uuid);\n\nvoid o2hb_unregister_callback(const char *region_uuid,\n\t\t\t      struct o2hb_callback_func *hc)\n{\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\n\tmlog(ML_CLUSTER, \"on behalf of %p for funcs %p\\n\",\n\t     __builtin_return_address(0), hc);\n\n\t/* XXX Can this happen _with_ a region reference? */\n\tif (list_empty(&hc->hc_item))\n\t\treturn;\n\n\tif (region_uuid)\n\t\to2hb_region_dec_user(region_uuid);\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_del_init(&hc->hc_item);\n\n\tup_write(&o2hb_callback_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}"
  },
  {
    "function_name": "dlm_try_to_join_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1600-1711",
    "snippet": "static int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status = 0, tmpstat, node;\n\tstruct domain_join_ctxt *ctxt;\n\tenum dlm_query_join_response_code response = JOIN_DISALLOW;\n\n\tmlog(0, \"%p\", dlm);\n\n\tctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\n\tif (!ctxt) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* group sem locking should work for us here -- we're already\n\t * registered for heartbeat events so filling this should be\n\t * atomic wrt getting those handlers called. */\n\to2hb_fill_node_map(dlm->live_nodes_map, sizeof(dlm->live_nodes_map));\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(ctxt->live_map, dlm->live_nodes_map, sizeof(ctxt->live_map));\n\n\t__dlm_set_joining_node(dlm, dlm->node_num);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tnode = -1;\n\twhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tstatus = dlm_request_join(dlm, node, &response);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Ok, either we got a response or the node doesn't have a\n\t\t * dlm up. */\n\t\tif (response == JOIN_OK)\n\t\t\tset_bit(node, ctxt->yes_resp_map);\n\n\t\tif (dlm_should_restart_join(dlm, ctxt, response)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tmlog(0, \"Yay, done querying nodes!\\n\");\n\n\t/* Yay, everyone agree's we can join the domain. My domain is\n\t * comprised of all nodes who were put in the\n\t * yes_resp_map. Copy that into our domain map and send a join\n\t * assert message to clean up everyone elses state. */\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->domain_map, ctxt->yes_resp_map,\n\t       sizeof(ctxt->yes_resp_map));\n\tset_bit(dlm->node_num, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* Support for global heartbeat and node info was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major > 1 ||\n\t    dlm->dlm_locking_proto.pv_minor > 0) {\n\t\tstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdlm_send_join_asserts(dlm, ctxt->yes_resp_map);\n\n\t/* Joined state *must* be set before the joining node\n\t * information, otherwise the query_join handler may read no\n\t * current joiner but a state of NEW and tell joining nodes\n\t * we're not in the domain. */\n\tspin_lock(&dlm_domain_lock);\n\tdlm->dlm_state = DLM_CTXT_JOINED;\n\tdlm->num_joins++;\n\tspin_unlock(&dlm_domain_lock);\n\nbail:\n\tspin_lock(&dlm->spinlock);\n\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tif (!status) {\n\t\tprintk(KERN_NOTICE \"o2dlm: Joining domain %s \", dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ctxt) {\n\t\t/* Do we need to send a cancel message to any nodes? */\n\t\tif (status < 0) {\n\t\t\ttmpstat = dlm_send_join_cancels(dlm,\n\t\t\t\t\t\t\tctxt->yes_resp_map,\n\t\t\t\t\t\t\tsizeof(ctxt->yes_resp_map));\n\t\t\tif (tmpstat < 0)\n\t\t\t\tmlog_errno(tmpstat);\n\t\t}\n\t\tkfree(ctxt);\n\t}\n\n\tmlog(0, \"returning %d\\n\", status);\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"returning %d\\n\"",
            "status"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctxt"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "tmpstat"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_join_cancels",
          "args": [
            "dlm",
            "ctxt->yes_resp_map",
            "sizeof(ctxt->yes_resp_map)"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_join_cancels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1394-1428",
          "snippet": "static int dlm_send_join_cancels(struct dlm_ctxt *dlm,\n\t\t\t\t unsigned long *node_map,\n\t\t\t\t unsigned int map_size)\n{\n\tint status, tmpstat;\n\tunsigned int node;\n\n\tif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\n\t\t\t sizeof(unsigned long))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\\n\",\n\t\t     map_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\ttmpstat = dlm_send_one_join_cancel(dlm, node);\n\t\tif (tmpstat) {\n\t\t\tmlog(ML_ERROR, \"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\", tmpstat, node);\n\t\t\tif (!status)\n\t\t\t\tstatus = tmpstat;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_join_cancels(struct dlm_ctxt *dlm,\n\t\t\t\t unsigned long *node_map,\n\t\t\t\t unsigned int map_size)\n{\n\tint status, tmpstat;\n\tunsigned int node;\n\n\tif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\n\t\t\t sizeof(unsigned long))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\\n\",\n\t\t     map_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\ttmpstat = dlm_send_one_join_cancel(dlm, node);\n\t\tif (tmpstat) {\n\t\t\tmlog(ML_ERROR, \"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\", tmpstat, node);\n\t\t\tif (!status)\n\t\t\t\tstatus = tmpstat;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_nodes",
          "args": [
            "dlm"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "533-546",
          "snippet": "static void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Joining domain %s \"",
            "dlm->name"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_set_joining_node",
          "args": [
            "dlm",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_set_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "267-274",
          "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_join_asserts",
          "args": [
            "dlm",
            "ctxt->yes_resp_map"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_join_asserts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1537-1569",
          "snippet": "static void dlm_send_join_asserts(struct dlm_ctxt *dlm,\n\t\t\t\t  unsigned long *node_map)\n{\n\tint status, node, live;\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\t/* It is very important that this message be\n\t\t\t * received so we spin until either the node\n\t\t\t * has died or it gets the message. */\n\t\t\tstatus = dlm_send_one_join_assert(dlm, node);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tlive = test_bit(node, dlm->live_nodes_map);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tif (status) {\n\t\t\t\tmlog(ML_ERROR, \"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\", status, node);\n\n\t\t\t\t/* give us some time between errors... */\n\t\t\t\tif (live)\n\t\t\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\t}\n\t\t} while (status && live);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_DOMAIN_BACKOFF_MS 200"
          ],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_send_join_asserts(struct dlm_ctxt *dlm,\n\t\t\t\t  unsigned long *node_map)\n{\n\tint status, node, live;\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\t/* It is very important that this message be\n\t\t\t * received so we spin until either the node\n\t\t\t * has died or it gets the message. */\n\t\t\tstatus = dlm_send_one_join_assert(dlm, node);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tlive = test_bit(node, dlm->live_nodes_map);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tif (status) {\n\t\t\t\tmlog(ML_ERROR, \"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\", status, node);\n\n\t\t\t\t/* give us some time between errors... */\n\t\t\t\tif (live)\n\t\t\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\t}\n\t\t} while (status && live);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_regions",
          "args": [
            "dlm",
            "ctxt->yes_resp_map"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1060-1111",
          "snippet": "static int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t/* if local hb, the numregions will be zero */\n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending regions to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"Region mismatch %d, node %d\\n\",\n\t\t\t     ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qr);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t/* if local hb, the numregions will be zero */\n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending regions to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"Region mismatch %d, node %d\\n\",\n\t\t\t     ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_nodeinfo",
          "args": [
            "dlm",
            "ctxt->yes_resp_map"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_nodeinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1232-1288",
          "snippet": "static int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_nodeinfo *qn = NULL;\n\tstruct o2nm_node *node;\n\tint ret = 0, status, count, i;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\n\tif (!qn) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\n\t\tnode = o2nm_get_node_by_num(i);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tqn->qn_nodes[count].ni_nodenum = node->nd_num;\n\t\tqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\n\t\tqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", node->nd_num,\n\t\t     &(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\n\t\t++count;\n\t\to2nm_node_put(node);\n\t}\n\n\tqn->qn_nodenum = dlm->node_num;\n\tqn->qn_numnodes = count;\n\tqn->qn_namelen = strlen(dlm->name);\n\tmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending nodeinfo to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\t qn, sizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"node mismatch %d, node %d\\n\", ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qn);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_nodeinfo *qn = NULL;\n\tstruct o2nm_node *node;\n\tint ret = 0, status, count, i;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\n\tif (!qn) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\n\t\tnode = o2nm_get_node_by_num(i);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tqn->qn_nodes[count].ni_nodenum = node->nd_num;\n\t\tqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\n\t\tqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", node->nd_num,\n\t\t     &(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\n\t\t++count;\n\t\to2nm_node_put(node);\n\t}\n\n\tqn->qn_nodenum = dlm->node_num;\n\tqn->qn_numnodes = count;\n\tqn->qn_namelen = strlen(dlm->name);\n\tmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending nodeinfo to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\t qn, sizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"node mismatch %d, node %d\\n\", ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "dlm->node_num",
            "dlm->domain_map"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dlm->domain_map",
            "ctxt->yes_resp_map",
            "sizeof(ctxt->yes_resp_map)"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Yay, done querying nodes!\\n\""
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_should_restart_join",
          "args": [
            "dlm",
            "ctxt",
            "response"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_should_restart_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1576-1598",
          "snippet": "static int dlm_should_restart_join(struct dlm_ctxt *dlm,\n\t\t\t\t   struct domain_join_ctxt *ctxt,\n\t\t\t\t   enum dlm_query_join_response_code response)\n{\n\tint ret;\n\n\tif (response == JOIN_DISALLOW) {\n\t\tmlog(0, \"Latest response of disallow -- should restart\\n\");\n\t\treturn 1;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\t/* For now, we restart the process if the node maps have\n\t * changed at all */\n\tret = memcmp(ctxt->live_map, dlm->live_nodes_map,\n\t\t     sizeof(dlm->live_nodes_map));\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret)\n\t\tmlog(0, \"Node maps changed -- should restart\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_should_restart_join(struct dlm_ctxt *dlm,\n\t\t\t\t   struct domain_join_ctxt *ctxt,\n\t\t\t\t   enum dlm_query_join_response_code response)\n{\n\tint ret;\n\n\tif (response == JOIN_DISALLOW) {\n\t\tmlog(0, \"Latest response of disallow -- should restart\\n\");\n\t\treturn 1;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\t/* For now, we restart the process if the node maps have\n\t * changed at all */\n\tret = memcmp(ctxt->live_map, dlm->live_nodes_map,\n\t\t     sizeof(dlm->live_nodes_map));\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret)\n\t\tmlog(0, \"Node maps changed -- should restart\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_request_join",
          "args": [
            "dlm",
            "node",
            "&response"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_request_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1430-1508",
          "snippet": "static int dlm_request_join(struct dlm_ctxt *dlm,\n\t\t\t    int node,\n\t\t\t    enum dlm_query_join_response_code *response)\n{\n\tint status;\n\tstruct dlm_query_join_request join_msg;\n\tstruct dlm_query_join_packet packet;\n\tu32 join_resp;\n\n\tmlog(0, \"querying node %d\\n\", node);\n\n\tmemset(&join_msg, 0, sizeof(join_msg));\n\tjoin_msg.node_idx = dlm->node_num;\n\tjoin_msg.name_len = strlen(dlm->name);\n\tmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\n\tjoin_msg.dlm_proto = dlm->dlm_locking_proto;\n\tjoin_msg.fs_proto = dlm->fs_locking_proto;\n\n\t/* copy live node map to join message */\n\tbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\n\t\t\t\t    sizeof(join_msg), node, &join_resp);\n\tif (status < 0 && status != -ENOPROTOOPT) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\tdlm_query_join_wire_to_packet(join_resp, &packet);\n\n\t/* -ENOPROTOOPT from the net code means the other side isn't\n\t    listening for our message type -- that's fine, it means\n\t    his dlm isn't up, so we can consider him a 'yes' but not\n\t    joined into the domain.  */\n\tif (status == -ENOPROTOOPT) {\n\t\tstatus = 0;\n\t\t*response = JOIN_OK_NO_MAP;\n\t} else if (packet.code == JOIN_DISALLOW ||\n\t\t   packet.code == JOIN_OK_NO_MAP) {\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_PROTOCOL_MISMATCH) {\n\t\tmlog(ML_NOTICE,\n\t\t     \"This node requested DLM locking protocol %u.%u and \"\n\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t     \"disconnecting\\n\",\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor,\n\t\t     node);\n\t\tstatus = -EPROTO;\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_OK) {\n\t\t*response = packet.code;\n\t\t/* Use the same locking protocol as the remote node */\n\t\tdlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\n\t\tdlm->fs_locking_proto.pv_minor = packet.fs_minor;\n\t\tmlog(0,\n\t\t     \"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t     \"%u.%u and fs locking protocol %u.%u\\n\",\n\t\t     node,\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor);\n\t} else {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid response %d from node %u\\n\",\n\t\t     packet.code, node);\n\t}\n\n\tmlog(0, \"status %d, node %d response is %d\\n\", status, node,\n\t     *response);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_request_join(struct dlm_ctxt *dlm,\n\t\t\t    int node,\n\t\t\t    enum dlm_query_join_response_code *response)\n{\n\tint status;\n\tstruct dlm_query_join_request join_msg;\n\tstruct dlm_query_join_packet packet;\n\tu32 join_resp;\n\n\tmlog(0, \"querying node %d\\n\", node);\n\n\tmemset(&join_msg, 0, sizeof(join_msg));\n\tjoin_msg.node_idx = dlm->node_num;\n\tjoin_msg.name_len = strlen(dlm->name);\n\tmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\n\tjoin_msg.dlm_proto = dlm->dlm_locking_proto;\n\tjoin_msg.fs_proto = dlm->fs_locking_proto;\n\n\t/* copy live node map to join message */\n\tbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\n\t\t\t\t    sizeof(join_msg), node, &join_resp);\n\tif (status < 0 && status != -ENOPROTOOPT) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\tdlm_query_join_wire_to_packet(join_resp, &packet);\n\n\t/* -ENOPROTOOPT from the net code means the other side isn't\n\t    listening for our message type -- that's fine, it means\n\t    his dlm isn't up, so we can consider him a 'yes' but not\n\t    joined into the domain.  */\n\tif (status == -ENOPROTOOPT) {\n\t\tstatus = 0;\n\t\t*response = JOIN_OK_NO_MAP;\n\t} else if (packet.code == JOIN_DISALLOW ||\n\t\t   packet.code == JOIN_OK_NO_MAP) {\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_PROTOCOL_MISMATCH) {\n\t\tmlog(ML_NOTICE,\n\t\t     \"This node requested DLM locking protocol %u.%u and \"\n\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t     \"disconnecting\\n\",\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor,\n\t\t     node);\n\t\tstatus = -EPROTO;\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_OK) {\n\t\t*response = packet.code;\n\t\t/* Use the same locking protocol as the remote node */\n\t\tdlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\n\t\tdlm->fs_locking_proto.pv_minor = packet.fs_minor;\n\t\tmlog(0,\n\t\t     \"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t     \"%u.%u and fs locking protocol %u.%u\\n\",\n\t\t     node,\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor);\n\t} else {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid response %d from node %u\\n\",\n\t\t     packet.code, node);\n\t}\n\n\tmlog(0, \"status %d, node %d response is %d\\n\", status, node,\n\t     *response);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "ctxt->live_map",
            "O2NM_MAX_NODES",
            "node + 1"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctxt->live_map",
            "dlm->live_nodes_map",
            "sizeof(ctxt->live_map)"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2hb_fill_node_map",
          "args": [
            "dlm->live_nodes_map",
            "sizeof(dlm->live_nodes_map)"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_fill_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "1417-1426",
          "snippet": "void o2hb_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\t/* callers want to serialize this map and callbacks so that they\n\t * can trust that they don't miss nodes coming to the party */\n\tdown_read(&o2hb_callback_sem);\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(map, bytes);\n\tspin_unlock(&o2hb_live_lock);\n\tup_read(&o2hb_callback_sem);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static DEFINE_SPINLOCK(o2hb_live_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic DEFINE_SPINLOCK(o2hb_live_lock);\n\nvoid o2hb_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\t/* callers want to serialize this map and callbacks so that they\n\t * can trust that they don't miss nodes coming to the party */\n\tdown_read(&o2hb_callback_sem);\n\tspin_lock(&o2hb_live_lock);\n\to2hb_fill_node_map_from_callback(map, bytes);\n\tspin_unlock(&o2hb_live_lock);\n\tup_read(&o2hb_callback_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ctxt)",
            "GFP_KERNEL"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\n{\n\tint status = 0, tmpstat, node;\n\tstruct domain_join_ctxt *ctxt;\n\tenum dlm_query_join_response_code response = JOIN_DISALLOW;\n\n\tmlog(0, \"%p\", dlm);\n\n\tctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\n\tif (!ctxt) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* group sem locking should work for us here -- we're already\n\t * registered for heartbeat events so filling this should be\n\t * atomic wrt getting those handlers called. */\n\to2hb_fill_node_map(dlm->live_nodes_map, sizeof(dlm->live_nodes_map));\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(ctxt->live_map, dlm->live_nodes_map, sizeof(ctxt->live_map));\n\n\t__dlm_set_joining_node(dlm, dlm->node_num);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tnode = -1;\n\twhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tstatus = dlm_request_join(dlm, node, &response);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Ok, either we got a response or the node doesn't have a\n\t\t * dlm up. */\n\t\tif (response == JOIN_OK)\n\t\t\tset_bit(node, ctxt->yes_resp_map);\n\n\t\tif (dlm_should_restart_join(dlm, ctxt, response)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tmlog(0, \"Yay, done querying nodes!\\n\");\n\n\t/* Yay, everyone agree's we can join the domain. My domain is\n\t * comprised of all nodes who were put in the\n\t * yes_resp_map. Copy that into our domain map and send a join\n\t * assert message to clean up everyone elses state. */\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->domain_map, ctxt->yes_resp_map,\n\t       sizeof(ctxt->yes_resp_map));\n\tset_bit(dlm->node_num, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* Support for global heartbeat and node info was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major > 1 ||\n\t    dlm->dlm_locking_proto.pv_minor > 0) {\n\t\tstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdlm_send_join_asserts(dlm, ctxt->yes_resp_map);\n\n\t/* Joined state *must* be set before the joining node\n\t * information, otherwise the query_join handler may read no\n\t * current joiner but a state of NEW and tell joining nodes\n\t * we're not in the domain. */\n\tspin_lock(&dlm_domain_lock);\n\tdlm->dlm_state = DLM_CTXT_JOINED;\n\tdlm->num_joins++;\n\tspin_unlock(&dlm_domain_lock);\n\nbail:\n\tspin_lock(&dlm->spinlock);\n\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tif (!status) {\n\t\tprintk(KERN_NOTICE \"o2dlm: Joining domain %s \", dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ctxt) {\n\t\t/* Do we need to send a cancel message to any nodes? */\n\t\tif (status < 0) {\n\t\t\ttmpstat = dlm_send_join_cancels(dlm,\n\t\t\t\t\t\t\tctxt->yes_resp_map,\n\t\t\t\t\t\t\tsizeof(ctxt->yes_resp_map));\n\t\t\tif (tmpstat < 0)\n\t\t\t\tmlog_errno(tmpstat);\n\t\t}\n\t\tkfree(ctxt);\n\t}\n\n\tmlog(0, \"returning %d\\n\", status);\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_should_restart_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1576-1598",
    "snippet": "static int dlm_should_restart_join(struct dlm_ctxt *dlm,\n\t\t\t\t   struct domain_join_ctxt *ctxt,\n\t\t\t\t   enum dlm_query_join_response_code response)\n{\n\tint ret;\n\n\tif (response == JOIN_DISALLOW) {\n\t\tmlog(0, \"Latest response of disallow -- should restart\\n\");\n\t\treturn 1;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\t/* For now, we restart the process if the node maps have\n\t * changed at all */\n\tret = memcmp(ctxt->live_map, dlm->live_nodes_map,\n\t\t     sizeof(dlm->live_nodes_map));\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret)\n\t\tmlog(0, \"Node maps changed -- should restart\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Node maps changed -- should restart\\n\""
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ctxt->live_map",
            "dlm->live_nodes_map",
            "sizeof(dlm->live_nodes_map)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_should_restart_join(struct dlm_ctxt *dlm,\n\t\t\t\t   struct domain_join_ctxt *ctxt,\n\t\t\t\t   enum dlm_query_join_response_code response)\n{\n\tint ret;\n\n\tif (response == JOIN_DISALLOW) {\n\t\tmlog(0, \"Latest response of disallow -- should restart\\n\");\n\t\treturn 1;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\t/* For now, we restart the process if the node maps have\n\t * changed at all */\n\tret = memcmp(ctxt->live_map, dlm->live_nodes_map,\n\t\t     sizeof(dlm->live_nodes_map));\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret)\n\t\tmlog(0, \"Node maps changed -- should restart\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_send_join_asserts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1537-1569",
    "snippet": "static void dlm_send_join_asserts(struct dlm_ctxt *dlm,\n\t\t\t\t  unsigned long *node_map)\n{\n\tint status, node, live;\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\t/* It is very important that this message be\n\t\t\t * received so we spin until either the node\n\t\t\t * has died or it gets the message. */\n\t\t\tstatus = dlm_send_one_join_assert(dlm, node);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tlive = test_bit(node, dlm->live_nodes_map);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tif (status) {\n\t\t\t\tmlog(ML_ERROR, \"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\", status, node);\n\n\t\t\t\t/* give us some time between errors... */\n\t\t\t\tif (live)\n\t\t\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\t}\n\t\t} while (status && live);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_DOMAIN_BACKOFF_MS 200"
    ],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "DLM_DOMAIN_BACKOFF_MS"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\"",
            "status",
            "node"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "node",
            "dlm->live_nodes_map"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_one_join_assert",
          "args": [
            "dlm",
            "node"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_join_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1510-1535",
          "snippet": "static int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tint ret;\n\tstruct dlm_assert_joined assert_msg;\n\n\tmlog(0, \"Sending join assert to node %u\\n\", node);\n\n\tmemset(&assert_msg, 0, sizeof(assert_msg));\n\tassert_msg.node_idx = dlm->node_num;\n\tassert_msg.name_len = strlen(dlm->name);\n\tmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t    &assert_msg, sizeof(assert_msg), node,\n\t\t\t\t    &ret);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t     node);\n\telse\n\t\tstatus = ret;\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tint ret;\n\tstruct dlm_assert_joined assert_msg;\n\n\tmlog(0, \"Sending join assert to node %u\\n\", node);\n\n\tmemset(&assert_msg, 0, sizeof(assert_msg));\n\tassert_msg.node_idx = dlm->node_num;\n\tassert_msg.name_len = strlen(dlm->name);\n\tmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t    &assert_msg, sizeof(assert_msg), node,\n\t\t\t\t    &ret);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t     node);\n\telse\n\t\tstatus = ret;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "node_map",
            "O2NM_MAX_NODES",
            "node + 1"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_send_join_asserts(struct dlm_ctxt *dlm,\n\t\t\t\t  unsigned long *node_map)\n{\n\tint status, node, live;\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\t/* It is very important that this message be\n\t\t\t * received so we spin until either the node\n\t\t\t * has died or it gets the message. */\n\t\t\tstatus = dlm_send_one_join_assert(dlm, node);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tlive = test_bit(node, dlm->live_nodes_map);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tif (status) {\n\t\t\t\tmlog(ML_ERROR, \"Error return %d asserting \"\n\t\t\t\t     \"join on node %d\\n\", status, node);\n\n\t\t\t\t/* give us some time between errors... */\n\t\t\t\tif (live)\n\t\t\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\t}\n\t\t} while (status && live);\n\t}\n}"
  },
  {
    "function_name": "dlm_send_one_join_assert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1510-1535",
    "snippet": "static int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tint ret;\n\tstruct dlm_assert_joined assert_msg;\n\n\tmlog(0, \"Sending join assert to node %u\\n\", node);\n\n\tmemset(&assert_msg, 0, sizeof(assert_msg));\n\tassert_msg.node_idx = dlm->node_num;\n\tassert_msg.name_len = strlen(dlm->name);\n\tmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t    &assert_msg, sizeof(assert_msg), node,\n\t\t\t\t    &ret);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t     node);\n\telse\n\t\tstatus = ret;\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\"",
            "status",
            "DLM_ASSERT_JOINED_MSG",
            "DLM_MOD_KEY",
            "node"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_ASSERT_JOINED_MSG",
            "DLM_MOD_KEY",
            "&assert_msg",
            "sizeof(assert_msg)",
            "node",
            "&ret"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "assert_msg.domain",
            "dlm->name",
            "assert_msg.name_len"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dlm->name"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&assert_msg",
            "0",
            "sizeof(assert_msg)"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Sending join assert to node %u\\n\"",
            "node"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tint ret;\n\tstruct dlm_assert_joined assert_msg;\n\n\tmlog(0, \"Sending join assert to node %u\\n\", node);\n\n\tmemset(&assert_msg, 0, sizeof(assert_msg));\n\tassert_msg.node_idx = dlm->node_num;\n\tassert_msg.name_len = strlen(dlm->name);\n\tmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t\t\t    &assert_msg, sizeof(assert_msg), node,\n\t\t\t\t    &ret);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\n\t\t     node);\n\telse\n\t\tstatus = ret;\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_request_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1430-1508",
    "snippet": "static int dlm_request_join(struct dlm_ctxt *dlm,\n\t\t\t    int node,\n\t\t\t    enum dlm_query_join_response_code *response)\n{\n\tint status;\n\tstruct dlm_query_join_request join_msg;\n\tstruct dlm_query_join_packet packet;\n\tu32 join_resp;\n\n\tmlog(0, \"querying node %d\\n\", node);\n\n\tmemset(&join_msg, 0, sizeof(join_msg));\n\tjoin_msg.node_idx = dlm->node_num;\n\tjoin_msg.name_len = strlen(dlm->name);\n\tmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\n\tjoin_msg.dlm_proto = dlm->dlm_locking_proto;\n\tjoin_msg.fs_proto = dlm->fs_locking_proto;\n\n\t/* copy live node map to join message */\n\tbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\n\t\t\t\t    sizeof(join_msg), node, &join_resp);\n\tif (status < 0 && status != -ENOPROTOOPT) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\tdlm_query_join_wire_to_packet(join_resp, &packet);\n\n\t/* -ENOPROTOOPT from the net code means the other side isn't\n\t    listening for our message type -- that's fine, it means\n\t    his dlm isn't up, so we can consider him a 'yes' but not\n\t    joined into the domain.  */\n\tif (status == -ENOPROTOOPT) {\n\t\tstatus = 0;\n\t\t*response = JOIN_OK_NO_MAP;\n\t} else if (packet.code == JOIN_DISALLOW ||\n\t\t   packet.code == JOIN_OK_NO_MAP) {\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_PROTOCOL_MISMATCH) {\n\t\tmlog(ML_NOTICE,\n\t\t     \"This node requested DLM locking protocol %u.%u and \"\n\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t     \"disconnecting\\n\",\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor,\n\t\t     node);\n\t\tstatus = -EPROTO;\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_OK) {\n\t\t*response = packet.code;\n\t\t/* Use the same locking protocol as the remote node */\n\t\tdlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\n\t\tdlm->fs_locking_proto.pv_minor = packet.fs_minor;\n\t\tmlog(0,\n\t\t     \"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t     \"%u.%u and fs locking protocol %u.%u\\n\",\n\t\t     node,\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor);\n\t} else {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid response %d from node %u\\n\",\n\t\t     packet.code, node);\n\t}\n\n\tmlog(0, \"status %d, node %d response is %d\\n\", status, node,\n\t     *response);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"status %d, node %d response is %d\\n\"",
            "status",
            "node",
            "*response"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"invalid response %d from node %u\\n\"",
            "packet.code",
            "node"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t     \"%u.%u and fs locking protocol %u.%u\\n\"",
            "node",
            "dlm->dlm_locking_proto.pv_major",
            "dlm->dlm_locking_proto.pv_minor",
            "dlm->fs_locking_proto.pv_major",
            "dlm->fs_locking_proto.pv_minor"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"This node requested DLM locking protocol %u.%u and \"\n\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t     \"disconnecting\\n\"",
            "dlm->dlm_locking_proto.pv_major",
            "dlm->dlm_locking_proto.pv_minor",
            "dlm->fs_locking_proto.pv_major",
            "dlm->fs_locking_proto.pv_minor",
            "node"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_query_join_wire_to_packet",
          "args": [
            "join_resp",
            "&packet"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_query_join_wire_to_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "798-805",
          "snippet": "static void dlm_query_join_wire_to_packet(u32 wire,\n\t\t\t\t\t  struct dlm_query_join_packet *packet)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.intval = cpu_to_be32(wire);\n\t*packet = response.packet;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_query_join_wire_to_packet(u32 wire,\n\t\t\t\t\t  struct dlm_query_join_packet *packet)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.intval = cpu_to_be32(wire);\n\t*packet = response.packet;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\"",
            "status",
            "DLM_QUERY_JOIN_MSG",
            "DLM_MOD_KEY",
            "node"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_QUERY_JOIN_MSG",
            "DLM_MOD_KEY",
            "&join_msg",
            "sizeof(join_msg)",
            "node",
            "&join_resp"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "byte_copymap",
          "args": [
            "join_msg.node_map",
            "dlm->live_nodes_map",
            "O2NM_MAX_NODES"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "byte_copymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "65-77",
          "snippet": "static inline void byte_copymap(u8 dmap[], unsigned long smap[],\n\t\t\tunsigned int sz)\n{\n\tunsigned int nn;\n\n\tif (!sz)\n\t\treturn;\n\n\tmemset(dmap, 0, ((sz + 7) >> 3));\n\tfor (nn = 0 ; nn < sz; nn++)\n\t\tif (test_bit(nn, smap))\n\t\t\tbyte_set_bit(nn, dmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_copymap(u8 dmap[], unsigned long smap[],\n\t\t\tunsigned int sz)\n{\n\tunsigned int nn;\n\n\tif (!sz)\n\t\treturn;\n\n\tmemset(dmap, 0, ((sz + 7) >> 3));\n\tfor (nn = 0 ; nn < sz; nn++)\n\t\tif (test_bit(nn, smap))\n\t\t\tbyte_set_bit(nn, dmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "join_msg.domain",
            "dlm->name",
            "join_msg.name_len"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dlm->name"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&join_msg",
            "0",
            "sizeof(join_msg)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"querying node %d\\n\"",
            "node"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_request_join(struct dlm_ctxt *dlm,\n\t\t\t    int node,\n\t\t\t    enum dlm_query_join_response_code *response)\n{\n\tint status;\n\tstruct dlm_query_join_request join_msg;\n\tstruct dlm_query_join_packet packet;\n\tu32 join_resp;\n\n\tmlog(0, \"querying node %d\\n\", node);\n\n\tmemset(&join_msg, 0, sizeof(join_msg));\n\tjoin_msg.node_idx = dlm->node_num;\n\tjoin_msg.name_len = strlen(dlm->name);\n\tmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\n\tjoin_msg.dlm_proto = dlm->dlm_locking_proto;\n\tjoin_msg.fs_proto = dlm->fs_locking_proto;\n\n\t/* copy live node map to join message */\n\tbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\n\n\tstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\n\t\t\t\t    sizeof(join_msg), node, &join_resp);\n\tif (status < 0 && status != -ENOPROTOOPT) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\tdlm_query_join_wire_to_packet(join_resp, &packet);\n\n\t/* -ENOPROTOOPT from the net code means the other side isn't\n\t    listening for our message type -- that's fine, it means\n\t    his dlm isn't up, so we can consider him a 'yes' but not\n\t    joined into the domain.  */\n\tif (status == -ENOPROTOOPT) {\n\t\tstatus = 0;\n\t\t*response = JOIN_OK_NO_MAP;\n\t} else if (packet.code == JOIN_DISALLOW ||\n\t\t   packet.code == JOIN_OK_NO_MAP) {\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_PROTOCOL_MISMATCH) {\n\t\tmlog(ML_NOTICE,\n\t\t     \"This node requested DLM locking protocol %u.%u and \"\n\t\t     \"filesystem locking protocol %u.%u.  At least one of \"\n\t\t     \"the protocol versions on node %d is not compatible, \"\n\t\t     \"disconnecting\\n\",\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor,\n\t\t     node);\n\t\tstatus = -EPROTO;\n\t\t*response = packet.code;\n\t} else if (packet.code == JOIN_OK) {\n\t\t*response = packet.code;\n\t\t/* Use the same locking protocol as the remote node */\n\t\tdlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\n\t\tdlm->fs_locking_proto.pv_minor = packet.fs_minor;\n\t\tmlog(0,\n\t\t     \"Node %d responds JOIN_OK with DLM locking protocol \"\n\t\t     \"%u.%u and fs locking protocol %u.%u\\n\",\n\t\t     node,\n\t\t     dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor,\n\t\t     dlm->fs_locking_proto.pv_major,\n\t\t     dlm->fs_locking_proto.pv_minor);\n\t} else {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid response %d from node %u\\n\",\n\t\t     packet.code, node);\n\t}\n\n\tmlog(0, \"status %d, node %d response is %d\\n\", status, node,\n\t     *response);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_join_cancels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1394-1428",
    "snippet": "static int dlm_send_join_cancels(struct dlm_ctxt *dlm,\n\t\t\t\t unsigned long *node_map,\n\t\t\t\t unsigned int map_size)\n{\n\tint status, tmpstat;\n\tunsigned int node;\n\n\tif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\n\t\t\t sizeof(unsigned long))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\\n\",\n\t\t     map_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\ttmpstat = dlm_send_one_join_cancel(dlm, node);\n\t\tif (tmpstat) {\n\t\t\tmlog(ML_ERROR, \"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\", tmpstat, node);\n\t\t\tif (!status)\n\t\t\t\tstatus = tmpstat;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\"",
            "tmpstat",
            "node"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_one_join_cancel",
          "args": [
            "dlm",
            "node"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_join_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1368-1391",
          "snippet": "static int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_cancel_join cancel_msg;\n\n\tmemset(&cancel_msg, 0, sizeof(cancel_msg));\n\tcancel_msg.node_idx = dlm->node_num;\n\tcancel_msg.name_len = strlen(dlm->name);\n\tmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t    &cancel_msg, sizeof(cancel_msg), node,\n\t\t\t\t    NULL);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_cancel_join cancel_msg;\n\n\tmemset(&cancel_msg, 0, sizeof(cancel_msg));\n\tcancel_msg.node_idx = dlm->node_num;\n\tcancel_msg.name_len = strlen(dlm->name);\n\tmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t    &cancel_msg, sizeof(cancel_msg), node,\n\t\t\t\t    NULL);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "node_map",
            "O2NM_MAX_NODES",
            "node + 1"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_join_cancels(struct dlm_ctxt *dlm,\n\t\t\t\t unsigned long *node_map,\n\t\t\t\t unsigned int map_size)\n{\n\tint status, tmpstat;\n\tunsigned int node;\n\n\tif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\n\t\t\t sizeof(unsigned long))) {\n\t\tmlog(ML_ERROR,\n\t\t     \"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\\n\",\n\t\t     map_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = 0;\n\tnode = -1;\n\twhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\ttmpstat = dlm_send_one_join_cancel(dlm, node);\n\t\tif (tmpstat) {\n\t\t\tmlog(ML_ERROR, \"Error return %d cancelling join on \"\n\t\t\t     \"node %d\\n\", tmpstat, node);\n\t\t\tif (!status)\n\t\t\t\tstatus = tmpstat;\n\t\t}\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_one_join_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1368-1391",
    "snippet": "static int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_cancel_join cancel_msg;\n\n\tmemset(&cancel_msg, 0, sizeof(cancel_msg));\n\tcancel_msg.node_idx = dlm->node_num;\n\tcancel_msg.name_len = strlen(dlm->name);\n\tmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t    &cancel_msg, sizeof(cancel_msg), node,\n\t\t\t\t    NULL);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\"",
            "status",
            "DLM_CANCEL_JOIN_MSG",
            "DLM_MOD_KEY",
            "node"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_CANCEL_JOIN_MSG",
            "DLM_MOD_KEY",
            "&cancel_msg",
            "sizeof(cancel_msg)",
            "node",
            "NULL"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cancel_msg.domain",
            "dlm->name",
            "cancel_msg.name_len"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dlm->name"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cancel_msg",
            "0",
            "sizeof(cancel_msg)"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_cancel_join cancel_msg;\n\n\tmemset(&cancel_msg, 0, sizeof(cancel_msg));\n\tcancel_msg.node_idx = dlm->node_num;\n\tcancel_msg.name_len = strlen(dlm->name);\n\tmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\n\n\tstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t\t\t    &cancel_msg, sizeof(cancel_msg), node,\n\t\t\t\t    NULL);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\n\t\t     node);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_cancel_join_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1339-1366",
    "snippet": "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_cancel_join *cancel;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tcancel = (struct dlm_cancel_join *) msg->buf;\n\n\tmlog(0, \"node %u cancels join on domain %s\\n\", cancel->node_idx,\n\t\t  cancel->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(cancel->domain, cancel->name_len);\n\n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t/* Yikes, this guy wants to cancel his join. No\n\t\t * problem, we simply cleanup our join state. */\n\t\tBUG_ON(dlm->joining_node != cancel->node_idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_set_joining_node",
          "args": [
            "dlm",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_set_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "267-274",
          "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->joining_node != cancel->node_idx"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "cancel->domain",
            "cancel->name_len"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u cancels join on domain %s\\n\"",
            "cancel->node_idx",
            "cancel->domain"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_cancel_join *cancel;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tcancel = (struct dlm_cancel_join *) msg->buf;\n\n\tmlog(0, \"node %u cancels join on domain %s\\n\", cancel->node_idx,\n\t\t  cancel->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(cancel->domain, cancel->name_len);\n\n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t/* Yikes, this guy wants to cancel his join. No\n\t\t * problem, we simply cleanup our join state. */\n\t\tBUG_ON(dlm->joining_node != cancel->node_idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_query_nodeinfo_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1290-1337",
    "snippet": "static int dlm_query_nodeinfo_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t      void *data, void **ret_data)\n{\n\tstruct dlm_query_nodeinfo *qn;\n\tstruct dlm_ctxt *dlm = NULL;\n\tint locked = 0, status = -EINVAL;\n\n\tqn = (struct dlm_query_nodeinfo *) msg->buf;\n\n\tmlog(0, \"Node %u queries nodes on domain %s\\n\", qn->qn_nodenum,\n\t     qn->qn_domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qn->qn_domain, qn->qn_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s before \"\n\t\t     \"join domain\\n\", qn->qn_nodenum, qn->qn_domain);\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tlocked = 1;\n\tif (dlm->joining_node != qn->qn_nodenum) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s but \"\n\t\t     \"joining node is %d\\n\", qn->qn_nodenum, qn->qn_domain,\n\t\t     dlm->joining_node);\n\t\tgoto bail;\n\t}\n\n\t/* Support for node query was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qn->qn_nodenum,\n\t\t     qn->qn_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_match_nodes(dlm, qn);\n\nbail:\n\tif (locked)\n\t\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_match_nodes",
          "args": [
            "dlm",
            "qn"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_match_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1172-1230",
          "snippet": "static int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\n{\n\tstruct o2nm_node *local;\n\tstruct dlm_node_info *remote;\n\tint i, j;\n\tint status = 0;\n\n\tfor (j = 0; j < qn->qn_numnodes; ++j)\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", qn->qn_nodes[j].ni_nodenum,\n\t\t     &(qn->qn_nodes[j].ni_ipv4_address),\n\t\t     ntohs(qn->qn_nodes[j].ni_ipv4_port));\n\n\tfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\n\t\tlocal = o2nm_get_node_by_num(i);\n\t\tremote = NULL;\n\t\tfor (j = 0; j < qn->qn_numnodes; ++j) {\n\t\t\tif (qn->qn_nodes[j].ni_nodenum == i) {\n\t\t\t\tremote = &(qn->qn_nodes[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!local && !remote)\n\t\t\tcontinue;\n\n\t\tif ((local && !remote) || (!local && remote))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (!status &&\n\t\t    ((remote->ni_nodenum != local->nd_num) ||\n\t\t     (remote->ni_ipv4_port != local->nd_ipv4_port) ||\n\t\t     (remote->ni_ipv4_address != local->nd_ipv4_address)))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (status) {\n\t\t\tif (remote && !local)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\", qn->qn_domain,\n\t\t\t\t     remote->ni_nodenum,\n\t\t\t\t     &(remote->ni_ipv4_address),\n\t\t\t\t     ntohs(remote->ni_ipv4_port),\n\t\t\t\t     qn->qn_nodenum, dlm->node_num);\n\t\t\tif (local && !remote)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\", qn->qn_domain,\n\t\t\t\t     local->nd_num, &(local->nd_ipv4_address),\n\t\t\t\t     ntohs(local->nd_ipv4_port),\n\t\t\t\t     dlm->node_num, qn->qn_nodenum);\n\t\t\tBUG_ON((!local && !remote));\n\t\t}\n\n\t\tif (local)\n\t\t\to2nm_node_put(local);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\n{\n\tstruct o2nm_node *local;\n\tstruct dlm_node_info *remote;\n\tint i, j;\n\tint status = 0;\n\n\tfor (j = 0; j < qn->qn_numnodes; ++j)\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", qn->qn_nodes[j].ni_nodenum,\n\t\t     &(qn->qn_nodes[j].ni_ipv4_address),\n\t\t     ntohs(qn->qn_nodes[j].ni_ipv4_port));\n\n\tfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\n\t\tlocal = o2nm_get_node_by_num(i);\n\t\tremote = NULL;\n\t\tfor (j = 0; j < qn->qn_numnodes; ++j) {\n\t\t\tif (qn->qn_nodes[j].ni_nodenum == i) {\n\t\t\t\tremote = &(qn->qn_nodes[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!local && !remote)\n\t\t\tcontinue;\n\n\t\tif ((local && !remote) || (!local && remote))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (!status &&\n\t\t    ((remote->ni_nodenum != local->nd_num) ||\n\t\t     (remote->ni_ipv4_port != local->nd_ipv4_port) ||\n\t\t     (remote->ni_ipv4_address != local->nd_ipv4_address)))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (status) {\n\t\t\tif (remote && !local)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\", qn->qn_domain,\n\t\t\t\t     remote->ni_nodenum,\n\t\t\t\t     &(remote->ni_ipv4_address),\n\t\t\t\t     ntohs(remote->ni_ipv4_port),\n\t\t\t\t     qn->qn_nodenum, dlm->node_num);\n\t\t\tif (local && !remote)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\", qn->qn_domain,\n\t\t\t\t     local->nd_num, &(local->nd_ipv4_address),\n\t\t\t\t     ntohs(local->nd_ipv4_port),\n\t\t\t\t     dlm->node_num, qn->qn_nodenum);\n\t\t\tBUG_ON((!local && !remote));\n\t\t}\n\n\t\tif (local)\n\t\t\to2nm_node_put(local);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried nodes on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\"",
            "qn->qn_nodenum",
            "qn->qn_domain",
            "dlm->dlm_locking_proto.pv_major",
            "dlm->dlm_locking_proto.pv_minor"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried nodes on domain %s but \"\n\t\t     \"joining node is %d\\n\"",
            "qn->qn_nodenum",
            "qn->qn_domain",
            "dlm->joining_node"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried nodes on domain %s before \"\n\t\t     \"join domain\\n\"",
            "qn->qn_nodenum",
            "qn->qn_domain"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "qn->qn_domain",
            "qn->qn_namelen"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_query_nodeinfo_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t      void *data, void **ret_data)\n{\n\tstruct dlm_query_nodeinfo *qn;\n\tstruct dlm_ctxt *dlm = NULL;\n\tint locked = 0, status = -EINVAL;\n\n\tqn = (struct dlm_query_nodeinfo *) msg->buf;\n\n\tmlog(0, \"Node %u queries nodes on domain %s\\n\", qn->qn_nodenum,\n\t     qn->qn_domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qn->qn_domain, qn->qn_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s before \"\n\t\t     \"join domain\\n\", qn->qn_nodenum, qn->qn_domain);\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tlocked = 1;\n\tif (dlm->joining_node != qn->qn_nodenum) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s but \"\n\t\t     \"joining node is %d\\n\", qn->qn_nodenum, qn->qn_domain,\n\t\t     dlm->joining_node);\n\t\tgoto bail;\n\t}\n\n\t/* Support for node query was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried nodes on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qn->qn_nodenum,\n\t\t     qn->qn_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto bail;\n\t}\n\n\tstatus = dlm_match_nodes(dlm, qn);\n\nbail:\n\tif (locked)\n\t\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_nodeinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1232-1288",
    "snippet": "static int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_nodeinfo *qn = NULL;\n\tstruct o2nm_node *node;\n\tint ret = 0, status, count, i;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\n\tif (!qn) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\n\t\tnode = o2nm_get_node_by_num(i);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tqn->qn_nodes[count].ni_nodenum = node->nd_num;\n\t\tqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\n\t\tqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", node->nd_num,\n\t\t     &(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\n\t\t++count;\n\t\to2nm_node_put(node);\n\t}\n\n\tqn->qn_nodenum = dlm->node_num;\n\tqn->qn_numnodes = count;\n\tqn->qn_namelen = strlen(dlm->name);\n\tmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending nodeinfo to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\t qn, sizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"node mismatch %d, node %d\\n\", ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qn);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qn"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"node mismatch %d, node %d\\n\"",
            "ret",
            "i"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_QUERY_NODEINFO",
            "DLM_MOD_KEY",
            "qn",
            "sizeof(struct dlm_query_nodeinfo)",
            "i",
            "&status"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Sending nodeinfo to node %d\\n\"",
            "i"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "node_map",
            "O2NM_MAX_NODES",
            "i + 1"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qn->qn_domain",
            "dlm->name",
            "qn->qn_namelen"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dlm->name"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "node"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Node %3d, %pI4:%u\\n\"",
            "node->nd_num",
            "&(node->nd_ipv4_address)",
            "ntohs(node->nd_ipv4_port)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "node->nd_ipv4_port"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "i"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_query_nodeinfo)",
            "GFP_KERNEL"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_nodeinfo *qn = NULL;\n\tstruct o2nm_node *node;\n\tint ret = 0, status, count, i;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\n\tif (!qn) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\n\t\tnode = o2nm_get_node_by_num(i);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tqn->qn_nodes[count].ni_nodenum = node->nd_num;\n\t\tqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\n\t\tqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", node->nd_num,\n\t\t     &(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\n\t\t++count;\n\t\to2nm_node_put(node);\n\t}\n\n\tqn->qn_nodenum = dlm->node_num;\n\tqn->qn_numnodes = count;\n\tqn->qn_namelen = strlen(dlm->name);\n\tmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending nodeinfo to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\n\t\t\t\t\t qn, sizeof(struct dlm_query_nodeinfo),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"node mismatch %d, node %d\\n\", ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qn);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_match_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1172-1230",
    "snippet": "static int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\n{\n\tstruct o2nm_node *local;\n\tstruct dlm_node_info *remote;\n\tint i, j;\n\tint status = 0;\n\n\tfor (j = 0; j < qn->qn_numnodes; ++j)\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", qn->qn_nodes[j].ni_nodenum,\n\t\t     &(qn->qn_nodes[j].ni_ipv4_address),\n\t\t     ntohs(qn->qn_nodes[j].ni_ipv4_port));\n\n\tfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\n\t\tlocal = o2nm_get_node_by_num(i);\n\t\tremote = NULL;\n\t\tfor (j = 0; j < qn->qn_numnodes; ++j) {\n\t\t\tif (qn->qn_nodes[j].ni_nodenum == i) {\n\t\t\t\tremote = &(qn->qn_nodes[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!local && !remote)\n\t\t\tcontinue;\n\n\t\tif ((local && !remote) || (!local && remote))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (!status &&\n\t\t    ((remote->ni_nodenum != local->nd_num) ||\n\t\t     (remote->ni_ipv4_port != local->nd_ipv4_port) ||\n\t\t     (remote->ni_ipv4_address != local->nd_ipv4_address)))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (status) {\n\t\t\tif (remote && !local)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\", qn->qn_domain,\n\t\t\t\t     remote->ni_nodenum,\n\t\t\t\t     &(remote->ni_ipv4_address),\n\t\t\t\t     ntohs(remote->ni_ipv4_port),\n\t\t\t\t     qn->qn_nodenum, dlm->node_num);\n\t\t\tif (local && !remote)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\", qn->qn_domain,\n\t\t\t\t     local->nd_num, &(local->nd_ipv4_address),\n\t\t\t\t     ntohs(local->nd_ipv4_port),\n\t\t\t\t     dlm->node_num, qn->qn_nodenum);\n\t\t\tBUG_ON((!local && !remote));\n\t\t}\n\n\t\tif (local)\n\t\t\to2nm_node_put(local);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "local"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(!local && !remote)"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\"",
            "qn->qn_domain",
            "local->nd_num",
            "&(local->nd_ipv4_address)",
            "ntohs(local->nd_ipv4_port)",
            "dlm->node_num",
            "qn->qn_nodenum"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "local->nd_ipv4_port"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\"",
            "qn->qn_domain",
            "remote->ni_nodenum",
            "&(remote->ni_ipv4_address)",
            "ntohs(remote->ni_ipv4_port)",
            "qn->qn_nodenum",
            "dlm->node_num"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "remote->ni_ipv4_port"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "i"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Node %3d, %pI4:%u\\n\"",
            "qn->qn_nodes[j].ni_nodenum",
            "&(qn->qn_nodes[j].ni_ipv4_address)",
            "ntohs(qn->qn_nodes[j].ni_ipv4_port)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "qn->qn_nodes[j].ni_ipv4_port"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\n{\n\tstruct o2nm_node *local;\n\tstruct dlm_node_info *remote;\n\tint i, j;\n\tint status = 0;\n\n\tfor (j = 0; j < qn->qn_numnodes; ++j)\n\t\tmlog(0, \"Node %3d, %pI4:%u\\n\", qn->qn_nodes[j].ni_nodenum,\n\t\t     &(qn->qn_nodes[j].ni_ipv4_address),\n\t\t     ntohs(qn->qn_nodes[j].ni_ipv4_port));\n\n\tfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\n\t\tlocal = o2nm_get_node_by_num(i);\n\t\tremote = NULL;\n\t\tfor (j = 0; j < qn->qn_numnodes; ++j) {\n\t\t\tif (qn->qn_nodes[j].ni_nodenum == i) {\n\t\t\t\tremote = &(qn->qn_nodes[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!local && !remote)\n\t\t\tcontinue;\n\n\t\tif ((local && !remote) || (!local && remote))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (!status &&\n\t\t    ((remote->ni_nodenum != local->nd_num) ||\n\t\t     (remote->ni_ipv4_port != local->nd_ipv4_port) ||\n\t\t     (remote->ni_ipv4_address != local->nd_ipv4_address)))\n\t\t\tstatus = -EINVAL;\n\n\t\tif (status) {\n\t\t\tif (remote && !local)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in joining node %d but not in \"\n\t\t\t\t     \"local node %d\\n\", qn->qn_domain,\n\t\t\t\t     remote->ni_nodenum,\n\t\t\t\t     &(remote->ni_ipv4_address),\n\t\t\t\t     ntohs(remote->ni_ipv4_port),\n\t\t\t\t     qn->qn_nodenum, dlm->node_num);\n\t\t\tif (local && !remote)\n\t\t\t\tmlog(ML_ERROR, \"Domain %s: Node %d (%pI4:%u) \"\n\t\t\t\t     \"registered in local node %d but not in \"\n\t\t\t\t     \"joining node %d\\n\", qn->qn_domain,\n\t\t\t\t     local->nd_num, &(local->nd_ipv4_address),\n\t\t\t\t     ntohs(local->nd_ipv4_port),\n\t\t\t\t     dlm->node_num, qn->qn_nodenum);\n\t\t\tBUG_ON((!local && !remote));\n\t\t}\n\n\t\tif (local)\n\t\t\to2nm_node_put(local);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_query_region_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1113-1170",
    "snippet": "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data)\n{\n\tstruct dlm_query_region *qr;\n\tstruct dlm_ctxt *dlm = NULL;\n\tchar *local = NULL;\n\tint status = 0;\n\n\tqr = (struct dlm_query_region *) msg->buf;\n\n\tmlog(0, \"Node %u queries hb regions on domain %s\\n\", qr->qr_node,\n\t     qr->qr_domain);\n\n\t/* buffer used in dlm_mast_regions() */\n\tlocal = kmalloc(sizeof(qr->qr_regions), GFP_KERNEL);\n\tif (!local)\n\t\treturn -ENOMEM;\n\n\tstatus = -EINVAL;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qr->qr_domain, qr->qr_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"before join domain\\n\", qr->qr_node, qr->qr_domain);\n\t\tgoto out_domain_lock;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->joining_node != qr->qr_node) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but joining node is %d\\n\", qr->qr_node, qr->qr_domain,\n\t\t     dlm->joining_node);\n\t\tgoto out_dlm_lock;\n\t}\n\n\t/* Support for global heartbeat was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qr->qr_node,\n\t\t     qr->qr_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto out_dlm_lock;\n\t}\n\n\tstatus = dlm_match_regions(dlm, qr, local, sizeof(qr->qr_regions));\n\nout_dlm_lock:\n\tspin_unlock(&dlm->spinlock);\n\nout_domain_lock:\n\tspin_unlock(&dlm_domain_lock);\n\n\tkfree(local);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "local"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_match_regions",
          "args": [
            "dlm",
            "qr",
            "local",
            "sizeof(qr->qr_regions)"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_match_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "974-1058",
          "snippet": "static int dlm_match_regions(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_query_region *qr,\n\t\t\t     char *local, int locallen)\n{\n\tchar *remote = qr->qr_regions;\n\tchar *l, *r;\n\tint localnr, i, j, foundit;\n\tint status = 0;\n\n\tif (!o2hb_global_heartbeat_active()) {\n\t\tif (qr->qr_numregions) {\n\t\t\tmlog(ML_ERROR, \"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\",\n\t\t\t     qr->qr_domain, qr->qr_node, dlm->node_num);\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\n\t\tmlog(ML_ERROR, \"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\",\n\t\t     qr->qr_domain, dlm->node_num, qr->qr_node);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, r);\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\tlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\n\tlocalnr = o2hb_get_all_regions(local, (u8)localnr);\n\n\t/* compare local regions with remote */\n\tl = local;\n\tfor (i = 0; i < localnr; ++i) {\n\t\tfoundit = 0;\n\t\tr = remote;\n\t\tfor (j = 0; j <= qr->qr_numregions; ++j) {\n\t\t\tif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\n\t\t\t     dlm->node_num, qr->qr_node);\n\t\t\tgoto bail;\n\t\t}\n\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\t/* compare remote with local regions */\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tfoundit = 0;\n\t\tl = local;\n\t\tfor (j = 0; j < localnr; ++j) {\n\t\t\tif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\n\t\t\t     qr->qr_node, dlm->node_num);\n\t\t\tgoto bail;\n\t\t}\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_match_regions(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_query_region *qr,\n\t\t\t     char *local, int locallen)\n{\n\tchar *remote = qr->qr_regions;\n\tchar *l, *r;\n\tint localnr, i, j, foundit;\n\tint status = 0;\n\n\tif (!o2hb_global_heartbeat_active()) {\n\t\tif (qr->qr_numregions) {\n\t\t\tmlog(ML_ERROR, \"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\",\n\t\t\t     qr->qr_domain, qr->qr_node, dlm->node_num);\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\n\t\tmlog(ML_ERROR, \"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\",\n\t\t     qr->qr_domain, dlm->node_num, qr->qr_node);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, r);\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\tlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\n\tlocalnr = o2hb_get_all_regions(local, (u8)localnr);\n\n\t/* compare local regions with remote */\n\tl = local;\n\tfor (i = 0; i < localnr; ++i) {\n\t\tfoundit = 0;\n\t\tr = remote;\n\t\tfor (j = 0; j <= qr->qr_numregions; ++j) {\n\t\t\tif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\n\t\t\t     dlm->node_num, qr->qr_node);\n\t\t\tgoto bail;\n\t\t}\n\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\t/* compare remote with local regions */\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tfoundit = 0;\n\t\tl = local;\n\t\tfor (j = 0; j < localnr; ++j) {\n\t\t\tif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\n\t\t\t     qr->qr_node, dlm->node_num);\n\t\t\tgoto bail;\n\t\t}\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried hb regions on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\"",
            "qr->qr_node",
            "qr->qr_domain",
            "dlm->dlm_locking_proto.pv_major",
            "dlm->dlm_locking_proto.pv_minor"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried hb regions on domain %s \"\n\t\t     \"but joining node is %d\\n\"",
            "qr->qr_node",
            "qr->qr_domain",
            "dlm->joining_node"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Node %d queried hb regions on domain %s \"\n\t\t     \"before join domain\\n\"",
            "qr->qr_node",
            "qr->qr_domain"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "qr->qr_domain",
            "qr->qr_namelen"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(qr->qr_regions)",
            "GFP_KERNEL"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data)\n{\n\tstruct dlm_query_region *qr;\n\tstruct dlm_ctxt *dlm = NULL;\n\tchar *local = NULL;\n\tint status = 0;\n\n\tqr = (struct dlm_query_region *) msg->buf;\n\n\tmlog(0, \"Node %u queries hb regions on domain %s\\n\", qr->qr_node,\n\t     qr->qr_domain);\n\n\t/* buffer used in dlm_mast_regions() */\n\tlocal = kmalloc(sizeof(qr->qr_regions), GFP_KERNEL);\n\tif (!local)\n\t\treturn -ENOMEM;\n\n\tstatus = -EINVAL;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(qr->qr_domain, qr->qr_namelen);\n\tif (!dlm) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"before join domain\\n\", qr->qr_node, qr->qr_domain);\n\t\tgoto out_domain_lock;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->joining_node != qr->qr_node) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but joining node is %d\\n\", qr->qr_node, qr->qr_domain,\n\t\t     dlm->joining_node);\n\t\tgoto out_dlm_lock;\n\t}\n\n\t/* Support for global heartbeat was added in 1.1 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor == 0) {\n\t\tmlog(ML_ERROR, \"Node %d queried hb regions on domain %s \"\n\t\t     \"but active dlm protocol is %d.%d\\n\", qr->qr_node,\n\t\t     qr->qr_domain, dlm->dlm_locking_proto.pv_major,\n\t\t     dlm->dlm_locking_proto.pv_minor);\n\t\tgoto out_dlm_lock;\n\t}\n\n\tstatus = dlm_match_regions(dlm, qr, local, sizeof(qr->qr_regions));\n\nout_dlm_lock:\n\tspin_unlock(&dlm->spinlock);\n\nout_domain_lock:\n\tspin_unlock(&dlm_domain_lock);\n\n\tkfree(local);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "1060-1111",
    "snippet": "static int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t/* if local hb, the numregions will be zero */\n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending regions to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"Region mismatch %d, node %d\\n\",\n\t\t\t     ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qr);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qr"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Region mismatch %d, node %d\\n\"",
            "ret",
            "i"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_QUERY_REGION",
            "DLM_MOD_KEY",
            "qr",
            "sizeof(struct dlm_query_region)",
            "i",
            "&status"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Sending regions to node %d\\n\"",
            "i"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "node_map",
            "O2NM_MAX_NODES",
            "i + 1"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_get_all_regions",
          "args": [
            "qr->qr_regions",
            "O2NM_MAX_REGIONS"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_get_all_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2646-2671",
          "snippet": "int o2hb_get_all_regions(char *region_uuids, u8 max_regions)\n{\n\tstruct o2hb_region *reg;\n\tint numregs = 0;\n\tchar *p;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tp = region_uuids;\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Region: %s\\n\", config_item_name(&reg->hr_item));\n\t\tif (numregs < max_regions) {\n\t\t\tmemcpy(p, config_item_name(&reg->hr_item),\n\t\t\t       O2HB_MAX_REGION_NAME_LEN);\n\t\t\tp += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tnumregs++;\n\t}\n\n\tspin_unlock(&o2hb_live_lock);\n\n\treturn numregs;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(o2hb_live_lock);",
            "static LIST_HEAD(o2hb_all_regions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(o2hb_live_lock);\nstatic LIST_HEAD(o2hb_all_regions);\n\nint o2hb_get_all_regions(char *region_uuids, u8 max_regions)\n{\n\tstruct o2hb_region *reg;\n\tint numregs = 0;\n\tchar *p;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tp = region_uuids;\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Region: %s\\n\", config_item_name(&reg->hr_item));\n\t\tif (numregs < max_regions) {\n\t\t\tmemcpy(p, config_item_name(&reg->hr_item),\n\t\t\t       O2HB_MAX_REGION_NAME_LEN);\n\t\t\tp += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tnumregs++;\n\t}\n\n\tspin_unlock(&o2hb_live_lock);\n\n\treturn numregs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_global_heartbeat_active",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_global_heartbeat_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2674-2677",
          "snippet": "int o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nunsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;\n\nint o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qr->qr_domain",
            "dlm->name",
            "qr->qr_namelen"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dlm->name"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_query_region)",
            "GFP_KERNEL"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\n{\n\tstruct dlm_query_region *qr = NULL;\n\tint status, ret = 0, i;\n\tchar *p;\n\n\tif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\n\t\tgoto bail;\n\n\tqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\n\tif (!qr) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tqr->qr_node = dlm->node_num;\n\tqr->qr_namelen = strlen(dlm->name);\n\tmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\n\t/* if local hb, the numregions will be zero */\n\tif (o2hb_global_heartbeat_active())\n\t\tqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\n\t\t\t\t\t\t\t O2NM_MAX_REGIONS);\n\n\tp = qr->qr_regions;\n\tfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, p);\n\n\ti = -1;\n\twhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\n\t\t\t\t  i + 1)) < O2NM_MAX_NODES) {\n\t\tif (i == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Sending regions to node %d\\n\", i);\n\n\t\tret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\n\t\t\t\t\t sizeof(struct dlm_query_region),\n\t\t\t\t\t i, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret) {\n\t\t\tmlog(ML_ERROR, \"Region mismatch %d, node %d\\n\",\n\t\t\t     ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\tkfree(qr);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_match_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "974-1058",
    "snippet": "static int dlm_match_regions(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_query_region *qr,\n\t\t\t     char *local, int locallen)\n{\n\tchar *remote = qr->qr_regions;\n\tchar *l, *r;\n\tint localnr, i, j, foundit;\n\tint status = 0;\n\n\tif (!o2hb_global_heartbeat_active()) {\n\t\tif (qr->qr_numregions) {\n\t\t\tmlog(ML_ERROR, \"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\",\n\t\t\t     qr->qr_domain, qr->qr_node, dlm->node_num);\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\n\t\tmlog(ML_ERROR, \"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\",\n\t\t     qr->qr_domain, dlm->node_num, qr->qr_node);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, r);\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\tlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\n\tlocalnr = o2hb_get_all_regions(local, (u8)localnr);\n\n\t/* compare local regions with remote */\n\tl = local;\n\tfor (i = 0; i < localnr; ++i) {\n\t\tfoundit = 0;\n\t\tr = remote;\n\t\tfor (j = 0; j <= qr->qr_numregions; ++j) {\n\t\t\tif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\n\t\t\t     dlm->node_num, qr->qr_node);\n\t\t\tgoto bail;\n\t\t}\n\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\t/* compare remote with local regions */\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tfoundit = 0;\n\t\tl = local;\n\t\tfor (j = 0; j < localnr; ++j) {\n\t\t\tif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\n\t\t\t     qr->qr_node, dlm->node_num);\n\t\t\tgoto bail;\n\t\t}\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\"",
            "qr->qr_domain",
            "O2HB_MAX_REGION_NAME_LEN",
            "r",
            "qr->qr_node",
            "dlm->node_num"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "r",
            "l",
            "O2HB_MAX_REGION_NAME_LEN"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\"",
            "qr->qr_domain",
            "O2HB_MAX_REGION_NAME_LEN",
            "l",
            "dlm->node_num",
            "qr->qr_node"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "l",
            "r",
            "O2HB_MAX_REGION_NAME_LEN"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2hb_get_all_regions",
          "args": [
            "local",
            "(u8)localnr"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_get_all_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2646-2671",
          "snippet": "int o2hb_get_all_regions(char *region_uuids, u8 max_regions)\n{\n\tstruct o2hb_region *reg;\n\tint numregs = 0;\n\tchar *p;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tp = region_uuids;\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Region: %s\\n\", config_item_name(&reg->hr_item));\n\t\tif (numregs < max_regions) {\n\t\t\tmemcpy(p, config_item_name(&reg->hr_item),\n\t\t\t       O2HB_MAX_REGION_NAME_LEN);\n\t\t\tp += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tnumregs++;\n\t}\n\n\tspin_unlock(&o2hb_live_lock);\n\n\treturn numregs;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(o2hb_live_lock);",
            "static LIST_HEAD(o2hb_all_regions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(o2hb_live_lock);\nstatic LIST_HEAD(o2hb_all_regions);\n\nint o2hb_get_all_regions(char *region_uuids, u8 max_regions)\n{\n\tstruct o2hb_region *reg;\n\tint numregs = 0;\n\tchar *p;\n\n\tspin_lock(&o2hb_live_lock);\n\n\tp = region_uuids;\n\tlist_for_each_entry(reg, &o2hb_all_regions, hr_all_item) {\n\t\tif (reg->hr_item_dropped)\n\t\t\tcontinue;\n\n\t\tmlog(0, \"Region: %s\\n\", config_item_name(&reg->hr_item));\n\t\tif (numregs < max_regions) {\n\t\t\tmemcpy(p, config_item_name(&reg->hr_item),\n\t\t\t       O2HB_MAX_REGION_NAME_LEN);\n\t\t\tp += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tnumregs++;\n\t}\n\n\tspin_unlock(&o2hb_live_lock);\n\n\treturn numregs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "O2NM_MAX_REGIONS",
            "locallen/O2HB_MAX_REGION_NAME_LEN"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Region %.*s\\n\"",
            "O2HB_MAX_REGION_NAME_LEN",
            "r"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\"",
            "qr->qr_domain",
            "dlm->node_num",
            "qr->qr_node"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2hb_global_heartbeat_active",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_global_heartbeat_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2674-2677",
          "snippet": "int o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nunsigned int o2hb_heartbeat_mode = O2HB_HEARTBEAT_LOCAL;\n\nint o2hb_global_heartbeat_active(void)\n{\n\treturn (o2hb_heartbeat_mode == O2HB_HEARTBEAT_GLOBAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\"",
            "qr->qr_domain",
            "qr->qr_node",
            "dlm->node_num"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_match_regions(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_query_region *qr,\n\t\t\t     char *local, int locallen)\n{\n\tchar *remote = qr->qr_regions;\n\tchar *l, *r;\n\tint localnr, i, j, foundit;\n\tint status = 0;\n\n\tif (!o2hb_global_heartbeat_active()) {\n\t\tif (qr->qr_numregions) {\n\t\t\tmlog(ML_ERROR, \"Domain %s: Joining node %d has global \"\n\t\t\t     \"heartbeat enabled but local node %d does not\\n\",\n\t\t\t     qr->qr_domain, qr->qr_node, dlm->node_num);\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tgoto bail;\n\t}\n\n\tif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\n\t\tmlog(ML_ERROR, \"Domain %s: Local node %d has global \"\n\t\t     \"heartbeat enabled but joining node %d does not\\n\",\n\t\t     qr->qr_domain, dlm->node_num, qr->qr_node);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tmlog(0, \"Region %.*s\\n\", O2HB_MAX_REGION_NAME_LEN, r);\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\tlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\n\tlocalnr = o2hb_get_all_regions(local, (u8)localnr);\n\n\t/* compare local regions with remote */\n\tl = local;\n\tfor (i = 0; i < localnr; ++i) {\n\t\tfoundit = 0;\n\t\tr = remote;\n\t\tfor (j = 0; j <= qr->qr_numregions; ++j) {\n\t\t\tif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in local node %d but not in joining node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\n\t\t\t     dlm->node_num, qr->qr_node);\n\t\t\tgoto bail;\n\t\t}\n\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\n\t/* compare remote with local regions */\n\tr = remote;\n\tfor (i = 0; i < qr->qr_numregions; ++i) {\n\t\tfoundit = 0;\n\t\tl = local;\n\t\tfor (j = 0; j < localnr; ++j) {\n\t\t\tif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\n\t\t\t\tfoundit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl += O2HB_MAX_REGION_NAME_LEN;\n\t\t}\n\t\tif (!foundit) {\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"Domain %s: Region '%.*s' registered \"\n\t\t\t     \"in joining node %d but not in local node %d\\n\",\n\t\t\t     qr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\n\t\t\t     qr->qr_node, dlm->node_num);\n\t\t\tgoto bail;\n\t\t}\n\t\tr += O2HB_MAX_REGION_NAME_LEN;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_assert_joined_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "927-972",
    "snippet": "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data)\n{\n\tstruct dlm_assert_joined *assert;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tassert = (struct dlm_assert_joined *) msg->buf;\n\n\tmlog(0, \"node %u asserts join on domain %s\\n\", assert->node_idx,\n\t\t  assert->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(assert->domain, assert->name_len);\n\t/* XXX should we consider no dlm ctxt an error? */\n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t/* Alright, this node has officially joined our\n\t\t * domain. Set him in the map and clean up our\n\t\t * leftover join state. */\n\t\tBUG_ON(dlm->joining_node != assert->node_idx);\n\n\t\tif (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"dlm recovery is ongoing, disallow join\\n\");\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tset_bit(assert->node_idx, dlm->domain_map);\n\t\tclear_bit(assert->node_idx, dlm->exit_domain_map);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tprintk(KERN_NOTICE \"o2dlm: Node %u joins domain %s \",\n\t\t       assert->node_idx, dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\n\t\t/* notify anything attached to the heartbeat events */\n\t\tdlm_hb_event_notify_attached(dlm, assert->node_idx, 1);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hb_event_notify_attached",
          "args": [
            "dlm",
            "assert->node_idx",
            "1"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hb_event_notify_attached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "361-373",
          "snippet": "void dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_nodes",
          "args": [
            "dlm"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "533-546",
          "snippet": "static void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Node %u joins domain %s \"",
            "assert->node_idx",
            "dlm->name"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_set_joining_node",
          "args": [
            "dlm",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_set_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "267-274",
          "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "assert->node_idx",
            "dlm->exit_domain_map"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "assert->node_idx",
            "dlm->domain_map"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm recovery is ongoing, disallow join\\n\""
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->joining_node != assert->node_idx"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "assert->domain",
            "assert->name_len"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u asserts join on domain %s\\n\"",
            "assert->node_idx",
            "assert->domain"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data)\n{\n\tstruct dlm_assert_joined *assert;\n\tstruct dlm_ctxt *dlm = NULL;\n\n\tassert = (struct dlm_assert_joined *) msg->buf;\n\n\tmlog(0, \"node %u asserts join on domain %s\\n\", assert->node_idx,\n\t\t  assert->domain);\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(assert->domain, assert->name_len);\n\t/* XXX should we consider no dlm ctxt an error? */\n\tif (dlm) {\n\t\tspin_lock(&dlm->spinlock);\n\n\t\t/* Alright, this node has officially joined our\n\t\t * domain. Set him in the map and clean up our\n\t\t * leftover join state. */\n\t\tBUG_ON(dlm->joining_node != assert->node_idx);\n\n\t\tif (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"dlm recovery is ongoing, disallow join\\n\");\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tspin_unlock(&dlm_domain_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tset_bit(assert->node_idx, dlm->domain_map);\n\t\tclear_bit(assert->node_idx, dlm->exit_domain_map);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\n\t\tprintk(KERN_NOTICE \"o2dlm: Node %u joins domain %s \",\n\t\t       assert->node_idx, dlm->name);\n\t\t__dlm_print_nodes(dlm);\n\n\t\t/* notify anything attached to the heartbeat events */\n\t\tdlm_hb_event_notify_attached(dlm, assert->node_idx, 1);\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_query_join_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "807-925",
    "snippet": "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_query_join_request *query;\n\tstruct dlm_query_join_packet packet = {\n\t\t.code = JOIN_DISALLOW,\n\t};\n\tstruct dlm_ctxt *dlm = NULL;\n\tu32 response;\n\tu8 nodenum;\n\n\tquery = (struct dlm_query_join_request *) msg->buf;\n\n\tmlog(0, \"node %u wants to join domain %s\\n\", query->node_idx,\n\t\t  query->domain);\n\n\t/*\n\t * If heartbeat doesn't consider the node live, tell it\n\t * to back off and try again.  This gives heartbeat a chance\n\t * to catch up.\n\t */\n\tif (!o2hb_check_node_heartbeating_no_sem(query->node_idx)) {\n\t\tmlog(0, \"node %u is not in our live map yet\\n\",\n\t\t     query->node_idx);\n\n\t\tpacket.code = JOIN_DISALLOW;\n\t\tgoto respond;\n\t}\n\n\tpacket.code = JOIN_OK_NO_MAP;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(query->domain, query->name_len);\n\tif (!dlm)\n\t\tgoto unlock_respond;\n\n\t/*\n\t * There is a small window where the joining node may not see the\n\t * node(s) that just left but still part of the cluster. DISALLOW\n\t * join request if joining node has different node map.\n\t */\n\tnodenum=0;\n\twhile (nodenum < O2NM_MAX_NODES) {\n\t\tif (test_bit(nodenum, dlm->domain_map)) {\n\t\t\tif (!byte_test_bit(nodenum, query->node_map)) {\n\t\t\t\tmlog(0, \"disallow join as node %u does not \"\n\t\t\t\t     \"have node %u in its nodemap\\n\",\n\t\t\t\t     query->node_idx, nodenum);\n\t\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t\t\tgoto unlock_respond;\n\t\t\t}\n\t\t}\n\t\tnodenum++;\n\t}\n\n\t/* Once the dlm ctxt is marked as leaving then we don't want\n\t * to be put in someone's domain map.\n\t * Also, explicitly disallow joining at certain troublesome\n\t * times (ie. during recovery). */\n\tif (dlm->dlm_state != DLM_CTXT_LEAVING) {\n\t\tint bit = query->node_idx;\n\t\tspin_lock(&dlm->spinlock);\n\n\t\tif (dlm->dlm_state == DLM_CTXT_NEW &&\n\t\t    dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/*If this is a brand new context and we\n\t\t\t * haven't started our join process yet, then\n\t\t\t * the other node won the race. */\n\t\t\tpacket.code = JOIN_OK_NO_MAP;\n\t\t} else if (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* Disallow parallel joins. */\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"node %u trying to join, but recovery \"\n\t\t\t     \"is ongoing.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->recovery_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"still needs recovery.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->domain_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"is still in the domain! needs recovery?\\n\",\n\t\t\t     bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else {\n\t\t\t/* Alright we're fully a part of this domain\n\t\t\t * so we keep some state as to who's joining\n\t\t\t * and indicate to him that needs to be fixed\n\t\t\t * up. */\n\n\t\t\t/* Make sure we speak compatible locking protocols.  */\n\t\t\tif (dlm_query_join_proto_check(\"DLM\", bit,\n\t\t\t\t\t\t       &dlm->dlm_locking_proto,\n\t\t\t\t\t\t       &query->dlm_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else if (dlm_query_join_proto_check(\"fs\", bit,\n\t\t\t\t\t\t\t      &dlm->fs_locking_proto,\n\t\t\t\t\t\t\t      &query->fs_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else {\n\t\t\t\tpacket.dlm_minor = query->dlm_proto.pv_minor;\n\t\t\t\tpacket.fs_minor = query->fs_proto.pv_minor;\n\t\t\t\tpacket.code = JOIN_OK;\n\t\t\t\t__dlm_set_joining_node(dlm, query->node_idx);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\nunlock_respond:\n\tspin_unlock(&dlm_domain_lock);\n\nrespond:\n\tmlog(0, \"We respond with %u\\n\", packet.code);\n\n\tdlm_query_join_packet_to_wire(&packet, &response);\n\treturn response;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_query_join_packet_to_wire",
          "args": [
            "&packet",
            "&response"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_query_join_packet_to_wire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "789-796",
          "snippet": "static void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\n\t\t\t\t\t  u32 *wire)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.packet = *packet;\n\t*wire = be32_to_cpu(response.intval);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\n\t\t\t\t\t  u32 *wire)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.packet = *packet;\n\t*wire = be32_to_cpu(response.intval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"We respond with %u\\n\"",
            "packet.code"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_set_joining_node",
          "args": [
            "dlm",
            "query->node_idx"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_set_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "267-274",
          "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_query_join_proto_check",
          "args": [
            "\"fs\"",
            "bit",
            "&dlm->fs_locking_proto",
            "&query->fs_proto"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_query_join_proto_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "744-774",
          "snippet": "static int dlm_query_join_proto_check(char *proto_type, int node,\n\t\t\t\t      struct dlm_protocol_version *ours,\n\t\t\t\t      struct dlm_protocol_version *request)\n{\n\tint rc;\n\tstruct dlm_protocol_version proto = *request;\n\n\tif (!dlm_protocol_compare(ours, &proto)) {\n\t\tmlog(0,\n\t\t     \"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     proto.pv_major, proto.pv_minor);\n\t\trequest->pv_minor = proto.pv_minor;\n\t\trc = 0;\n\t} else {\n\t\tmlog(ML_NOTICE,\n\t\t     \"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     ours->pv_major,\n\t\t     ours->pv_minor);\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic int dlm_query_join_proto_check(char *proto_type, int node,\n\t\t\t\t      struct dlm_protocol_version *ours,\n\t\t\t\t      struct dlm_protocol_version *request)\n{\n\tint rc;\n\tstruct dlm_protocol_version proto = *request;\n\n\tif (!dlm_protocol_compare(ours, &proto)) {\n\t\tmlog(0,\n\t\t     \"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     proto.pv_major, proto.pv_minor);\n\t\trequest->pv_minor = proto.pv_minor;\n\t\trc = 0;\n\t} else {\n\t\tmlog(ML_NOTICE,\n\t\t     \"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     ours->pv_major,\n\t\t     ours->pv_minor);\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit",
            "dlm->domain_map"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"disallow join as node %u does not \"\n\t\t\t\t     \"have node %u in its nodemap\\n\"",
            "query->node_idx",
            "nodenum"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "query->domain",
            "query->name_len"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_check_node_heartbeating_no_sem",
          "args": [
            "query->node_idx"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_check_node_heartbeating_no_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2575-2591",
          "snippet": "int o2hb_check_node_heartbeating_no_sem(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&o2hb_live_lock, flags);\n\to2hb_fill_node_map_from_callback(testing_map, sizeof(testing_map));\n\tspin_unlock_irqrestore(&o2hb_live_lock, flags);\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(o2hb_live_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(o2hb_live_lock);\n\nint o2hb_check_node_heartbeating_no_sem(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&o2hb_live_lock, flags);\n\to2hb_fill_node_map_from_callback(testing_map, sizeof(testing_map));\n\tspin_unlock_irqrestore(&o2hb_live_lock, flags);\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_query_join_request *query;\n\tstruct dlm_query_join_packet packet = {\n\t\t.code = JOIN_DISALLOW,\n\t};\n\tstruct dlm_ctxt *dlm = NULL;\n\tu32 response;\n\tu8 nodenum;\n\n\tquery = (struct dlm_query_join_request *) msg->buf;\n\n\tmlog(0, \"node %u wants to join domain %s\\n\", query->node_idx,\n\t\t  query->domain);\n\n\t/*\n\t * If heartbeat doesn't consider the node live, tell it\n\t * to back off and try again.  This gives heartbeat a chance\n\t * to catch up.\n\t */\n\tif (!o2hb_check_node_heartbeating_no_sem(query->node_idx)) {\n\t\tmlog(0, \"node %u is not in our live map yet\\n\",\n\t\t     query->node_idx);\n\n\t\tpacket.code = JOIN_DISALLOW;\n\t\tgoto respond;\n\t}\n\n\tpacket.code = JOIN_OK_NO_MAP;\n\n\tspin_lock(&dlm_domain_lock);\n\tdlm = __dlm_lookup_domain_full(query->domain, query->name_len);\n\tif (!dlm)\n\t\tgoto unlock_respond;\n\n\t/*\n\t * There is a small window where the joining node may not see the\n\t * node(s) that just left but still part of the cluster. DISALLOW\n\t * join request if joining node has different node map.\n\t */\n\tnodenum=0;\n\twhile (nodenum < O2NM_MAX_NODES) {\n\t\tif (test_bit(nodenum, dlm->domain_map)) {\n\t\t\tif (!byte_test_bit(nodenum, query->node_map)) {\n\t\t\t\tmlog(0, \"disallow join as node %u does not \"\n\t\t\t\t     \"have node %u in its nodemap\\n\",\n\t\t\t\t     query->node_idx, nodenum);\n\t\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t\t\tgoto unlock_respond;\n\t\t\t}\n\t\t}\n\t\tnodenum++;\n\t}\n\n\t/* Once the dlm ctxt is marked as leaving then we don't want\n\t * to be put in someone's domain map.\n\t * Also, explicitly disallow joining at certain troublesome\n\t * times (ie. during recovery). */\n\tif (dlm->dlm_state != DLM_CTXT_LEAVING) {\n\t\tint bit = query->node_idx;\n\t\tspin_lock(&dlm->spinlock);\n\n\t\tif (dlm->dlm_state == DLM_CTXT_NEW &&\n\t\t    dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/*If this is a brand new context and we\n\t\t\t * haven't started our join process yet, then\n\t\t\t * the other node won the race. */\n\t\t\tpacket.code = JOIN_OK_NO_MAP;\n\t\t} else if (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* Disallow parallel joins. */\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\n\t\t\tmlog(0, \"node %u trying to join, but recovery \"\n\t\t\t     \"is ongoing.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->recovery_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"still needs recovery.\\n\", bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else if (test_bit(bit, dlm->domain_map)) {\n\t\t\tmlog(0, \"node %u trying to join, but it \"\n\t\t\t     \"is still in the domain! needs recovery?\\n\",\n\t\t\t     bit);\n\t\t\tpacket.code = JOIN_DISALLOW;\n\t\t} else {\n\t\t\t/* Alright we're fully a part of this domain\n\t\t\t * so we keep some state as to who's joining\n\t\t\t * and indicate to him that needs to be fixed\n\t\t\t * up. */\n\n\t\t\t/* Make sure we speak compatible locking protocols.  */\n\t\t\tif (dlm_query_join_proto_check(\"DLM\", bit,\n\t\t\t\t\t\t       &dlm->dlm_locking_proto,\n\t\t\t\t\t\t       &query->dlm_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else if (dlm_query_join_proto_check(\"fs\", bit,\n\t\t\t\t\t\t\t      &dlm->fs_locking_proto,\n\t\t\t\t\t\t\t      &query->fs_proto)) {\n\t\t\t\tpacket.code = JOIN_PROTOCOL_MISMATCH;\n\t\t\t} else {\n\t\t\t\tpacket.dlm_minor = query->dlm_proto.pv_minor;\n\t\t\t\tpacket.fs_minor = query->fs_proto.pv_minor;\n\t\t\t\tpacket.code = JOIN_OK;\n\t\t\t\t__dlm_set_joining_node(dlm, query->node_idx);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t}\nunlock_respond:\n\tspin_unlock(&dlm_domain_lock);\n\nrespond:\n\tmlog(0, \"We respond with %u\\n\", packet.code);\n\n\tdlm_query_join_packet_to_wire(&packet, &response);\n\treturn response;\n}"
  },
  {
    "function_name": "dlm_query_join_wire_to_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "798-805",
    "snippet": "static void dlm_query_join_wire_to_packet(u32 wire,\n\t\t\t\t\t  struct dlm_query_join_packet *packet)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.intval = cpu_to_be32(wire);\n\t*packet = response.packet;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "wire"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_query_join_wire_to_packet(u32 wire,\n\t\t\t\t\t  struct dlm_query_join_packet *packet)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.intval = cpu_to_be32(wire);\n\t*packet = response.packet;\n}"
  },
  {
    "function_name": "dlm_query_join_packet_to_wire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "789-796",
    "snippet": "static void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\n\t\t\t\t\t  u32 *wire)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.packet = *packet;\n\t*wire = be32_to_cpu(response.intval);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "response.intval"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\n\t\t\t\t\t  u32 *wire)\n{\n\tunion dlm_query_join_response response;\n\n\tresponse.packet = *packet;\n\t*wire = be32_to_cpu(response.intval);\n}"
  },
  {
    "function_name": "dlm_query_join_proto_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "744-774",
    "snippet": "static int dlm_query_join_proto_check(char *proto_type, int node,\n\t\t\t\t      struct dlm_protocol_version *ours,\n\t\t\t\t      struct dlm_protocol_version *request)\n{\n\tint rc;\n\tstruct dlm_protocol_version proto = *request;\n\n\tif (!dlm_protocol_compare(ours, &proto)) {\n\t\tmlog(0,\n\t\t     \"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     proto.pv_major, proto.pv_minor);\n\t\trequest->pv_minor = proto.pv_minor;\n\t\trc = 0;\n\t} else {\n\t\tmlog(ML_NOTICE,\n\t\t     \"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     ours->pv_major,\n\t\t     ours->pv_minor);\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\"",
            "node",
            "proto_type",
            "request->pv_major",
            "request->pv_minor",
            "ours->pv_major",
            "ours->pv_minor"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\"",
            "node",
            "proto_type",
            "request->pv_major",
            "request->pv_minor",
            "proto.pv_major",
            "proto.pv_minor"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_protocol_compare",
          "args": [
            "ours",
            "&proto"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_protocol_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2087-2100",
          "snippet": "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\n\t\t\t\tstruct dlm_protocol_version *request);\n\nstatic int dlm_query_join_proto_check(char *proto_type, int node,\n\t\t\t\t      struct dlm_protocol_version *ours,\n\t\t\t\t      struct dlm_protocol_version *request)\n{\n\tint rc;\n\tstruct dlm_protocol_version proto = *request;\n\n\tif (!dlm_protocol_compare(ours, &proto)) {\n\t\tmlog(0,\n\t\t     \"node %u wanted to join with %s locking protocol \"\n\t\t     \"%u.%u, we respond with %u.%u\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     proto.pv_major, proto.pv_minor);\n\t\trequest->pv_minor = proto.pv_minor;\n\t\trc = 0;\n\t} else {\n\t\tmlog(ML_NOTICE,\n\t\t     \"Node %u wanted to join with %s locking \"\n\t\t     \"protocol %u.%u, but we have %u.%u, disallowing\\n\",\n\t\t     node, proto_type,\n\t\t     request->pv_major,\n\t\t     request->pv_minor,\n\t\t     ours->pv_major,\n\t\t     ours->pv_minor);\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dlm_unregister_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "691-741",
    "snippet": "void dlm_unregister_domain(struct dlm_ctxt *dlm)\n{\n\tint leave = 0;\n\tstruct dlm_lock_resource *res;\n\n\tspin_lock(&dlm_domain_lock);\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_JOINED);\n\tBUG_ON(!dlm->num_joins);\n\n\tdlm->num_joins--;\n\tif (!dlm->num_joins) {\n\t\t/* We mark it \"in shutdown\" now so new register\n\t\t * requests wait until we've completely left the\n\t\t * domain. Don't use DLM_CTXT_LEAVING yet as we still\n\t\t * want new domain joins to communicate with us at\n\t\t * least until we've completed migration of our\n\t\t * resources. */\n\t\tdlm->dlm_state = DLM_CTXT_IN_SHUTDOWN;\n\t\tleave = 1;\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\tif (leave) {\n\t\tmlog(0, \"shutting down domain %s\\n\", dlm->name);\n\t\tdlm_begin_exit_domain(dlm);\n\n\t\t/* We changed dlm state, notify the thread */\n\t\tdlm_kick_thread(dlm, NULL);\n\n\t\twhile (dlm_migrate_all_locks(dlm)) {\n\t\t\t/* Give dlm_thread time to purge the lockres' */\n\t\t\tmsleep(500);\n\t\t\tmlog(0, \"%s: more migration to do\\n\", dlm->name);\n\t\t}\n\n\t\t/* This list should be empty. If not, print remaining lockres */\n\t\tif (!list_empty(&dlm->tracking_list)) {\n\t\t\tmlog(ML_ERROR, \"Following lockres' are still on the \"\n\t\t\t     \"tracking list:\\n\");\n\t\t\tlist_for_each_entry(res, &dlm->tracking_list, tracking)\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t}\n\n\t\tdlm_mark_domain_leaving(dlm);\n\t\tdlm_leave_domain(dlm);\n\t\tprintk(KERN_NOTICE \"o2dlm: Leaving domain %s\\n\", dlm->name);\n\t\tdlm_force_free_mles(dlm);\n\t\tdlm_complete_dlm_shutdown(dlm);\n\t}\n\tdlm_put(dlm);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "345-350",
          "snippet": "void dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_complete_dlm_shutdown",
          "args": [
            "dlm"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_complete_dlm_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "401-418",
          "snippet": "static void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\n{\n\tdlm_unregister_domain_handlers(dlm);\n\tdlm_debug_shutdown(dlm);\n\tdlm_complete_thread(dlm);\n\tdlm_complete_recovery_thread(dlm);\n\tdlm_destroy_dlm_worker(dlm);\n\n\t/* We've left the domain. Now we can take ourselves out of the\n\t * list and allow the kref stuff to help us free the\n\t * memory. */\n\tspin_lock(&dlm_domain_lock);\n\tlist_del_init(&dlm->list);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/* Wake up anyone waiting for us to remove this domain */\n\twake_up(&dlm_domain_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\n{\n\tdlm_unregister_domain_handlers(dlm);\n\tdlm_debug_shutdown(dlm);\n\tdlm_complete_thread(dlm);\n\tdlm_complete_recovery_thread(dlm);\n\tdlm_destroy_dlm_worker(dlm);\n\n\t/* We've left the domain. Now we can take ourselves out of the\n\t * list and allow the kref stuff to help us free the\n\t * memory. */\n\tspin_lock(&dlm_domain_lock);\n\tlist_del_init(&dlm->list);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/* Wake up anyone waiting for us to remove this domain */\n\twake_up(&dlm_domain_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_force_free_mles",
          "args": [
            "dlm"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_force_free_mles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3438-3474",
          "snippet": "void dlm_force_free_mles(struct dlm_ctxt *dlm)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_master_list_entry *mle;\n\tstruct hlist_node *tmp;\n\n\t/*\n\t * We notified all other nodes that we are exiting the domain and\n\t * marked the dlm state to DLM_CTXT_LEAVING. If any mles are still\n\t * around we force free them and wake any processes that are waiting\n\t * on the mles\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_LEAVING);\n\tBUG_ON((find_next_bit(dlm->domain_map, O2NM_MAX_NODES, 0) < O2NM_MAX_NODES));\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tif (mle->type != DLM_MLE_BLOCK) {\n\t\t\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t}\n\t\t\tatomic_set(&mle->woken, 1);\n\t\t\twake_up(&mle->wq);\n\n\t\t\t__dlm_unlink_mle(dlm, mle);\n\t\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\n\nvoid dlm_force_free_mles(struct dlm_ctxt *dlm)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_master_list_entry *mle;\n\tstruct hlist_node *tmp;\n\n\t/*\n\t * We notified all other nodes that we are exiting the domain and\n\t * marked the dlm state to DLM_CTXT_LEAVING. If any mles are still\n\t * around we force free them and wake any processes that are waiting\n\t * on the mles\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_LEAVING);\n\tBUG_ON((find_next_bit(dlm->domain_map, O2NM_MAX_NODES, 0) < O2NM_MAX_NODES));\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tif (mle->type != DLM_MLE_BLOCK) {\n\t\t\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t}\n\t\t\tatomic_set(&mle->woken, 1);\n\t\t\twake_up(&mle->wq);\n\n\t\t\t__dlm_unlink_mle(dlm, mle);\n\t\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Leaving domain %s\\n\"",
            "dlm->name"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_leave_domain",
          "args": [
            "dlm"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_leave_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "629-675",
          "snippet": "static void dlm_leave_domain(struct dlm_ctxt *dlm)\n{\n\tint node, clear_node, status;\n\n\t/* At this point we've migrated away all our locks and won't\n\t * accept mastership of new ones. The dlm is responsible for\n\t * almost nothing now. We make sure not to confuse any joining\n\t * nodes and then commence shutdown procedure. */\n\n\tspin_lock(&dlm->spinlock);\n\t/* Clear ourselves from the domain map */\n\tclear_bit(dlm->node_num, dlm->domain_map);\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     0)) < O2NM_MAX_NODES) {\n\t\t/* Drop the dlm spinlock. This is safe wrt the domain_map.\n\t\t * -nodes cannot be added now as the\n\t\t *   query_join_handlers knows to respond with OK_NO_MAP\n\t\t * -we catch the right network errors if a node is\n\t\t *   removed from the map while we're sending him the\n\t\t *   exit message. */\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tclear_node = 1;\n\n\t\tstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\n\t\t\t\t\t\t  node);\n\t\tif (status < 0 &&\n\t\t    status != -ENOPROTOOPT &&\n\t\t    status != -ENOTCONN) {\n\t\t\tmlog(ML_NOTICE, \"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\", status, node);\n\n\t\t\t/* Not sure what to do here but lets sleep for\n\t\t\t * a bit in case this was a transient\n\t\t\t * error... */\n\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\tclear_node = 0;\n\t\t}\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t/* If we're not clearing the node bit then we intend\n\t\t * to loop back around to try again. */\n\t\tif (clear_node)\n\t\t\tclear_bit(node, dlm->domain_map);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_DOMAIN_BACKOFF_MS 200"
          ],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_leave_domain(struct dlm_ctxt *dlm)\n{\n\tint node, clear_node, status;\n\n\t/* At this point we've migrated away all our locks and won't\n\t * accept mastership of new ones. The dlm is responsible for\n\t * almost nothing now. We make sure not to confuse any joining\n\t * nodes and then commence shutdown procedure. */\n\n\tspin_lock(&dlm->spinlock);\n\t/* Clear ourselves from the domain map */\n\tclear_bit(dlm->node_num, dlm->domain_map);\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     0)) < O2NM_MAX_NODES) {\n\t\t/* Drop the dlm spinlock. This is safe wrt the domain_map.\n\t\t * -nodes cannot be added now as the\n\t\t *   query_join_handlers knows to respond with OK_NO_MAP\n\t\t * -we catch the right network errors if a node is\n\t\t *   removed from the map while we're sending him the\n\t\t *   exit message. */\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tclear_node = 1;\n\n\t\tstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\n\t\t\t\t\t\t  node);\n\t\tif (status < 0 &&\n\t\t    status != -ENOPROTOOPT &&\n\t\t    status != -ENOTCONN) {\n\t\t\tmlog(ML_NOTICE, \"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\", status, node);\n\n\t\t\t/* Not sure what to do here but lets sleep for\n\t\t\t * a bit in case this was a transient\n\t\t\t * error... */\n\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\tclear_node = 0;\n\t\t}\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t/* If we're not clearing the node bit then we intend\n\t\t * to loop back around to try again. */\n\t\tif (clear_node)\n\t\t\tclear_bit(node, dlm->domain_map);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mark_domain_leaving",
          "args": [
            "dlm"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mark_domain_leaving",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "510-531",
          "snippet": "static void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\n{\n\t/* Yikes, a double spinlock! I need domain_lock for the dlm\n\t * state and the dlm spinlock for join state... Sorry! */\nagain:\n\tspin_lock(&dlm_domain_lock);\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"Node %d is joining, we wait on it.\\n\",\n\t\t\t  dlm->joining_node);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\twait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\n\t\tgoto again;\n\t}\n\n\tdlm->dlm_state = DLM_CTXT_LEAVING;\n\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\n{\n\t/* Yikes, a double spinlock! I need domain_lock for the dlm\n\t * state and the dlm spinlock for join state... Sorry! */\nagain:\n\tspin_lock(&dlm_domain_lock);\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"Node %d is joining, we wait on it.\\n\",\n\t\t\t  dlm->joining_node);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\twait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\n\t\tgoto again;\n\t}\n\n\tdlm->dlm_state = DLM_CTXT_LEAVING;\n\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "res",
            "&dlm->tracking_list",
            "tracking"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Following lockres' are still on the \"\n\t\t\t     \"tracking list:\\n\""
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dlm->tracking_list"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: more migration to do\\n\"",
            "dlm->name"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "500"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_migrate_all_locks",
          "args": [
            "dlm"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_migrate_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "420-475",
          "snippet": "static int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\n{\n\tint i, num, n, ret = 0;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_node *iter;\n\tstruct hlist_head *bucket;\n\tint dropped;\n\n\tmlog(0, \"Migrating locks from domain %s\\n\", dlm->name);\n\n\tnum = 0;\n\tspin_lock(&dlm->spinlock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\nredo_bucket:\n\t\tn = 0;\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\titer = bucket->first;\n\t\twhile (iter) {\n\t\t\tn++;\n\t\t\tres = hlist_entry(iter, struct dlm_lock_resource,\n\t\t\t\t\t  hash_node);\n\t\t\tdlm_lockres_get(res);\n\t\t\t/* migrate, if necessary.  this will drop the dlm\n\t\t\t * spinlock and retake it if it does migration. */\n\t\t\tdropped = dlm_empty_lockres(dlm, res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (dropped)\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\telse\n\t\t\t\titer = res->hash_node.next;\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tdlm_lockres_put(res);\n\n\t\t\tif (dropped) {\n\t\t\t\tcond_resched_lock(&dlm->spinlock);\n\t\t\t\tgoto redo_bucket;\n\t\t\t}\n\t\t}\n\t\tcond_resched_lock(&dlm->spinlock);\n\t\tnum += n;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\twake_up(&dlm->dlm_thread_wq);\n\n\t/* let the dlm thread take care of purging, keep scanning until\n\t * nothing remains in the hash */\n\tif (num) {\n\t\tmlog(0, \"%s: %d lock resources in hash last pass\\n\",\n\t\t     dlm->name, num);\n\t\tret = -EAGAIN;\n\t}\n\tmlog(0, \"DONE Migrating locks from domain %s\\n\", dlm->name);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\n{\n\tint i, num, n, ret = 0;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_node *iter;\n\tstruct hlist_head *bucket;\n\tint dropped;\n\n\tmlog(0, \"Migrating locks from domain %s\\n\", dlm->name);\n\n\tnum = 0;\n\tspin_lock(&dlm->spinlock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\nredo_bucket:\n\t\tn = 0;\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\titer = bucket->first;\n\t\twhile (iter) {\n\t\t\tn++;\n\t\t\tres = hlist_entry(iter, struct dlm_lock_resource,\n\t\t\t\t\t  hash_node);\n\t\t\tdlm_lockres_get(res);\n\t\t\t/* migrate, if necessary.  this will drop the dlm\n\t\t\t * spinlock and retake it if it does migration. */\n\t\t\tdropped = dlm_empty_lockres(dlm, res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (dropped)\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\telse\n\t\t\t\titer = res->hash_node.next;\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tdlm_lockres_put(res);\n\n\t\t\tif (dropped) {\n\t\t\t\tcond_resched_lock(&dlm->spinlock);\n\t\t\t\tgoto redo_bucket;\n\t\t\t}\n\t\t}\n\t\tcond_resched_lock(&dlm->spinlock);\n\t\tnum += n;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\twake_up(&dlm->dlm_thread_wq);\n\n\t/* let the dlm thread take care of purging, keep scanning until\n\t * nothing remains in the hash */\n\tif (num) {\n\t\tmlog(0, \"%s: %d lock resources in hash last pass\\n\",\n\t\t     dlm->name, num);\n\t\tret = -EAGAIN;\n\t}\n\tmlog(0, \"DONE Migrating locks from domain %s\\n\", dlm->name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "NULL"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_begin_exit_domain",
          "args": [
            "dlm"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_begin_exit_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "600-627",
          "snippet": "static void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\n{\n\tint node = -1;\n\n\t/* Support for begin exit domain was added in 1.2 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor < 2)\n\t\treturn;\n\n\t/*\n\t * Unlike DLM_EXIT_DOMAIN_MSG, DLM_BEGIN_EXIT_DOMAIN_MSG is purely\n\t * informational. Meaning if a node does not receive the message,\n\t * so be it.\n\t */\n\tspin_lock(&dlm->spinlock);\n\twhile (1) {\n\t\tnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\n\t\tif (node >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\n\t\tspin_lock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\n{\n\tint node = -1;\n\n\t/* Support for begin exit domain was added in 1.2 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor < 2)\n\t\treturn;\n\n\t/*\n\t * Unlike DLM_EXIT_DOMAIN_MSG, DLM_BEGIN_EXIT_DOMAIN_MSG is purely\n\t * informational. Meaning if a node does not receive the message,\n\t * so be it.\n\t */\n\tspin_lock(&dlm->spinlock);\n\twhile (1) {\n\t\tnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\n\t\tif (node >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\n\t\tspin_lock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm->num_joins"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->dlm_state != DLM_CTXT_JOINED"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_unregister_domain(struct dlm_ctxt *dlm)\n{\n\tint leave = 0;\n\tstruct dlm_lock_resource *res;\n\n\tspin_lock(&dlm_domain_lock);\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_JOINED);\n\tBUG_ON(!dlm->num_joins);\n\n\tdlm->num_joins--;\n\tif (!dlm->num_joins) {\n\t\t/* We mark it \"in shutdown\" now so new register\n\t\t * requests wait until we've completely left the\n\t\t * domain. Don't use DLM_CTXT_LEAVING yet as we still\n\t\t * want new domain joins to communicate with us at\n\t\t * least until we've completed migration of our\n\t\t * resources. */\n\t\tdlm->dlm_state = DLM_CTXT_IN_SHUTDOWN;\n\t\tleave = 1;\n\t}\n\tspin_unlock(&dlm_domain_lock);\n\n\tif (leave) {\n\t\tmlog(0, \"shutting down domain %s\\n\", dlm->name);\n\t\tdlm_begin_exit_domain(dlm);\n\n\t\t/* We changed dlm state, notify the thread */\n\t\tdlm_kick_thread(dlm, NULL);\n\n\t\twhile (dlm_migrate_all_locks(dlm)) {\n\t\t\t/* Give dlm_thread time to purge the lockres' */\n\t\t\tmsleep(500);\n\t\t\tmlog(0, \"%s: more migration to do\\n\", dlm->name);\n\t\t}\n\n\t\t/* This list should be empty. If not, print remaining lockres */\n\t\tif (!list_empty(&dlm->tracking_list)) {\n\t\t\tmlog(ML_ERROR, \"Following lockres' are still on the \"\n\t\t\t     \"tracking list:\\n\");\n\t\t\tlist_for_each_entry(res, &dlm->tracking_list, tracking)\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t}\n\n\t\tdlm_mark_domain_leaving(dlm);\n\t\tdlm_leave_domain(dlm);\n\t\tprintk(KERN_NOTICE \"o2dlm: Leaving domain %s\\n\", dlm->name);\n\t\tdlm_force_free_mles(dlm);\n\t\tdlm_complete_dlm_shutdown(dlm);\n\t}\n\tdlm_put(dlm);\n}"
  },
  {
    "function_name": "dlm_shutting_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "677-689",
    "snippet": "int dlm_shutting_down(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tif (dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_shutting_down(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tif (dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_leave_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "629-675",
    "snippet": "static void dlm_leave_domain(struct dlm_ctxt *dlm)\n{\n\tint node, clear_node, status;\n\n\t/* At this point we've migrated away all our locks and won't\n\t * accept mastership of new ones. The dlm is responsible for\n\t * almost nothing now. We make sure not to confuse any joining\n\t * nodes and then commence shutdown procedure. */\n\n\tspin_lock(&dlm->spinlock);\n\t/* Clear ourselves from the domain map */\n\tclear_bit(dlm->node_num, dlm->domain_map);\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     0)) < O2NM_MAX_NODES) {\n\t\t/* Drop the dlm spinlock. This is safe wrt the domain_map.\n\t\t * -nodes cannot be added now as the\n\t\t *   query_join_handlers knows to respond with OK_NO_MAP\n\t\t * -we catch the right network errors if a node is\n\t\t *   removed from the map while we're sending him the\n\t\t *   exit message. */\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tclear_node = 1;\n\n\t\tstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\n\t\t\t\t\t\t  node);\n\t\tif (status < 0 &&\n\t\t    status != -ENOPROTOOPT &&\n\t\t    status != -ENOTCONN) {\n\t\t\tmlog(ML_NOTICE, \"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\", status, node);\n\n\t\t\t/* Not sure what to do here but lets sleep for\n\t\t\t * a bit in case this was a transient\n\t\t\t * error... */\n\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\tclear_node = 0;\n\t\t}\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t/* If we're not clearing the node bit then we intend\n\t\t * to loop back around to try again. */\n\t\tif (clear_node)\n\t\t\tclear_bit(node, dlm->domain_map);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_DOMAIN_BACKOFF_MS 200"
    ],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "node",
            "dlm->domain_map"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "DLM_DOMAIN_BACKOFF_MS"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\"",
            "status",
            "node"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_one_domain_exit",
          "args": [
            "dlm",
            "DLM_EXIT_DOMAIN_MSG",
            "node"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_domain_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "578-598",
          "snippet": "static int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->domain_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define DLM_DOMAIN_BACKOFF_MS 200\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_leave_domain(struct dlm_ctxt *dlm)\n{\n\tint node, clear_node, status;\n\n\t/* At this point we've migrated away all our locks and won't\n\t * accept mastership of new ones. The dlm is responsible for\n\t * almost nothing now. We make sure not to confuse any joining\n\t * nodes and then commence shutdown procedure. */\n\n\tspin_lock(&dlm->spinlock);\n\t/* Clear ourselves from the domain map */\n\tclear_bit(dlm->node_num, dlm->domain_map);\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     0)) < O2NM_MAX_NODES) {\n\t\t/* Drop the dlm spinlock. This is safe wrt the domain_map.\n\t\t * -nodes cannot be added now as the\n\t\t *   query_join_handlers knows to respond with OK_NO_MAP\n\t\t * -we catch the right network errors if a node is\n\t\t *   removed from the map while we're sending him the\n\t\t *   exit message. */\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tclear_node = 1;\n\n\t\tstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\n\t\t\t\t\t\t  node);\n\t\tif (status < 0 &&\n\t\t    status != -ENOPROTOOPT &&\n\t\t    status != -ENOTCONN) {\n\t\t\tmlog(ML_NOTICE, \"Error %d sending domain exit message \"\n\t\t\t     \"to node %d\\n\", status, node);\n\n\t\t\t/* Not sure what to do here but lets sleep for\n\t\t\t * a bit in case this was a transient\n\t\t\t * error... */\n\t\t\tmsleep(DLM_DOMAIN_BACKOFF_MS);\n\t\t\tclear_node = 0;\n\t\t}\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t/* If we're not clearing the node bit then we intend\n\t\t * to loop back around to try again. */\n\t\tif (clear_node)\n\t\t\tclear_bit(node, dlm->domain_map);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_begin_exit_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "600-627",
    "snippet": "static void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\n{\n\tint node = -1;\n\n\t/* Support for begin exit domain was added in 1.2 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor < 2)\n\t\treturn;\n\n\t/*\n\t * Unlike DLM_EXIT_DOMAIN_MSG, DLM_BEGIN_EXIT_DOMAIN_MSG is purely\n\t * informational. Meaning if a node does not receive the message,\n\t * so be it.\n\t */\n\tspin_lock(&dlm->spinlock);\n\twhile (1) {\n\t\tnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\n\t\tif (node >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\n\t\tspin_lock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_one_domain_exit",
          "args": [
            "dlm",
            "DLM_BEGIN_EXIT_DOMAIN_MSG",
            "node"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_domain_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "578-598",
          "snippet": "static int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->domain_map",
            "O2NM_MAX_NODES",
            "node + 1"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\n{\n\tint node = -1;\n\n\t/* Support for begin exit domain was added in 1.2 */\n\tif (dlm->dlm_locking_proto.pv_major == 1 &&\n\t    dlm->dlm_locking_proto.pv_minor < 2)\n\t\treturn;\n\n\t/*\n\t * Unlike DLM_EXIT_DOMAIN_MSG, DLM_BEGIN_EXIT_DOMAIN_MSG is purely\n\t * informational. Meaning if a node does not receive the message,\n\t * so be it.\n\t */\n\tspin_lock(&dlm->spinlock);\n\twhile (1) {\n\t\tnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\n\t\tif (node >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (node == dlm->node_num)\n\t\t\tcontinue;\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\n\t\tspin_lock(&dlm->spinlock);\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_send_one_domain_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "578-598",
    "snippet": "static int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\"",
            "status",
            "msg_type",
            "node",
            "dlm->name"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "msg_type",
            "dlm->key",
            "&leave_msg",
            "sizeof(leave_msg)",
            "node",
            "NULL"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&leave_msg",
            "0",
            "sizeof(leave_msg)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Sending domain exit message %u to node %u\\n\"",
            "dlm->name",
            "msg_type",
            "node"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\n\t\t\t\t    unsigned int node)\n{\n\tint status;\n\tstruct dlm_exit_domain leave_msg;\n\n\tmlog(0, \"%s: Sending domain exit message %u to node %u\\n\", dlm->name,\n\t     msg_type, node);\n\n\tmemset(&leave_msg, 0, sizeof(leave_msg));\n\tleave_msg.node_idx = dlm->node_num;\n\n\tstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\n\t\t\t\t    sizeof(leave_msg), node, NULL);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d sending domain exit message %u \"\n\t\t     \"to node %u on domain %s\\n\", status, msg_type, node,\n\t\t     dlm->name);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_exit_domain_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "548-576",
    "snippet": "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tmlog(0, \"%p %u %p\", msg, len, data);\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\n\tspin_lock(&dlm->spinlock);\n\tclear_bit(node, dlm->domain_map);\n\tclear_bit(node, dlm->exit_domain_map);\n\tprintk(KERN_NOTICE \"o2dlm: Node %u leaves domain %s \", node, dlm->name);\n\t__dlm_print_nodes(dlm);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, node, 0);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "345-350",
          "snippet": "void dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hb_event_notify_attached",
          "args": [
            "dlm",
            "node",
            "0"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hb_event_notify_attached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "361-373",
          "snippet": "void dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_nodes",
          "args": [
            "dlm"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "533-546",
          "snippet": "static void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Node %u leaves domain %s \"",
            "node",
            "dlm->name"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "node",
            "dlm->exit_domain_map"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%p %u %p\"",
            "msg",
            "len",
            "data"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tmlog(0, \"%p %u %p\", msg, len, data);\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\n\tspin_lock(&dlm->spinlock);\n\tclear_bit(node, dlm->domain_map);\n\tclear_bit(node, dlm->exit_domain_map);\n\tprintk(KERN_NOTICE \"o2dlm: Node %u leaves domain %s \", node, dlm->name);\n\t__dlm_print_nodes(dlm);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, node, 0);\n\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__dlm_print_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "533-546",
    "snippet": "static void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\") %u nodes\\n\"",
            "num"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->domain_map",
            "O2NM_MAX_NODES",
            "node + 1"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\n{\n\tint node = -1, num = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tprintk(\"( \");\n\twhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\n\t\t\t\t     node + 1)) < O2NM_MAX_NODES) {\n\t\tprintk(\"%d \", node);\n\t\t++num;\n\t}\n\tprintk(\") %u nodes\\n\", num);\n}"
  },
  {
    "function_name": "dlm_mark_domain_leaving",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "510-531",
    "snippet": "static void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\n{\n\t/* Yikes, a double spinlock! I need domain_lock for the dlm\n\t * state and the dlm spinlock for join state... Sorry! */\nagain:\n\tspin_lock(&dlm_domain_lock);\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"Node %d is joining, we wait on it.\\n\",\n\t\t\t  dlm->joining_node);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\twait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\n\t\tgoto again;\n\t}\n\n\tdlm->dlm_state = DLM_CTXT_LEAVING;\n\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->dlm_join_events",
            "dlm_no_joining_node(dlm)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_no_joining_node",
          "args": [
            "dlm"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "477-486",
          "snippet": "static int dlm_no_joining_node(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\tret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\n\tspin_unlock(&dlm->spinlock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_no_joining_node(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\tret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\n\tspin_unlock(&dlm->spinlock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Node %d is joining, we wait on it.\\n\"",
            "dlm->joining_node"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\n{\n\t/* Yikes, a double spinlock! I need domain_lock for the dlm\n\t * state and the dlm spinlock for join state... Sorry! */\nagain:\n\tspin_lock(&dlm_domain_lock);\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"Node %d is joining, we wait on it.\\n\",\n\t\t\t  dlm->joining_node);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_unlock(&dlm_domain_lock);\n\n\t\twait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\n\t\tgoto again;\n\t}\n\n\tdlm->dlm_state = DLM_CTXT_LEAVING;\n\tspin_unlock(&dlm->spinlock);\n\tspin_unlock(&dlm_domain_lock);\n}"
  },
  {
    "function_name": "dlm_begin_exit_domain_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "488-508",
    "snippet": "static int dlm_begin_exit_domain_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t\t void *data, void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\tmlog(0, \"%s: Node %u sent a begin exit domain message\\n\", dlm->name, node);\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(node, dlm->exit_domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);",
      "static int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);",
      "static int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);",
      "static int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "345-350",
          "snippet": "void dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "node",
            "dlm->exit_domain_map"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Node %u sent a begin exit domain message\\n\"",
            "dlm->name",
            "node"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data);\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t     void **ret_data);\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t    void *data, void **ret_data);\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t   void **ret_data);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_begin_exit_domain_handler(struct o2net_msg *msg, u32 len,\n\t\t\t\t\t void *data, void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned int node;\n\tstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tnode = exit_msg->node_idx;\n\tmlog(0, \"%s: Node %u sent a begin exit domain message\\n\", dlm->name, node);\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(node, dlm->exit_domain_map);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_no_joining_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "477-486",
    "snippet": "static int dlm_no_joining_node(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\tret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\n\tspin_unlock(&dlm->spinlock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_no_joining_node(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\tret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\n\tspin_unlock(&dlm->spinlock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_migrate_all_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "420-475",
    "snippet": "static int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\n{\n\tint i, num, n, ret = 0;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_node *iter;\n\tstruct hlist_head *bucket;\n\tint dropped;\n\n\tmlog(0, \"Migrating locks from domain %s\\n\", dlm->name);\n\n\tnum = 0;\n\tspin_lock(&dlm->spinlock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\nredo_bucket:\n\t\tn = 0;\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\titer = bucket->first;\n\t\twhile (iter) {\n\t\t\tn++;\n\t\t\tres = hlist_entry(iter, struct dlm_lock_resource,\n\t\t\t\t\t  hash_node);\n\t\t\tdlm_lockres_get(res);\n\t\t\t/* migrate, if necessary.  this will drop the dlm\n\t\t\t * spinlock and retake it if it does migration. */\n\t\t\tdropped = dlm_empty_lockres(dlm, res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (dropped)\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\telse\n\t\t\t\titer = res->hash_node.next;\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tdlm_lockres_put(res);\n\n\t\t\tif (dropped) {\n\t\t\t\tcond_resched_lock(&dlm->spinlock);\n\t\t\t\tgoto redo_bucket;\n\t\t\t}\n\t\t}\n\t\tcond_resched_lock(&dlm->spinlock);\n\t\tnum += n;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\twake_up(&dlm->dlm_thread_wq);\n\n\t/* let the dlm thread take care of purging, keep scanning until\n\t * nothing remains in the hash */\n\tif (num) {\n\t\tmlog(0, \"%s: %d lock resources in hash last pass\\n\",\n\t\t     dlm->name, num);\n\t\tret = -EAGAIN;\n\t}\n\tmlog(0, \"DONE Migrating locks from domain %s\\n\", dlm->name);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"DONE Migrating locks from domain %s\\n\"",
            "dlm->name"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: %d lock resources in hash last pass\\n\"",
            "dlm->name",
            "num"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->dlm_thread_wq"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "124-148",
          "snippet": "void __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_empty_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_empty_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2686-2713",
          "snippet": "int dlm_empty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tint ret;\n\tint lock_dropped = 0;\n\tu8 target = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (dlm_is_lockres_migrateable(dlm, res))\n\t\ttarget = dlm_pick_migration_target(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (target == O2NM_MAX_NODES)\n\t\tgoto leave;\n\n\t/* Wheee! Migrate lockres here! Will sleep so drop spinlock. */\n\tspin_unlock(&dlm->spinlock);\n\tlock_dropped = 1;\n\tret = dlm_migrate_lockres(dlm, res, target);\n\tif (ret)\n\t\tmlog(0, \"%s: res %.*s, Migrate to node %u failed with %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     target, ret);\n\tspin_lock(&dlm->spinlock);\nleave:\n\treturn lock_dropped;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_empty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tint ret;\n\tint lock_dropped = 0;\n\tu8 target = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (dlm_is_lockres_migrateable(dlm, res))\n\t\ttarget = dlm_pick_migration_target(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (target == O2NM_MAX_NODES)\n\t\tgoto leave;\n\n\t/* Wheee! Migrate lockres here! Will sleep so drop spinlock. */\n\tspin_unlock(&dlm->spinlock);\n\tlock_dropped = 1;\n\tret = dlm_migrate_lockres(dlm, res, target);\n\tif (ret)\n\t\tmlog(0, \"%s: res %.*s, Migrate to node %u failed with %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     target, ret);\n\tspin_lock(&dlm->spinlock);\nleave:\n\treturn lock_dropped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "iter",
            "structdlm_lock_resource",
            "hash_node"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\n{\n\tint i, num, n, ret = 0;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_node *iter;\n\tstruct hlist_head *bucket;\n\tint dropped;\n\n\tmlog(0, \"Migrating locks from domain %s\\n\", dlm->name);\n\n\tnum = 0;\n\tspin_lock(&dlm->spinlock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\nredo_bucket:\n\t\tn = 0;\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\titer = bucket->first;\n\t\twhile (iter) {\n\t\t\tn++;\n\t\t\tres = hlist_entry(iter, struct dlm_lock_resource,\n\t\t\t\t\t  hash_node);\n\t\t\tdlm_lockres_get(res);\n\t\t\t/* migrate, if necessary.  this will drop the dlm\n\t\t\t * spinlock and retake it if it does migration. */\n\t\t\tdropped = dlm_empty_lockres(dlm, res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (dropped)\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\telse\n\t\t\t\titer = res->hash_node.next;\n\t\t\tspin_unlock(&res->spinlock);\n\n\t\t\tdlm_lockres_put(res);\n\n\t\t\tif (dropped) {\n\t\t\t\tcond_resched_lock(&dlm->spinlock);\n\t\t\t\tgoto redo_bucket;\n\t\t\t}\n\t\t}\n\t\tcond_resched_lock(&dlm->spinlock);\n\t\tnum += n;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\twake_up(&dlm->dlm_thread_wq);\n\n\t/* let the dlm thread take care of purging, keep scanning until\n\t * nothing remains in the hash */\n\tif (num) {\n\t\tmlog(0, \"%s: %d lock resources in hash last pass\\n\",\n\t\t     dlm->name, num);\n\t\tret = -EAGAIN;\n\t}\n\tmlog(0, \"DONE Migrating locks from domain %s\\n\", dlm->name);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_complete_dlm_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "401-418",
    "snippet": "static void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\n{\n\tdlm_unregister_domain_handlers(dlm);\n\tdlm_debug_shutdown(dlm);\n\tdlm_complete_thread(dlm);\n\tdlm_complete_recovery_thread(dlm);\n\tdlm_destroy_dlm_worker(dlm);\n\n\t/* We've left the domain. Now we can take ourselves out of the\n\t * list and allow the kref stuff to help us free the\n\t * memory. */\n\tspin_lock(&dlm_domain_lock);\n\tlist_del_init(&dlm->list);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/* Wake up anyone waiting for us to remove this domain */\n\twake_up(&dlm_domain_events);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm_domain_events"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dlm->list"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_dlm_worker",
          "args": [
            "dlm"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_dlm_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "392-399",
          "snippet": "static void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_complete_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_complete_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "218-225",
          "snippet": "void dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_complete_thread",
          "args": [
            "dlm"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_complete_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "496-503",
          "snippet": "void dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_debug_shutdown",
          "args": [
            "dlm"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_debug_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "62-64",
          "snippet": "static inline void dlm_debug_shutdown(struct dlm_ctxt *dlm)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dlm_debug_shutdown(struct dlm_ctxt *dlm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unregister_domain_handlers",
          "args": [
            "dlm"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unregister_domain_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "1713-1718",
          "snippet": "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\n{\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\n\to2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\n\to2net_unregister_handler_list(&dlm->dlm_domain_handlers);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\n{\n\tdlm_unregister_domain_handlers(dlm);\n\tdlm_debug_shutdown(dlm);\n\tdlm_complete_thread(dlm);\n\tdlm_complete_recovery_thread(dlm);\n\tdlm_destroy_dlm_worker(dlm);\n\n\t/* We've left the domain. Now we can take ourselves out of the\n\t * list and allow the kref stuff to help us free the\n\t * memory. */\n\tspin_lock(&dlm_domain_lock);\n\tlist_del_init(&dlm->list);\n\tspin_unlock(&dlm_domain_lock);\n\n\t/* Wake up anyone waiting for us to remove this domain */\n\twake_up(&dlm_domain_events);\n}"
  },
  {
    "function_name": "dlm_destroy_dlm_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "392-399",
    "snippet": "static void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "dlm->dlm_worker"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "dlm->dlm_worker"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_worker) {\n\t\tflush_workqueue(dlm->dlm_worker);\n\t\tdestroy_workqueue(dlm->dlm_worker);\n\t\tdlm->dlm_worker = NULL;\n\t}\n}"
  },
  {
    "function_name": "dlm_domain_fully_joined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "380-390",
    "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "360-378",
    "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_get",
          "args": [
            "target"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "352-355",
          "snippet": "static void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "target",
            "&dlm_domains",
            "list"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__dlm_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "352-355",
    "snippet": "static void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&dlm->dlm_refs"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void __dlm_get(struct dlm_ctxt *dlm)\n{\n\tkref_get(&dlm->dlm_refs);\n}"
  },
  {
    "function_name": "dlm_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "345-350",
    "snippet": "void dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&dlm->dlm_refs",
            "dlm_ctxt_release"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid dlm_put(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm_domain_lock);\n\tkref_put(&dlm->dlm_refs, dlm_ctxt_release);\n\tspin_unlock(&dlm_domain_lock);\n}"
  },
  {
    "function_name": "dlm_ctxt_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "322-343",
    "snippet": "static void dlm_ctxt_release(struct kref *kref)\n{\n\tstruct dlm_ctxt *dlm;\n\n\tdlm = container_of(kref, struct dlm_ctxt, dlm_refs);\n\n\tBUG_ON(dlm->num_joins);\n\tBUG_ON(dlm->dlm_state == DLM_CTXT_JOINED);\n\n\t/* we may still be in the list if we hit an error during join. */\n\tlist_del_init(&dlm->list);\n\n\tspin_unlock(&dlm_domain_lock);\n\n\tmlog(0, \"freeing memory from domain %s\\n\", dlm->name);\n\n\twake_up(&dlm_domain_events);\n\n\tdlm_free_ctxt_mem(dlm);\n\n\tspin_lock(&dlm_domain_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);",
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_ctxt_mem",
          "args": [
            "dlm"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_ctxt_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "305-317",
          "snippet": "static void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm_domain_events"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"freeing memory from domain %s\\n\"",
            "dlm->name"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dlm->list"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->dlm_state == DLM_CTXT_JOINED"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->num_joins"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_ctxt",
            "dlm_refs"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dlm_domain_events);\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_ctxt_release(struct kref *kref)\n{\n\tstruct dlm_ctxt *dlm;\n\n\tdlm = container_of(kref, struct dlm_ctxt, dlm_refs);\n\n\tBUG_ON(dlm->num_joins);\n\tBUG_ON(dlm->dlm_state == DLM_CTXT_JOINED);\n\n\t/* we may still be in the list if we hit an error during join. */\n\tlist_del_init(&dlm->list);\n\n\tspin_unlock(&dlm_domain_lock);\n\n\tmlog(0, \"freeing memory from domain %s\\n\", dlm->name);\n\n\twake_up(&dlm_domain_events);\n\n\tdlm_free_ctxt_mem(dlm);\n\n\tspin_lock(&dlm_domain_lock);\n}"
  },
  {
    "function_name": "dlm_free_ctxt_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "305-317",
    "snippet": "static void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dlm"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dlm->name"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_free_pagevec",
          "args": [
            "(void **)dlm->master_hash",
            "DLM_HASH_PAGES"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "79-84",
          "snippet": "static void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_debugfs_subroot",
          "args": [
            "dlm"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_debugfs_subroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.h",
          "lines": "69-71",
          "snippet": "static inline void dlm_destroy_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dlm_destroy_debugfs_subroot(struct dlm_ctxt *dlm)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstatic void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\n{\n\tdlm_destroy_debugfs_subroot(dlm);\n\n\tif (dlm->lockres_hash)\n\t\tdlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\n\n\tif (dlm->master_hash)\n\t\tdlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\n\n\tkfree(dlm->name);\n\tkfree(dlm);\n}"
  },
  {
    "function_name": "dlm_wait_on_domain_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "288-303",
    "snippet": "static int dlm_wait_on_domain_helper(const char *domain)\n{\n\tint ret = 0;\n\tstruct dlm_ctxt *tmp = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\ttmp = __dlm_lookup_domain(domain);\n\tif (!tmp)\n\t\tret = 1;\n\telse if (tmp->dlm_state == DLM_CTXT_JOINED)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_domain",
          "args": [
            "domain"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "277-282",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int dlm_wait_on_domain_helper(const char *domain)\n{\n\tint ret = 0;\n\tstruct dlm_ctxt *tmp = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\ttmp = __dlm_lookup_domain(domain);\n\tif (!tmp)\n\t\tret = 1;\n\telse if (tmp->dlm_state == DLM_CTXT_JOINED)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__dlm_lookup_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "277-282",
    "snippet": "static struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_lookup_domain_full",
          "args": [
            "domain",
            "strlen(domain)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_domain_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "259-274",
          "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\n{\n\tassert_spin_locked(&dlm_domain_lock);\n\n\treturn __dlm_lookup_domain_full(domain, strlen(domain));\n}"
  },
  {
    "function_name": "__dlm_lookup_domain_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "259-274",
    "snippet": "static struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "tmp->name",
            "domain",
            "len"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp->name"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&dlm_domains",
            "list"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm_domain_lock"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\n{\n\tstruct dlm_ctxt *tmp;\n\n\tassert_spin_locked(&dlm_domain_lock);\n\n\t/* tmp->name here is always NULL terminated,\n\t * but domain may not be! */\n\tlist_for_each_entry(tmp, &dlm_domains, list) {\n\t\tif (strlen(tmp->name) == len &&\n\t\t    memcmp(tmp->name, domain, len)==0)\n\t\t\treturn tmp;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_lookup_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "246-257",
    "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "len",
            "hash"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "len"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
  },
  {
    "function_name": "__dlm_lookup_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "221-244",
    "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres_full",
          "args": [
            "dlm",
            "name",
            "len",
            "hash"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "188-213",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s\\n\"",
            "len",
            "name"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "__dlm_lookup_lockres_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "188-213",
    "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "res->lockname.name + 1",
            "name + 1",
            "len - 1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "res->lockname.len != len"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "res",
            "bucket",
            "hash_node"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "hash"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s\\n\"",
            "len",
            "name"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__dlm_insert_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "169-186",
    "snippet": "void __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Hash res %.*s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&res->hash_node",
            "bucket"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "q->hash"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
  },
  {
    "function_name": "__dlm_unhash_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "158-167",
    "snippet": "void __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (hlist_unhashed(&res->hash_node))\n\t\treturn;\n\n\tmlog(0, \"%s: Unhash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\thlist_del_init(&res->hash_node);\n\tdlm_lockres_put(res);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&res->hash_node"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Unhash res %.*s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&res->hash_node"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (hlist_unhashed(&res->hash_node))\n\t\treturn;\n\n\tmlog(0, \"%s: Unhash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\thlist_del_init(&res->hash_node);\n\tdlm_lockres_put(res);\n}"
  },
  {
    "function_name": "dlm_alloc_pagevec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "86-105",
    "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_free_pagevec",
          "args": [
            "vec",
            "i"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "79-84",
          "snippet": "static void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\"",
            "pages",
            "(unsigned long)DLM_HASH_PAGES",
            "(unsigned long)DLM_BUCKETS_PER_PAGE"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pages * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_free_pagevec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "79-84",
    "snippet": "static void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vec"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)vec[pages]"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_free_pagevec(void **vec, int pages)\n{\n\twhile (pages--)\n\t\tfree_page((unsigned long)vec[pages]);\n\tkfree(vec);\n}"
  },
  {
    "function_name": "byte_copymap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "65-77",
    "snippet": "static inline void byte_copymap(u8 dmap[], unsigned long smap[],\n\t\t\tunsigned int sz)\n{\n\tunsigned int nn;\n\n\tif (!sz)\n\t\treturn;\n\n\tmemset(dmap, 0, ((sz + 7) >> 3));\n\tfor (nn = 0 ; nn < sz; nn++)\n\t\tif (test_bit(nn, smap))\n\t\t\tbyte_set_bit(nn, dmap);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "byte_set_bit",
          "args": [
            "nn",
            "dmap"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "nn",
            "smap"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dmap",
            "0",
            "((sz + 7) >> 3)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_copymap(u8 dmap[], unsigned long smap[],\n\t\t\tunsigned int sz)\n{\n\tunsigned int nn;\n\n\tif (!sz)\n\t\treturn;\n\n\tmemset(dmap, 0, ((sz + 7) >> 3));\n\tfor (nn = 0 ; nn < sz; nn++)\n\t\tif (test_bit(nn, smap))\n\t\t\tbyte_set_bit(nn, dmap);\n}"
  },
  {
    "function_name": "byte_test_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "60-63",
    "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
  },
  {
    "function_name": "byte_set_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
    "lines": "55-58",
    "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/debugfs.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
  }
]