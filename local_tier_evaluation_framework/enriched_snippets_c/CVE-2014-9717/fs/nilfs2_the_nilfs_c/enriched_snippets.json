[
  {
    "function_name": "nilfs_put_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "801-815",
    "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root->ifile"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&root->rb_node",
            "&nilfs->ns_cptree"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_delete_snapshot_group",
          "args": [
            "root"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_delete_snapshot_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "227-230",
          "snippet": "void nilfs_sysfs_delete_snapshot_group(struct nilfs_root *root)\n{\n\tkobject_del(&root->snapshot_kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nvoid nilfs_sysfs_delete_snapshot_group(struct nilfs_root *root)\n{\n\tkobject_del(&root->snapshot_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&root->count"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
  },
  {
    "function_name": "nilfs_find_or_create_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "744-799",
    "snippet": "struct nilfs_root *\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nilfs_root *root, *new;\n\tint err;\n\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root)\n\t\treturn root;\n\n\tnew = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\n\tp = &nilfs->ns_cptree.rb_node;\n\tparent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\troot = rb_entry(parent, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\tkfree(new);\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tnew->cno = cno;\n\tnew->ifile = NULL;\n\tnew->nilfs = nilfs;\n\tatomic_set(&new->count, 1);\n\tatomic64_set(&new->inodes_count, 0);\n\tatomic64_set(&new->blocks_count, 0);\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, &nilfs->ns_cptree);\n\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\terr = nilfs_sysfs_create_snapshot_group(new);\n\tif (err) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t}\n\n\treturn new;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_create_snapshot_group",
          "args": [
            "new"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_create_snapshot_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "198-225",
          "snippet": "int nilfs_sysfs_create_snapshot_group(struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct kobject *parent;\n\tint err;\n\n\tnilfs = root->nilfs;\n\tparent = &nilfs->ns_dev_subgroups->sg_mounted_snapshots_kobj;\n\troot->snapshot_kobj.kset = nilfs_kset;\n\tinit_completion(&root->snapshot_kobj_unregister);\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    &nilfs->ns_dev_kobj,\n\t\t\t\t\t    \"current_checkpoint\");\n\t} else {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    parent,\n\t\t\t\t\t    \"%llu\", root->cno);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *nilfs_kset;",
            "static struct kobj_type nilfs_snapshot_ktype = {\n\t.default_attrs\t= nilfs_snapshot_attrs,\n\t.sysfs_ops\t= &nilfs_snapshot_attr_ops,\n\t.release\t= nilfs_snapshot_attr_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nstatic struct kset *nilfs_kset;\nstatic struct kobj_type nilfs_snapshot_ktype = {\n\t.default_attrs\t= nilfs_snapshot_attrs,\n\t.sysfs_ops\t= &nilfs_snapshot_attr_ops,\n\t.release\t= nilfs_snapshot_attr_release,\n};\n\nint nilfs_sysfs_create_snapshot_group(struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct kobject *parent;\n\tint err;\n\n\tnilfs = root->nilfs;\n\tparent = &nilfs->ns_dev_subgroups->sg_mounted_snapshots_kobj;\n\troot->snapshot_kobj.kset = nilfs_kset;\n\tinit_completion(&root->snapshot_kobj_unregister);\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    &nilfs->ns_dev_kobj,\n\t\t\t\t\t    \"current_checkpoint\");\n\t} else {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    parent,\n\t\t\t\t\t    \"%llu\", root->cno);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->rb_node",
            "&nilfs->ns_cptree"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->rb_node",
            "parent",
            "p"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&new->blocks_count",
            "0"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&new->inodes_count",
            "0"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->count",
            "1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->count"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structnilfs_root",
            "rb_node"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*root)",
            "GFP_KERNEL"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_lookup_root",
          "args": [
            "nilfs",
            "cno"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_lookup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "719-742",
          "snippet": "struct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct nilfs_root *\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nilfs_root *root, *new;\n\tint err;\n\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root)\n\t\treturn root;\n\n\tnew = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\n\tp = &nilfs->ns_cptree.rb_node;\n\tparent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\troot = rb_entry(parent, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\tkfree(new);\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tnew->cno = cno;\n\tnew->ifile = NULL;\n\tnew->nilfs = nilfs;\n\tatomic_set(&new->count, 1);\n\tatomic64_set(&new->inodes_count, 0);\n\tatomic64_set(&new->blocks_count, 0);\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, &nilfs->ns_cptree);\n\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\terr = nilfs_sysfs_create_snapshot_group(new);\n\tif (err) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t}\n\n\treturn new;\n}"
  },
  {
    "function_name": "nilfs_lookup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "719-742",
    "snippet": "struct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->count"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structnilfs_root",
            "rb_node"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nilfs_near_disk_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "708-717",
    "snippet": "int nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nilfs->ns_ndirtyblks"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_get_ncleansegs",
          "args": [
            "nilfs->ns_sufile"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_get_ncleansegs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "133-136",
          "snippet": "unsigned long nilfs_sufile_get_ncleansegs(struct inode *sufile)\n{\n\treturn NILFS_SUI(sufile)->ncleansegs;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nunsigned long nilfs_sufile_get_ncleansegs(struct inode *sufile)\n{\n\treturn NILFS_SUI(sufile)->ncleansegs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}"
  },
  {
    "function_name": "nilfs_count_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "697-706",
    "snippet": "int nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_get_ncleansegs",
          "args": [
            "nilfs->ns_sufile"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_get_ncleansegs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "133-136",
          "snippet": "unsigned long nilfs_sufile_get_ncleansegs(struct inode *sufile)\n{\n\treturn NILFS_SUI(sufile)->ncleansegs;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nunsigned long nilfs_sufile_get_ncleansegs(struct inode *sufile)\n{\n\treturn NILFS_SUI(sufile)->ncleansegs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(nilfs->ns_dat)->mi_sem"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_discard_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "660-695",
    "snippet": "int nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\n\t\t\t    size_t nsegs)\n{\n\tsector_t seg_start, seg_end;\n\tsector_t start = 0, nblocks = 0;\n\tunsigned int sects_per_block;\n\t__u64 *sn;\n\tint ret = 0;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tfor (sn = segnump; sn < segnump + nsegs; sn++) {\n\t\tnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\n\n\t\tif (!nblocks) {\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t} else if (start + nblocks == seg_start) {\n\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t} else {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t\t   GFP_NOFS, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tnblocks = 0;\n\t\t}\n\t}\n\tif (nblocks)\n\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t   GFP_NOFS, 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "nilfs->ns_bdev",
            "start * sects_per_block",
            "nblocks * sects_per_block",
            "GFP_NOFS",
            "0"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "nilfs->ns_bdev",
            "start * sects_per_block",
            "nblocks * sects_per_block",
            "GFP_NOFS",
            "0"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_get_segment_range",
          "args": [
            "nilfs",
            "*sn",
            "&seg_start",
            "&seg_end"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segment_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "319-327",
          "snippet": "static inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "nilfs->ns_bdev"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\n\t\t\t    size_t nsegs)\n{\n\tsector_t seg_start, seg_end;\n\tsector_t start = 0, nblocks = 0;\n\tunsigned int sects_per_block;\n\t__u64 *sn;\n\tint ret = 0;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tfor (sn = segnump; sn < segnump + nsegs; sn++) {\n\t\tnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\n\n\t\tif (!nblocks) {\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t} else if (start + nblocks == seg_start) {\n\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t} else {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t\t   GFP_NOFS, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tnblocks = 0;\n\t\t}\n\t}\n\tif (nblocks)\n\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t   GFP_NOFS, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_nilfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "573-658",
    "snippet": "int init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\n{\n\tstruct nilfs_super_block *sbp;\n\tint blocksize;\n\tint err;\n\n\tdown_write(&nilfs->ns_sem);\n\n\tblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: unable to set blocksize\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\tif (err)\n\t\tgoto out;\n\n\terr = nilfs_store_magic_and_option(sb, sbp, data);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_check_feature_compatibility(sb, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp->s_log_block_size);\n\tif (blocksize < NILFS_MIN_BLOCK_SIZE ||\n\t    blocksize > NILFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"filesystem blocksize %d\\n\", blocksize);\n\t\terr = -EINVAL;\n\t\tgoto failed_sbh;\n\t}\n\tif (sb->s_blocksize != blocksize) {\n\t\tint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\n\n\t\tif (blocksize < hw_blocksize) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: blocksize %d too small for device \"\n\t\t\t       \"(sector-size = %d).\\n\",\n\t\t\t       blocksize, hw_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_sbh;\n\t\t}\n\t\tnilfs_release_super_block(nilfs);\n\t\tsb_set_blocksize(sb, blocksize);\n\n\t\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t\t/* not failed_sbh; sbh is released automatically\n\t\t\t   when reloading fails. */\n\t}\n\tnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\n\tnilfs->ns_blocksize = blocksize;\n\n\tget_random_bytes(&nilfs->ns_next_generation,\n\t\t\t sizeof(nilfs->ns_next_generation));\n\n\terr = nilfs_store_disk_layout(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\n\n\tnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\n\n\terr = nilfs_store_log_cursor(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_sysfs_create_device_group(sb);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tset_nilfs_init(nilfs);\n\terr = 0;\n out:\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n\n failed_sbh:\n\tnilfs_release_super_block(nilfs);\n\tgoto out;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_release_super_block",
          "args": [
            "nilfs"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_release_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "463-474",
          "snippet": "static void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nilfs_init",
          "args": [
            "nilfs"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_create_device_group",
          "args": [
            "sb"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_create_device_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "993-1055",
          "snippet": "int nilfs_sysfs_create_device_group(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tsize_t devgrp_size = sizeof(struct nilfs_sysfs_dev_subgroups);\n\tint err;\n\n\tnilfs->ns_dev_subgroups = kzalloc(devgrp_size, GFP_KERNEL);\n\tif (unlikely(!nilfs->ns_dev_subgroups)) {\n\t\terr = -ENOMEM;\n\t\tprintk(KERN_ERR \"NILFS: unable to allocate memory for device group\\n\");\n\t\tgoto failed_create_device_group;\n\t}\n\n\tnilfs->ns_dev_kobj.kset = nilfs_kset;\n\tinit_completion(&nilfs->ns_dev_kobj_unregister);\n\terr = kobject_init_and_add(&nilfs->ns_dev_kobj, &nilfs_dev_ktype, NULL,\n\t\t\t\t    \"%s\", sb->s_id);\n\tif (err)\n\t\tgoto free_dev_subgroups;\n\n\terr = nilfs_sysfs_create_mounted_snapshots_group(nilfs);\n\tif (err)\n\t\tgoto cleanup_dev_kobject;\n\n\terr = nilfs_sysfs_create_checkpoints_group(nilfs);\n\tif (err)\n\t\tgoto delete_mounted_snapshots_group;\n\n\terr = nilfs_sysfs_create_segments_group(nilfs);\n\tif (err)\n\t\tgoto delete_checkpoints_group;\n\n\terr = nilfs_sysfs_create_superblock_group(nilfs);\n\tif (err)\n\t\tgoto delete_segments_group;\n\n\terr = nilfs_sysfs_create_segctor_group(nilfs);\n\tif (err)\n\t\tgoto delete_superblock_group;\n\n\treturn 0;\n\ndelete_superblock_group:\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\ndelete_segments_group:\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\ndelete_checkpoints_group:\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\ndelete_mounted_snapshots_group:\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\ncleanup_dev_kobject:\n\tkobject_del(&nilfs->ns_dev_kobj);\n\nfree_dev_subgroups:\n\tkfree(nilfs->ns_dev_subgroups);\n\nfailed_create_device_group:\n\treturn err;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *nilfs_kset;",
            "static struct kobj_type nilfs_dev_ktype = {\n\t.default_attrs\t= nilfs_dev_attrs,\n\t.sysfs_ops\t= &nilfs_dev_attr_ops,\n\t.release\t= nilfs_dev_attr_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nstatic struct kset *nilfs_kset;\nstatic struct kobj_type nilfs_dev_ktype = {\n\t.default_attrs\t= nilfs_dev_attrs,\n\t.sysfs_ops\t= &nilfs_dev_attr_ops,\n\t.release\t= nilfs_dev_attr_release,\n};\n\nint nilfs_sysfs_create_device_group(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tsize_t devgrp_size = sizeof(struct nilfs_sysfs_dev_subgroups);\n\tint err;\n\n\tnilfs->ns_dev_subgroups = kzalloc(devgrp_size, GFP_KERNEL);\n\tif (unlikely(!nilfs->ns_dev_subgroups)) {\n\t\terr = -ENOMEM;\n\t\tprintk(KERN_ERR \"NILFS: unable to allocate memory for device group\\n\");\n\t\tgoto failed_create_device_group;\n\t}\n\n\tnilfs->ns_dev_kobj.kset = nilfs_kset;\n\tinit_completion(&nilfs->ns_dev_kobj_unregister);\n\terr = kobject_init_and_add(&nilfs->ns_dev_kobj, &nilfs_dev_ktype, NULL,\n\t\t\t\t    \"%s\", sb->s_id);\n\tif (err)\n\t\tgoto free_dev_subgroups;\n\n\terr = nilfs_sysfs_create_mounted_snapshots_group(nilfs);\n\tif (err)\n\t\tgoto cleanup_dev_kobject;\n\n\terr = nilfs_sysfs_create_checkpoints_group(nilfs);\n\tif (err)\n\t\tgoto delete_mounted_snapshots_group;\n\n\terr = nilfs_sysfs_create_segments_group(nilfs);\n\tif (err)\n\t\tgoto delete_checkpoints_group;\n\n\terr = nilfs_sysfs_create_superblock_group(nilfs);\n\tif (err)\n\t\tgoto delete_segments_group;\n\n\terr = nilfs_sysfs_create_segctor_group(nilfs);\n\tif (err)\n\t\tgoto delete_superblock_group;\n\n\treturn 0;\n\ndelete_superblock_group:\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\ndelete_segments_group:\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\ndelete_checkpoints_group:\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\ndelete_mounted_snapshots_group:\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\ncleanup_dev_kobject:\n\tkobject_del(&nilfs->ns_dev_kobj);\n\nfree_dev_subgroups:\n\tkfree(nilfs->ns_dev_subgroups);\n\nfailed_create_device_group:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_store_log_cursor",
          "args": [
            "nilfs",
            "sbp"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_store_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "183-202",
          "snippet": "static int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp->s_state"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_max_size",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "358-367",
          "snippet": "static unsigned long long nilfs_max_size(unsigned int blkbits)\n{\n\tunsigned int max_bits;\n\tunsigned long long res = MAX_LFS_FILESIZE; /* page cache limit */\n\n\tmax_bits = blkbits + NILFS_BMAP_KEY_BIT; /* bmap size limit */\n\tif (max_bits < 64)\n\t\tres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\n\treturn res;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic unsigned long long nilfs_max_size(unsigned int blkbits)\n{\n\tunsigned int max_bits;\n\tunsigned long long res = MAX_LFS_FILESIZE; /* page cache limit */\n\n\tmax_bits = blkbits + NILFS_BMAP_KEY_BIT; /* bmap size limit */\n\tif (max_bits < 64)\n\t\tres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_store_disk_layout",
          "args": [
            "nilfs",
            "sbp"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_store_disk_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "387-434",
          "snippet": "static int nilfs_store_disk_layout(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_super_block *sbp)\n{\n\tif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\n\t\tprintk(KERN_ERR \"NILFS: unsupported revision \"\n\t\t       \"(superblock rev.=%d.%d, current rev.=%d.%d). \"\n\t\t       \"Please check the version of mkfs.nilfs.\\n\",\n\t\t       le32_to_cpu(sbp->s_rev_level),\n\t\t       le16_to_cpu(sbp->s_minor_rev_level),\n\t\t       NILFS_CURRENT_REV, NILFS_MINOR_REV);\n\t\treturn -EINVAL;\n\t}\n\tnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\n\tif (nilfs->ns_sbsize > BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\n\tif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: too large inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: too small inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\n\n\tnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\n\t\tprintk(KERN_ERR \"NILFS: too short segment.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\n\tnilfs->ns_r_segments_percentage =\n\t\tle32_to_cpu(sbp->s_r_segments_percentage);\n\tif (nilfs->ns_r_segments_percentage < 1 ||\n\t    nilfs->ns_r_segments_percentage > 99) {\n\t\tprintk(KERN_ERR \"NILFS: invalid reserved segments percentage.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs_set_nsegments(nilfs, le64_to_cpu(sbp->s_nsegments));\n\tnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_store_disk_layout(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_super_block *sbp)\n{\n\tif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\n\t\tprintk(KERN_ERR \"NILFS: unsupported revision \"\n\t\t       \"(superblock rev.=%d.%d, current rev.=%d.%d). \"\n\t\t       \"Please check the version of mkfs.nilfs.\\n\",\n\t\t       le32_to_cpu(sbp->s_rev_level),\n\t\t       le16_to_cpu(sbp->s_minor_rev_level),\n\t\t       NILFS_CURRENT_REV, NILFS_MINOR_REV);\n\t\treturn -EINVAL;\n\t}\n\tnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\n\tif (nilfs->ns_sbsize > BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\n\tif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: too large inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: too small inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\n\n\tnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\n\t\tprintk(KERN_ERR \"NILFS: too short segment.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\n\tnilfs->ns_r_segments_percentage =\n\t\tle32_to_cpu(sbp->s_r_segments_percentage);\n\tif (nilfs->ns_r_segments_percentage < 1 ||\n\t    nilfs->ns_r_segments_percentage > 99) {\n\t\tprintk(KERN_ERR \"NILFS: invalid reserved segments percentage.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs_set_nsegments(nilfs, le64_to_cpu(sbp->s_nsegments));\n\tnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&nilfs->ns_next_generation",
            "sizeof(nilfs->ns_next_generation)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_load_super_block",
          "args": [
            "nilfs",
            "sb",
            "blocksize",
            "&sbp"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_load_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "496-558",
          "snippet": "static int nilfs_load_super_block(struct the_nilfs *nilfs,\n\t\t\t\t  struct super_block *sb, int blocksize,\n\t\t\t\t  struct nilfs_super_block **sbpp)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct buffer_head **sbh = nilfs->ns_sbh;\n\tu64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);\n\tint valid[2], swp = 0;\n\n\tsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\n\t\t\t\t\t&sbh[0]);\n\tsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\n\n\tif (!sbp[0]) {\n\t\tif (!sbp[1]) {\n\t\t\tprintk(KERN_ERR \"NILFS: unable to read superblock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read primary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t} else if (!sbp[1]) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read secondary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t}\n\n\t/*\n\t * Compare two super blocks and set 1 in swp if the secondary\n\t * super block is valid and newer.  Otherwise, set 0 in swp.\n\t */\n\tvalid[0] = nilfs_valid_sb(sbp[0]);\n\tvalid[1] = nilfs_valid_sb(sbp[1]);\n\tswp = valid[1] && (!valid[0] ||\n\t\t\t   le64_to_cpu(sbp[1]->s_last_cno) >\n\t\t\t   le64_to_cpu(sbp[0]->s_last_cno));\n\n\tif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\n\t\tbrelse(sbh[1]);\n\t\tsbh[1] = NULL;\n\t\tsbp[1] = NULL;\n\t\tvalid[1] = 0;\n\t\tswp = 0;\n\t}\n\tif (!valid[swp]) {\n\t\tnilfs_release_super_block(nilfs);\n\t\tprintk(KERN_ERR \"NILFS: Can't find nilfs on dev %s.\\n\",\n\t\t       sb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid[!swp])\n\t\tprintk(KERN_WARNING \"NILFS warning: broken superblock. \"\n\t\t       \"using spare superblock (blocksize = %d).\\n\", blocksize);\n\tif (swp)\n\t\tnilfs_swap_super_block(nilfs);\n\n\tnilfs->ns_sbwcount = 0;\n\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\tnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\n\t*sbpp = sbp[0];\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_load_super_block(struct the_nilfs *nilfs,\n\t\t\t\t  struct super_block *sb, int blocksize,\n\t\t\t\t  struct nilfs_super_block **sbpp)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct buffer_head **sbh = nilfs->ns_sbh;\n\tu64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);\n\tint valid[2], swp = 0;\n\n\tsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\n\t\t\t\t\t&sbh[0]);\n\tsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\n\n\tif (!sbp[0]) {\n\t\tif (!sbp[1]) {\n\t\t\tprintk(KERN_ERR \"NILFS: unable to read superblock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read primary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t} else if (!sbp[1]) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read secondary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t}\n\n\t/*\n\t * Compare two super blocks and set 1 in swp if the secondary\n\t * super block is valid and newer.  Otherwise, set 0 in swp.\n\t */\n\tvalid[0] = nilfs_valid_sb(sbp[0]);\n\tvalid[1] = nilfs_valid_sb(sbp[1]);\n\tswp = valid[1] && (!valid[0] ||\n\t\t\t   le64_to_cpu(sbp[1]->s_last_cno) >\n\t\t\t   le64_to_cpu(sbp[0]->s_last_cno));\n\n\tif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\n\t\tbrelse(sbh[1]);\n\t\tsbh[1] = NULL;\n\t\tsbp[1] = NULL;\n\t\tvalid[1] = 0;\n\t\tswp = 0;\n\t}\n\tif (!valid[swp]) {\n\t\tnilfs_release_super_block(nilfs);\n\t\tprintk(KERN_ERR \"NILFS: Can't find nilfs on dev %s.\\n\",\n\t\t       sb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid[!swp])\n\t\tprintk(KERN_WARNING \"NILFS warning: broken superblock. \"\n\t\t       \"using spare superblock (blocksize = %d).\\n\", blocksize);\n\tif (swp)\n\t\tnilfs_swap_super_block(nilfs);\n\n\tnilfs->ns_sbwcount = 0;\n\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\tnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\n\t*sbpp = sbp[0];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"NILFS: blocksize %d too small for device \"\n\t\t\t       \"(sector-size = %d).\\n\"",
            "blocksize",
            "hw_blocksize"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp->s_log_block_size"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_check_feature_compatibility",
          "args": [
            "sb",
            "sbp"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_check_feature_compatibility",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "894-916",
          "snippet": "int nilfs_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t      struct nilfs_super_block *sbp)\n{\n\t__u64 features;\n\n\tfeatures = le64_to_cpu(sbp->s_feature_incompat) &\n\t\t~NILFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\tfeatures = le64_to_cpu(sbp->s_feature_compat_ro) &\n\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t      struct nilfs_super_block *sbp)\n{\n\t__u64 features;\n\n\tfeatures = le64_to_cpu(sbp->s_feature_incompat) &\n\t\t~NILFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\tfeatures = le64_to_cpu(sbp->s_feature_compat_ro) &\n\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_store_magic_and_option",
          "args": [
            "sb",
            "sbp",
            "data"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_store_magic_and_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "871-892",
          "snippet": "int nilfs_store_magic_and_option(struct super_block *sb,\n\t\t\t\t struct nilfs_super_block *sbp,\n\t\t\t\t char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tsb->s_magic = le16_to_cpu(sbp->s_magic);\n\n\t/* FS independent flags */\n#ifdef NILFS_ATIME_DISABLE\n\tsb->s_flags |= MS_NOATIME;\n#endif\n\n\tnilfs_set_default_options(sb, sbp);\n\n\tnilfs->ns_resuid = le16_to_cpu(sbp->s_def_resuid);\n\tnilfs->ns_resgid = le16_to_cpu(sbp->s_def_resgid);\n\tnilfs->ns_interval = le32_to_cpu(sbp->s_c_interval);\n\tnilfs->ns_watermark = le32_to_cpu(sbp->s_c_block_max);\n\n\treturn !parse_options(data, sb, 0) ? -EINVAL : 0 ;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nint nilfs_store_magic_and_option(struct super_block *sb,\n\t\t\t\t struct nilfs_super_block *sbp,\n\t\t\t\t char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tsb->s_magic = le16_to_cpu(sbp->s_magic);\n\n\t/* FS independent flags */\n#ifdef NILFS_ATIME_DISABLE\n\tsb->s_flags |= MS_NOATIME;\n#endif\n\n\tnilfs_set_default_options(sb, sbp);\n\n\tnilfs->ns_resuid = le16_to_cpu(sbp->s_def_resuid);\n\tnilfs->ns_resgid = le16_to_cpu(sbp->s_def_resgid);\n\tnilfs->ns_interval = le32_to_cpu(sbp->s_c_interval);\n\tnilfs->ns_watermark = le32_to_cpu(sbp->s_c_block_max);\n\n\treturn !parse_options(data, sb, 0) ? -EINVAL : 0 ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "NILFS_MIN_BLOCK_SIZE"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nint init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\n{\n\tstruct nilfs_super_block *sbp;\n\tint blocksize;\n\tint err;\n\n\tdown_write(&nilfs->ns_sem);\n\n\tblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: unable to set blocksize\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\tif (err)\n\t\tgoto out;\n\n\terr = nilfs_store_magic_and_option(sb, sbp, data);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_check_feature_compatibility(sb, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp->s_log_block_size);\n\tif (blocksize < NILFS_MIN_BLOCK_SIZE ||\n\t    blocksize > NILFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"filesystem blocksize %d\\n\", blocksize);\n\t\terr = -EINVAL;\n\t\tgoto failed_sbh;\n\t}\n\tif (sb->s_blocksize != blocksize) {\n\t\tint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\n\n\t\tif (blocksize < hw_blocksize) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: blocksize %d too small for device \"\n\t\t\t       \"(sector-size = %d).\\n\",\n\t\t\t       blocksize, hw_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_sbh;\n\t\t}\n\t\tnilfs_release_super_block(nilfs);\n\t\tsb_set_blocksize(sb, blocksize);\n\n\t\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t\t/* not failed_sbh; sbh is released automatically\n\t\t\t   when reloading fails. */\n\t}\n\tnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\n\tnilfs->ns_blocksize = blocksize;\n\n\tget_random_bytes(&nilfs->ns_next_generation,\n\t\t\t sizeof(nilfs->ns_next_generation));\n\n\terr = nilfs_store_disk_layout(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\n\n\tnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\n\n\terr = nilfs_store_log_cursor(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_sysfs_create_device_group(sb);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tset_nilfs_init(nilfs);\n\terr = 0;\n out:\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n\n failed_sbh:\n\tnilfs_release_super_block(nilfs);\n\tgoto out;\n}"
  },
  {
    "function_name": "nilfs_load_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "496-558",
    "snippet": "static int nilfs_load_super_block(struct the_nilfs *nilfs,\n\t\t\t\t  struct super_block *sb, int blocksize,\n\t\t\t\t  struct nilfs_super_block **sbpp)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct buffer_head **sbh = nilfs->ns_sbh;\n\tu64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);\n\tint valid[2], swp = 0;\n\n\tsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\n\t\t\t\t\t&sbh[0]);\n\tsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\n\n\tif (!sbp[0]) {\n\t\tif (!sbp[1]) {\n\t\t\tprintk(KERN_ERR \"NILFS: unable to read superblock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read primary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t} else if (!sbp[1]) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read secondary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t}\n\n\t/*\n\t * Compare two super blocks and set 1 in swp if the secondary\n\t * super block is valid and newer.  Otherwise, set 0 in swp.\n\t */\n\tvalid[0] = nilfs_valid_sb(sbp[0]);\n\tvalid[1] = nilfs_valid_sb(sbp[1]);\n\tswp = valid[1] && (!valid[0] ||\n\t\t\t   le64_to_cpu(sbp[1]->s_last_cno) >\n\t\t\t   le64_to_cpu(sbp[0]->s_last_cno));\n\n\tif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\n\t\tbrelse(sbh[1]);\n\t\tsbh[1] = NULL;\n\t\tsbp[1] = NULL;\n\t\tvalid[1] = 0;\n\t\tswp = 0;\n\t}\n\tif (!valid[swp]) {\n\t\tnilfs_release_super_block(nilfs);\n\t\tprintk(KERN_ERR \"NILFS: Can't find nilfs on dev %s.\\n\",\n\t\t       sb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid[!swp])\n\t\tprintk(KERN_WARNING \"NILFS warning: broken superblock. \"\n\t\t       \"using spare superblock (blocksize = %d).\\n\", blocksize);\n\tif (swp)\n\t\tnilfs_swap_super_block(nilfs);\n\n\tnilfs->ns_sbwcount = 0;\n\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\tnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\n\t*sbpp = sbp[0];\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp[valid[1] & !swp]->s_last_seq"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_swap_super_block",
          "args": [
            "nilfs"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_swap_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "485-494",
          "snippet": "void nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NILFS warning: broken superblock. \"\n\t\t       \"using spare superblock (blocksize = %d).\\n\"",
            "blocksize"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_release_super_block",
          "args": [
            "nilfs"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_release_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "463-474",
          "snippet": "static void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbh[1]"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sb2_bad_offset",
          "args": [
            "sbp[swp]",
            "sb2off"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb2_bad_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "456-461",
          "snippet": "static int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_valid_sb",
          "args": [
            "sbp[1]"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_valid_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "436-454",
          "snippet": "static int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_read_super_block",
          "args": [
            "sb",
            "sb2off",
            "blocksize",
            "&sbh[1]"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "857-869",
          "snippet": "struct nilfs_super_block *nilfs_read_super_block(struct super_block *sb,\n\t\t\t\t\t\t u64 pos, int blocksize,\n\t\t\t\t\t\t struct buffer_head **pbh)\n{\n\tunsigned long long sb_index = pos;\n\tunsigned long offset;\n\n\toffset = do_div(sb_index, blocksize);\n\t*pbh = sb_bread(sb, sb_index);\n\tif (!*pbh)\n\t\treturn NULL;\n\treturn (struct nilfs_super_block *)((char *)(*pbh)->b_data + offset);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block *nilfs_read_super_block(struct super_block *sb,\n\t\t\t\t\t\t u64 pos, int blocksize,\n\t\t\t\t\t\t struct buffer_head **pbh)\n{\n\tunsigned long long sb_index = pos;\n\tunsigned long offset;\n\n\toffset = do_div(sb_index, blocksize);\n\t*pbh = sb_bread(sb, sb_index);\n\tif (!*pbh)\n\t\treturn NULL;\n\treturn (struct nilfs_super_block *)((char *)(*pbh)->b_data + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_SB2_OFFSET_BYTES",
          "args": [
            "nilfs->ns_bdev->bd_inode->i_size"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_load_super_block(struct the_nilfs *nilfs,\n\t\t\t\t  struct super_block *sb, int blocksize,\n\t\t\t\t  struct nilfs_super_block **sbpp)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct buffer_head **sbh = nilfs->ns_sbh;\n\tu64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);\n\tint valid[2], swp = 0;\n\n\tsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\n\t\t\t\t\t&sbh[0]);\n\tsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\n\n\tif (!sbp[0]) {\n\t\tif (!sbp[1]) {\n\t\t\tprintk(KERN_ERR \"NILFS: unable to read superblock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read primary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t} else if (!sbp[1]) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to read secondary superblock \"\n\t\t       \"(blocksize = %d)\\n\", blocksize);\n\t}\n\n\t/*\n\t * Compare two super blocks and set 1 in swp if the secondary\n\t * super block is valid and newer.  Otherwise, set 0 in swp.\n\t */\n\tvalid[0] = nilfs_valid_sb(sbp[0]);\n\tvalid[1] = nilfs_valid_sb(sbp[1]);\n\tswp = valid[1] && (!valid[0] ||\n\t\t\t   le64_to_cpu(sbp[1]->s_last_cno) >\n\t\t\t   le64_to_cpu(sbp[0]->s_last_cno));\n\n\tif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\n\t\tbrelse(sbh[1]);\n\t\tsbh[1] = NULL;\n\t\tsbp[1] = NULL;\n\t\tvalid[1] = 0;\n\t\tswp = 0;\n\t}\n\tif (!valid[swp]) {\n\t\tnilfs_release_super_block(nilfs);\n\t\tprintk(KERN_ERR \"NILFS: Can't find nilfs on dev %s.\\n\",\n\t\t       sb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid[!swp])\n\t\tprintk(KERN_WARNING \"NILFS warning: broken superblock. \"\n\t\t       \"using spare superblock (blocksize = %d).\\n\", blocksize);\n\tif (swp)\n\t\tnilfs_swap_super_block(nilfs);\n\n\tnilfs->ns_sbwcount = 0;\n\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\tnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\n\t*sbpp = sbp[0];\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_swap_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "485-494",
    "snippet": "void nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}"
  },
  {
    "function_name": "nilfs_fall_back_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "476-483",
    "snippet": "void nilfs_fall_back_super_block(struct the_nilfs *nilfs)\n{\n\tbrelse(nilfs->ns_sbh[0]);\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = NULL;\n\tnilfs->ns_sbp[1] = NULL;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nilfs->ns_sbh[0]"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_fall_back_super_block(struct the_nilfs *nilfs)\n{\n\tbrelse(nilfs->ns_sbh[0]);\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = NULL;\n\tnilfs->ns_sbp[1] = NULL;\n}"
  },
  {
    "function_name": "nilfs_release_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "463-474",
    "snippet": "static void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nilfs->ns_sbh[i]"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nilfs_sb2_bad_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "456-461",
    "snippet": "static int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp->s_log_block_size"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp->s_nsegments"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}"
  },
  {
    "function_name": "nilfs_valid_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "436-454",
    "snippet": "static int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp->s_sum"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "(unsigned char *)sbp + sumoff + 4",
            "bytes - sumoff - 4"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "sum",
            "4"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "le32_to_cpu(sbp->s_crc_seed)",
            "(unsigned char *)sbp",
            "sumoff"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp->s_bytes"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}"
  },
  {
    "function_name": "nilfs_store_disk_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "387-434",
    "snippet": "static int nilfs_store_disk_layout(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_super_block *sbp)\n{\n\tif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\n\t\tprintk(KERN_ERR \"NILFS: unsupported revision \"\n\t\t       \"(superblock rev.=%d.%d, current rev.=%d.%d). \"\n\t\t       \"Please check the version of mkfs.nilfs.\\n\",\n\t\t       le32_to_cpu(sbp->s_rev_level),\n\t\t       le16_to_cpu(sbp->s_minor_rev_level),\n\t\t       NILFS_CURRENT_REV, NILFS_MINOR_REV);\n\t\treturn -EINVAL;\n\t}\n\tnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\n\tif (nilfs->ns_sbsize > BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\n\tif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: too large inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: too small inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\n\n\tnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\n\t\tprintk(KERN_ERR \"NILFS: too short segment.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\n\tnilfs->ns_r_segments_percentage =\n\t\tle32_to_cpu(sbp->s_r_segments_percentage);\n\tif (nilfs->ns_r_segments_percentage < 1 ||\n\t    nilfs->ns_r_segments_percentage > 99) {\n\t\tprintk(KERN_ERR \"NILFS: invalid reserved segments percentage.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs_set_nsegments(nilfs, le64_to_cpu(sbp->s_nsegments));\n\tnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp->s_crc_seed"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_nsegments",
          "args": [
            "nilfs",
            "le64_to_cpu(sbp->s_nsegments)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_nsegments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "381-385",
          "snippet": "void nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\tnilfs->ns_nsegments = nsegs;\n\tnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\tnilfs->ns_nsegments = nsegs;\n\tnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp->s_nsegments"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: invalid reserved segments percentage.\\n\""
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp->s_inode_size"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_store_disk_layout(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_super_block *sbp)\n{\n\tif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\n\t\tprintk(KERN_ERR \"NILFS: unsupported revision \"\n\t\t       \"(superblock rev.=%d.%d, current rev.=%d.%d). \"\n\t\t       \"Please check the version of mkfs.nilfs.\\n\",\n\t\t       le32_to_cpu(sbp->s_rev_level),\n\t\t       le16_to_cpu(sbp->s_minor_rev_level),\n\t\t       NILFS_CURRENT_REV, NILFS_MINOR_REV);\n\t\treturn -EINVAL;\n\t}\n\tnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\n\tif (nilfs->ns_sbsize > BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\n\tif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: too large inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: too small inode size: %d bytes.\\n\",\n\t\t       nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\n\n\tnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\n\t\tprintk(KERN_ERR \"NILFS: too short segment.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\n\tnilfs->ns_r_segments_percentage =\n\t\tle32_to_cpu(sbp->s_r_segments_percentage);\n\tif (nilfs->ns_r_segments_percentage < 1 ||\n\t    nilfs->ns_r_segments_percentage > 99) {\n\t\tprintk(KERN_ERR \"NILFS: invalid reserved segments percentage.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs_set_nsegments(nilfs, le64_to_cpu(sbp->s_nsegments));\n\tnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_set_nsegments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "381-385",
    "snippet": "void nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\tnilfs->ns_nsegments = nsegs;\n\tnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_nrsvsegs",
          "args": [
            "nilfs",
            "nsegs"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_nrsvsegs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "374-379",
          "snippet": "unsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\treturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\n\t\t     DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100));\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nunsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\treturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\n\t\t     DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\tnilfs->ns_nsegments = nsegs;\n\tnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\n}"
  },
  {
    "function_name": "nilfs_nrsvsegs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "374-379",
    "snippet": "unsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\treturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\n\t\t     DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "NILFS_MIN_NRSVSEGS",
            "DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nsegs * nilfs->ns_r_segments_percentage",
            "100"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nunsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\treturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\n\t\t     DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100));\n}"
  },
  {
    "function_name": "nilfs_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "358-367",
    "snippet": "static unsigned long long nilfs_max_size(unsigned int blkbits)\n{\n\tunsigned int max_bits;\n\tunsigned long long res = MAX_LFS_FILESIZE; /* page cache limit */\n\n\tmax_bits = blkbits + NILFS_BMAP_KEY_BIT; /* bmap size limit */\n\tif (max_bits < 64)\n\t\tres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\n\treturn res;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong long",
            "res",
            "(1ULL << max_bits) - 1"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic unsigned long long nilfs_max_size(unsigned int blkbits)\n{\n\tunsigned int max_bits;\n\tunsigned long long res = MAX_LFS_FILESIZE; /* page cache limit */\n\n\tmax_bits = blkbits + NILFS_BMAP_KEY_BIT; /* bmap size limit */\n\tif (max_bits < 64)\n\t\tres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\n\treturn res;\n}"
  },
  {
    "function_name": "load_nilfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "213-356",
    "snippet": "int load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\n{\n\tstruct nilfs_recovery_info ri;\n\tunsigned int s_flags = sb->s_flags;\n\tint really_read_only = bdev_read_only(nilfs->ns_bdev);\n\tint valid_fs = nilfs_valid_fs(nilfs);\n\tint err;\n\n\tif (!valid_fs) {\n\t\tprintk(KERN_WARNING \"NILFS warning: mounting unchecked fs\\n\");\n\t\tif (s_flags & MS_RDONLY) {\n\t\t\tprintk(KERN_INFO \"NILFS: INFO: recovery \"\n\t\t\t       \"required for readonly filesystem.\\n\");\n\t\t\tprintk(KERN_INFO \"NILFS: write access will \"\n\t\t\t       \"be enabled during recovery.\\n\");\n\t\t}\n\t}\n\n\tnilfs_init_recovery_info(&ri);\n\n\terr = nilfs_search_super_root(nilfs, &ri);\n\tif (unlikely(err)) {\n\t\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\t\tint blocksize;\n\n\t\tif (err != -EINVAL)\n\t\t\tgoto scan_error;\n\n\t\tif (!nilfs_valid_sb(sbp[1])) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: unable to fall back to spare\"\n\t\t\t       \"super block\\n\");\n\t\t\tgoto scan_error;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"NILFS: try rollback from an earlier position\\n\");\n\n\t\t/*\n\t\t * restore super block with its spare and reconfigure\n\t\t * relevant states of the nilfs object.\n\t\t */\n\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\tnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\n\t\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\n\t\t/* verify consistency between two super blocks */\n\t\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp[0]->s_log_block_size);\n\t\tif (blocksize != nilfs->ns_blocksize) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: blocksize differs between \"\n\t\t\t       \"two super blocks (%d != %d)\\n\",\n\t\t\t       blocksize, nilfs->ns_blocksize);\n\t\t\tgoto scan_error;\n\t\t}\n\n\t\terr = nilfs_store_log_cursor(nilfs, sbp[0]);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\t/* drop clean flag to allow roll-forward and recovery */\n\t\tnilfs->ns_mount_state &= ~NILFS_VALID_FS;\n\t\tvalid_fs = 0;\n\n\t\terr = nilfs_search_super_root(nilfs, &ri);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\t}\n\n\terr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: error loading super root.\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (valid_fs)\n\t\tgoto skip_recovery;\n\n\tif (s_flags & MS_RDONLY) {\n\t\t__u64 features;\n\n\t\tif (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\t\tprintk(KERN_INFO \"NILFS: norecovery option specified. \"\n\t\t\t       \"skipping roll-forward recovery\\n\");\n\t\t\tgoto skip_recovery;\n\t\t}\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tif (features) {\n\t\t\tprintk(KERN_ERR \"NILFS: couldn't proceed with \"\n\t\t\t       \"recovery because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tif (really_read_only) {\n\t\t\tprintk(KERN_ERR \"NILFS: write access \"\n\t\t\t       \"unavailable, cannot proceed.\\n\");\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\tprintk(KERN_ERR \"NILFS: recovery cancelled because norecovery \"\n\t\t       \"option was specified for a read/write mount\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failed_unload;\n\t}\n\n\terr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\n\tif (err)\n\t\tgoto failed_unload;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_mount_state |= NILFS_VALID_FS; /* set \"clean\" flag */\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: failed to update super block. \"\n\t\t       \"recovery unfinished.\\n\");\n\t\tgoto failed_unload;\n\t}\n\tprintk(KERN_INFO \"NILFS: recovery complete.\\n\");\n\n skip_recovery:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn 0;\n\n scan_error:\n\tprintk(KERN_ERR \"NILFS: error searching super root.\\n\");\n\tgoto failed;\n\n failed_unload:\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_dat);\n\n failed:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_clear_recovery_info",
          "args": [
            "&ri"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_recovery_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "168-171",
          "snippet": "static void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tnilfs_dispose_segment_list(&ri->ri_used_segments);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tnilfs_dispose_segment_list(&ri->ri_used_segments);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: error searching super root.\\n\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cleanup_super",
          "args": [
            "sb"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cleanup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "327-350",
          "snippet": "int nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_salvage_orphan_logs",
          "args": [
            "nilfs",
            "sb",
            "&ri"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_salvage_orphan_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "744-793",
          "snippet": "int nilfs_salvage_orphan_logs(struct the_nilfs *nilfs,\n\t\t\t      struct super_block *sb,\n\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct nilfs_root *root;\n\tint err;\n\n\tif (ri->ri_lsegs_start == 0 || ri->ri_lsegs_end == 0)\n\t\treturn 0;\n\n\terr = nilfs_attach_checkpoint(sb, ri->ri_cno, true, &root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: error loading the latest checkpoint.\\n\");\n\t\treturn err;\n\t}\n\n\terr = nilfs_do_roll_forward(nilfs, sb, root, ri);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (ri->ri_need_recovery == NILFS_RECOVERY_ROLLFORWARD_DONE) {\n\t\terr = nilfs_prepare_segment_for_recovery(nilfs, sb, ri);\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Error preparing segments for \"\n\t\t\t       \"recovery.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tset_nilfs_discontinued(nilfs);\n\t\terr = nilfs_construct_segment(sb);\n\t\tnilfs_detach_log_writer(sb);\n\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Oops! recovery failed. \"\n\t\t\t       \"(err=%d)\\n\", err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnilfs_finish_roll_forward(nilfs, ri);\n\t}\n\n failed:\n\tnilfs_put_root(root);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_salvage_orphan_logs(struct the_nilfs *nilfs,\n\t\t\t      struct super_block *sb,\n\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct nilfs_root *root;\n\tint err;\n\n\tif (ri->ri_lsegs_start == 0 || ri->ri_lsegs_end == 0)\n\t\treturn 0;\n\n\terr = nilfs_attach_checkpoint(sb, ri->ri_cno, true, &root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: error loading the latest checkpoint.\\n\");\n\t\treturn err;\n\t}\n\n\terr = nilfs_do_roll_forward(nilfs, sb, root, ri);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (ri->ri_need_recovery == NILFS_RECOVERY_ROLLFORWARD_DONE) {\n\t\terr = nilfs_prepare_segment_for_recovery(nilfs, sb, ri);\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Error preparing segments for \"\n\t\t\t       \"recovery.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tset_nilfs_discontinued(nilfs);\n\t\terr = nilfs_construct_segment(sb);\n\t\tnilfs_detach_log_writer(sb);\n\n\t\tif (unlikely(err)) {\n\t\t\tprintk(KERN_ERR \"NILFS: Oops! recovery failed. \"\n\t\t\t       \"(err=%d)\\n\", err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnilfs_finish_roll_forward(nilfs, ri);\n\t}\n\n failed:\n\tnilfs_put_root(root);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "NORECOVERY"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "nilfs->ns_sbp[0]->s_feature_compat_ro"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "NORECOVERY"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_load_super_root",
          "args": [
            "nilfs",
            "sb",
            "ri.ri_super_root"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_load_super_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "108-160",
          "snippet": "static int nilfs_load_super_root(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb, sector_t sr_block)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct nilfs_inode *rawi;\n\tunsigned dat_entry_size, segment_usage_size, checkpoint_size;\n\tunsigned inode_size;\n\tint err;\n\n\terr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdown_read(&nilfs->ns_sem);\n\tdat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\n\tcheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\n\tsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\n\tup_read(&nilfs->ns_sem);\n\n\tinode_size = nilfs->ns_inode_size;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\n\terr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\n\tif (err)\n\t\tgoto failed;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\n\terr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\n\tif (err)\n\t\tgoto failed_dat;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\n\terr = nilfs_sufile_read(sb, segment_usage_size, rawi,\n\t\t\t\t&nilfs->ns_sufile);\n\tif (err)\n\t\tgoto failed_cpfile;\n\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\n\n failed:\n\tbrelse(bh_sr);\n\treturn err;\n\n failed_cpfile:\n\tiput(nilfs->ns_cpfile);\n\n failed_dat:\n\tiput(nilfs->ns_dat);\n\tgoto failed;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_load_super_root(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb, sector_t sr_block)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct nilfs_inode *rawi;\n\tunsigned dat_entry_size, segment_usage_size, checkpoint_size;\n\tunsigned inode_size;\n\tint err;\n\n\terr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdown_read(&nilfs->ns_sem);\n\tdat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\n\tcheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\n\tsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\n\tup_read(&nilfs->ns_sem);\n\n\tinode_size = nilfs->ns_inode_size;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\n\terr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\n\tif (err)\n\t\tgoto failed;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\n\terr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\n\tif (err)\n\t\tgoto failed_dat;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\n\terr = nilfs_sufile_read(sb, segment_usage_size, rawi,\n\t\t\t\t&nilfs->ns_sufile);\n\tif (err)\n\t\tgoto failed_cpfile;\n\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\n\n failed:\n\tbrelse(bh_sr);\n\treturn err;\n\n failed_cpfile:\n\tiput(nilfs->ns_cpfile);\n\n failed_dat:\n\tiput(nilfs->ns_dat);\n\tgoto failed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_search_super_root",
          "args": [
            "nilfs",
            "&ri"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_search_super_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "813-964",
          "snippet": "int nilfs_search_super_root(struct the_nilfs *nilfs,\n\t\t\t    struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start, pseg_end, sr_pseg_start = 0;\n\tsector_t seg_start, seg_end; /* range of full segment (block number) */\n\tsector_t b, end;\n\tunsigned long nblocks;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\t__u64 cno;\n\tLIST_HEAD(segments);\n\tint empty_seg = 0, scan_newer = 0;\n\tint ret;\n\n\tpseg_start = nilfs->ns_last_pseg;\n\tseg_seq = nilfs->ns_last_seq;\n\tcno = nilfs->ns_last_cno;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\n\t/* Calculate range of segment */\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\t/* Read ahead segment */\n\tb = seg_start;\n\twhile (b <= seg_end)\n\t\t__breadahead(nilfs->ns_bdev, b++, nilfs->ns_blocksize);\n\n\tfor (;;) {\n\t\tbrelse(bh_sum);\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum)\n\t\t\tgoto failed;\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO)\n\t\t\t\tgoto failed;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tnblocks = le32_to_cpu(sum->ss_nblocks);\n\t\tpseg_end = pseg_start + nblocks - 1;\n\t\tif (unlikely(pseg_end > seg_end)) {\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\t/* A valid partial segment */\n\t\tri->ri_pseg_start = pseg_start;\n\t\tri->ri_seq = seg_seq;\n\t\tri->ri_segnum = segnum;\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tri->ri_nextnum = nextnum;\n\t\tempty_seg = 0;\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (!(flags & NILFS_SS_SR) && !scan_newer) {\n\t\t\t/* This will never happen because a superblock\n\t\t\t   (last_segment) always points to a pseg\n\t\t\t   having a super root. */\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (pseg_start == seg_start) {\n\t\t\tnilfs_get_segment_range(nilfs, nextnum, &b, &end);\n\t\t\twhile (b <= end)\n\t\t\t\t__breadahead(nilfs->ns_bdev, b++,\n\t\t\t\t\t     nilfs->ns_blocksize);\n\t\t}\n\t\tif (!(flags & NILFS_SS_SR)) {\n\t\t\tif (!ri->ri_lsegs_start && (flags & NILFS_SS_LOGBGN)) {\n\t\t\t\tri->ri_lsegs_start = pseg_start;\n\t\t\t\tri->ri_lsegs_start_seq = seg_seq;\n\t\t\t}\n\t\t\tif (flags & NILFS_SS_LOGEND)\n\t\t\t\tri->ri_lsegs_end = pseg_start;\n\t\t\tgoto try_next_pseg;\n\t\t}\n\n\t\t/* A valid super root was found. */\n\t\tri->ri_cno = cno++;\n\t\tri->ri_super_root = pseg_end;\n\t\tri->ri_lsegs_start = ri->ri_lsegs_end = 0;\n\n\t\tnilfs_dispose_segment_list(&segments);\n\t\tsr_pseg_start = pseg_start;\n\t\tnilfs->ns_pseg_offset = pseg_start + nblocks - seg_start;\n\t\tnilfs->ns_seg_seq = seg_seq;\n\t\tnilfs->ns_segnum = segnum;\n\t\tnilfs->ns_cno = cno;  /* nilfs->ns_cno = ri->ri_cno + 1 */\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tnilfs->ns_nextnum = nextnum;\n\n\t\tif (scan_newer)\n\t\t\tri->ri_need_recovery = NILFS_RECOVERY_SR_UPDATED;\n\t\telse {\n\t\t\tif (nilfs->ns_mount_state & NILFS_VALID_FS)\n\t\t\t\tgoto super_root_found;\n\t\t\tscan_newer = 1;\n\t\t}\n\n try_next_pseg:\n\t\t/* Standing on a course, or met an inconsistent state */\n\t\tpseg_start += nblocks;\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\t/* Off the trail */\n\t\tif (!scan_newer)\n\t\t\t/*\n\t\t\t * This can happen if a checkpoint was written without\n\t\t\t * barriers, or as a result of an I/O failure.\n\t\t\t */\n\t\t\tgoto failed;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tgoto super_root_found; /* found a valid super root */\n\n\t\tret = nilfs_segment_list_add(&segments, segnum);\n\t\tif (unlikely(ret))\n\t\t\tgoto failed;\n\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n super_root_found:\n\t/* Updating pointers relating to the latest checkpoint */\n\tbrelse(bh_sum);\n\tlist_splice_tail(&segments, &ri->ri_used_segments);\n\tnilfs->ns_last_pseg = sr_pseg_start;\n\tnilfs->ns_last_seq = nilfs->ns_seg_seq;\n\tnilfs->ns_last_cno = ri->ri_cno;\n\treturn 0;\n\n failed:\n\tbrelse(bh_sum);\n\tnilfs_dispose_segment_list(&segments);\n\treturn (ret < 0) ? ret : nilfs_warn_segment_error(ret);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_search_super_root(struct the_nilfs *nilfs,\n\t\t\t    struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum;\n\tsector_t pseg_start, pseg_end, sr_pseg_start = 0;\n\tsector_t seg_start, seg_end; /* range of full segment (block number) */\n\tsector_t b, end;\n\tunsigned long nblocks;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\t__u64 cno;\n\tLIST_HEAD(segments);\n\tint empty_seg = 0, scan_newer = 0;\n\tint ret;\n\n\tpseg_start = nilfs->ns_last_pseg;\n\tseg_seq = nilfs->ns_last_seq;\n\tcno = nilfs->ns_last_cno;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\n\t/* Calculate range of segment */\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\t/* Read ahead segment */\n\tb = seg_start;\n\twhile (b <= seg_end)\n\t\t__breadahead(nilfs->ns_bdev, b++, nilfs->ns_blocksize);\n\n\tfor (;;) {\n\t\tbrelse(bh_sum);\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum)\n\t\t\tgoto failed;\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO)\n\t\t\t\tgoto failed;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tnblocks = le32_to_cpu(sum->ss_nblocks);\n\t\tpseg_end = pseg_start + nblocks - 1;\n\t\tif (unlikely(pseg_end > seg_end)) {\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\t/* A valid partial segment */\n\t\tri->ri_pseg_start = pseg_start;\n\t\tri->ri_seq = seg_seq;\n\t\tri->ri_segnum = segnum;\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tri->ri_nextnum = nextnum;\n\t\tempty_seg = 0;\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (!(flags & NILFS_SS_SR) && !scan_newer) {\n\t\t\t/* This will never happen because a superblock\n\t\t\t   (last_segment) always points to a pseg\n\t\t\t   having a super root. */\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (pseg_start == seg_start) {\n\t\t\tnilfs_get_segment_range(nilfs, nextnum, &b, &end);\n\t\t\twhile (b <= end)\n\t\t\t\t__breadahead(nilfs->ns_bdev, b++,\n\t\t\t\t\t     nilfs->ns_blocksize);\n\t\t}\n\t\tif (!(flags & NILFS_SS_SR)) {\n\t\t\tif (!ri->ri_lsegs_start && (flags & NILFS_SS_LOGBGN)) {\n\t\t\t\tri->ri_lsegs_start = pseg_start;\n\t\t\t\tri->ri_lsegs_start_seq = seg_seq;\n\t\t\t}\n\t\t\tif (flags & NILFS_SS_LOGEND)\n\t\t\t\tri->ri_lsegs_end = pseg_start;\n\t\t\tgoto try_next_pseg;\n\t\t}\n\n\t\t/* A valid super root was found. */\n\t\tri->ri_cno = cno++;\n\t\tri->ri_super_root = pseg_end;\n\t\tri->ri_lsegs_start = ri->ri_lsegs_end = 0;\n\n\t\tnilfs_dispose_segment_list(&segments);\n\t\tsr_pseg_start = pseg_start;\n\t\tnilfs->ns_pseg_offset = pseg_start + nblocks - seg_start;\n\t\tnilfs->ns_seg_seq = seg_seq;\n\t\tnilfs->ns_segnum = segnum;\n\t\tnilfs->ns_cno = cno;  /* nilfs->ns_cno = ri->ri_cno + 1 */\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tnilfs->ns_nextnum = nextnum;\n\n\t\tif (scan_newer)\n\t\t\tri->ri_need_recovery = NILFS_RECOVERY_SR_UPDATED;\n\t\telse {\n\t\t\tif (nilfs->ns_mount_state & NILFS_VALID_FS)\n\t\t\t\tgoto super_root_found;\n\t\t\tscan_newer = 1;\n\t\t}\n\n try_next_pseg:\n\t\t/* Standing on a course, or met an inconsistent state */\n\t\tpseg_start += nblocks;\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\t/* Off the trail */\n\t\tif (!scan_newer)\n\t\t\t/*\n\t\t\t * This can happen if a checkpoint was written without\n\t\t\t * barriers, or as a result of an I/O failure.\n\t\t\t */\n\t\t\tgoto failed;\n\n feed_segment:\n\t\t/* Looking to the next full segment */\n\t\tif (empty_seg++)\n\t\t\tgoto super_root_found; /* found a valid super root */\n\n\t\tret = nilfs_segment_list_add(&segments, segnum);\n\t\tif (unlikely(ret))\n\t\t\tgoto failed;\n\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n super_root_found:\n\t/* Updating pointers relating to the latest checkpoint */\n\tbrelse(bh_sum);\n\tlist_splice_tail(&segments, &ri->ri_used_segments);\n\tnilfs->ns_last_pseg = sr_pseg_start;\n\tnilfs->ns_last_seq = nilfs->ns_seg_seq;\n\tnilfs->ns_last_cno = ri->ri_cno;\n\treturn 0;\n\n failed:\n\tbrelse(bh_sum);\n\tnilfs_dispose_segment_list(&segments);\n\treturn (ret < 0) ? ret : nilfs_warn_segment_error(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_store_log_cursor",
          "args": [
            "nilfs",
            "sbp[0]"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_store_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "183-202",
          "snippet": "static int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp[0]->s_log_block_size"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbp[0]",
            "sbp[1]",
            "nilfs->ns_sbsize"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_valid_sb",
          "args": [
            "sbp[1]"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_valid_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "436-454",
          "snippet": "static int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_init_recovery_info",
          "args": [
            "&ri"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_init_recovery_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "162-166",
          "snippet": "static void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_valid_fs",
          "args": [
            "nilfs"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_valid_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "309-317",
          "snippet": "static inline int nilfs_valid_fs(struct the_nilfs *nilfs)\n{\n\tunsigned valid_fs;\n\n\tdown_read(&nilfs->ns_sem);\n\tvalid_fs = (nilfs->ns_mount_state & NILFS_VALID_FS);\n\tup_read(&nilfs->ns_sem);\n\treturn valid_fs;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_valid_fs(struct the_nilfs *nilfs)\n{\n\tunsigned valid_fs;\n\n\tdown_read(&nilfs->ns_sem);\n\tvalid_fs = (nilfs->ns_mount_state & NILFS_VALID_FS);\n\tup_read(&nilfs->ns_sem);\n\treturn valid_fs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "nilfs->ns_bdev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nint load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\n{\n\tstruct nilfs_recovery_info ri;\n\tunsigned int s_flags = sb->s_flags;\n\tint really_read_only = bdev_read_only(nilfs->ns_bdev);\n\tint valid_fs = nilfs_valid_fs(nilfs);\n\tint err;\n\n\tif (!valid_fs) {\n\t\tprintk(KERN_WARNING \"NILFS warning: mounting unchecked fs\\n\");\n\t\tif (s_flags & MS_RDONLY) {\n\t\t\tprintk(KERN_INFO \"NILFS: INFO: recovery \"\n\t\t\t       \"required for readonly filesystem.\\n\");\n\t\t\tprintk(KERN_INFO \"NILFS: write access will \"\n\t\t\t       \"be enabled during recovery.\\n\");\n\t\t}\n\t}\n\n\tnilfs_init_recovery_info(&ri);\n\n\terr = nilfs_search_super_root(nilfs, &ri);\n\tif (unlikely(err)) {\n\t\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\t\tint blocksize;\n\n\t\tif (err != -EINVAL)\n\t\t\tgoto scan_error;\n\n\t\tif (!nilfs_valid_sb(sbp[1])) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: unable to fall back to spare\"\n\t\t\t       \"super block\\n\");\n\t\t\tgoto scan_error;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"NILFS: try rollback from an earlier position\\n\");\n\n\t\t/*\n\t\t * restore super block with its spare and reconfigure\n\t\t * relevant states of the nilfs object.\n\t\t */\n\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\tnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\n\t\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\n\t\t/* verify consistency between two super blocks */\n\t\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp[0]->s_log_block_size);\n\t\tif (blocksize != nilfs->ns_blocksize) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: blocksize differs between \"\n\t\t\t       \"two super blocks (%d != %d)\\n\",\n\t\t\t       blocksize, nilfs->ns_blocksize);\n\t\t\tgoto scan_error;\n\t\t}\n\n\t\terr = nilfs_store_log_cursor(nilfs, sbp[0]);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\t/* drop clean flag to allow roll-forward and recovery */\n\t\tnilfs->ns_mount_state &= ~NILFS_VALID_FS;\n\t\tvalid_fs = 0;\n\n\t\terr = nilfs_search_super_root(nilfs, &ri);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\t}\n\n\terr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: error loading super root.\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (valid_fs)\n\t\tgoto skip_recovery;\n\n\tif (s_flags & MS_RDONLY) {\n\t\t__u64 features;\n\n\t\tif (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\t\tprintk(KERN_INFO \"NILFS: norecovery option specified. \"\n\t\t\t       \"skipping roll-forward recovery\\n\");\n\t\t\tgoto skip_recovery;\n\t\t}\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tif (features) {\n\t\t\tprintk(KERN_ERR \"NILFS: couldn't proceed with \"\n\t\t\t       \"recovery because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tif (really_read_only) {\n\t\t\tprintk(KERN_ERR \"NILFS: write access \"\n\t\t\t       \"unavailable, cannot proceed.\\n\");\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\tprintk(KERN_ERR \"NILFS: recovery cancelled because norecovery \"\n\t\t       \"option was specified for a read/write mount\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failed_unload;\n\t}\n\n\terr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\n\tif (err)\n\t\tgoto failed_unload;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_mount_state |= NILFS_VALID_FS; /* set \"clean\" flag */\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: failed to update super block. \"\n\t\t       \"recovery unfinished.\\n\");\n\t\tgoto failed_unload;\n\t}\n\tprintk(KERN_INFO \"NILFS: recovery complete.\\n\");\n\n skip_recovery:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn 0;\n\n scan_error:\n\tprintk(KERN_ERR \"NILFS: error searching super root.\\n\");\n\tgoto failed;\n\n failed_unload:\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_dat);\n\n failed:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_store_log_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "183-202",
    "snippet": "static int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS invalid last segment number.\\n\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_segnum_of_block",
          "args": [
            "nilfs",
            "nilfs->ns_last_pseg"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_segnum_of_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "336-343",
          "snippet": "static inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp->s_last_seq"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tprintk(KERN_ERR \"NILFS invalid last segment number.\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_clear_recovery_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "168-171",
    "snippet": "static void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tnilfs_dispose_segment_list(&ri->ri_used_segments);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_dispose_segment_list",
          "args": [
            "&ri->ri_used_segments"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dispose_segment_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "416-425",
          "snippet": "void nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tnilfs_dispose_segment_list(&ri->ri_used_segments);\n}"
  },
  {
    "function_name": "nilfs_init_recovery_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "162-166",
    "snippet": "static void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ri->ri_used_segments"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ri",
            "0",
            "sizeof(*ri)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}"
  },
  {
    "function_name": "nilfs_load_super_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "108-160",
    "snippet": "static int nilfs_load_super_root(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb, sector_t sr_block)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct nilfs_inode *rawi;\n\tunsigned dat_entry_size, segment_usage_size, checkpoint_size;\n\tunsigned inode_size;\n\tint err;\n\n\terr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdown_read(&nilfs->ns_sem);\n\tdat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\n\tcheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\n\tsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\n\tup_read(&nilfs->ns_sem);\n\n\tinode_size = nilfs->ns_inode_size;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\n\terr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\n\tif (err)\n\t\tgoto failed;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\n\terr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\n\tif (err)\n\t\tgoto failed_dat;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\n\terr = nilfs_sufile_read(sb, segment_usage_size, rawi,\n\t\t\t\t&nilfs->ns_sufile);\n\tif (err)\n\t\tgoto failed_cpfile;\n\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\n\n failed:\n\tbrelse(bh_sr);\n\treturn err;\n\n failed_cpfile:\n\tiput(nilfs->ns_cpfile);\n\n failed_dat:\n\tiput(nilfs->ns_dat);\n\tgoto failed;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_sr"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "raw_sr->sr_nongc_ctime"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_read",
          "args": [
            "sb",
            "segment_usage_size",
            "rawi",
            "&nilfs->ns_sufile"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "1162-1222",
          "snippet": "int nilfs_sufile_read(struct super_block *sb, size_t susize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *sufile;\n\tstruct nilfs_sufile_info *sui;\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tvoid *kaddr;\n\tint err;\n\n\tif (susize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large segment usage size: %zu bytes.\\n\",\n\t\t       susize);\n\t\treturn -EINVAL;\n\t} else if (susize < NILFS_MIN_SEGMENT_USAGE_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small segment usage size: %zu bytes.\\n\",\n\t\t       susize);\n\t\treturn -EINVAL;\n\t}\n\n\tsufile = nilfs_iget_locked(sb, NULL, NILFS_SUFILE_INO);\n\tif (unlikely(!sufile))\n\t\treturn -ENOMEM;\n\tif (!(sufile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(sufile, NILFS_MDT_GFP, sizeof(*sui));\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(sufile, susize,\n\t\t\t\t sizeof(struct nilfs_sufile_header));\n\n\terr = nilfs_read_inode_common(sufile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (err)\n\t\tgoto failed;\n\n\tsui = NILFS_SUI(sufile);\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tsui->ncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tkunmap_atomic(kaddr);\n\tbrelse(header_bh);\n\n\tsui->allocmax = nilfs_sufile_get_nsegments(sufile) - 1;\n\tsui->allocmin = 0;\n\n\tunlock_new_inode(sufile);\n out:\n\t*inodep = sufile;\n\treturn 0;\n failed:\n\tiget_failed(sufile);\n\treturn err;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_read(struct super_block *sb, size_t susize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *sufile;\n\tstruct nilfs_sufile_info *sui;\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tvoid *kaddr;\n\tint err;\n\n\tif (susize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large segment usage size: %zu bytes.\\n\",\n\t\t       susize);\n\t\treturn -EINVAL;\n\t} else if (susize < NILFS_MIN_SEGMENT_USAGE_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small segment usage size: %zu bytes.\\n\",\n\t\t       susize);\n\t\treturn -EINVAL;\n\t}\n\n\tsufile = nilfs_iget_locked(sb, NULL, NILFS_SUFILE_INO);\n\tif (unlikely(!sufile))\n\t\treturn -ENOMEM;\n\tif (!(sufile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(sufile, NILFS_MDT_GFP, sizeof(*sui));\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(sufile, susize,\n\t\t\t\t sizeof(struct nilfs_sufile_header));\n\n\terr = nilfs_read_inode_common(sufile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (err)\n\t\tgoto failed;\n\n\tsui = NILFS_SUI(sufile);\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tsui->ncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tkunmap_atomic(kaddr);\n\tbrelse(header_bh);\n\n\tsui->allocmax = nilfs_sufile_get_nsegments(sufile) - 1;\n\tsui->allocmin = 0;\n\n\tunlock_new_inode(sufile);\n out:\n\t*inodep = sufile;\n\treturn 0;\n failed:\n\tiget_failed(sufile);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_SR_SUFILE_OFFSET",
          "args": [
            "inode_size"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_read",
          "args": [
            "sb",
            "checkpoint_size",
            "rawi",
            "&nilfs->ns_cpfile"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "939-981",
          "snippet": "int nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *cpfile;\n\tint err;\n\n\tif (cpsize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t} else if (cpsize < NILFS_MIN_CHECKPOINT_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t}\n\n\tcpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\n\tif (unlikely(!cpfile))\n\t\treturn -ENOMEM;\n\tif (!(cpfile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(cpfile, cpsize,\n\t\t\t\t sizeof(struct nilfs_cpfile_header));\n\n\terr = nilfs_read_inode_common(cpfile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(cpfile);\n out:\n\t*inodep = cpfile;\n\treturn 0;\n failed:\n\tiget_failed(cpfile);\n\treturn err;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *cpfile;\n\tint err;\n\n\tif (cpsize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t} else if (cpsize < NILFS_MIN_CHECKPOINT_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t}\n\n\tcpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\n\tif (unlikely(!cpfile))\n\t\treturn -ENOMEM;\n\tif (!(cpfile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(cpfile, cpsize,\n\t\t\t\t sizeof(struct nilfs_cpfile_header));\n\n\terr = nilfs_read_inode_common(cpfile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(cpfile);\n out:\n\t*inodep = cpfile;\n\treturn 0;\n failed:\n\tiget_failed(cpfile);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_SR_CPFILE_OFFSET",
          "args": [
            "inode_size"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_dat_read",
          "args": [
            "sb",
            "dat_entry_size",
            "rawi",
            "&nilfs->ns_dat"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dat_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/dat.c",
          "lines": "479-529",
          "snippet": "int nilfs_dat_read(struct super_block *sb, size_t entry_size,\n\t\t   struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstatic struct lock_class_key dat_lock_key;\n\tstruct inode *dat;\n\tstruct nilfs_dat_info *di;\n\tint err;\n\n\tif (entry_size > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large DAT entry size: %zu bytes.\\n\",\n\t\t       entry_size);\n\t\treturn -EINVAL;\n\t} else if (entry_size < NILFS_MIN_DAT_ENTRY_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small DAT entry size: %zu bytes.\\n\",\n\t\t       entry_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdat = nilfs_iget_locked(sb, NULL, NILFS_DAT_INO);\n\tif (unlikely(!dat))\n\t\treturn -ENOMEM;\n\tif (!(dat->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(dat, NILFS_MDT_GFP, sizeof(*di));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(dat, entry_size);\n\tif (err)\n\t\tgoto failed;\n\n\tdi = NILFS_DAT_I(dat);\n\tlockdep_set_class(&di->mi.mi_sem, &dat_lock_key);\n\tnilfs_palloc_setup_cache(dat, &di->palloc_cache);\n\tnilfs_mdt_setup_shadow_map(dat, &di->shadow);\n\n\terr = nilfs_read_inode_common(dat, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(dat);\n out:\n\t*inodep = dat;\n\treturn 0;\n failed:\n\tiget_failed(dat);\n\treturn err;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_dat_read(struct super_block *sb, size_t entry_size,\n\t\t   struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstatic struct lock_class_key dat_lock_key;\n\tstruct inode *dat;\n\tstruct nilfs_dat_info *di;\n\tint err;\n\n\tif (entry_size > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large DAT entry size: %zu bytes.\\n\",\n\t\t       entry_size);\n\t\treturn -EINVAL;\n\t} else if (entry_size < NILFS_MIN_DAT_ENTRY_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small DAT entry size: %zu bytes.\\n\",\n\t\t       entry_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdat = nilfs_iget_locked(sb, NULL, NILFS_DAT_INO);\n\tif (unlikely(!dat))\n\t\treturn -ENOMEM;\n\tif (!(dat->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(dat, NILFS_MDT_GFP, sizeof(*di));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(dat, entry_size);\n\tif (err)\n\t\tgoto failed;\n\n\tdi = NILFS_DAT_I(dat);\n\tlockdep_set_class(&di->mi.mi_sem, &dat_lock_key);\n\tnilfs_palloc_setup_cache(dat, &di->palloc_cache);\n\tnilfs_mdt_setup_shadow_map(dat, &di->shadow);\n\n\terr = nilfs_read_inode_common(dat, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(dat);\n out:\n\t*inodep = dat;\n\treturn 0;\n failed:\n\tiget_failed(dat);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_SR_DAT_OFFSET",
          "args": [
            "inode_size"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp[0]->s_segment_usage_size"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_read_super_root_block",
          "args": [
            "nilfs",
            "sr_block",
            "&bh_sr",
            "1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_super_root_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "142-184",
          "snippet": "int nilfs_read_super_root_block(struct the_nilfs *nilfs, sector_t sr_block,\n\t\t\t\tstruct buffer_head **pbh, int check)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *sr;\n\tu32 crc;\n\tint ret;\n\n\t*pbh = NULL;\n\tbh_sr = __bread(nilfs->ns_bdev, sr_block, nilfs->ns_blocksize);\n\tif (unlikely(!bh_sr)) {\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tgoto failed;\n\t}\n\n\tsr = (struct nilfs_super_root *)bh_sr->b_data;\n\tif (check) {\n\t\tunsigned bytes = le16_to_cpu(sr->sr_bytes);\n\n\t\tif (bytes == 0 || bytes > nilfs->ns_blocksize) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (nilfs_compute_checksum(\n\t\t\t    nilfs, bh_sr, &crc, sizeof(sr->sr_sum), bytes,\n\t\t\t    sr_block, 1)) {\n\t\t\tret = NILFS_SEG_FAIL_IO;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (crc != le32_to_cpu(sr->sr_sum)) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t}\n\t*pbh = bh_sr;\n\treturn 0;\n\n failed_bh:\n\tbrelse(bh_sr);\n\n failed:\n\treturn nilfs_warn_segment_error(ret);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_super_root_block(struct the_nilfs *nilfs, sector_t sr_block,\n\t\t\t\tstruct buffer_head **pbh, int check)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *sr;\n\tu32 crc;\n\tint ret;\n\n\t*pbh = NULL;\n\tbh_sr = __bread(nilfs->ns_bdev, sr_block, nilfs->ns_blocksize);\n\tif (unlikely(!bh_sr)) {\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tgoto failed;\n\t}\n\n\tsr = (struct nilfs_super_root *)bh_sr->b_data;\n\tif (check) {\n\t\tunsigned bytes = le16_to_cpu(sr->sr_bytes);\n\n\t\tif (bytes == 0 || bytes > nilfs->ns_blocksize) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (nilfs_compute_checksum(\n\t\t\t    nilfs, bh_sr, &crc, sizeof(sr->sr_sum), bytes,\n\t\t\t    sr_block, 1)) {\n\t\t\tret = NILFS_SEG_FAIL_IO;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (crc != le32_to_cpu(sr->sr_sum)) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t}\n\t*pbh = bh_sr;\n\treturn 0;\n\n failed_bh:\n\tbrelse(bh_sr);\n\n failed:\n\treturn nilfs_warn_segment_error(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_load_super_root(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb, sector_t sr_block)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct nilfs_inode *rawi;\n\tunsigned dat_entry_size, segment_usage_size, checkpoint_size;\n\tunsigned inode_size;\n\tint err;\n\n\terr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdown_read(&nilfs->ns_sem);\n\tdat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\n\tcheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\n\tsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\n\tup_read(&nilfs->ns_sem);\n\n\tinode_size = nilfs->ns_inode_size;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\n\terr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\n\tif (err)\n\t\tgoto failed;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\n\terr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\n\tif (err)\n\t\tgoto failed_dat;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\n\terr = nilfs_sufile_read(sb, segment_usage_size, rawi,\n\t\t\t\t&nilfs->ns_sufile);\n\tif (err)\n\t\tgoto failed_cpfile;\n\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\n\n failed:\n\tbrelse(bh_sr);\n\treturn err;\n\n failed_cpfile:\n\tiput(nilfs->ns_cpfile);\n\n failed_dat:\n\tiput(nilfs->ns_dat);\n\tgoto failed;\n}"
  },
  {
    "function_name": "destroy_nilfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "97-106",
    "snippet": "void destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nilfs"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nilfs->ns_sbh[1]"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_delete_device_group",
          "args": [
            "nilfs"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_delete_device_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "1057-1066",
          "snippet": "void nilfs_sysfs_delete_device_group(struct the_nilfs *nilfs)\n{\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\tnilfs_sysfs_delete_segctor_group(nilfs);\n\tkobject_del(&nilfs->ns_dev_kobj);\n\tkfree(nilfs->ns_dev_subgroups);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nvoid nilfs_sysfs_delete_device_group(struct the_nilfs *nilfs)\n{\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\tnilfs_sysfs_delete_segctor_group(nilfs);\n\tkobject_del(&nilfs->ns_dev_kobj);\n\tkfree(nilfs->ns_dev_subgroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_init",
          "args": [
            "nilfs"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_init_recovery_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "162-166",
          "snippet": "static void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}"
  },
  {
    "function_name": "alloc_nilfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "68-91",
    "snippet": "struct the_nilfs *alloc_nilfs(struct block_device *bdev)\n{\n\tstruct the_nilfs *nilfs;\n\n\tnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\n\tif (!nilfs)\n\t\treturn NULL;\n\n\tnilfs->ns_bdev = bdev;\n\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\tinit_rwsem(&nilfs->ns_sem);\n\tmutex_init(&nilfs->ns_snapshot_mount_mutex);\n\tINIT_LIST_HEAD(&nilfs->ns_dirty_files);\n\tINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\n\tspin_lock_init(&nilfs->ns_inode_lock);\n\tspin_lock_init(&nilfs->ns_next_gen_lock);\n\tspin_lock_init(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_cptree = RB_ROOT;\n\tspin_lock_init(&nilfs->ns_cptree_lock);\n\tinit_rwsem(&nilfs->ns_segctor_sem);\n\tnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\n\n\treturn nilfs;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nilfs->ns_cptree_lock"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nilfs->ns_next_gen_lock"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nilfs->ns_gc_inodes"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nilfs->ns_dirty_files"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&nilfs->ns_snapshot_mount_mutex"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nilfs->ns_ndirtyblks",
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*nilfs)",
            "GFP_KERNEL"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct the_nilfs *alloc_nilfs(struct block_device *bdev)\n{\n\tstruct the_nilfs *nilfs;\n\n\tnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\n\tif (!nilfs)\n\t\treturn NULL;\n\n\tnilfs->ns_bdev = bdev;\n\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\tinit_rwsem(&nilfs->ns_sem);\n\tmutex_init(&nilfs->ns_snapshot_mount_mutex);\n\tINIT_LIST_HEAD(&nilfs->ns_dirty_files);\n\tINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\n\tspin_lock_init(&nilfs->ns_inode_lock);\n\tspin_lock_init(&nilfs->ns_next_gen_lock);\n\tspin_lock_init(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_cptree = RB_ROOT;\n\tspin_lock_init(&nilfs->ns_cptree_lock);\n\tinit_rwsem(&nilfs->ns_segctor_sem);\n\tnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\n\n\treturn nilfs;\n}"
  },
  {
    "function_name": "nilfs_set_last_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
    "lines": "41-59",
    "snippet": "void nilfs_set_last_segment(struct the_nilfs *nilfs,\n\t\t\t    sector_t start_blocknr, u64 seq, __u64 cno)\n{\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_last_pseg = start_blocknr;\n\tnilfs->ns_last_seq = seq;\n\tnilfs->ns_last_cno = cno;\n\n\tif (!nilfs_sb_dirty(nilfs)) {\n\t\tif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\n\t\t\tgoto stay_cursor;\n\n\t\tset_nilfs_sb_dirty(nilfs);\n\t}\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\n stay_cursor:\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"alloc.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/random.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nilfs_sb_dirty",
          "args": [
            "nilfs"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sb_dirty",
          "args": [
            "nilfs"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_last_segment(struct the_nilfs *nilfs,\n\t\t\t    sector_t start_blocknr, u64 seq, __u64 cno)\n{\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_last_pseg = start_blocknr;\n\tnilfs->ns_last_seq = seq;\n\tnilfs->ns_last_cno = cno;\n\n\tif (!nilfs_sb_dirty(nilfs)) {\n\t\tif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\n\t\t\tgoto stay_cursor;\n\n\t\tset_nilfs_sb_dirty(nilfs);\n\t}\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\n stay_cursor:\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
  }
]