[
  {
    "function_name": "__nfs_readpage_to_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "417-439",
    "snippet": "void __nfs_readpage_to_fscache(struct inode *inode, struct page *page, int sync)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_to_fscache(fsc:%p/p:%p(i:%lx f:%lx)/%d)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, sync);\n\n\tret = fscache_write_page(nfs_i_fscache(inode), page, GFP_KERNEL);\n\tdfprintk(FSCACHE,\n\t\t \"NFS:     readpage_to_fscache: p:%p(i:%lu f:%lx) ret %d\\n\",\n\t\t page, page->index, page->flags, ret);\n\n\tif (ret != 0) {\n\t\tfscache_uncache_page(nfs_i_fscache(inode), page);\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t} else {\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_OK);\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_inc_fscache_stats",
          "args": [
            "inode",
            "NFSIOS_FSCACHE_PAGES_WRITTEN_OK"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_fscache_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "58-62",
          "snippet": "static inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "nfs_i_fscache(inode)",
            "page"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS:     readpage_to_fscache: p:%p(i:%lu f:%lx) ret %d\\n\"",
            "page",
            "page->index",
            "page->flags",
            "ret"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_write_page",
          "args": [
            "nfs_i_fscache(inode)",
            "page",
            "GFP_KERNEL"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "922-1052",
          "snippet": "int __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: readpage_to_fscache(fsc:%p/p:%p(i:%lx f:%lx)/%d)\\n\"",
            "nfs_i_fscache(inode)",
            "page",
            "page->index",
            "page->flags",
            "sync"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __nfs_readpage_to_fscache(struct inode *inode, struct page *page, int sync)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_to_fscache(fsc:%p/p:%p(i:%lx f:%lx)/%d)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, sync);\n\n\tret = fscache_write_page(nfs_i_fscache(inode), page, GFP_KERNEL);\n\tdfprintk(FSCACHE,\n\t\t \"NFS:     readpage_to_fscache: p:%p(i:%lu f:%lx) ret %d\\n\",\n\t\t page, page->index, page->flags, ret);\n\n\tif (ret != 0) {\n\t\tfscache_uncache_page(nfs_i_fscache(inode), page);\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t} else {\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_OK);\n\t}\n}"
  },
  {
    "function_name": "__nfs_readpages_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "366-411",
    "snippet": "int __nfs_readpages_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct address_space *mapping,\n\t\t\t\t struct list_head *pages,\n\t\t\t\t unsigned *nr_pages)\n{\n\tunsigned npages = *nr_pages;\n\tint ret;\n\n\tdfprintk(FSCACHE, \"NFS: nfs_getpages_from_fscache (0x%p/%u/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), npages, inode);\n\n\tret = fscache_read_or_alloc_pages(nfs_i_fscache(inode),\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  nfs_readpage_from_fscache_complete,\n\t\t\t\t\t  ctx,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tif (*nr_pages < npages)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK,\n\t\t\t\t      npages);\n\tif (*nr_pages > 0)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL,\n\t\t\t\t      *nr_pages);\n\n\tswitch (ret) {\n\tcase 0: /* read submitted to the cache for all pages */\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: submitted\\n\");\n\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* some pages aren't cached and can't be */\n\tcase -ENODATA: /* some pages aren't cached */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: no page: %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: ret  %d\\n\", ret);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfs_getpages_from_fscache: ret  %d\\n\"",
            "ret"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfs_getpages_from_fscache: no page: %d\\n\"",
            "ret"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfs_getpages_from_fscache: submitted\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*nr_pages != 0"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_add_fscache_stats",
          "args": [
            "inode",
            "NFSIOS_FSCACHE_PAGES_READ_FAIL",
            "*nr_pages"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_fscache_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "52-57",
          "snippet": "static inline void nfs_add_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat,\n\t\t\t\t\t long addend)\n{\n\tthis_cpu_add(NFS_SERVER(inode)->io_stats->fscache[stat], addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat,\n\t\t\t\t\t long addend)\n{\n\tthis_cpu_add(NFS_SERVER(inode)->io_stats->fscache[stat], addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_pages",
          "args": [
            "nfs_i_fscache(inode)",
            "mapping",
            "pages",
            "nr_pages",
            "nfs_readpage_from_fscache_complete",
            "ctx",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "532-642",
          "snippet": "int __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfs_getpages_from_fscache (0x%p/%u/0x%p)\\n\"",
            "nfs_i_fscache(inode)",
            "npages",
            "inode"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint __nfs_readpages_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct address_space *mapping,\n\t\t\t\t struct list_head *pages,\n\t\t\t\t unsigned *nr_pages)\n{\n\tunsigned npages = *nr_pages;\n\tint ret;\n\n\tdfprintk(FSCACHE, \"NFS: nfs_getpages_from_fscache (0x%p/%u/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), npages, inode);\n\n\tret = fscache_read_or_alloc_pages(nfs_i_fscache(inode),\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  nfs_readpage_from_fscache_complete,\n\t\t\t\t\t  ctx,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tif (*nr_pages < npages)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK,\n\t\t\t\t      npages);\n\tif (*nr_pages > 0)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL,\n\t\t\t\t      *nr_pages);\n\n\tswitch (ret) {\n\tcase 0: /* read submitted to the cache for all pages */\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: submitted\\n\");\n\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* some pages aren't cached and can't be */\n\tcase -ENODATA: /* some pages aren't cached */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: no page: %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: ret  %d\\n\", ret);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__nfs_readpage_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "327-361",
    "snippet": "int __nfs_readpage_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\tstruct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache(fsc:%p/p:%p(i:%lx f:%lx)/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, inode);\n\n\tret = fscache_read_or_alloc_page(nfs_i_fscache(inode),\n\t\t\t\t\t page,\n\t\t\t\t\t nfs_readpage_from_fscache_complete,\n\t\t\t\t\t ctx,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\tcase 0: /* read BIO submitted (page in fscache) */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache: BIO submitted\\n\");\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK);\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* inode not in cache */\n\tcase -ENODATA: /* page not in cache */\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE, \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_inc_fscache_stats",
          "args": [
            "inode",
            "NFSIOS_FSCACHE_PAGES_READ_FAIL"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_fscache_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "58-62",
          "snippet": "static inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS:    readpage_from_fscache %d\\n\"",
            "ret"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS:    readpage_from_fscache %d\\n\"",
            "ret"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS:    readpage_from_fscache: BIO submitted\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_page",
          "args": [
            "nfs_i_fscache(inode)",
            "page",
            "nfs_readpage_from_fscache_complete",
            "ctx",
            "GFP_KERNEL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "399-511",
          "snippet": "int __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: readpage_from_fscache(fsc:%p/p:%p(i:%lx f:%lx)/0x%p)\\n\"",
            "nfs_i_fscache(inode)",
            "page",
            "page->index",
            "page->flags",
            "inode"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint __nfs_readpage_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\tstruct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache(fsc:%p/p:%p(i:%lx f:%lx)/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, inode);\n\n\tret = fscache_read_or_alloc_page(nfs_i_fscache(inode),\n\t\t\t\t\t page,\n\t\t\t\t\t nfs_readpage_from_fscache_complete,\n\t\t\t\t\t ctx,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\tcase 0: /* read BIO submitted (page in fscache) */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache: BIO submitted\\n\");\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK);\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* inode not in cache */\n\tcase -ENODATA: /* page not in cache */\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE, \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_readpage_from_fscache_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "304-322",
    "snippet": "static void nfs_readpage_from_fscache_complete(struct page *page,\n\t\t\t\t\t       void *context,\n\t\t\t\t\t       int error)\n{\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache_complete (0x%p/0x%p/%d)\\n\",\n\t\t page, context, error);\n\n\t/* if the read completes with an error, we just unlock the page and let\n\t * the VM reissue the readpage */\n\tif (!error) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = nfs_readpage_async(context, page->mapping->host, page);\n\t\tif (error)\n\t\t\tunlock_page(page);\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readpage_async",
          "args": [
            "context",
            "page->mapping->host",
            "page"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "85-116",
          "snippet": "int nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;",
            "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};\n\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: readpage_from_fscache_complete (0x%p/0x%p/%d)\\n\"",
            "page",
            "context",
            "error"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void nfs_readpage_from_fscache_complete(struct page *page,\n\t\t\t\t\t       void *context,\n\t\t\t\t\t       int error)\n{\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache_complete (0x%p/0x%p/%d)\\n\",\n\t\t page, context, error);\n\n\t/* if the read completes with an error, we just unlock the page and let\n\t * the VM reissue the readpage */\n\tif (!error) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = nfs_readpage_async(context, page->mapping->host, page);\n\t\tif (error)\n\t\t\tunlock_page(page);\n\t}\n}"
  },
  {
    "function_name": "__nfs_fscache_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "283-298",
    "snippet": "void __nfs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tBUG_ON(!cookie);\n\n\tdfprintk(FSCACHE, \"NFS: fscache invalidatepage (0x%p/0x%p/0x%p)\\n\",\n\t\t cookie, page, NFS_I(inode));\n\n\tfscache_wait_on_page_write(cookie, page);\n\n\tBUG_ON(!PageLocked(page));\n\tfscache_uncache_page(cookie, page);\n\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_inc_fscache_stats",
          "args": [
            "page->mapping->host",
            "NFSIOS_FSCACHE_PAGES_UNCACHED"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_fscache_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "58-62",
          "snippet": "static inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "cookie",
            "page"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_wait_on_page_write",
          "args": [
            "cookie",
            "page"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.h",
          "lines": "199-200",
          "snippet": "static inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: fscache invalidatepage (0x%p/0x%p/0x%p)\\n\"",
            "cookie",
            "page",
            "NFS_I(inode)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cookie"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __nfs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tBUG_ON(!cookie);\n\n\tdfprintk(FSCACHE, \"NFS: fscache invalidatepage (0x%p/0x%p/0x%p)\\n\",\n\t\t cookie, page, NFS_I(inode));\n\n\tfscache_wait_on_page_write(cookie, page);\n\n\tBUG_ON(!PageLocked(page));\n\tfscache_uncache_page(cookie, page);\n\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n}"
  },
  {
    "function_name": "nfs_fscache_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "260-277",
    "snippet": "int nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_inc_fscache_stats",
          "args": [
            "page->mapping->host",
            "NFSIOS_FSCACHE_PAGES_UNCACHED"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_fscache_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "58-62",
          "snippet": "static inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_fscache_stats(struct inode *inode,\n\t\t\t\t\t enum nfs_stat_fscachecounters stat)\n{\n\tthis_cpu_inc(NFS_SERVER(inode)->io_stats->fscache[stat]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_maybe_release_page",
          "args": [
            "cookie",
            "page",
            "gfp"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_maybe_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "63-137",
          "snippet": "bool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\"",
            "cookie",
            "page",
            "NFS_I(page->mapping->host)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cookie"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "page->mapping->host"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs_fscache_open_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "233-252",
    "snippet": "void nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_INO_FSCACHE",
            "&NFS_I(inode)->flags"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_enable_cookie",
          "args": [
            "cookie",
            "nfs_fscache_can_enable",
            "inode"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_enable_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "156-183",
          "snippet": "void __fscache_enable_cookie(struct fscache_cookie *cookie,\n\t\t\t     bool (*can_enable)(void *data),\n\t\t\t     void *data)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\n\tif (test_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock;\n\n\tif (can_enable && !can_enable(data)) {\n\t\t/* The netfs decided it didn't want to enable after all */\n\t} else if (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* Wait for outstanding disablement to complete */\n\t\t__fscache_wait_on_invalidate(cookie);\n\n\t\tif (fscache_acquire_non_index_cookie(cookie) == 0)\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t} else {\n\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t}\n\nout_unlock:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_enable_cookie(struct fscache_cookie *cookie,\n\t\t\t     bool (*can_enable)(void *data),\n\t\t\t     void *data)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\n\tif (test_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock;\n\n\tif (can_enable && !can_enable(data)) {\n\t\t/* The netfs decided it didn't want to enable after all */\n\t} else if (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* Wait for outstanding disablement to complete */\n\t\t__fscache_wait_on_invalidate(cookie);\n\n\t\tif (fscache_acquire_non_index_cookie(cookie) == 0)\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t} else {\n\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t}\n\nout_unlock:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfsi 0x%p enabling cache\\n\"",
            "nfsi"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_uncache_all_inode_pages",
          "args": [
            "cookie",
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_all_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1161-1194",
          "snippet": "void __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_disable_cookie",
          "args": [
            "cookie",
            "true"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_disable_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "511-572",
          "snippet": "void __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_INO_FSCACHE",
            "&nfsi->flags"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: nfsi 0x%p disabling cache\\n\"",
            "nfsi"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_is_open_for_write",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_valid",
          "args": [
            "cookie"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}"
  },
  {
    "function_name": "nfs_fscache_can_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "207-212",
    "snippet": "static bool nfs_fscache_can_enable(void *data)\n{\n\tstruct inode *inode = data;\n\n\treturn !inode_is_open_for_write(inode);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_is_open_for_write",
          "args": [
            "inode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic bool nfs_fscache_can_enable(void *data)\n{\n\tstruct inode *inode = data;\n\n\treturn !inode_is_open_for_write(inode);\n}"
  },
  {
    "function_name": "nfs_fscache_clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "196-205",
    "snippet": "void nfs_fscache_clear_inode(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tdfprintk(FSCACHE, \"NFS: clear cookie (0x%p/0x%p)\\n\", nfsi, cookie);\n\n\tfscache_relinquish_cookie(cookie, false);\n\tnfsi->fscache = NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "cookie",
            "false"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: clear cookie (0x%p/0x%p)\\n\"",
            "nfsi",
            "cookie"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_i_fscache",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_clear_inode(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tdfprintk(FSCACHE, \"NFS: clear cookie (0x%p/0x%p)\\n\", nfsi, cookie);\n\n\tfscache_relinquish_cookie(cookie, false);\n\tnfsi->fscache = NULL;\n}"
  },
  {
    "function_name": "nfs_fscache_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "181-191",
    "snippet": "void nfs_fscache_init_inode(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnfsi->fscache = NULL;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\tnfsi->fscache = fscache_acquire_cookie(NFS_SB(inode->i_sb)->fscache,\n\t\t\t\t\t       &nfs_fscache_inode_object_def,\n\t\t\t\t\t       nfsi, false);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "NFS_SB(inode->i_sb)->fscache",
            "&nfs_fscache_inode_object_def",
            "nfsi",
            "false"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_init_inode(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnfsi->fscache = NULL;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\tnfsi->fscache = fscache_acquire_cookie(NFS_SB(inode->i_sb)->fscache,\n\t\t\t\t\t       &nfs_fscache_inode_object_def,\n\t\t\t\t\t       nfsi, false);\n}"
  },
  {
    "function_name": "nfs_fscache_release_super_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "159-176",
    "snippet": "void nfs_fscache_release_super_cookie(struct super_block *sb)\n{\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\n\tdfprintk(FSCACHE, \"NFS: releasing superblock cookie (0x%p/0x%p)\\n\",\n\t\t nfss, nfss->fscache);\n\n\tfscache_relinquish_cookie(nfss->fscache, 0);\n\tnfss->fscache = NULL;\n\n\tif (nfss->fscache_key) {\n\t\tspin_lock(&nfs_fscache_keys_lock);\n\t\trb_erase(&nfss->fscache_key->node, &nfs_fscache_keys);\n\t\tspin_unlock(&nfs_fscache_keys_lock);\n\t\tkfree(nfss->fscache_key);\n\t\tnfss->fscache_key = NULL;\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root nfs_fscache_keys = RB_ROOT;",
      "static DEFINE_SPINLOCK(nfs_fscache_keys_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nfss->fscache_key"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs_fscache_keys_lock"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&nfss->fscache_key->node",
            "&nfs_fscache_keys"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs_fscache_keys_lock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "nfss->fscache",
            "0"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: releasing superblock cookie (0x%p/0x%p)\\n\"",
            "nfss",
            "nfss->fscache"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "sb"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root nfs_fscache_keys = RB_ROOT;\nstatic DEFINE_SPINLOCK(nfs_fscache_keys_lock);\n\nvoid nfs_fscache_release_super_cookie(struct super_block *sb)\n{\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\n\tdfprintk(FSCACHE, \"NFS: releasing superblock cookie (0x%p/0x%p)\\n\",\n\t\t nfss, nfss->fscache);\n\n\tfscache_relinquish_cookie(nfss->fscache, 0);\n\tnfss->fscache = NULL;\n\n\tif (nfss->fscache_key) {\n\t\tspin_lock(&nfs_fscache_keys_lock);\n\t\trb_erase(&nfss->fscache_key->node, &nfs_fscache_keys);\n\t\tspin_unlock(&nfs_fscache_keys_lock);\n\t\tkfree(nfss->fscache_key);\n\t\tnfss->fscache_key = NULL;\n\t}\n}"
  },
  {
    "function_name": "nfs_fscache_get_super_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "67-154",
    "snippet": "void nfs_fscache_get_super_cookie(struct super_block *sb, const char *uniq, int ulen)\n{\n\tstruct nfs_fscache_key *key, *xkey;\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\tstruct rb_node **p, *parent;\n\tint diff;\n\n\tif (!uniq) {\n\t\tuniq = \"\";\n\t\tulen = 1;\n\t}\n\n\tkey = kzalloc(sizeof(*key) + ulen, GFP_KERNEL);\n\tif (!key)\n\t\treturn;\n\n\tkey->nfs_client = nfss->nfs_client;\n\tkey->key.super.s_flags = sb->s_flags & NFS_MS_MASK;\n\tkey->key.nfs_server.flags = nfss->flags;\n\tkey->key.nfs_server.rsize = nfss->rsize;\n\tkey->key.nfs_server.wsize = nfss->wsize;\n\tkey->key.nfs_server.acregmin = nfss->acregmin;\n\tkey->key.nfs_server.acregmax = nfss->acregmax;\n\tkey->key.nfs_server.acdirmin = nfss->acdirmin;\n\tkey->key.nfs_server.acdirmax = nfss->acdirmax;\n\tkey->key.nfs_server.fsid = nfss->fsid;\n\tkey->key.rpc_auth.au_flavor = nfss->client->cl_auth->au_flavor;\n\n\tkey->key.uniq_len = ulen;\n\tmemcpy(key->key.uniquifier, uniq, ulen);\n\n\tspin_lock(&nfs_fscache_keys_lock);\n\tp = &nfs_fscache_keys.rb_node;\n\tparent = NULL;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct nfs_fscache_key, node);\n\n\t\tif (key->nfs_client < xkey->nfs_client)\n\t\t\tgoto go_left;\n\t\tif (key->nfs_client > xkey->nfs_client)\n\t\t\tgoto go_right;\n\n\t\tdiff = memcmp(&key->key, &xkey->key, sizeof(key->key));\n\t\tif (diff < 0)\n\t\t\tgoto go_left;\n\t\tif (diff > 0)\n\t\t\tgoto go_right;\n\n\t\tif (key->key.uniq_len == 0)\n\t\t\tgoto non_unique;\n\t\tdiff = memcmp(key->key.uniquifier,\n\t\t\t      xkey->key.uniquifier,\n\t\t\t      key->key.uniq_len);\n\t\tif (diff < 0)\n\t\t\tgoto go_left;\n\t\tif (diff > 0)\n\t\t\tgoto go_right;\n\t\tgoto non_unique;\n\n\tgo_left:\n\t\tp = &(*p)->rb_left;\n\t\tcontinue;\n\tgo_right:\n\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&key->node, parent, p);\n\trb_insert_color(&key->node, &nfs_fscache_keys);\n\tspin_unlock(&nfs_fscache_keys_lock);\n\tnfss->fscache_key = key;\n\n\t/* create a cache index for looking up filehandles */\n\tnfss->fscache = fscache_acquire_cookie(nfss->nfs_client->fscache,\n\t\t\t\t\t       &nfs_fscache_super_index_def,\n\t\t\t\t\t       nfss, true);\n\tdfprintk(FSCACHE, \"NFS: get superblock cookie (0x%p/0x%p)\\n\",\n\t\t nfss, nfss->fscache);\n\treturn;\n\nnon_unique:\n\tspin_unlock(&nfs_fscache_keys_lock);\n\tkfree(key);\n\tnfss->fscache_key = NULL;\n\tnfss->fscache = NULL;\n\tprintk(KERN_WARNING \"NFS:\"\n\t       \" Cache request denied due to non-unique superblock keys\\n\");\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root nfs_fscache_keys = RB_ROOT;",
      "static DEFINE_SPINLOCK(nfs_fscache_keys_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFS:\"\n\t       \" Cache request denied due to non-unique superblock keys\\n\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs_fscache_keys_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: get superblock cookie (0x%p/0x%p)\\n\"",
            "nfss",
            "nfss->fscache"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "nfss->nfs_client->fscache",
            "&nfs_fscache_super_index_def",
            "nfss",
            "true"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&key->node",
            "&nfs_fscache_keys"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&key->node",
            "parent",
            "p"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key->key.uniquifier",
            "xkey->key.uniquifier",
            "key->key.uniq_len"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&key->key",
            "&xkey->key",
            "sizeof(key->key)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structnfs_fscache_key",
            "node"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs_fscache_keys_lock"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key->key.uniquifier",
            "uniq",
            "ulen"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*key) + ulen",
            "GFP_KERNEL"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "sb"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root nfs_fscache_keys = RB_ROOT;\nstatic DEFINE_SPINLOCK(nfs_fscache_keys_lock);\n\nvoid nfs_fscache_get_super_cookie(struct super_block *sb, const char *uniq, int ulen)\n{\n\tstruct nfs_fscache_key *key, *xkey;\n\tstruct nfs_server *nfss = NFS_SB(sb);\n\tstruct rb_node **p, *parent;\n\tint diff;\n\n\tif (!uniq) {\n\t\tuniq = \"\";\n\t\tulen = 1;\n\t}\n\n\tkey = kzalloc(sizeof(*key) + ulen, GFP_KERNEL);\n\tif (!key)\n\t\treturn;\n\n\tkey->nfs_client = nfss->nfs_client;\n\tkey->key.super.s_flags = sb->s_flags & NFS_MS_MASK;\n\tkey->key.nfs_server.flags = nfss->flags;\n\tkey->key.nfs_server.rsize = nfss->rsize;\n\tkey->key.nfs_server.wsize = nfss->wsize;\n\tkey->key.nfs_server.acregmin = nfss->acregmin;\n\tkey->key.nfs_server.acregmax = nfss->acregmax;\n\tkey->key.nfs_server.acdirmin = nfss->acdirmin;\n\tkey->key.nfs_server.acdirmax = nfss->acdirmax;\n\tkey->key.nfs_server.fsid = nfss->fsid;\n\tkey->key.rpc_auth.au_flavor = nfss->client->cl_auth->au_flavor;\n\n\tkey->key.uniq_len = ulen;\n\tmemcpy(key->key.uniquifier, uniq, ulen);\n\n\tspin_lock(&nfs_fscache_keys_lock);\n\tp = &nfs_fscache_keys.rb_node;\n\tparent = NULL;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct nfs_fscache_key, node);\n\n\t\tif (key->nfs_client < xkey->nfs_client)\n\t\t\tgoto go_left;\n\t\tif (key->nfs_client > xkey->nfs_client)\n\t\t\tgoto go_right;\n\n\t\tdiff = memcmp(&key->key, &xkey->key, sizeof(key->key));\n\t\tif (diff < 0)\n\t\t\tgoto go_left;\n\t\tif (diff > 0)\n\t\t\tgoto go_right;\n\n\t\tif (key->key.uniq_len == 0)\n\t\t\tgoto non_unique;\n\t\tdiff = memcmp(key->key.uniquifier,\n\t\t\t      xkey->key.uniquifier,\n\t\t\t      key->key.uniq_len);\n\t\tif (diff < 0)\n\t\t\tgoto go_left;\n\t\tif (diff > 0)\n\t\t\tgoto go_right;\n\t\tgoto non_unique;\n\n\tgo_left:\n\t\tp = &(*p)->rb_left;\n\t\tcontinue;\n\tgo_right:\n\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&key->node, parent, p);\n\trb_insert_color(&key->node, &nfs_fscache_keys);\n\tspin_unlock(&nfs_fscache_keys_lock);\n\tnfss->fscache_key = key;\n\n\t/* create a cache index for looking up filehandles */\n\tnfss->fscache = fscache_acquire_cookie(nfss->nfs_client->fscache,\n\t\t\t\t\t       &nfs_fscache_super_index_def,\n\t\t\t\t\t       nfss, true);\n\tdfprintk(FSCACHE, \"NFS: get superblock cookie (0x%p/0x%p)\\n\",\n\t\t nfss, nfss->fscache);\n\treturn;\n\nnon_unique:\n\tspin_unlock(&nfs_fscache_keys_lock);\n\tkfree(key);\n\tnfss->fscache_key = NULL;\n\tnfss->fscache = NULL;\n\tprintk(KERN_WARNING \"NFS:\"\n\t       \" Cache request denied due to non-unique superblock keys\\n\");\n}"
  },
  {
    "function_name": "nfs_fscache_release_client_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "50-57",
    "snippet": "void nfs_fscache_release_client_cookie(struct nfs_client *clp)\n{\n\tdfprintk(FSCACHE, \"NFS: releasing client cookie (0x%p/0x%p)\\n\",\n\t\t clp, clp->fscache);\n\n\tfscache_relinquish_cookie(clp->fscache, 0);\n\tclp->fscache = NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "clp->fscache",
            "0"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: releasing client cookie (0x%p/0x%p)\\n\"",
            "clp",
            "clp->fscache"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_release_client_cookie(struct nfs_client *clp)\n{\n\tdfprintk(FSCACHE, \"NFS: releasing client cookie (0x%p/0x%p)\\n\",\n\t\t clp, clp->fscache);\n\n\tfscache_relinquish_cookie(clp->fscache, 0);\n\tclp->fscache = NULL;\n}"
  },
  {
    "function_name": "nfs_fscache_get_client_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
    "lines": "37-45",
    "snippet": "void nfs_fscache_get_client_cookie(struct nfs_client *clp)\n{\n\t/* create a cache index for looking up filehandles */\n\tclp->fscache = fscache_acquire_cookie(nfs_fscache_netfs.primary_index,\n\t\t\t\t\t      &nfs_fscache_server_index_def,\n\t\t\t\t\t      clp, true);\n\tdfprintk(FSCACHE, \"NFS: get client cookie (0x%p/0x%p)\\n\",\n\t\t clp, clp->fscache);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/in6.h>",
      "#include <linux/nfs_fs_sb.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FSCACHE",
            "\"NFS: get client cookie (0x%p/0x%p)\\n\"",
            "clp",
            "clp->fscache"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "nfs_fscache_netfs.primary_index",
            "&nfs_fscache_server_index_def",
            "clp",
            "true"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_get_client_cookie(struct nfs_client *clp)\n{\n\t/* create a cache index for looking up filehandles */\n\tclp->fscache = fscache_acquire_cookie(nfs_fscache_netfs.primary_index,\n\t\t\t\t\t      &nfs_fscache_server_index_def,\n\t\t\t\t\t      clp, true);\n\tdfprintk(FSCACHE, \"NFS: get client cookie (0x%p/0x%p)\\n\",\n\t\t clp, clp->fscache);\n}"
  }
]